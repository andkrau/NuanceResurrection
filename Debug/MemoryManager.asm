; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\MemoryManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG10083
_DATA	ENDS
CONST	SEGMENT
$SG10083 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??0MemoryManager@@QAE@II@Z			; MemoryManager::MemoryManager
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
xdata$x	SEGMENT
__unwindtable$??0MemoryManager@@QAE@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryManager@@QAE@II@Z$0
__ehfuncinfo$??0MemoryManager@@QAE@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryManager@@QAE@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\memorymanager.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_maxBytes$ = 8						; size = 4
_defaultAlignment$ = 12					; size = 4
??0MemoryManager@@QAE@II@Z PROC				; MemoryManager::MemoryManager
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryManager@@QAE@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >

; 7    :   this->defaultAlignment = defaultAlignment;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _defaultAlignment$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 8    :   this->maxBytes = maxBytes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _maxBytes$[ebp]
	mov	DWORD PTR [edx], eax

; 9    : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0MemoryManager@@QAE@II@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
__ehhandler$??0MemoryManager@@QAE@II@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MemoryManager@@QAE@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryManager@@QAE@II@Z ENDP				; MemoryManager::MemoryManager
PUBLIC	?TestForInvalidPowerOfTwo@MemoryManager@@AAE_NI@Z ; MemoryManager::TestForInvalidPowerOfTwo
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_requestedAlignment$ = 8				; size = 4
?TestForInvalidPowerOfTwo@MemoryManager@@AAE_NI@Z PROC	; MemoryManager::TestForInvalidPowerOfTwo
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 13   :   return (requestedAlignment & (requestedAlignment - 1)) != 0;

	mov	eax, DWORD PTR _requestedAlignment$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _requestedAlignment$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax

; 14   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TestForInvalidPowerOfTwo@MemoryManager@@AAE_NI@Z ENDP	; MemoryManager::TestForInvalidPowerOfTwo
_TEXT	ENDS
PUBLIC	?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::erase
PUBLIC	??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
PUBLIC	?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::push_back
PUBLIC	?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back
PUBLIC	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
PUBLIC	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert
PUBLIC	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
PUBLIC	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
PUBLIC	?Add@MemoryManager@@QAEXIII@Z			; MemoryManager::Add
EXTRN	@_RTC_CheckStackVars@8:PROC
xdata$x	SEGMENT
__unwindtable$?Add@MemoryManager@@QAEXIII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@MemoryManager@@QAEXIII@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@MemoryManager@@QAEXIII@Z$5
__ehfuncinfo$?Add@MemoryManager@@QAEXIII@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Add@MemoryManager@@QAEXIII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv277 = -168						; size = 4
tv276 = -164						; size = 4
tv274 = -160						; size = 4
tv280 = -156						; size = 4
tv233 = -152						; size = 4
tv196 = -148						; size = 4
tv271 = -144						; size = 4
tv270 = -140						; size = 4
tv267 = -136						; size = 4
tv279 = -132						; size = 4
tv152 = -128						; size = 4
tv146 = -124						; size = 4
tv264 = -120						; size = 4
tv263 = -116						; size = 4
$T16864 = -112						; size = 12
$T16863 = -100						; size = 12
$T16862 = -88						; size = 4
$T16861 = -84						; size = 12
$T16860 = -72						; size = 12
$T16859 = -60						; size = 4
$T16858 = -56						; size = 12
$T16857 = -44						; size = 4
_vectorSize$ = -40					; size = 4
_newFreeBlock$ = -32					; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_startAddress$ = 8					; size = 4
_endAddress$ = 12					; size = 4
_index$ = 16						; size = 4
?Add@MemoryManager@@QAEXIII@Z PROC			; MemoryManager::Add
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Add@MemoryManager@@QAEXIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 156				; 0000009cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 39					; 00000027H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 18   :   FreeMemoryBlock newFreeBlock;
; 19   :   uint32 vectorSize;
; 20   : 
; 21   :   newFreeBlock.startAddress = startAddress;

	mov	eax, DWORD PTR _startAddress$[ebp]
	mov	DWORD PTR _newFreeBlock$[ebp], eax

; 22   :   newFreeBlock.endAddress = endAddress;

	mov	ecx, DWORD PTR _endAddress$[ebp]
	mov	DWORD PTR _newFreeBlock$[ebp+4], ecx

; 23   :   newFreeBlock.numBytes = endAddress - startAddress + 1;

	mov	edx, DWORD PTR _endAddress$[ebp]
	sub	edx, DWORD PTR _startAddress$[ebp]
	add	edx, 1
	mov	DWORD PTR _newFreeBlock$[ebp+8], edx

; 24   : 
; 25   :   vectorSize = (uint32)freeBlockVector.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	mov	DWORD PTR _vectorSize$[ebp], eax

; 26   : 
; 27   :   if(vectorSize == 0)

	cmp	DWORD PTR _vectorSize$[ebp], 0
	jne	SHORT $LN15@Add

; 28   :   {
; 29   :     //Only block in list so just add it
; 30   :     freeBlockVector.insert(freeBlockVector.begin(),newFreeBlock);

	lea	eax, DWORD PTR _newFreeBlock$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16857[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv263[ebp], eax
	lea	edx, DWORD PTR $T16858[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert
	mov	DWORD PTR tv264[ebp], eax
	lea	ecx, DWORD PTR $T16858[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ

; 31   :     return;

	jmp	$LN16@Add
$LN15@Add:

; 32   :   }
; 33   : 
; 34   :   if((index == 0) || (index >= vectorSize))

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN13@Add
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _vectorSize$[ebp]
	jb	SHORT $LN14@Add
$LN13@Add:

; 35   :   {
; 36   :     //Dont know where to put it
; 37   :     for(index = 0; index < vectorSize; index++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN12@Add
$LN11@Add:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
$LN12@Add:
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _vectorSize$[ebp]
	jae	SHORT $LN14@Add

; 38   :     {
; 39   :       if(freeBlockVector[index].startAddress > startAddress)

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _startAddress$[ebp]
	jbe	SHORT $LN9@Add

; 40   :       {
; 41   :         break;

	jmp	SHORT $LN14@Add
$LN9@Add:

; 42   :       }
; 43   :     }

	jmp	SHORT $LN11@Add
$LN14@Add:

; 44   :   }
; 45   : 
; 46   :   if(index == vectorSize)

	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR _vectorSize$[ebp]
	jne	SHORT $LN8@Add

; 47   :   {
; 48   :     //Add free block to end of list: check to see if new entry can
; 49   :     //be combined with entry at end of list
; 50   :     if(startAddress != (freeBlockVector.back().endAddress + 1))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back
	mov	eax, DWORD PTR [eax+4]
	add	eax, 1
	cmp	DWORD PTR _startAddress$[ebp], eax
	je	SHORT $LN7@Add

; 51   :     {
; 52   :       //New block cannot be combined with the block currently at the end of the list so 
; 53   :       //just add the new block to the end of the list
; 54   :       freeBlockVector.push_back(newFreeBlock);

	lea	ecx, DWORD PTR _newFreeBlock$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::push_back

; 55   :     }
; 56   :     else

	jmp	SHORT $LN6@Add
$LN7@Add:

; 57   :     {
; 58   :       //Combine new block with existing block entry at end of list
; 59   :       freeBlockVector.back().numBytes += newFreeBlock.numBytes;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back
	add	eax, 8
	mov	DWORD PTR tv146[ebp], eax
	mov	edx, DWORD PTR tv146[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _newFreeBlock$[ebp+8]
	mov	ecx, DWORD PTR tv146[ebp]
	mov	DWORD PTR [ecx], eax

; 60   :       freeBlockVector.back().endAddress += newFreeBlock.numBytes;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back
	add	eax, 4
	mov	DWORD PTR tv152[ebp], eax
	mov	edx, DWORD PTR tv152[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _newFreeBlock$[ebp+8]
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@Add:

; 61   :     }
; 62   :   }
; 63   :   else

	jmp	$LN16@Add
$LN8@Add:

; 64   :   {
; 65   :     //An entry exists after insertion point so try to combine ([new][old])
; 66   :     if(endAddress != (freeBlockVector[index].startAddress - 1))

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	eax, DWORD PTR [eax]
	sub	eax, 1
	cmp	DWORD PTR _endAddress$[ebp], eax
	je	SHORT $LN4@Add

; 67   :     {
; 68   :       //The existing block is not contiguous with the new block so no
; 69   :       //combining can be done
; 70   :       freeBlockVector.insert(freeBlockVector.begin() + index, newFreeBlock);

	lea	ecx, DWORD PTR _newFreeBlock$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T16859[ebp], esp
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T16860[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv279[ebp], eax
	mov	edx, DWORD PTR tv279[ebp]
	mov	DWORD PTR tv267[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv267[ebp]
	call	??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
	mov	DWORD PTR tv270[ebp], eax
	lea	eax, DWORD PTR $T16861[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert
	mov	DWORD PTR tv271[ebp], eax
	lea	ecx, DWORD PTR $T16861[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16860[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ

; 71   :     }
; 72   :     else

	jmp	SHORT $LN3@Add
$LN4@Add:

; 73   :     {
; 74   :       //Another free block exists at the index at which we are inserting
; 75   :       //and the existing block starts at the memory address immediately
; 76   :       //following the end address of the new free block so they can be
; 77   :       //combined
; 78   : 
; 79   :       //Add free block after the provided index and combine with the free block
; 80   :       //that currently follows the block at the provided index
; 81   :       freeBlockVector[index].startAddress = newFreeBlock.startAddress;

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	edx, DWORD PTR _newFreeBlock$[ebp]
	mov	DWORD PTR [eax], edx

; 82   :       freeBlockVector[index].numBytes += newFreeBlock.numBytes;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	add	eax, 8
	mov	DWORD PTR tv196[ebp], eax
	mov	ecx, DWORD PTR tv196[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _newFreeBlock$[ebp+8]
	mov	eax, DWORD PTR tv196[ebp]
	mov	DWORD PTR [eax], edx
$LN3@Add:

; 83   :     }
; 84   : 
; 85   :     //check to see if an entry exists to the left of the insertion point
; 86   :     if(index != 0)

	cmp	DWORD PTR _index$[ebp], 0
	je	$LN16@Add

; 87   :     {
; 88   :       //An entry exists so try to combine the entry just added with the
; 89   :       //entry immediately to the left of the insertion point: ([old][new_merged])
; 90   :       if(freeBlockVector[index - 1].endAddress == (freeBlockVector[index].startAddress - 1))

	mov	ecx, DWORD PTR _index$[ebp]
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	esi, eax
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	eax, DWORD PTR [eax]
	sub	eax, 1
	cmp	DWORD PTR [esi+4], eax
	jne	$LN16@Add

; 91   :       {
; 92   :         //Combine previous entry (index-1) with newly inserted entry (index)
; 93   :         freeBlockVector[index - 1].endAddress = freeBlockVector[index].endAddress;

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	esi, eax
	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 94   :         freeBlockVector[index - 1].numBytes += freeBlockVector[index].numBytes;

	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	add	eax, 8
	mov	DWORD PTR tv233[ebp], eax
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR tv233[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv233[ebp]
	mov	DWORD PTR [eax], edx

; 95   :         freeBlockVector.erase(freeBlockVector.begin() + index);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16862[ebp], esp
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T16863[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv280[ebp], eax
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR tv274[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv274[ebp]
	call	??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
	mov	DWORD PTR tv276[ebp], eax
	lea	edx, DWORD PTR $T16864[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::erase
	mov	DWORD PTR tv277[ebp], eax
	lea	ecx, DWORD PTR $T16864[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16863[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN16@Add:

; 96   :       }
; 97   :     }
; 98   :   }
; 99   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@Add
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN29@Add:
	DD	1
	DD	$LN28@Add
$LN28@Add:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN26@Add
$LN26@Add:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Add@MemoryManager@@QAEXIII@Z$2:
	lea	ecx, DWORD PTR $T16860[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?Add@MemoryManager@@QAEXIII@Z$5:
	lea	ecx, DWORD PTR $T16863[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?Add@MemoryManager@@QAEXIII@Z:
	mov	eax, OFFSET __ehfuncinfo$?Add@MemoryManager@@QAEXIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Add@MemoryManager@@QAEXIII@Z ENDP			; MemoryManager::Add
PUBLIC	??1?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::~_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??1_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::~_Iterator_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ PROC ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::~_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::~_Iterator_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ENDP ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::~_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
_TEXT	ENDS
PUBLIC	?_Orphan_me@_Iterator_base@std@@QAEXXZ		; std::_Iterator_base::_Orphan_me
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1_Iterator_base@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Iterator_base@std@@QAE@XZ$0
__ehfuncinfo$??1_Iterator_base@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_Iterator_base@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??1_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::~_Iterator_base, COMDAT
; _this$ = ecx

; 148  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Iterator_base@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 150  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 151  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Iterator_b:
	DD	1
	DD	$LN6@Iterator_b
$LN6@Iterator_b:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN4@Iterator_b
$LN4@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Iterator_base@std@@QAE@XZ$0:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??1_Iterator_base@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Iterator_base@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::~_Iterator_base
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ ; `string'
EXTRN	?_Debug_message@std@@YAXPB_W0I@Z:PROC		; std::_Debug_message
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
CONST	SEGMENT
??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' '
	DB	00H, '8', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\'
	DB	00H, 'x', 00H, 'u', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ?_Orphan_me@_Iterator_base@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$6444 = -8					; size = 4
_this$ = -4						; size = 4
?_Orphan_me@_Iterator_base@std@@QAEXXZ PROC		; std::_Iterator_base::_Orphan_me, COMDAT
; _this$ = ecx

; 169  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 		if (_Mycont != 0 && _Mycont->_Myfirstiter != _IGNORE_MYITERLIST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_me
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx], -3			; fffffffdH
	je	SHORT $LN5@Orphan_me

; 171  : 			{	// adopted, remove self from list
; 172  : 			_Iterator_base **_Pnext =
; 173  : 				(_Iterator_base **)&_Mycont->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$6444[ebp], ecx
$LN3@Orphan_me:

; 174  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	edx, DWORD PTR __Pnext$6444[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN2@Orphan_me
	mov	eax, DWORD PTR __Pnext$6444[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN2@Orphan_me

; 175  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	edx, DWORD PTR __Pnext$6444[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	DWORD PTR __Pnext$6444[ebp], eax
	jmp	SHORT $LN3@Orphan_me
$LN2@Orphan_me:

; 176  : 
; 177  : 			if (*_Pnext == 0)

	mov	ecx, DWORD PTR __Pnext$6444[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Orphan_me

; 178  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	push	178					; 000000b2H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN1@Orphan_me:

; 179  : 			*_Pnext = _Mynextiter;

	mov	edx, DWORD PTR __Pnext$6444[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx

; 180  : 			_Mycont = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$LN5@Orphan_me:

; 181  : 			}
; 182  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base@std@@QAEXXZ ENDP		; std::_Iterator_base::_Orphan_me
_TEXT	ENDS
PUBLIC	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::insert
PUBLIC	??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+
PUBLIC	?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
PUBLIC	??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
PUBLIC	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
PUBLIC	?AddAllocatedBlock@MemoryManager@@QAEXII@Z	; MemoryManager::AddAllocatedBlock
xdata$x	SEGMENT
__unwindtable$?AddAllocatedBlock@MemoryManager@@QAEXII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddAllocatedBlock@MemoryManager@@QAEXII@Z$0
__ehfuncinfo$?AddAllocatedBlock@MemoryManager@@QAEXII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddAllocatedBlock@MemoryManager@@QAEXII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\memorymanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv138 = -84						; size = 4
tv137 = -80						; size = 4
tv134 = -76						; size = 4
tv140 = -72						; size = 4
$T16907 = -68						; size = 12
$T16906 = -56						; size = 12
$T16905 = -44						; size = 4
_index$ = -40						; size = 4
_vectorSize$ = -36					; size = 4
_newAllocatedBlock$ = -28				; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_startAddress$ = 8					; size = 4
_numBytes$ = 12						; size = 4
?AddAllocatedBlock@MemoryManager@@QAEXII@Z PROC		; MemoryManager::AddAllocatedBlock
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddAllocatedBlock@MemoryManager@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  :   AllocatedMemoryBlock newAllocatedBlock;
; 104  :   uint32 vectorSize;
; 105  :   uint32 index;
; 106  : 
; 107  :   newAllocatedBlock.startAddress = startAddress;

	mov	eax, DWORD PTR _startAddress$[ebp]
	mov	DWORD PTR _newAllocatedBlock$[ebp], eax

; 108  :   newAllocatedBlock.numBytes = numBytes;

	mov	ecx, DWORD PTR _numBytes$[ebp]
	mov	DWORD PTR _newAllocatedBlock$[ebp+4], ecx

; 109  : 
; 110  :   vectorSize = (uint32)allocatedBlockVector.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	mov	DWORD PTR _vectorSize$[ebp], eax

; 111  : 
; 112  :   for(index = 0; index < vectorSize; index++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@AddAllocat
$LN3@AddAllocat:
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx
$LN4@AddAllocat:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _vectorSize$[ebp]
	jae	SHORT $LN2@AddAllocat

; 113  :   {
; 114  :     if(allocatedBlockVector[index].startAddress > startAddress)

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _startAddress$[ebp]
	jbe	SHORT $LN1@AddAllocat

; 115  :     {
; 116  :       break;

	jmp	SHORT $LN2@AddAllocat
$LN1@AddAllocat:

; 117  :     }
; 118  :   }

	jmp	SHORT $LN3@AddAllocat
$LN2@AddAllocat:

; 119  : 
; 120  :   allocatedBlockVector.insert(allocatedBlockVector.begin() + index, newAllocatedBlock);

	lea	eax, DWORD PTR _newAllocatedBlock$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T16905[ebp], esp
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T16906[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv134[ebp]
	call	??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+
	mov	DWORD PTR tv137[ebp], eax
	lea	edx, DWORD PTR $T16907[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::insert
	mov	DWORD PTR tv138[ebp], eax
	lea	ecx, DWORD PTR $T16907[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16906[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ

; 121  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@AddAllocat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN13@AddAllocat:
	DD	1
	DD	$LN12@AddAllocat
$LN12@AddAllocat:
	DD	-28					; ffffffe4H
	DD	8
	DD	$LN10@AddAllocat
$LN10@AddAllocat:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddAllocatedBlock@MemoryManager@@QAEXII@Z$0:
	lea	ecx, DWORD PTR $T16906[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?AddAllocatedBlock@MemoryManager@@QAEXII@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddAllocatedBlock@MemoryManager@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddAllocatedBlock@MemoryManager@@QAEXII@Z ENDP		; MemoryManager::AddAllocatedBlock
PUBLIC	??1?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::~_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ PROC ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::~_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::~_Iterator_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ENDP ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::~_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
_TEXT	ENDS
PUBLIC	?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::erase
PUBLIC	?Free@MemoryManager@@QAEXI@Z			; MemoryManager::Free
xdata$x	SEGMENT
__unwindtable$?Free@MemoryManager@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Free@MemoryManager@@QAEXI@Z$0
__ehfuncinfo$?Free@MemoryManager@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Free@MemoryManager@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv154 = -88						; size = 4
tv153 = -84						; size = 4
tv151 = -80						; size = 4
tv156 = -76						; size = 4
$T16930 = -72						; size = 12
$T16929 = -60						; size = 12
$T16928 = -48						; size = 4
_index$ = -44						; size = 4
_vectorSize$ = -40					; size = 4
_newFreeBlock$ = -32					; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_startAddress$ = 8					; size = 4
?Free@MemoryManager@@QAEXI@Z PROC			; MemoryManager::Free
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Free@MemoryManager@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  :   FreeMemoryBlock newFreeBlock;
; 126  :   uint32 vectorSize, index;
; 127  : 
; 128  :   vectorSize = (uint32)allocatedBlockVector.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	mov	DWORD PTR _vectorSize$[ebp], eax

; 129  : 
; 130  :   for(index = 0; index < vectorSize; index++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@Free
$LN3@Free:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@Free:
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR _vectorSize$[ebp]
	jae	$LN5@Free

; 131  :   {
; 132  :     if(allocatedBlockVector[index].startAddress == startAddress)

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR _startAddress$[ebp]
	jne	$LN1@Free

; 133  :     {
; 134  :       newFreeBlock.startAddress = allocatedBlockVector[index].startAddress;

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _newFreeBlock$[ebp], edx

; 135  :       newFreeBlock.numBytes = allocatedBlockVector[index].numBytes;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newFreeBlock$[ebp+8], ecx

; 136  :       newFreeBlock.endAddress = newFreeBlock.startAddress + newFreeBlock.numBytes - 1;

	mov	edx, DWORD PTR _newFreeBlock$[ebp+8]
	mov	eax, DWORD PTR _newFreeBlock$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	DWORD PTR _newFreeBlock$[ebp+4], ecx

; 137  :       //Remove the allocated block structure from the allocated block list
; 138  :       allocatedBlockVector.erase(allocatedBlockVector.begin() + index);

	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T16928[ebp], esp
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T16929[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
	mov	DWORD PTR tv156[ebp], eax
	mov	edx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv151[ebp]
	call	??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+
	mov	DWORD PTR tv153[ebp], eax
	lea	eax, DWORD PTR $T16930[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::erase
	mov	DWORD PTR tv154[ebp], eax
	lea	ecx, DWORD PTR $T16930[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16929[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ

; 139  :       //Add a new memory block item into the free block list (specify index equal to size
; 140  :       //to force search for proper insertion point)
; 141  :       Add(newFreeBlock.startAddress,newFreeBlock.endAddress,(uint32)freeBlockVector.size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	push	eax
	mov	ecx, DWORD PTR _newFreeBlock$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _newFreeBlock$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@MemoryManager@@QAEXIII@Z		; MemoryManager::Add

; 142  :       return;

	jmp	SHORT $LN5@Free
$LN1@Free:

; 143  :     }

	jmp	$LN3@Free
$LN5@Free:

; 144  :   }
; 145  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Free
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN13@Free:
	DD	1
	DD	$LN12@Free
$LN12@Free:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN10@Free
$LN10@Free:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Free@MemoryManager@@QAEXI@Z$0:
	lea	ecx, DWORD PTR $T16929[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?Free@MemoryManager@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?Free@MemoryManager@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Free@MemoryManager@@QAEXI@Z ENDP			; MemoryManager::Free
PUBLIC	?AlignAddress@MemoryManager@@AAEIII@Z		; MemoryManager::AlignAddress
PUBLIC	?Allocate@MemoryManager@@QAEPAXII@Z		; MemoryManager::Allocate
xdata$x	SEGMENT
__unwindtable$?Allocate@MemoryManager@@QAEPAXII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Allocate@MemoryManager@@QAEPAXII@Z$0
__ehfuncinfo$?Allocate@MemoryManager@@QAEPAXII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Allocate@MemoryManager@@QAEPAXII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv204 = -100						; size = 4
tv189 = -96						; size = 4
tv256 = -92						; size = 4
tv255 = -88						; size = 4
tv253 = -84						; size = 4
tv258 = -80						; size = 4
$T16944 = -76						; size = 12
$T16943 = -64						; size = 12
$T16942 = -52						; size = 4
_vectorSize$ = -48					; size = 4
_adjustedAddress$ = -44					; size = 4
_index$ = -40						; size = 4
_fmb2$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_requestedBytes$ = 8					; size = 4
_requestedAlignment$ = 12				; size = 4
?Allocate@MemoryManager@@QAEPAXII@Z PROC		; MemoryManager::Allocate
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Allocate@MemoryManager@@QAEPAXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  :   FreeMemoryBlock fmb2;
; 150  :   uint32 index, adjustedAddress;
; 151  :   uint32 vectorSize;
; 152  : 
; 153  :   if(requestedBytes == 0)

	cmp	DWORD PTR _requestedBytes$[ebp], 0
	jne	SHORT $LN18@Allocate

; 154  :   {
; 155  :     requestedBytes = 1;

	mov	DWORD PTR _requestedBytes$[ebp], 1
$LN18@Allocate:

; 156  :   }
; 157  : 
; 158  :   //force vector alignment minimum
; 159  :   if(requestedAlignment < 16)

	cmp	DWORD PTR _requestedAlignment$[ebp], 16	; 00000010H
	jae	SHORT $LN17@Allocate

; 160  :   {
; 161  :     requestedAlignment = 16;

	mov	DWORD PTR _requestedAlignment$[ebp], 16	; 00000010H
$LN17@Allocate:

; 162  :   }
; 163  : 
; 164  :   //stricter alignments must be powers of two
; 165  :   if(TestForInvalidPowerOfTwo(requestedAlignment))

	mov	eax, DWORD PTR _requestedAlignment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TestForInvalidPowerOfTwo@MemoryManager@@AAE_NI@Z ; MemoryManager::TestForInvalidPowerOfTwo
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@Allocate

; 166  :   {
; 167  :     return NULL;

	xor	eax, eax
	jmp	$LN19@Allocate
$LN16@Allocate:

; 168  :   }
; 169  : 
; 170  :   //pad requested byte count to the nearest vector
; 171  :   requestedBytes = (requestedBytes + 15) & 0xFFFFFFF0UL;

	mov	edx, DWORD PTR _requestedBytes$[ebp]
	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	mov	DWORD PTR _requestedBytes$[ebp], edx

; 172  : 
; 173  :   vectorSize = (uint32)freeBlockVector.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	mov	DWORD PTR _vectorSize$[ebp], eax

; 174  : 
; 175  :   if(vectorSize == 0)

	cmp	DWORD PTR _vectorSize$[ebp], 0
	jne	SHORT $LN15@Allocate

; 176  :   {
; 177  :     return NULL;

	xor	eax, eax
	jmp	$LN19@Allocate
$LN15@Allocate:

; 178  :   }
; 179  : 
; 180  :   for(index = 0; index < vectorSize; index++)

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN14@Allocate
$LN13@Allocate:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN14@Allocate:
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR _vectorSize$[ebp]
	jae	$LN12@Allocate

; 181  :   {
; 182  :     if(freeBlockVector[index].numBytes >= requestedBytes)

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR _requestedBytes$[ebp]
	jb	$LN11@Allocate

; 183  :     {
; 184  :       //Find the first address greater or equal to the block starting address
; 185  :       //that is aligned to the number of bytes specified by requestedAlignment
; 186  :       adjustedAddress = AlignAddress(freeBlockVector[index].startAddress, requestedAlignment);

	mov	ecx, DWORD PTR _requestedAlignment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AlignAddress@MemoryManager@@AAEIII@Z	; MemoryManager::AlignAddress
	mov	DWORD PTR _adjustedAddress$[ebp], eax

; 187  :       if(adjustedAddress <= freeBlockVector[index].endAddress)

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	edx, DWORD PTR _adjustedAddress$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	ja	$LN11@Allocate

; 188  :       {
; 189  :         if((freeBlockVector[index].endAddress - adjustedAddress + 1) >= requestedBytes)

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _adjustedAddress$[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _requestedBytes$[ebp]
	jb	$LN11@Allocate

; 190  :         {
; 191  :           //Block candidate meets all requirements
; 192  :           AddAllocatedBlock(adjustedAddress, requestedBytes);

	mov	edx, DWORD PTR _requestedBytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _adjustedAddress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddAllocatedBlock@MemoryManager@@QAEXII@Z ; MemoryManager::AddAllocatedBlock

; 193  : 
; 194  :           if(requestedBytes == freeBlockVector[index].numBytes)

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	edx, DWORD PTR _requestedBytes$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN8@Allocate

; 195  :           {
; 196  :             //Entire block is used so delete the block from the Free Block list
; 197  :             freeBlockVector.erase(freeBlockVector.begin() + index);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T16942[ebp], esp
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T16943[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv258[ebp], eax
	mov	eax, DWORD PTR tv258[ebp]
	mov	DWORD PTR tv253[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv253[ebp]
	call	??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
	mov	DWORD PTR tv255[ebp], eax
	lea	ecx, DWORD PTR $T16944[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::erase
	mov	DWORD PTR tv256[ebp], eax
	lea	ecx, DWORD PTR $T16944[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16943[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ

; 198  :           }
; 199  :           else

	jmp	$LN7@Allocate
$LN8@Allocate:

; 200  :           {
; 201  :             if(adjustedAddress == freeBlockVector[index].startAddress)

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR _adjustedAddress$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@Allocate

; 202  :             {
; 203  :               //Allocated block begins right at start_address
; 204  :               freeBlockVector[index].startAddress = adjustedAddress + requestedBytes;

	mov	esi, DWORD PTR _adjustedAddress$[ebp]
	add	esi, DWORD PTR _requestedBytes$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	DWORD PTR [eax], esi

; 205  :               freeBlockVector[index].numBytes -= requestedBytes;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	add	eax, 8
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR tv189[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _requestedBytes$[ebp]
	mov	eax, DWORD PTR tv189[ebp]
	mov	DWORD PTR [eax], edx
	jmp	$LN7@Allocate
$LN6@Allocate:

; 206  :               //End address of new free block stays the same
; 207  :             }
; 208  :             else if((adjustedAddress + requestedBytes - 1) == freeBlockVector[index].endAddress)

	mov	ecx, DWORD PTR _requestedBytes$[ebp]
	mov	edx, DWORD PTR _adjustedAddress$[ebp]
	lea	esi, DWORD PTR [edx+ecx-1]
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN4@Allocate

; 209  :             {
; 210  :               //Allocated block ends right at end_address
; 211  :               //Start address of new free block stays the same
; 212  :               freeBlockVector[index].numBytes -= requestedBytes;

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	add	eax, 8
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _requestedBytes$[ebp]
	mov	ecx, DWORD PTR tv204[ebp]
	mov	DWORD PTR [ecx], eax

; 213  :               freeBlockVector[index].endAddress = adjustedAddress - 1;

	mov	esi, DWORD PTR _adjustedAddress$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	DWORD PTR [eax+4], esi

; 214  :             }
; 215  :             else

	jmp	$LN7@Allocate
$LN4@Allocate:

; 216  :             {
; 217  :               //Allocated block splits free block in two
; 218  :               fmb2.endAddress = freeBlockVector[index].endAddress;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fmb2$[ebp+4], ecx

; 219  :               //NewFreeBlock1: pFB1.start_address stays the same
; 220  :               freeBlockVector[index].endAddress = adjustedAddress - 1;

	mov	esi, DWORD PTR _adjustedAddress$[ebp]
	sub	esi, 1
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	DWORD PTR [eax+4], esi

; 221  :               freeBlockVector[index].numBytes = 
; 222  :                 freeBlockVector[index].endAddress - freeBlockVector[index].startAddress + 1;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	esi, DWORD PTR [esi+4]
	sub	esi, DWORD PTR [eax]
	add	esi, 1
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
	mov	DWORD PTR [eax+8], esi

; 223  :               //NewFreeBlock2: pFB2.end_address stays the same
; 224  :               fmb2.startAddress = adjustedAddress + requestedBytes;

	mov	eax, DWORD PTR _adjustedAddress$[ebp]
	add	eax, DWORD PTR _requestedBytes$[ebp]
	mov	DWORD PTR _fmb2$[ebp], eax

; 225  :               fmb2.numBytes = fmb2.endAddress - fmb2.startAddress + 1;

	mov	ecx, DWORD PTR _fmb2$[ebp+4]
	sub	ecx, DWORD PTR _fmb2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _fmb2$[ebp+8], ecx

; 226  :               //Insert pFB2 into ordered Free Blocks list
; 227  :               if((index + 1) != vectorSize)

	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _vectorSize$[ebp]
	je	SHORT $LN2@Allocate

; 228  :               {
; 229  :                 Add(fmb2.startAddress,fmb2.endAddress,index+1);

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _fmb2$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _fmb2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@MemoryManager@@QAEXIII@Z		; MemoryManager::Add

; 230  :               }
; 231  :               else

	jmp	SHORT $LN7@Allocate
$LN2@Allocate:

; 232  :               {
; 233  :                 freeBlockVector.push_back(fmb2);

	lea	eax, DWORD PTR _fmb2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::push_back
$LN7@Allocate:

; 234  :               }
; 235  :             }
; 236  :           }
; 237  : 
; 238  :           return (void *)adjustedAddress;

	mov	eax, DWORD PTR _adjustedAddress$[ebp]
	jmp	SHORT $LN19@Allocate
$LN11@Allocate:

; 239  :         }
; 240  :         //Not enough bytes in block after aligning the starting address
; 241  :       }
; 242  :       //Aligned starting address is outside of block candidate
; 243  :     }
; 244  :     //Trivial rejection of block candidates that do not have enough bytes
; 245  :     //to meet the request under any circumstance
; 246  :   }

	jmp	$LN13@Allocate
$LN12@Allocate:

; 247  :   //No block was able to meet the requirements
; 248  :   return NULL;

	xor	eax, eax
$LN19@Allocate:

; 249  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@Allocate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN27@Allocate:
	DD	1
	DD	$LN26@Allocate
$LN26@Allocate:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN24@Allocate
$LN24@Allocate:
	DB	102					; 00000066H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	50					; 00000032H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Allocate@MemoryManager@@QAEPAXII@Z$0:
	lea	ecx, DWORD PTR $T16943[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?Allocate@MemoryManager@@QAEPAXII@Z:
	mov	eax, OFFSET __ehfuncinfo$?Allocate@MemoryManager@@QAEPAXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Allocate@MemoryManager@@QAEPAXII@Z ENDP		; MemoryManager::Allocate
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?AlignAddress@MemoryManager@@AAEIII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_alignment$ = 12					; size = 4
?AlignAddress@MemoryManager@@AAEIII@Z PROC		; MemoryManager::AlignAddress, COMDAT
; _this$ = ecx

; 252  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 253  :   return (address + alignment - 1) & (~(alignment - 1));

	mov	eax, DWORD PTR _alignment$[ebp]
	mov	ecx, DWORD PTR _address$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	mov	edx, DWORD PTR _alignment$[ebp]
	sub	edx, 1
	not	edx
	and	eax, edx

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AlignAddress@MemoryManager@@AAEIII@Z ENDP		; MemoryManager::AlignAddress
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	?_Buy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE_NI@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Buy
PUBLIC	??0?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE@V?$allocator@VFreeMemoryBlock@@@1@@Z ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??0?$allocator@VFreeMemoryBlock@@@std@@QAE@XZ	; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T16958 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx

; 457  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T16958[ebp], esp
	call	??0?$allocator@VFreeMemoryBlock@@@std@@QAE@XZ ; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE@V?$allocator@VFreeMemoryBlock@@@1@@Z ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 458  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE_NI@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Buy

; 459  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	?_Tidy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 546  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Tidy

; 547  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ
_TEXT	SEGMENT
$T16978 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin, COMDAT
; _this$ = ecx

; 627  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T16978[ebp], 0

; 628  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	mov	eax, DWORD PTR $T16978[ebp]
	or	eax, 1
	mov	DWORD PTR $T16978[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size, COMDAT
; _this$ = ecx

; 702  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@size
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@size
$LN3@size:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@size:
	mov	eax, DWORD PTR tv70[ebp]

; 704  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
_TEXT	ENDS
PUBLIC	??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1LK@KPOHDDAF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAF?$AAr?$AAe?$AAe?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAB?$AAl?$AAo?$AAc@ ; `string'
PUBLIC	??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; `string'
PUBLIC	??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ ; `string'
EXTRN	__invalid_parameter:PROC
EXTRN	__CrtDbgReportW:PROC
;	COMDAT ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'P', 00H, 'o', 00H, 's', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '('
	DB	00H, ')', 00H, '"', 00H, ',', 00H, ' ', 00H, '0', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@KPOHDDAF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAF?$AAr?$AAe?$AAe?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAB?$AAl?$AAo?$AAc@
CONST	SEGMENT
??_C@_1LK@KPOHDDAF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAF?$AAr?$AAe?$AAe?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAB?$AAl?$AAo?$AAc@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'F', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r'
	DB	00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'M'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
CONST	SEGMENT
??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ DB '('
	DB	00H, '"', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'a', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+'
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H
	DB	'r', 00H, 'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u'
	DB	00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H
	DB	'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ',', 00H, ' '
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
CONST	SEGMENT
??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' '
	DB	00H, '8', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[], COMDAT
; _this$ = ecx

; 751  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 752  : 
; 753  :  #if _HAS_ITERATOR_DEBUGGING
; 754  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator

; 755  : 			{
; 756  : 			_DEBUG_ERROR("vector subscript out of range");

	push	756					; 000002f4H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH

; 757  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	757					; 000002f5H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@operator
	int	3
$LN5@operator:
	push	0
	push	757					; 000002f5H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1LK@KPOHDDAF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAF?$AAr?$AAe?$AAe?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAB?$AAl?$AAo?$AAc@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@operator:

; 758  : 			}
; 759  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 760  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator
	xor	edx, edx
	jne	SHORT $LN6@operator
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	760					; 000002f8H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	push	0
	push	760					; 000002f8H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1LK@KPOHDDAF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAF?$AAr?$AAe?$AAe?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AAB?$AAl?$AAo?$AAc@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN1@operator:

; 761  : 
; 762  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]

; 763  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@I@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEAAVFreeMemoryBlock@@XZ ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*
PUBLIC	??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
PUBLIC	?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::end
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ$1
__ehfuncinfo$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv82 = -56						; size = 4
tv78 = -52						; size = 4
tv81 = -48						; size = 4
$T16992 = -44						; size = 12
$T16991 = -32						; size = 12
$T16990 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back, COMDAT
; _this$ = ecx

; 776  : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T16992[ebp]
	push	eax
	lea	ecx, DWORD PTR $T16991[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::end
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv78[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv78[ebp]
	call	??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
	mov	DWORD PTR tv82[ebp], eax
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv80[ebp]
	call	??D?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEAAVFreeMemoryBlock@@XZ ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*
	mov	DWORD PTR $T16990[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T16992[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16991[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T16990[ebp]

; 778  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ$0:
	lea	ecx, DWORD PTR $T16991[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ$1:
	lea	ecx, DWORD PTR $T16992[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAVFreeMemoryBlock@@XZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::back
PUBLIC	?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill
PUBLIC	?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range
PUBLIC	?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::capacity
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
tv135 = -28						; size = 4
tv134 = -24						; size = 4
$T17004 = -20						; size = 12
$T17003 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::push_back, COMDAT
; _this$ = ecx

; 786  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 788  : 
; 789  :  #if _HAS_ITERATOR_DEBUGGING
; 790  : 			{ // room at end, construct it there
; 791  : 			_Orphan_range(_Mylast, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range

; 792  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 793  : 			}
; 794  : 
; 795  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 796  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 797  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 798  : 
; 799  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 800  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T17003[ebp], esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::end
	mov	DWORD PTR tv134[ebp], eax
	lea	ecx, DWORD PTR $T17004[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert
	mov	DWORD PTR tv135[ebp], eax
	lea	ecx, DWORD PTR $T17004[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN3@push_back:

; 801  : 		}

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEXABVFreeMemoryBlock@@@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Insert_n
PUBLIC	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$3
__ehfuncinfo$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
tv149 = -76						; size = 4
tv157 = -72						; size = 4
tv147 = -68						; size = 4
tv141 = -64						; size = 4
tv155 = -60						; size = 4
tv76 = -56						; size = 4
$T17015 = -52						; size = 4
$T17013 = -48						; size = 12
$T17012 = -36						; size = 4
$T17009 = -32						; size = 12
__Off$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__Val$ = 24						; size = 4
?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert, COMDAT
; _this$ = ecx

; 852  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17015[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 853  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T17009[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T17015[ebp]
	or	edx, 1
	mov	DWORD PTR $T17015[ebp], edx
	mov	eax, DWORD PTR tv141[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
	mov	DWORD PTR tv76[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR __Off$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T17015[ebp]
	and	edx, 1
	je	SHORT $LN8@insert
	and	DWORD PTR $T17015[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T17009[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN8@insert:

; 854  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T17012[ebp], esp
	lea	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Insert_n

; 855  : 		return (begin() + _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T17013[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::begin
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv149[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv149[ebp]
	call	??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
	mov	ecx, DWORD PTR $T17015[ebp]
	or	ecx, 2
	mov	DWORD PTR $T17015[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T17013[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 856  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$1:
	mov	eax, DWORD PTR $T17015[ebp]
	and	eax, 1
	je	$LN7@insert
	and	DWORD PTR $T17015[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T17009[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN7@insert:
	ret	0
__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$3:
	lea	ecx, DWORD PTR $T17013[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z$4:
	mov	eax, DWORD PTR $T17015[ebp]
	and	eax, 2
	je	$LN12@insert
	and	DWORD PTR $T17015[ebp], -3		; fffffffdH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN12@insert:
	ret	0
__ehhandler$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?insert@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@ABVFreeMemoryBlock@@@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::insert
PUBLIC	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy
PUBLIC	??$unchecked_copy@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ; stdext::unchecked_copy<FreeMemoryBlock *,FreeMemoryBlock *>
PUBLIC	??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; `string'
;	COMDAT ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
CONST	SEGMENT
??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z$0
__ehfuncinfo$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z
_TEXT	SEGMENT
$T17033 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::erase, COMDAT
; _this$ = ecx

; 983  : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17033[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 984  : 		if (_Where._Mycont != this
; 985  : 			|| _Where._Myptr < _Myfirst || _Mylast <= _Where._Myptr)

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 986  : 			_DEBUG_ERROR("vector erase iterator outside range");

	push	986					; 000003daH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@erase:

; 987  : 		_STDEXT unchecked_copy(_Where._Myptr + 1, _Mylast, _Where._Myptr);

	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	add	edx, 12					; 0000000cH
	push	edx
	call	??$unchecked_copy@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ; stdext::unchecked_copy<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 12					; 0000000cH

; 988  : 		_Destroy(_Mylast - 1, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy

; 989  : 		_Orphan_range(_Where._Myptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range

; 990  : 		--_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 991  : 		return (iterator(_Where._Myptr, this));

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	mov	eax, DWORD PTR $T17033[ebp]
	or	eax, 1
	mov	DWORD PTR $T17033[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z$1:
	mov	eax, DWORD PTR $T17033[ebp]
	and	eax, 1
	je	$LN7@erase
	and	DWORD PTR $T17033[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN7@erase:
	ret	0
__ehhandler$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@V32@@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::erase
PUBLIC	??1?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	?_Buy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE_NI@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Buy
PUBLIC	??0?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE@V?$allocator@VAllocatedMemoryBlock@@@1@@Z ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@XZ ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T17043 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx

; 457  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T17043[ebp], esp
	call	??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@XZ ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE@V?$allocator@VAllocatedMemoryBlock@@@1@@Z ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 458  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE_NI@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Buy

; 459  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ
_TEXT	SEGMENT
$T17054 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin, COMDAT
; _this$ = ecx

; 627  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17054[ebp], 0

; 628  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	mov	eax, DWORD PTR $T17054[ebp]
	or	eax, 1
	mov	DWORD PTR $T17054[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size, COMDAT
; _this$ = ecx

; 702  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@size@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@size@2
$LN3@size@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@size@2:
	mov	eax, DWORD PTR tv70[ebp]

; 704  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
_TEXT	ENDS
PUBLIC	??_C@_1MO@CMLBFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AAM?$AAe?$AAm?$AAo?$AAr@ ; `string'
;	COMDAT ??_C@_1MO@CMLBFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AAM?$AAe?$AAm?$AAo?$AAr@
CONST	SEGMENT
??_C@_1MO@CMLBFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AAM?$AAe?$AAm?$AAo?$AAr@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o'
	DB	00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[], COMDAT
; _this$ = ecx

; 751  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 752  : 
; 753  :  #if _HAS_ITERATOR_DEBUGGING
; 754  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@operator@2

; 755  : 			{
; 756  : 			_DEBUG_ERROR("vector subscript out of range");

	push	756					; 000002f4H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH

; 757  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@2
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	757					; 000002f5H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@operator@2
	int	3
$LN5@operator@2:
	push	0
	push	757					; 000002f5H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1MO@CMLBFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AAM?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@operator@2:

; 758  : 			}
; 759  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 760  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@2
	xor	edx, edx
	jne	SHORT $LN6@operator@2
	push	OFFSET ??_C@_1CK@POGJDOKA@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAo?$AAs?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	760					; 000002f8H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN6@operator@2
	int	3
$LN6@operator@2:
	push	0
	push	760					; 000002f8H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1MO@CMLBFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AAd?$AAM?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN1@operator@2:

; 761  : 
; 762  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [edx+eax*8]

; 763  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAVAllocatedMemoryBlock@@I@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator[]
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Insert_n
PUBLIC	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??G?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@1@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$3
__ehfuncinfo$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
tv149 = -76						; size = 4
tv157 = -72						; size = 4
tv147 = -68						; size = 4
tv141 = -64						; size = 4
tv155 = -60						; size = 4
tv76 = -56						; size = 4
$T17072 = -52						; size = 4
$T17070 = -48						; size = 12
$T17069 = -36						; size = 4
$T17066 = -32						; size = 12
__Off$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__Val$ = 24						; size = 4
?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::insert, COMDAT
; _this$ = ecx

; 852  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17072[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 853  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	lea	eax, DWORD PTR $T17066[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T17072[ebp]
	or	edx, 1
	mov	DWORD PTR $T17072[ebp], edx
	mov	eax, DWORD PTR tv141[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@1@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-
	mov	DWORD PTR tv76[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR __Off$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T17072[ebp]
	and	edx, 1
	je	SHORT $LN8@insert@2
	and	DWORD PTR $T17072[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T17066[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN8@insert@2:

; 854  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T17069[ebp], esp
	lea	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Insert_n

; 855  : 		return (begin() + _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T17070[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@XZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::begin
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv149[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv149[ebp]
	call	??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+
	mov	ecx, DWORD PTR $T17072[ebp]
	or	ecx, 2
	mov	DWORD PTR $T17072[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T17070[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 856  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$1:
	mov	eax, DWORD PTR $T17072[ebp]
	and	eax, 1
	je	$LN7@insert@2
	and	DWORD PTR $T17072[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T17066[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN7@insert@2:
	ret	0
__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$3:
	lea	ecx, DWORD PTR $T17070[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z$4:
	mov	eax, DWORD PTR $T17072[ebp]
	and	eax, 2
	je	$LN12@insert@2
	and	DWORD PTR $T17072[ebp], -3		; fffffffdH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN12@insert@2:
	ret	0
__ehhandler$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?insert@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@ABVAllocatedMemoryBlock@@@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::insert
PUBLIC	?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range
PUBLIC	?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy
PUBLIC	??$unchecked_copy@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ; stdext::unchecked_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z$0
__ehfuncinfo$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z
_TEXT	SEGMENT
$T17090 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::erase, COMDAT
; _this$ = ecx

; 983  : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17090[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 984  : 		if (_Where._Mycont != this
; 985  : 			|| _Where._Myptr < _Myfirst || _Mylast <= _Where._Myptr)

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN1@erase@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase@2
$LN1@erase@2:

; 986  : 			_DEBUG_ERROR("vector erase iterator outside range");

	push	986					; 000003daH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@erase@2:

; 987  : 		_STDEXT unchecked_copy(_Where._Myptr + 1, _Mylast, _Where._Myptr);

	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	add	edx, 8
	push	edx
	call	??$unchecked_copy@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ; stdext::unchecked_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 12					; 0000000cH

; 988  : 		_Destroy(_Mylast - 1, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy

; 989  : 		_Orphan_range(_Where._Myptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range

; 990  : 		--_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 991  : 		return (iterator(_Where._Myptr, this));

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	mov	eax, DWORD PTR $T17090[ebp]
	or	eax, 1
	mov	DWORD PTR $T17090[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z$1:
	mov	eax, DWORD PTR $T17090[ebp]
	and	eax, 1
	je	$LN7@erase@2
	and	DWORD PTR $T17090[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN7@erase@2:
	ret	0
__ehhandler$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@V32@@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::erase
PUBLIC	??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T17102 = -40						; size = 4
__Tmp$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+, COMDAT
; _this$ = ecx

; 367  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17102[ebp], 0

; 368  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 369  : 		return (_Tmp += _Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T17102[ebp]
	or	edx, 1
	mov	DWORD PTR $T17102[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator@3:
	DD	1
	DD	$LN8@operator@3
$LN8@operator@3:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN6@operator@3
$LN6@operator@3:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T17102[ebp]
	and	eax, 1
	je	$LN5@operator@3
	and	DWORD PTR $T17102[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN5@operator@3:
	ret	0
__ehhandler$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z:
	mov	eax, OFFSET __ehfuncinfo$??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+
PUBLIC	??Y?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T17117 = -40						; size = 4
__Tmp$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+, COMDAT
; _this$ = ecx

; 367  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17117[ebp], 0

; 368  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 369  : 		return (_Tmp += _Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T17117[ebp]
	or	edx, 1
	mov	DWORD PTR $T17117[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator@4:
	DD	1
	DD	$LN8@operator@4
$LN8@operator@4:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN6@operator@4
$LN6@operator@4:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T17117[ebp]
	and	eax, 1
	je	$LN5@operator@4
	and	DWORD PTR $T17117[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN5@operator@4:
	ret	0
__ehhandler$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z:
	mov	eax, OFFSET __ehfuncinfo$??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??H?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+
PUBLIC	??1_Container_base@std@@QAE@XZ			; std::_Container_base::~_Container_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base@std@@QAE@XZ		; std::_Container_base::~_Container_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::~_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base@std@@QBEXXZ	; std::_Container_base::_Orphan_all
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??1_Container_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base@std@@QAE@XZ PROC			; std::_Container_base::~_Container_base, COMDAT
; _this$ = ecx

; 105  : 		{	// destroy the container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base@std@@QBEXXZ ; std::_Container_base::_Orphan_all

; 107  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base@std@@QAE@XZ ENDP			; std::_Container_base::~_Container_base
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base@std@@QBEXXZ
_TEXT	SEGMENT
__Pnext$6459 = -20					; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Orphan_all@_Container_base@std@@QBEXXZ PROC		; std::_Container_base::_Orphan_all, COMDAT
; _this$ = ecx

; 191  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 	_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 193  : 	if (_Myfirstiter != _IGNORE_MYITERLIST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN4@Orphan_all

; 194  : 		{
; 195  : 		for (_Iterator_base **_Pnext = (_Iterator_base **)&_Myfirstiter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Pnext$6459[ebp], ecx
	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 196  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

	mov	edx, DWORD PTR __Pnext$6459[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Pnext$6459[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$LN3@Orphan_all:
	mov	eax, DWORD PTR __Pnext$6459[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_all

; 197  : 			(*_Pnext)->_Mycont = 0;

	mov	ecx, DWORD PTR __Pnext$6459[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 198  : 		*(_Iterator_base **)&_Myfirstiter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@Orphan_all:

; 199  : 		}
; 200  : 	}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN8@Orphan_all
$LN8@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all@_Container_base@std@@QBEXXZ ENDP		; std::_Container_base::_Orphan_all
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base@std@@QAE@XZ		; std::_Container_base::~_Container_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::~_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@ABV01@@Z		; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z PROC ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@ABV01@@Z	; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z ENDP ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
_TEXT	ENDS
PUBLIC	??4_Iterator_base@std@@QAEAAV01@ABV01@@Z	; std::_Iterator_base::operator=
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0_Iterator_base@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base@std@@QAE@ABV01@@Z PROC		; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 132  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 133  : 		*this = _Right;

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base@std@@QAEAAV01@ABV01@@Z ; std::_Iterator_base::operator=

; 134  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base@std@@QAE@ABV01@@Z ENDP		; std::_Iterator_base::_Iterator_base
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z ; std::_Iterator_base::_Adopt
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Lock$6429 = -24					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base@std@@QAEAAV01@ABV01@@Z PROC		; std::_Iterator_base::operator=, COMDAT
; _this$ = ecx

; 137  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		if (_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN1@operator@5

; 139  : 			{	// change parentage
; 140  : 			_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$6429[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 141  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 142  : 			_Adopt(_Right._Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z ; std::_Iterator_base::_Adopt

; 143  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$6429[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN1@operator@5:

; 144  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@operator@5
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN8@operator@5:
	DD	1
	DD	$LN7@operator@5
$LN7@operator@5:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN5@operator@5
$LN5@operator@5:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z$0:
	lea	ecx, DWORD PTR __Lock$6429[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base@std@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base@std@@QAEAAV01@ABV01@@Z ENDP		; std::_Iterator_base::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z$0
__ehfuncinfo$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z
_TEXT	SEGMENT
__Lock$6436 = -24					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z PROC ; std::_Iterator_base::_Adopt, COMDAT
; _this$ = ecx

; 154  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		if (_Mycont != _Parent)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent$[ebp]
	je	SHORT $LN3@Adopt

; 156  : 			{	// change parentage
; 157  : 			_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$6436[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 158  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base@std@@QAEXXZ	; std::_Iterator_base::_Orphan_me

; 159  : 			if (_Parent != 0 && _Parent->_Myfirstiter != _IGNORE_MYITERLIST)

	cmp	DWORD PTR __Parent$[ebp], 0
	je	SHORT $LN1@Adopt
	mov	edx, DWORD PTR __Parent$[ebp]
	cmp	DWORD PTR [edx], -3			; fffffffdH
	je	SHORT $LN1@Adopt

; 160  : 				{	// switch to new parent
; 161  : 				_Mynextiter = _Parent->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 162  : 				((_Container_base *)_Parent)->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Adopt:

; 163  : 				}
; 164  : 			_Mycont = _Parent;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parent$[ebp]
	mov	DWORD PTR [edx], eax

; 165  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$6436[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN3@Adopt:

; 166  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@Adopt:
	DD	1
	DD	$LN8@Adopt
$LN8@Adopt:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN6@Adopt
$LN6@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z$0:
	lea	ecx, DWORD PTR __Lock$6436[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z ENDP ; std::_Iterator_base::_Adopt
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z PROC ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@ABV01@@Z	; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@ABU01@@Z ENDP ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::capacity, COMDAT
; _this$ = ecx

; 621  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 623  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::capacity
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ
_TEXT	SEGMENT
$T17193 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::end, COMDAT
; _this$ = ecx

; 637  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17193[ebp], 0

; 638  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	mov	eax, DWORD PTR $T17193[ebp]
	or	eax, 1
	mov	DWORD PTR $T17193[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 639  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@XZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::end
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::allocate
PUBLIC	?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Xlen
PUBLIC	?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Buy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE_NI@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Buy, COMDAT
; _this$ = ecx

; 1066 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1068 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1069 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1070 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1071 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Xlen

; 1072 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1075 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+12], ecx

; 1076 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN3@Buy:

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1079 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@@Z ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy, COMDAT
; _this$ = ecx

; 1082 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@@Z ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	add	esp, 12					; 0000000cH

; 1084 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::deallocate
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Tidy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXXZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Tidy, COMDAT
; _this$ = ecx

; 1087 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1088 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@Tidy

; 1089 : 			{	// something to free, destroy and deallocate it
; 1090 : 
; 1091 :  #if _HAS_ITERATOR_DEBUGGING
; 1092 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base@std@@QBEXXZ ; std::_Container_base::_Orphan_all

; 1093 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1094 : 
; 1095 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy

; 1096 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::deallocate
$LN1@Tidy:

; 1097 : 			}
; 1098 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1099 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXXZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ; stdext::_Unchecked_move_backward<FreeMemoryBlock *,FreeMemoryBlock *>
PUBLIC	??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ; std::fill<FreeMemoryBlock *,FreeMemoryBlock>
PUBLIC	??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>
PUBLIC	??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ ; `string'
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
CONST	SEGMENT
??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$2
__catchsym$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$6
__unwindtable$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
tv263 = -68						; size = 4
tv262 = -64						; size = 4
tv94 = -60						; size = 4
__Oldend$14404 = -56					; size = 4
__Ptr$14384 = -52					; size = 4
__Newvec$14383 = -48					; size = 4
__Capacity$ = -44					; size = 4
__Tmp$ = -36						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 12
__Count$ = 20						; size = 4
__Val$ = 24						; size = 4
?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Insert_n, COMDAT
; _this$ = ecx

; 1117 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1118 : 
; 1119 :  #if _HAS_ITERATOR_DEBUGGING
; 1120 : 		if (_Where._Mycont != this
; 1121 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN13@Insert_n
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN13@Insert_n
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	jae	SHORT $LN14@Insert_n
$LN13@Insert_n:

; 1122 : 			_DEBUG_ERROR("vector insert iterator outside range");

	push	1122					; 00000462H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN14@Insert_n:

; 1123 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1124 : 
; 1125 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$[ebp+8], edx

; 1126 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1127 : 
; 1128 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN12@Insert_n
	jmp	$LN11@Insert_n
$LN12@Insert_n:

; 1129 : 			;
; 1130 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN10@Insert_n

; 1131 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Xlen
	jmp	$LN11@Insert_n
$LN10@Insert_n:

; 1132 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN8@Insert_n

; 1133 : 			{	// not enough room, reallocate
; 1134 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1135 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv94[ebp], eax
$LN18@Insert_n:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1136 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN7@Insert_n

; 1137 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN7@Insert_n:

; 1138 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::allocate
	mov	DWORD PTR __Newvec$14383[ebp], eax

; 1139 : 			pointer _Ptr = _Newvec;

	mov	eax, DWORD PTR __Newvec$14383[ebp]
	mov	DWORD PTR __Ptr$14384[ebp], eax

; 1140 : 
; 1141 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1142 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1143 : 				_Newvec);	// copy prefix

	mov	ecx, DWORD PTR __Newvec$14383[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>
	mov	DWORD PTR tv262[ebp], eax
	mov	edx, DWORD PTR tv262[ebp]
	mov	DWORD PTR __Ptr$14384[ebp], edx

; 1144 : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$14384[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill
	mov	DWORD PTR tv263[ebp], eax
	mov	eax, DWORD PTR tv263[ebp]
	mov	DWORD PTR __Ptr$14384[ebp], eax

; 1145 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	ecx, DWORD PTR __Ptr$14384[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$0:

; 1146 : 			_CATCH_ALL
; 1147 : 			_Destroy(_Newvec, _Ptr);

	mov	edx, DWORD PTR __Ptr$14384[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$14383[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy

; 1148 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$14383[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::deallocate

; 1149 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1150 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$1:

; 1151 : 
; 1152 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1153 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@Insert_n

; 1154 : 				{	// destroy and deallocate old array
; 1155 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy

; 1156 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z ; std::allocator<FreeMemoryBlock>::deallocate
$LN5@Insert_n:

; 1157 : 				}
; 1158 : 
; 1159 :  #if _HAS_ITERATOR_DEBUGGING
; 1160 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base@std@@QBEXXZ ; std::_Container_base::_Orphan_all

; 1161 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1162 : 
; 1163 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$14383[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1164 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$14383[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1165 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$14383[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN11@Insert_n
$LN8@Insert_n:

; 1166 : 			}
; 1167 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR __Where$[ebp+8]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1168 : 			{	// new stuff spills off end
; 1169 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1170 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>

; 1171 : 
; 1172 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1173 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1174 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR __Where$[ebp+8]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$2:

; 1175 : 			_CATCH_ALL
; 1176 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Destroy

; 1177 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1178 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$3:

; 1179 : 
; 1180 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1181 : 
; 1182 :  #if _HAS_ITERATOR_DEBUGGING
; 1183 : 			_Orphan_range(_Where._Myptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range

; 1184 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1185 : 
; 1186 : 			fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1187 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	call	??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ; std::fill<FreeMemoryBlock *,FreeMemoryBlock>
	add	esp, 12					; 0000000cH

; 1188 : 			}
; 1189 : 		else

	jmp	SHORT $LN11@Insert_n
$LN3@Insert_n:

; 1190 : 			{	// new stuff can all be assigned
; 1191 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Oldend$14404[ebp], edx

; 1192 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1193 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Oldend$14404[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Oldend$14404[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 1194 : 
; 1195 :  #if _HAS_ITERATOR_DEBUGGING
; 1196 : 			_Orphan_range(_Where._Myptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range

; 1197 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1198 : 
; 1199 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1200 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$14404[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR __Oldend$14404[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	call	??$_Unchecked_move_backward@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ; stdext::_Unchecked_move_backward<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 12					; 0000000cH

; 1201 : 			fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1202 : 				_Tmp);	// insert into hole

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	call	??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ; std::fill<FreeMemoryBlock *,FreeMemoryBlock>
	add	esp, 12					; 0000000cH
$LN11@Insert_n:

; 1203 : 			}
; 1204 : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN16@Insert_n:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@Insert_n
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN33@Insert_n:
	DD	1
	DD	$LN32@Insert_n
$LN32@Insert_n:
	DD	-36					; ffffffdcH
	DD	12					; 0000000cH
	DD	$LN30@Insert_n
$LN30@Insert_n:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z$4:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@2@IABVFreeMemoryBlock@@@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Insert_n
PUBLIC	??$unchecked_uninitialized_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill, COMDAT
; _this$ = ecx

; 1207 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1208 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	add	esp, 16					; 00000010H

; 1209 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Ptr$[ebp]

; 1210 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV3@IABV3@@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Ufill
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z
_TEXT	SEGMENT
__Pnext$ = -20						; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1229 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1230 : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 1231 : 		const_iterator **_Pnext = (const_iterator **)&this->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Pnext$[ebp], eax
$LN5@Orphan_ran:

; 1232 : 		while (*_Pnext != 0)

	mov	ecx, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@Orphan_ran

; 1233 : 			if ((*_Pnext)->_Myptr < _First || _Last < (*_Pnext)->_Myptr)

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1234 : 				_Pnext = (const_iterator **)&(*_Pnext)->_Mynextiter;

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 1235 : 			else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1236 : 				{	// orphan the iterator
; 1237 : 				(*_Pnext)->_Mycont = 0;

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], 0

; 1238 : 				*_Pnext = (const_iterator *)(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN1@Orphan_ran:

; 1239 : 				}

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1240 : 		}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN11@Orphan_ran:
	DD	1
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN9@Orphan_ran
$LN9@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_range@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IBEXPAVFreeMemoryBlock@@0@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@VFreeMemoryBlock@@@std@@QAE@ABV01@@Z ; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>
PUBLIC	??0_Container_base@std@@QAE@XZ			; std::_Container_base::_Container_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE@V?$allocator@VFreeMemoryBlock@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE@V?$allocator@VFreeMemoryBlock@@@1@@Z PROC ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx

; 412  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base@std@@QAE@XZ		; std::_Container_base::_Container_base
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@VFreeMemoryBlock@@@std@@QAE@ABV01@@Z ; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>

; 413  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAE@V?$allocator@VFreeMemoryBlock@@@1@@Z ENDP ; std::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_val<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Container_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base@std@@QAE@XZ PROC			; std::_Container_base::_Container_base, COMDAT
; _this$ = ecx

; 91   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 92   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base@std@@QAE@XZ ENDP			; std::_Container_base::_Container_base
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VFreeMemoryBlock@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VFreeMemoryBlock@@@std@@QAE@XZ PROC	; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VFreeMemoryBlock@@@std@@QAE@XZ ENDP	; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::allocate
PUBLIC	?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Xlen
PUBLIC	?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
;	COMDAT ?_Buy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE_NI@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Buy, COMDAT
; _this$ = ecx

; 1066 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1068 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1069 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1070 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1071 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Xlen

; 1072 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1075 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+12], ecx

; 1076 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx
$LN3@Buy@2:

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1079 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@@Z ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy, COMDAT
; _this$ = ecx

; 1082 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@@Z ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	add	esp, 12					; 0000000cH

; 1084 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ; stdext::_Unchecked_move_backward<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
PUBLIC	??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ; std::fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
PUBLIC	?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::deallocate
PUBLIC	?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Ufill
PUBLIC	??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>
PUBLIC	?capacity@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::capacity
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$2
__catchsym$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$6
__unwindtable$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
tv263 = -64						; size = 4
tv262 = -60						; size = 4
tv94 = -56						; size = 4
__Oldend$14504 = -52					; size = 4
__Ptr$14484 = -48					; size = 4
__Newvec$14483 = -44					; size = 4
__Capacity$ = -40					; size = 4
__Tmp$ = -32						; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 12
__Count$ = 20						; size = 4
__Val$ = 24						; size = 4
?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Insert_n, COMDAT
; _this$ = ecx

; 1117 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1118 : 
; 1119 :  #if _HAS_ITERATOR_DEBUGGING
; 1120 : 		if (_Where._Mycont != this
; 1121 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN13@Insert_n@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN13@Insert_n@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	jae	SHORT $LN14@Insert_n@2
$LN13@Insert_n@2:

; 1122 : 			_DEBUG_ERROR("vector insert iterator outside range");

	push	1122					; 00000462H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN14@Insert_n@2:

; 1123 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1124 : 
; 1125 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$[ebp], eax
	mov	DWORD PTR __Tmp$[ebp+4], ecx

; 1126 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1127 : 
; 1128 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN12@Insert_n@2
	jmp	$LN11@Insert_n@2
$LN12@Insert_n@2:

; 1129 : 			;
; 1130 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN10@Insert_n@2

; 1131 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Xlen
	jmp	$LN11@Insert_n@2
$LN10@Insert_n@2:

; 1132 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN8@Insert_n@2

; 1133 : 			{	// not enough room, reallocate
; 1134 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1135 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv94[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1136 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN7@Insert_n@2

; 1137 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN7@Insert_n@2:

; 1138 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::allocate
	mov	DWORD PTR __Newvec$14483[ebp], eax

; 1139 : 			pointer _Ptr = _Newvec;

	mov	edx, DWORD PTR __Newvec$14483[ebp]
	mov	DWORD PTR __Ptr$14484[ebp], edx

; 1140 : 
; 1141 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1142 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1143 : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR __Newvec$14483[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>
	mov	DWORD PTR tv262[ebp], eax
	mov	ecx, DWORD PTR tv262[ebp]
	mov	DWORD PTR __Ptr$14484[ebp], ecx

; 1144 : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$14484[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Ufill
	mov	DWORD PTR tv263[ebp], eax
	mov	edx, DWORD PTR tv263[ebp]
	mov	DWORD PTR __Ptr$14484[ebp], edx

; 1145 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	eax, DWORD PTR __Ptr$14484[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$0:

; 1146 : 			_CATCH_ALL
; 1147 : 			_Destroy(_Newvec, _Ptr);

	mov	ecx, DWORD PTR __Ptr$14484[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$14483[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy

; 1148 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$14483[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::deallocate

; 1149 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1150 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$1:

; 1151 : 
; 1152 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1153 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN5@Insert_n@2

; 1154 : 				{	// destroy and deallocate old array
; 1155 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy

; 1156 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z ; std::allocator<AllocatedMemoryBlock>::deallocate
$LN5@Insert_n@2:

; 1157 : 				}
; 1158 : 
; 1159 :  #if _HAS_ITERATOR_DEBUGGING
; 1160 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base@std@@QBEXXZ ; std::_Container_base::_Orphan_all

; 1161 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1162 : 
; 1163 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$14483[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1164 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$14483[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1165 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$14483[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN11@Insert_n@2
$LN8@Insert_n@2:

; 1166 : 			}
; 1167 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR __Where$[ebp+8]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1168 : 			{	// new stuff spills off end
; 1169 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1170 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>

; 1171 : 
; 1172 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1173 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1174 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR __Where$[ebp+8]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$2:

; 1175 : 			_CATCH_ALL
; 1176 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Destroy

; 1177 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1178 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, __tryend$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$3:

; 1179 : 
; 1180 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1181 : 
; 1182 :  #if _HAS_ITERATOR_DEBUGGING
; 1183 : 			_Orphan_range(_Where._Myptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range

; 1184 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1185 : 
; 1186 : 			fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1187 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	call	??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ; std::fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH

; 1188 : 			}
; 1189 : 		else

	jmp	SHORT $LN11@Insert_n@2
$LN3@Insert_n@2:

; 1190 : 			{	// new stuff can all be assigned
; 1191 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Oldend$14504[ebp], eax

; 1192 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1193 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Oldend$14504[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$14504[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1194 : 
; 1195 :  #if _HAS_ITERATOR_DEBUGGING
; 1196 : 			_Orphan_range(_Where._Myptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range

; 1197 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1198 : 
; 1199 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1200 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$14504[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$14504[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	call	??$_Unchecked_move_backward@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ; stdext::_Unchecked_move_backward<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 12					; 0000000cH

; 1201 : 			fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1202 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+8]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	call	??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ; std::fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH
$LN11@Insert_n@2:

; 1203 : 			}
; 1204 : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
$LN16@Insert_n@2:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@Insert_n@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN33@Insert_n@2:
	DD	1
	DD	$LN32@Insert_n@2
$LN32@Insert_n@2:
	DD	-32					; ffffffe0H
	DD	8
	DD	$LN30@Insert_n@2
$LN30@Insert_n@2:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z$4:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEXV?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@2@IABVAllocatedMemoryBlock@@@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Insert_n
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z
_TEXT	SEGMENT
__Pnext$ = -20						; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1229 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1230 : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 1231 : 		const_iterator **_Pnext = (const_iterator **)&this->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Pnext$[ebp], eax
$LN5@Orphan_ran@2:

; 1232 : 		while (*_Pnext != 0)

	mov	ecx, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@Orphan_ran@2

; 1233 : 			if ((*_Pnext)->_Myptr < _First || _Last < (*_Pnext)->_Myptr)

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran@2
	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Orphan_ran@2
$LN2@Orphan_ran@2:

; 1234 : 				_Pnext = (const_iterator **)&(*_Pnext)->_Mynextiter;

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 1235 : 			else

	jmp	SHORT $LN1@Orphan_ran@2
$LN3@Orphan_ran@2:

; 1236 : 				{	// orphan the iterator
; 1237 : 				(*_Pnext)->_Mycont = 0;

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], 0

; 1238 : 				*_Pnext = (const_iterator *)(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN1@Orphan_ran@2:

; 1239 : 				}

	jmp	SHORT $LN5@Orphan_ran@2
$LN4@Orphan_ran@2:

; 1240 : 		}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Orphan_ran@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN11@Orphan_ran@2:
	DD	1
	DD	$LN10@Orphan_ran@2
$LN10@Orphan_ran@2:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN9@Orphan_ran@2
$LN9@Orphan_ran@2:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_range@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IBEXPAVAllocatedMemoryBlock@@0@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@ABV01@@Z ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE@V?$allocator@VAllocatedMemoryBlock@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE@V?$allocator@VAllocatedMemoryBlock@@@1@@Z PROC ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx

; 412  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base@std@@QAE@XZ		; std::_Container_base::_Container_base
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@ABV01@@Z ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>

; 413  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAE@V?$allocator@VAllocatedMemoryBlock@@@1@@Z ENDP ; std::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_val<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@XZ PROC	; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@XZ ENDP	; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx

; 308  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >

; 309  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEABVFreeMemoryBlock@@XZ ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??D?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEAAVFreeMemoryBlock@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEAAVFreeMemoryBlock@@XZ PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*, COMDAT
; _this$ = ecx

; 325  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEABVFreeMemoryBlock@@XZ ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*

; 327  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEAAVFreeMemoryBlock@@XZ ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=, COMDAT
; _this$ = ecx

; 361  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=

; 363  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0
__ehfuncinfo$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
$T17297 = -40						; size = 4
__Tmp$ = -32						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-, COMDAT
; _this$ = ecx

; 378  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T17297[ebp], 0

; 379  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 380  : 		return (_Tmp -= _Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T17297[ebp]
	or	edx, 1
	mov	DWORD PTR $T17297[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 381  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator@6
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator@6:
	DD	1
	DD	$LN8@operator@6
$LN8@operator@6:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN6@operator@6
$LN6@operator@6:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
__unwindfunclet$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z$1:
	mov	eax, DWORD PTR $T17297[ebp]
	and	eax, 1
	je	$LN5@operator@6
	and	DWORD PTR $T17297[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@XZ
$LN5@operator@6:
	ret	0
__ehhandler$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z:
	mov	eax, OFFSET __ehfuncinfo$??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
PUBLIC	??G?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@1@@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-, COMDAT
; _this$ = ecx

; 384  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-

; 386  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@1@@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx

; 308  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >

; 309  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??Y?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=, COMDAT
; _this$ = ecx

; 361  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=

; 363  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??G?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@1@@Z PROC ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-, COMDAT
; _this$ = ecx

; 384  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-

; 386  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@1@@Z ENDP ; std::_Vector_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VFreeMemoryBlock@@@std@@QBEIXZ ; std::allocator<FreeMemoryBlock>::max_size
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size, COMDAT
; _this$ = ecx

; 707  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$allocator@VFreeMemoryBlock@@@std@@QBEIXZ ; std::allocator<FreeMemoryBlock>::max_size

; 709  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::max_size
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02cH
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z44
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z44
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T17322 = -88						; size = 32
$T17321 = -56						; size = 44
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T17322[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T17322[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17321[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T17321[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T17322[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@Xlen:

; 1215 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T17322[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@KAXXZ ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Xlen
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File c:\microsoft visual studio 8\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 106  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 107  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??0exception@std@@QAE@XZ:PROC			; std::exception::exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 27   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 28   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 37   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 31   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@

; 32   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 110  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 111  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File c:\microsoft visual studio 8\vc\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 720  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 721  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 722  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 723  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 904  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 905  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 906  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1621 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1622 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1623 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??1_String_base@std@@QAE@XZ			; std::_String_base::~_String_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_String_base@std@@QAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1_String_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_String_base@std@@QAE@XZ PROC			; std::_String_base::~_String_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base@std@@QAE@XZ		; std::_Container_base::~_Container_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_String_base@std@@QAE@XZ ENDP			; std::_String_base::~_String_base
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1038 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1040 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1041 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1042 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1043 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1044 : 
; 1045 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1046 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1047 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1048 : 			{	// make room and assign new stuff
; 1049 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1050 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1051 : 			}
; 1052 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1053 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$14323 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2066 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2067 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy@2
	jmp	SHORT $LN3@Tidy@2
$LN4@Tidy@2:

; 2068 : 			;
; 2069 : 		else if (_BUF_SIZE <= _Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 16			; 00000010H
	jb	SHORT $LN3@Tidy@2

; 2070 : 			{	// copy any leftovers to small buffer and deallocate
; 2071 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Ptr$14323[ebp], eax

; 2072 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy@2

; 2073 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$14323[ebp]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H
$LN1@Tidy@2:

; 2074 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$14323[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN3@Tidy@2:

; 2075 : 			}
; 2076 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 15			; 0000000fH

; 2077 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2078 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2092 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2093 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR tv70[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv70[ebp]

; 2094 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0_String_base@std@@QAE@XZ			; std::_String_base::_String_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 477  : 		{	// copy constructor

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_String_base@std@@QAE@XZ
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 478  : #if defined(_DEBUG)
; 479  : 		if (_Right._Myfirstiter == _IGNORE_MYITERLIST)

	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx], -3			; fffffffdH
	jne	SHORT $LN2@String_val

; 480  : 			{
; 481  : 			this->_Myfirstiter = _IGNORE_MYITERLIST;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], -3			; fffffffdH
$LN2@String_val:

; 482  : 			}
; 483  : #endif
; 484  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??0_String_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_String_base@std@@QAE@XZ PROC			; std::_String_base::_String_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base@std@@QAE@XZ		; std::_Container_base::_Container_base
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_String_base@std@@QAE@XZ ENDP			; std::_String_base::_String_base
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$14568 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1240 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1241 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN3@erase@3

; 1242 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase@3:

; 1243 : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN2@erase@3

; 1244 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN2@erase@3:

; 1245 : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@erase@3

; 1246 : 			{	// move elements down
; 1247 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1248 : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1249 : 			size_type _Newsize = _Mysize - _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$14568[ebp], edx

; 1250 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$14568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@erase@3:

; 1251 : 			}
; 1252 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1253 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1636 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 1638 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T17399 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2030 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2031 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T17399[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+24], ecx
	lea	edx, DWORD PTR $T17399[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2032 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 417  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 418  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 419  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2036 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2037 : 			if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2038 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2039 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2040 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2041 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2042 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2043 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv80[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv80[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2044 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2045 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2046 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 2047 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2087 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2088 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN4@Myptr@2
$LN3@Myptr@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR tv70[ebp], eax
$LN4@Myptr@2:
	mov	eax, DWORD PTR tv70[ebp]

; 2089 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$allocator@VFreeMemoryBlock@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VFreeMemoryBlock@@@std@@QAE@ABV01@@Z PROC ; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VFreeMemoryBlock@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<FreeMemoryBlock>::allocator<FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z PROC ; std::allocator<FreeMemoryBlock>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@I@Z ENDP ; std::allocator<FreeMemoryBlock>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@VFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@IPAV1@@Z ; std::_Allocate<FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z PROC ; std::allocator<FreeMemoryBlock>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@IPAV1@@Z ; std::_Allocate<FreeMemoryBlock>
	add	esp, 8

; 147  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VFreeMemoryBlock@@@std@@QAEPAVFreeMemoryBlock@@I@Z ENDP ; std::allocator<FreeMemoryBlock>::allocate
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::capacity, COMDAT
; _this$ = ecx

; 621  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 623  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VAllocatedMemoryBlock@@@std@@QBEIXZ ; std::allocator<AllocatedMemoryBlock>::max_size
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size, COMDAT
; _this$ = ecx

; 707  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$allocator@VAllocatedMemoryBlock@@@std@@QBEIXZ ; std::allocator<AllocatedMemoryBlock>::max_size

; 709  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::max_size
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Ufill, COMDAT
; _this$ = ecx

; 1207 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1208 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	add	esp, 16					; 00000010H

; 1209 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1210 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV3@IABV3@@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Ufill
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T17431 = -88						; size = 32
$T17430 = -56						; size = 44
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T17431[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T17431[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17430[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T17430[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T17431[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@Xlen@2:

; 1215 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T17431[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@KAXXZ ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Xlen
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@ABV01@@Z PROC ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VAllocatedMemoryBlock@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<AllocatedMemoryBlock>::allocator<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z PROC ; std::allocator<AllocatedMemoryBlock>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@I@Z ENDP ; std::allocator<AllocatedMemoryBlock>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@VAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@IPAV1@@Z ; std::_Allocate<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z PROC ; std::allocator<AllocatedMemoryBlock>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@IPAV1@@Z ; std::_Allocate<AllocatedMemoryBlock>
	add	esp, 8

; 147  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VAllocatedMemoryBlock@@@std@@QAEPAVAllocatedMemoryBlock@@I@Z ENDP ; std::allocator<AllocatedMemoryBlock>::allocate
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Z?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-=, COMDAT
; _this$ = ecx

; 373  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=

; 375  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Vector_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-=
_TEXT	ENDS
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1PA@HNBAMDIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@ ; `string'
PUBLIC	??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1PA@HNBAMDIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1PA@HNBAMDIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'F', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
CONST	SEGMENT
??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, '(', 00H, '(', 00H, '(', 00H, '_', 00H, 'M'
	DB	00H, 'y', 00H, 'v', 00H, 'e', 00H, 'c', 00H, ' ', 00H, '*', 00H
	DB	')', 00H, '_', 00H, 'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ')', 00H, '-', 00H, '>', 00H, '_', 00H
	DB	'M', 00H, 'y', 00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, '(', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, ' ', 00H, '*', 00H, ')', 00H, '_', 00H
	DB	'P', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, '_', 00H, 'M', 00H, 'y', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 't', 00H, ')', 00H, '"', 00H, ','
	DB	00H, ' ', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT
; _this$ = ecx

; 69   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 70   : 		{	// construct with pointer _Ptr
; 71   : 		_SCL_SECURE_VALIDATE(_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast));

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN2@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	xor	ecx, ecx
	jne	SHORT $LN5@Vector_con
	push	OFFSET ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
	push	0
	push	71					; 00000047H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@Vector_con
	int	3
$LN5@Vector_con:
	push	0
	push	71					; 00000047H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1PA@HNBAMDIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@Vector_con:

; 72   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z ; std::_Iterator_base::_Adopt

; 73   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 74   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAE@PAVFreeMemoryBlock@@PBV_Container_base@1@@Z ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	??_C@_1NI@IDJCJMFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
;	COMDAT ??_C@_1NI@IDJCJMFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NI@IDJCJMFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'F', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '*', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEABVFreeMemoryBlock@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEABVFreeMemoryBlock@@XZ PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*, COMDAT
; _this$ = ecx

; 92   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 
; 94   :  #if _HAS_ITERATOR_DEBUGGING
; 95   : 		if (this->_Mycont == 0
; 96   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 97   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $LN1@operator@7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator@7
$LN1@operator@7:

; 98   : 			{
; 99   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	push	99					; 00000063H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH

; 100  : 			_SCL_SECURE_OUT_OF_RANGE;

	xor	eax, eax
	jne	SHORT $LN5@operator@7
	push	OFFSET ??_C@_1FG@CMLDHNON@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
	push	0
	push	100					; 00000064H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@operator@7
	int	3
$LN5@operator@7:
	push	0
	push	100					; 00000064H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1NI@IDJCJMFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@operator@7:

; 101  : 			}
; 102  :  #else
; 103  :  		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);
; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);
; 105  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 106  : 
; 107  : 		return (*_Myptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]

; 108  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEABVFreeMemoryBlock@@XZ ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator*
_TEXT	ENDS
PUBLIC	??_C@_1OO@PBNBABMO@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$CL?$AA?5?$AA_?$AAO?$AAf?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt@ ; `string'
PUBLIC	??_C@_1NK@GJOLCLLL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1DK@LIMPPGHH@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAM?$AAy?$AAc?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1OO@PBNBABMO@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$CL?$AA?5?$AA_?$AAO?$AAf?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt@
CONST	SEGMENT
??_C@_1OO@PBNBABMO@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$CL?$AA?5?$AA_?$AAO?$AAf?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt@ DB '('
	DB	00H, '"', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'p', 00H, 't', 00H
	DB	'r', 00H, ' ', 00H, '+', 00H, ' ', 00H, '_', 00H, 'O', 00H, 'f'
	DB	00H, 'f', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H
	DB	'(', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, ' ', 00H, '*', 00H, ')', 00H, '(', 00H, 't', 00H, 'h', 00H
	DB	'i', 00H, 's', 00H, '-', 00H, '>', 00H, '_', 00H, 'M', 00H, 'y'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, ')', 00H, ')', 00H
	DB	'-', 00H, '>', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 't', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'_', 00H, 'M', 00H, 'y', 00H, 'p', 00H, 't', 00H, 'r', 00H, ' '
	DB	00H, '+', 00H, ' ', 00H, '_', 00H, 'O', 00H, 'f', 00H, 'f', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '(', 00H, '(', 00H, '_'
	DB	00H, 'M', 00H, 'y', 00H, 'v', 00H, 'e', 00H, 'c', 00H, ' ', 00H
	DB	'*', 00H, ')', 00H, '(', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, '-', 00H, '>', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, ')', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, '_', 00H, 'M', 00H, 'y', 00H, 'f', 00H, 'i', 00H, 'r', 00H
	DB	's', 00H, 't', 00H, '"', 00H, ',', 00H, ' ', 00H, '0', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@GJOLCLLL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@GJOLCLLL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'F', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, '=', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@LIMPPGHH@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAM?$AAy?$AAc?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@LIMPPGHH@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAM?$AAy?$AAc?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, '"', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H
	DB	'>', 00H, '_', 00H, 'M', 00H, 'y', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, '"', 00H, ',', 00H, ' ', 00H, '0'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=, COMDAT
; _this$ = ecx

; 146  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator@8
	xor	ecx, ecx
	jne	SHORT $LN6@operator@8
	push	OFFSET ??_C@_1DK@LIMPPGHH@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAM?$AAy?$AAc?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	147					; 00000093H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN6@operator@8
	int	3
$LN6@operator@8:
	push	0
	push	147					; 00000093H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1NK@GJOLCLLL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN3@operator@8:

; 148  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+12]
	ja	SHORT $LN1@operator@8
	mov	edx, DWORD PTR __Off$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@8
$LN1@operator@8:
	xor	ecx, ecx
	jne	SHORT $LN7@operator@8
	push	OFFSET ??_C@_1OO@PBNBABMO@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$CL?$AA?5?$AA_?$AAO?$AAf?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt@
	push	0
	push	150					; 00000096H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN7@operator@8
	int	3
$LN7@operator@8:

; 149  : 			_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast &&
; 150  : 			_Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst);

	push	0
	push	150					; 00000096H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1NK@GJOLCLLL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@operator@8:

; 151  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 152  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator+=
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Compat
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??G?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-, COMDAT
; _this$ = ecx

; 173  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 
; 175  :  #if _HAS_ITERATOR_DEBUGGING
; 176  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Compat

; 177  :  #else
; 178  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);
; 179  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 180  : 
; 181  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 182  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::operator-
_TEXT	ENDS
PUBLIC	??_C@_1BAE@GLJHINLB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
;	COMDAT ??_C@_1BAE@GLJHINLB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1BAE@GLJHINLB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'M'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT
; _this$ = ecx

; 69   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 70   : 		{	// construct with pointer _Ptr
; 71   : 		_SCL_SECURE_VALIDATE(_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast));

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN2@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	xor	ecx, ecx
	jne	SHORT $LN5@Vector_con@2
	push	OFFSET ??_C@_1NK@JLHOCNGO@?$AA?$CI?$AA?$CC?$AA_?$AAP?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5@
	push	0
	push	71					; 00000047H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@Vector_con@2
	int	3
$LN5@Vector_con@2:
	push	0
	push	71					; 00000047H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1BAE@GLJHINLB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@Vector_con@2:

; 72   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base@std@@QAEXPBV_Container_base@2@@Z ; std::_Iterator_base::_Adopt

; 73   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 74   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAE@PAVAllocatedMemoryBlock@@PBV_Container_base@1@@Z ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??_C@_1OO@OLDFJFKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1OO@OLDFJFKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OO@OLDFJFKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'M'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '='
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=, COMDAT
; _this$ = ecx

; 146  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator@9
	xor	ecx, ecx
	jne	SHORT $LN6@operator@9
	push	OFFSET ??_C@_1DK@LIMPPGHH@?$AA?$CI?$AA?$CC?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AA_?$AAM?$AAy?$AAc?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$CC?$AA?0?$AA?5?$AA0?$AA?$CJ?$AA?$AA@
	push	0
	push	147					; 00000093H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN6@operator@9
	int	3
$LN6@operator@9:
	push	0
	push	147					; 00000093H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1OO@OLDFJFKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN3@operator@9:

; 148  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	ja	SHORT $LN1@operator@9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN2@operator@9
$LN1@operator@9:
	xor	eax, eax
	jne	SHORT $LN7@operator@9
	push	OFFSET ??_C@_1OO@PBNBABMO@?$AA?$CI?$AA?$CC?$AA_?$AAM?$AAy?$AAp?$AAt?$AAr?$AA?5?$AA?$CL?$AA?5?$AA_?$AAO?$AAf?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AA_?$AAM?$AAy?$AAv?$AAe?$AAc?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAt@
	push	0
	push	150					; 00000096H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN7@operator@9
	int	3
$LN7@operator@9:

; 149  : 			_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast &&
; 150  : 			_Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst);

	push	0
	push	150					; 00000096H
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1OO@OLDFJFKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN2@operator@9:

; 151  : 		_Myptr += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 152  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator+=
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Compat
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??G?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-, COMDAT
; _this$ = ecx

; 173  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 
; 175  :  #if _HAS_ITERATOR_DEBUGGING
; 176  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Compat

; 177  :  #else
; 178  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);
; 179  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 180  : 
; 181  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 3

; 182  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::operator-
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ PROC ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VFreeMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ENDP ; std::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>::_Ranit<FreeMemoryBlock,int,FreeMemoryBlock const *,FreeMemoryBlock const &>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 127  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 128  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ PROC ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VAllocatedMemoryBlock@@HPBV1@ABV1@@std@@QAE@XZ ENDP ; std::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>::_Ranit<AllocatedMemoryBlock,int,AllocatedMemoryBlock const *,AllocatedMemoryBlock const &>
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T17505 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 650  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T17505[ebp], esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 651  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 652  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 653  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1641 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1642 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1643 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv69[ebp]

; 1644 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv149 = -36						; size = 4
tv148 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2000 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2001 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2002 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN6@Copy

; 2003 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2004 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN5@Copy
$LN6@Copy:

; 2005 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $LN5@Copy
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+28]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], eax
	ja	SHORT $LN5@Copy

; 2006 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR __Newres$[ebp], eax
$LN5@Copy:

; 2007 : 		_Elem *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 2008 : 
; 2009 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2010 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv148[ebp], eax
	mov	eax, DWORD PTR tv148[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN9@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 2011 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2012 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2013 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2014 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv149[ebp], eax
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN11@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 2015 : 			_CATCH_ALL
; 2016 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2017 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2018 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$2
	ret	0
$LN11@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$2:

; 2019 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3
	ret	0
$LN9@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3:

; 2020 : 
; 2021 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2022 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H
$LN1@Copy:

; 2023 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2024 : 		_Bx._Ptr = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 2025 : 		_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 2026 : 		_Eos(_Oldlen);

	mov	edx, DWORD PTR __Oldlen$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN8@Copy:

; 2027 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VFreeMemoryBlock@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@VFreeMemoryBlock@@@std@@QBEIXZ PROC ; std::allocator<FreeMemoryBlock>::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 357913941	; 15555555H

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VFreeMemoryBlock@@@std@@QBEIXZ ENDP ; std::allocator<FreeMemoryBlock>::max_size
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VAllocatedMemoryBlock@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@VAllocatedMemoryBlock@@@std@@QBEIXZ PROC ; std::allocator<AllocatedMemoryBlock>::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VAllocatedMemoryBlock@@@std@@QBEIXZ ENDP ; std::allocator<AllocatedMemoryBlock>::max_size
_TEXT	ENDS
PUBLIC	??_C@_1NC@CBJKFKDD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1NC@CBJKFKDD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; File c:\microsoft visual studio 8\vc\include\vector
CONST	SEGMENT
??_C@_1NC@CBJKFKDD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'F', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
CONST	SEGMENT
??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@ DB '('
	DB	00H, '"', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'a', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+'
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H
	DB	'r', 00H, 'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H
	DB	'A', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, '"', 00H, ',', 00H, ' ', 00H, '0', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Compat, COMDAT
; _this$ = ecx

; 235  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN3@Compat
$LN1@Compat:

; 237  : 			{
; 238  : 			_DEBUG_ERROR("vector iterators incompatible");

	push	238					; 000000eeH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH

; 239  : 			_SCL_SECURE_INVALID_ARGUMENT;

	xor	ecx, ecx
	jne	SHORT $LN5@Compat
	push	OFFSET ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
	push	0
	push	239					; 000000efH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	push	0
	push	239					; 000000efH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1NC@CBJKFKDD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN3@Compat:

; 240  : 			}
; 241  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Compat
_TEXT	ENDS
PUBLIC	??_C@_1OG@FMFLCIEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
;	COMDAT ??_C@_1OG@FMFLCIEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OG@FMFLCIEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, 'M', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'k', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'M'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Compat, COMDAT
; _this$ = ecx

; 235  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 		if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Compat@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN3@Compat@2
$LN1@Compat@2:

; 237  : 			{
; 238  : 			_DEBUG_ERROR("vector iterators incompatible");

	push	238					; 000000eeH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH

; 239  : 			_SCL_SECURE_INVALID_ARGUMENT;

	xor	ecx, ecx
	jne	SHORT $LN5@Compat@2
	push	OFFSET ??_C@_1FO@OCPOOAIA@?$AA?$CI?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd@
	push	0
	push	239					; 000000efH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	2
	call	__CrtDbgReportW
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $LN5@Compat@2
	int	3
$LN5@Compat@2:
	push	0
	push	239					; 000000efH
	push	OFFSET ??_C@_1FO@LOAHDEOC@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	push	OFFSET ??_C@_1OG@FMFLCIEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
$LN3@Compat@2:

; 240  : 			}
; 241  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Compat
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1069 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1070 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1071 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 440  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 441  : //		_DEBUG_POINTER(_First);
; 442  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 443  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 471  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_String_base@std@@QAE@XZ
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 472  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 147  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1056 : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign@2

; 1058 : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign@2
$LN2@assign@2:

; 1059 : 
; 1060 : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign@2

; 1061 : 			{	// make room and assign new stuff
; 1062 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 16					; 00000010H

; 1063 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign@2:

; 1064 : 			}
; 1065 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign@2:

; 1066 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	??_C@_1GA@JCBKCKEE@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ ; `string'
;	COMDAT ??_C@_1GA@JCBKCKEE@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
CONST	SEGMENT
??_C@_1GA@JCBKCKEE@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' '
	DB	00H, '8', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\'
	DB	00H, 'x', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2050 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2051 : 		_DEBUG_POINTER(_Ptr);

	push	2051					; 00000803H
	push	OFFSET ??_C@_1GA@JCBKCKEE@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 2052 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2053 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2054 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2055 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2056 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; File c:\microsoft visual studio 8\vc\include\xutility
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 1370 : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp

; 1371 : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 1372 : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin:

; 1373 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *>
PUBLIC	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
PUBLIC	??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z ; std::_Iter_random<FreeMemoryBlock *,FreeMemoryBlock *>
PUBLIC	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$unchecked_copy@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z
_TEXT	SEGMENT
$T17576 = -3						; size = 1
$T17575 = -2						; size = 1
$T17574 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z PROC ; stdext::unchecked_copy<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 3407 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 3408 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3409 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17574[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17575[ebp], al
	mov	al, BYTE PTR $T17574[ebp]
	push	eax
	mov	cl, BYTE PTR $T17575[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17576[ebp]
	push	ecx
	call	??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z ; std::_Iter_random<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 12					; 0000000cH
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 24					; 00000018H

; 3410 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ENDP ; stdext::unchecked_copy<FreeMemoryBlock *,FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
PUBLIC	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
PUBLIC	??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z ; std::_Iter_random<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
PUBLIC	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$unchecked_copy@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z
_TEXT	SEGMENT
$T17581 = -3						; size = 1
$T17580 = -2						; size = 1
$T17579 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z PROC ; stdext::unchecked_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 3407 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 3408 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3409 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17579[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17580[ebp], al
	mov	al, BYTE PTR $T17579[ebp]
	push	eax
	mov	cl, BYTE PTR $T17580[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17581[ebp]
	push	ecx
	call	??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z ; std::_Iter_random<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 12					; 0000000cH
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 24					; 00000018H

; 3410 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ENDP ; stdext::unchecked_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
$T17584 = -1						; size = 1
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 581  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 582  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	call	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
	mov	BYTE PTR $T17584[ebp], al
	mov	al, BYTE PTR $T17584[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
	add	esp, 20					; 00000014H

; 583  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@@Z
_TEXT	SEGMENT
$T17587 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@@Z PROC ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT

; 225  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17587[ebp], al
	mov	dl, BYTE PTR $T17587[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	add	esp, 16					; 00000010H

; 227  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@@Z ENDP ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z PROC ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
	add	esp, 16					; 00000010H

; 1113 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAVFreeMemoryBlock@@@?$vector@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@IAEPAVFreeMemoryBlock@@PAV2@00@Z ENDP ; std::vector<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >::_Umove<FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ; std::_Fill<FreeMemoryBlock *,FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z PROC ; std::fill<FreeMemoryBlock *,FreeMemoryBlock>, COMDAT

; 2976 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2977 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ; std::_Fill<FreeMemoryBlock *,FreeMemoryBlock>
	add	esp, 12					; 0000000cH

; 2978 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ENDP ; std::fill<FreeMemoryBlock *,FreeMemoryBlock>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVFreeMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z ; std::_Move_cat<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Unchecked_move_backward@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z
_TEXT	SEGMENT
$T17596 = -3						; size = 1
$T17595 = -2						; size = 1
$T17594 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 3497 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 3498 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3499 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17594[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z ; std::_Move_cat<FreeMemoryBlock *>
	add	esp, 4
	mov	BYTE PTR $T17595[ebp], al
	mov	dl, BYTE PTR $T17594[ebp]
	push	edx
	mov	al, BYTE PTR $T17595[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T17596[ebp]
	push	eax
	call	??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z ; std::_Iter_random<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 12					; 0000000cH
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAVFreeMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3500 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVFreeMemoryBlock@@PAV1@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<FreeMemoryBlock *,FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17600 = -2						; size = 1
$T17599 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT

; 914  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 915  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 916  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17599[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17600[ebp], al
	mov	al, BYTE PTR $T17599[ebp]
	push	eax
	mov	cl, BYTE PTR $T17600[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
	add	esp, 24					; 00000018H

; 917  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@@Z
_TEXT	SEGMENT
$T17603 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@@Z PROC ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 225  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17603[ebp], al
	mov	dl, BYTE PTR $T17603[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	add	esp, 16					; 00000010H

; 227  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@@Z ENDP ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z PROC ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
	add	esp, 16					; 00000010H

; 1113 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAVAllocatedMemoryBlock@@@?$vector@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@IAEPAVAllocatedMemoryBlock@@PAV2@00@Z ENDP ; std::vector<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >::_Umove<AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ; std::_Fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z PROC ; std::fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>, COMDAT

; 2976 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2977 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ; std::_Fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH

; 2978 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ENDP ; std::fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z ; std::_Move_cat<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Unchecked_move_backward@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z
_TEXT	SEGMENT
$T17612 = -3						; size = 1
$T17611 = -2						; size = 1
$T17610 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 3497 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 3498 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3499 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17610[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z ; std::_Move_cat<AllocatedMemoryBlock *>
	add	esp, 4
	mov	BYTE PTR $T17611[ebp], al
	mov	dl, BYTE PTR $T17610[ebp]
	push	edx
	mov	al, BYTE PTR $T17611[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T17612[ebp]
	push	eax
	call	??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z ; std::_Iter_random<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 12					; 0000000cH
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3500 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVAllocatedMemoryBlock@@PAV1@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
$T17615 = -1						; size = 1
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 608  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 609  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	call	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
	mov	BYTE PTR $T17615[ebp], al
	mov	al, BYTE PTR $T17615[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	call	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
	add	esp, 20					; 00000014H

; 610  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\microsoft visual studio 8\vc\include\xmemory
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Allocate@VFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@IPAV1@@Z
_TEXT	SEGMENT
$T17618 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@IPAV1@@Z PROC ; std::_Allocate<FreeMemoryBlock>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@2

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T17618[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T17618[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 45   : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@IPAV1@@Z ENDP ; std::_Allocate<FreeMemoryBlock>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File c:\microsoft visual studio 8\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17628 = -2						; size = 1
$T17627 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 914  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 915  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 916  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17627[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17628[ebp], al
	mov	al, BYTE PTR $T17627[ebp]
	push	eax
	mov	cl, BYTE PTR $T17628[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
	add	esp, 24					; 00000018H

; 917  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@IPAV1@@Z
_TEXT	SEGMENT
$T17631 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@IPAV1@@Z PROC ; std::_Allocate<AllocatedMemoryBlock>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@3

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T17631[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T17631[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 45   : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@IPAV1@@Z ENDP ; std::_Allocate<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T17634 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 1
	jae	SHORT $LN2@Allocate@4

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T17634[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T17634[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 45   : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z
_TEXT	SEGMENT
__Base_tag$ = -5					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z PROC ; std::_Checked_base<FreeMemoryBlock *>, COMDAT

; 1009 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1010 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1011 : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 8

; 1012 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Checked_ba
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Checked_ba:
	DD	1
	DD	$LN4@Checked_ba
$LN4@Checked_ba:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Checked_ba
$LN3@Checked_ba:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ENDP ; std::_Checked_base<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z PROC ; std::_Iter_random<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 839  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 840  : 	typename _Iter_random_helper<
; 841  : 		iterator_traits<_Iter1>::iterator_category, 
; 842  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 843  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 844  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_rando
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Iter_rando:
	DD	1
	DD	$LN4@Iter_rando
$LN4@Iter_rando:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_rando
$LN3@Iter_rando:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_random@PAVFreeMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@0@Z ENDP ; std::_Iter_random<FreeMemoryBlock *,FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z PROC ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 1329 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1330 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1331 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1332 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ENDP ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17657 = -7						; size = 1
$T17656 = -6						; size = 1
$T17655 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 2275 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2276 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2277 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2278 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2279 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T17655[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T17656[ebp], al
	mov	cl, BYTE PTR $T17655[ebp]
	push	ecx
	mov	dl, BYTE PTR $T17656[ebp]
	push	edx
	mov	al, BYTE PTR $T17657[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2280 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2281 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z
_TEXT	SEGMENT
__Base_tag$ = -5					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z PROC ; std::_Checked_base<AllocatedMemoryBlock *>, COMDAT

; 1009 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1010 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1011 : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 8

; 1012 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Checked_ba@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Checked_ba@2:
	DD	1
	DD	$LN4@Checked_ba@2
$LN4@Checked_ba@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Checked_ba@2
$LN3@Checked_ba@2:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ENDP ; std::_Checked_base<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z PROC ; std::_Iter_random<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 839  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 840  : 	typename _Iter_random_helper<
; 841  : 		iterator_traits<_Iter1>::iterator_category, 
; 842  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 843  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 844  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_rando@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Iter_rando@2:
	DD	1
	DD	$LN4@Iter_rando@2
$LN4@Iter_rando@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_rando@2
$LN3@Iter_rando@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_random@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@0@Z ENDP ; std::_Iter_random<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z PROC ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 1329 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1330 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1331 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1332 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Ptr_cat@2:
	DD	1
	DD	$LN4@Ptr_cat@2
$LN4@Ptr_cat@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat@2
$LN3@Ptr_cat@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ENDP ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17677 = -7						; size = 1
$T17676 = -6						; size = 1
$T17675 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 2275 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2276 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2277 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2278 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2279 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17675[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T17676[ebp], cl
	mov	dl, BYTE PTR $T17675[ebp]
	push	edx
	mov	al, BYTE PTR $T17676[ebp]
	push	eax
	mov	cl, BYTE PTR $T17677[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2280 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2281 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -5						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 568  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 569  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 570  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[ebp]

; 571  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Char_trait
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Char_trait:
	DD	1
	DD	$LN4@Char_trait
$LN4@Char_trait:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Char_trait
$LN3@Char_trait:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 589  : 	{

	push	ebp
	mov	ebp, esp

; 590  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ; std::char_traits<char>::_Copy_s
	add	esp, 16					; 00000010H

; 591  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
EXTRN	_memcpy_s:PROC
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 455  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 456  : //		_DEBUG_POINTER(_First1);
; 457  : //		_DEBUG_POINTER(_First2);
; 458  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size_in_bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 459  : 		return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 460  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z ; std::allocator<FreeMemoryBlock>::destroy
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 234  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 235  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z ; std::allocator<FreeMemoryBlock>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 236  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Destroy_range@VFreeMemoryBlock@@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@0AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock>,std::_Undefined_move_tag>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17692 = -2						; size = 1
$T17691 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >, COMDAT

; 843  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 844  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 845  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17691[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z ; std::_Move_cat<FreeMemoryBlock *>
	add	esp, 4
	mov	BYTE PTR $T17692[ebp], al
	mov	dl, BYTE PTR $T17691[ebp]
	push	edx
	mov	al, BYTE PTR $T17692[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 846  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ; std::_Debug_range<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z PROC ; std::_Fill<FreeMemoryBlock *,FreeMemoryBlock>, COMDAT

; 2946 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2947 : 	_DEBUG_RANGE(_First, _Last);

	push	2947					; 00000b83H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ; std::_Debug_range<FreeMemoryBlock *>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@Fill
$LN2@Fill:

; 2948 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN3@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 2949 : 		*_First = _Val;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 2950 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Fill@PAVFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@0ABV1@@Z ENDP ; std::_Fill<FreeMemoryBlock *,FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z PROC ; std::_Move_cat<FreeMemoryBlock *>, COMDAT

; 1046 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1047 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1048 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1049 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Move_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Move_cat:
	DD	1
	DD	$LN4@Move_cat
$LN4@Move_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Move_cat
$LN3@Move_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Move_cat@PAVFreeMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVFreeMemoryBlock@@@Z ENDP ; std::_Move_cat<FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Move_backward_opt@PAVFreeMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17703 = -2						; size = 1
$T17702 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVFreeMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2546 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2547 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2548 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17702[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17703[ebp], al
	mov	al, BYTE PTR $T17702[ebp]
	push	eax
	mov	cl, BYTE PTR $T17703[ebp]
	push	ecx
	mov	dl, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 24					; 00000018H

; 2549 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAVFreeMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z ; std::allocator<FreeMemoryBlock>::construct
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >, COMDAT

; 390  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR __$EHRec$[ebp], esp

; 391  : 
; 392  :  #if _HAS_ITERATOR_DEBUGGING
; 393  : //	if (_Count < 0)
; 394  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 395  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 396  : 
; 397  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 398  : 
; 399  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:

; 400  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 401  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z ; std::allocator<FreeMemoryBlock>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:

; 402  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:

; 403  : 	for (; _Next != _First; ++_Next)

	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 404  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z ; std::allocator<FreeMemoryBlock>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 405  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 406  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 407  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVFreeMemoryBlock@@IV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAXPAVFreeMemoryBlock@@IABV1@AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<FreeMemoryBlock *,unsigned int,FreeMemoryBlock,std::allocator<FreeMemoryBlock> >
PUBLIC	?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z ; std::allocator<AllocatedMemoryBlock>::destroy
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 234  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 235  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z ; std::allocator<AllocatedMemoryBlock>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 236  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Destroy_range@VAllocatedMemoryBlock@@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@0AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock>,std::_Undefined_move_tag>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17724 = -2						; size = 1
$T17723 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 843  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 844  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 845  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17723[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z ; std::_Move_cat<AllocatedMemoryBlock *>
	add	esp, 4
	mov	BYTE PTR $T17724[ebp], al
	mov	dl, BYTE PTR $T17723[ebp]
	push	edx
	mov	al, BYTE PTR $T17724[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 846  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
_TEXT	ENDS
PUBLIC	??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ; std::_Debug_range<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z PROC ; std::_Fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>, COMDAT

; 2946 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2947 : 	_DEBUG_RANGE(_First, _Last);

	push	2947					; 00000b83H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ; std::_Debug_range<AllocatedMemoryBlock *>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:

; 2948 : 	for (; _First != _Last; ++_First)

	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN3@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 2949 : 		*_First = _Val;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 2950 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Fill@PAVAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@0ABV1@@Z ENDP ; std::_Fill<AllocatedMemoryBlock *,AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z PROC ; std::_Move_cat<AllocatedMemoryBlock *>, COMDAT

; 1046 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1047 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1048 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1049 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Move_cat@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Move_cat@2:
	DD	1
	DD	$LN4@Move_cat@2
$LN4@Move_cat@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Move_cat@2
$LN3@Move_cat@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Move_cat@PAVAllocatedMemoryBlock@@@std@@YA?AU_Undefined_move_tag@0@ABQAVAllocatedMemoryBlock@@@Z ENDP ; std::_Move_cat<AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Move_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17735 = -2						; size = 1
$T17734 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2546 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2547 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2548 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17734[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17735[ebp], al
	mov	al, BYTE PTR $T17734[ebp]
	push	eax
	mov	cl, BYTE PTR $T17735[ebp]
	push	ecx
	mov	dl, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 24					; 00000018H

; 2549 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 616  : 	{

	push	ebp
	mov	ebp, esp

; 617  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ; std::char_traits<char>::_Move_s
	add	esp, 16					; 00000010H

; 618  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
EXTRN	_memmove_s:PROC
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 479  : 		{	// move [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 480  : //		_DEBUG_POINTER(_First1);
; 481  : //		_DEBUG_POINTER(_First2);
; 482  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Size_in_bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H

; 483  : 		return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 484  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z ; std::allocator<AllocatedMemoryBlock>::construct
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 390  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR __$EHRec$[ebp], esp

; 391  : 
; 392  :  #if _HAS_ITERATOR_DEBUGGING
; 393  : //	if (_Count < 0)
; 394  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 395  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 396  : 
; 397  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 398  : 
; 399  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:

; 400  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 401  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z ; std::allocator<AllocatedMemoryBlock>::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:

; 402  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:

; 403  : 	for (; _Next != _First; ++_Next)

	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 404  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z ; std::allocator<AllocatedMemoryBlock>::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 405  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 406  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 407  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVAllocatedMemoryBlock@@IV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAXPAVAllocatedMemoryBlock@@IABV1@AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<AllocatedMemoryBlock *,unsigned int,AllocatedMemoryBlock,std::allocator<AllocatedMemoryBlock> >
PUBLIC	??$_Construct@VFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@ABV1@@Z ; std::_Construct<FreeMemoryBlock,FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z PROC ; std::allocator<FreeMemoryBlock>::construct, COMDAT
; _this$ = ecx

; 155  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@VFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@ABV1@@Z ; std::_Construct<FreeMemoryBlock,FreeMemoryBlock>
	add	esp, 8

; 157  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z ENDP ; std::allocator<FreeMemoryBlock>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@@Z ; std::_Destroy<FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z PROC ; std::allocator<FreeMemoryBlock>::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@@Z ; std::_Destroy<FreeMemoryBlock>
	add	esp, 4

; 162  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z ENDP ; std::allocator<FreeMemoryBlock>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@VAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@ABV1@@Z ; std::_Construct<AllocatedMemoryBlock,AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z PROC ; std::allocator<AllocatedMemoryBlock>::construct, COMDAT
; _this$ = ecx

; 155  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@VAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@ABV1@@Z ; std::_Construct<AllocatedMemoryBlock,AllocatedMemoryBlock>
	add	esp, 8

; 157  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z ENDP ; std::allocator<AllocatedMemoryBlock>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@@Z ; std::_Destroy<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z PROC ; std::allocator<AllocatedMemoryBlock>::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@@Z ; std::_Destroy<AllocatedMemoryBlock>
	add	esp, 4

; 162  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z ENDP ; std::allocator<AllocatedMemoryBlock>::destroy
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<FreeMemoryBlock *>, COMDAT

; 992  : 	{

	push	ebp
	mov	ebp, esp

; 993  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 994  : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>, COMDAT

; 2263 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2264 : 	_DEBUG_RANGE(_First, _Last);

	push	2264					; 000008d8H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ; std::_Debug_range<FreeMemoryBlock *>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@Copy_opt
$LN2@Copy_opt:

; 2265 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	edx, DWORD PTR __Dest$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2266 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN2@Copy_opt
$LN1@Copy_opt:

; 2267 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2268 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Copy_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<AllocatedMemoryBlock *>, COMDAT

; 992  : 	{

	push	ebp
	mov	ebp, esp

; 993  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 994  : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>, COMDAT

; 2263 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2264 : 	_DEBUG_RANGE(_First, _Last);

	push	2264					; 000008d8H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ; std::_Debug_range<AllocatedMemoryBlock *>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:

; 2265 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	edx, DWORD PTR __Dest$[ebp]
	add	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@2

; 2266 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2267 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2268 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Copy_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock>,std::_Undefined_move_tag>, COMDAT

; 205  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 206  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
	add	esp, 16					; 00000010H

; 207  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Uninit_move@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Debug_range2@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<FreeMemoryBlock *>
PUBLIC	??$_Iter_cat@PAVFreeMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@@Z ; std::_Iter_cat<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z
_TEXT	SEGMENT
$T17775 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z PROC ; std::_Debug_range<FreeMemoryBlock *>, COMDAT

; 1405 : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1406 : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17775[ebp]
	push	ecx
	call	??$_Iter_cat@PAVFreeMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@@Z ; std::_Iter_cat<FreeMemoryBlock *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_range2@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<FreeMemoryBlock *>
	add	esp, 20					; 00000014H

; 1407 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ENDP ; std::_Debug_range<FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17780 = -7						; size = 1
$T17779 = -6						; size = 1
$T17778 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *>, COMDAT

; 2479 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2480 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2481 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2482 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2483 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T17778[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T17779[ebp], cl
	mov	dl, BYTE PTR $T17778[ebp]
	push	edx
	mov	al, BYTE PTR $T17779[ebp]
	push	eax
	mov	cl, BYTE PTR $T17780[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2484 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2485 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@@std@@YAPAVFreeMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock>,std::_Undefined_move_tag>, COMDAT

; 205  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 206  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ; stdext::unchecked_uninitialized_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
	add	esp, 16					; 00000010H

; 207  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Uninit_move@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@U_Undefined_move_tag@3@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Debug_range2@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<AllocatedMemoryBlock *>
PUBLIC	??$_Iter_cat@PAVAllocatedMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@@Z ; std::_Iter_cat<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z
_TEXT	SEGMENT
$T17785 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z PROC ; std::_Debug_range<AllocatedMemoryBlock *>, COMDAT

; 1405 : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1406 : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17785[ebp]
	push	ecx
	call	??$_Iter_cat@PAVAllocatedMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@@Z ; std::_Iter_cat<AllocatedMemoryBlock *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_range2@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<AllocatedMemoryBlock *>
	add	esp, 20					; 00000014H

; 1407 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ENDP ; std::_Debug_range<AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T17790 = -7						; size = 1
$T17789 = -6						; size = 1
$T17788 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>, COMDAT

; 2479 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2480 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2481 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2482 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2483 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T17788[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T17789[ebp], al
	mov	cl, BYTE PTR $T17788[ebp]
	push	ecx
	mov	dl, BYTE PTR $T17789[ebp]
	push	edx
	mov	al, BYTE PTR $T17790[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2484 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2485 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Construct@VFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@ABV1@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T17793 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@ABV1@@Z PROC ; std::_Construct<FreeMemoryBlock,FreeMemoryBlock>, COMDAT

; 51   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 52   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 53   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T17793[ebp], eax
	cmp	DWORD PTR $T17793[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T17793[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T17793[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct:

; 54   : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@VFreeMemoryBlock@@V1@@std@@YAXPAVFreeMemoryBlock@@ABV1@@Z ENDP ; std::_Construct<FreeMemoryBlock,FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\new
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@@Z PROC ; std::_Destroy<FreeMemoryBlock>, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);
; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@@Z ENDP ; std::_Destroy<FreeMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Construct@VAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@ABV1@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T17802 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@ABV1@@Z PROC ; std::_Construct<AllocatedMemoryBlock,AllocatedMemoryBlock>, COMDAT

; 51   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 52   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 53   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T17802[ebp], eax
	cmp	DWORD PTR $T17802[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T17802[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T17802[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@2:

; 54   : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@VAllocatedMemoryBlock@@V1@@std@@YAXPAVAllocatedMemoryBlock@@ABV1@@Z ENDP ; std::_Construct<AllocatedMemoryBlock,AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@@Z PROC ; std::_Destroy<AllocatedMemoryBlock>, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);
; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@@Z ENDP ; std::_Destroy<AllocatedMemoryBlock>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17810 = -2						; size = 1
$T17809 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >, COMDAT

; 803  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 804  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 805  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17809[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVFreeMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVFreeMemoryBlock@@0@Z ; std::_Ptr_cat<FreeMemoryBlock *,FreeMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17810[ebp], al
	mov	al, BYTE PTR $T17809[ebp]
	push	eax
	mov	cl, BYTE PTR $T17810[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVFreeMemoryBlock@@@std@@YAPAVFreeMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<FreeMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
	add	esp, 24					; 00000018H

; 806  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@stdext@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAVFreeMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVFreeMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@@Z PROC ; std::_Iter_cat<FreeMemoryBlock *>, COMDAT

; 798  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 799  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 800  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 801  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAVFreeMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVFreeMemoryBlock@@@Z ENDP ; std::_Iter_cat<FreeMemoryBlock *>
_TEXT	ENDS
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<FreeMemoryBlock>
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
;	COMDAT ??$_Debug_range2@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<FreeMemoryBlock *>, COMDAT

; 1393 : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp

; 1394 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 1395 : 		{	// check for non-null pointers, valid range
; 1396 : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<FreeMemoryBlock>
	add	esp, 12					; 0000000cH

; 1397 : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<FreeMemoryBlock>
	add	esp, 12					; 0000000cH

; 1398 : 		if (_Last < _First)

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 1399 : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	edx, DWORD PTR __Line$[ebp]
	push	edx
	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN3@Debug_rang:

; 1400 : 		}
; 1401 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Debug_range2@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<FreeMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>, COMDAT

; 2467 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2468 : 	_DEBUG_RANGE(_First, _Last);

	push	2468					; 000009a4H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ; std::_Debug_range<FreeMemoryBlock *>
	add	esp, 16					; 00000010H
$LN2@Copy_backw:

; 2469 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw

; 2470 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR __Last$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN2@Copy_backw
$LN1@Copy_backw:

; 2471 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2472 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVFreeMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<FreeMemoryBlock *,FreeMemoryBlock *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z
_TEXT	SEGMENT
$T17823 = -2						; size = 1
$T17822 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 803  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 804  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 805  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T17822[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVAllocatedMemoryBlock@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVAllocatedMemoryBlock@@0@Z ; std::_Ptr_cat<AllocatedMemoryBlock *,AllocatedMemoryBlock *>
	add	esp, 8
	mov	BYTE PTR $T17823[ebp], al
	mov	al, BYTE PTR $T17822[ebp]
	push	eax
	mov	cl, BYTE PTR $T17823[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVAllocatedMemoryBlock@@@std@@YAPAVAllocatedMemoryBlock@@AAPAV1@@Z ; std::_Checked_base<AllocatedMemoryBlock *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
	add	esp, 24					; 00000018H

; 806  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@stdext@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAVAllocatedMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVAllocatedMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@@Z PROC ; std::_Iter_cat<AllocatedMemoryBlock *>, COMDAT

; 798  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 799  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 800  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 801  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Iter_cat@2:
	DD	1
	DD	$LN4@Iter_cat@2
$LN4@Iter_cat@2:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat@2
$LN3@Iter_cat@2:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAVAllocatedMemoryBlock@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVAllocatedMemoryBlock@@@Z ENDP ; std::_Iter_cat<AllocatedMemoryBlock *>
_TEXT	ENDS
PUBLIC	??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<AllocatedMemoryBlock>
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??$_Debug_range2@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<AllocatedMemoryBlock *>, COMDAT

; 1393 : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp

; 1394 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang@2

; 1395 : 		{	// check for non-null pointers, valid range
; 1396 : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH

; 1397 : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH

; 1398 : 		if (_Last < _First)

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang@2

; 1399 : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	edx, DWORD PTR __Line$[ebp]
	push	edx
	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN3@Debug_rang@2:

; 1400 : 		}
; 1401 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Debug_range2@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<AllocatedMemoryBlock *>
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>, COMDAT

; 2467 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2468 : 	_DEBUG_RANGE(_First, _Last);

	push	2468					; 000009a4H
	push	OFFSET ??_C@_1GC@BOCMKMKF@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ; std::_Debug_range<AllocatedMemoryBlock *>
	add	esp, 16					; 00000010H
$LN2@Copy_backw@2:

; 2469 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@2

; 2470 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Last$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2471 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2472 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVAllocatedMemoryBlock@@PAV1@Uforward_iterator_tag@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ ; `string'
;	COMDAT ??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
; File c:\microsoft visual studio 8\vc\include\memory
CONST	SEGMENT
??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H
	DB	'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H, 'V'
	DB	00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' '
	DB	00H, '8', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\'
	DB	00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >, COMDAT

; 123  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR __$EHRec$[ebp], esp

; 124  : 	_DEBUG_RANGE(_First, _Last);

	push	124					; 0000007cH
	push	OFFSET ??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@0PB_WI@Z ; std::_Debug_range<FreeMemoryBlock *>
	add	esp, 16					; 00000010H

; 125  : 	_DEBUG_POINTER(_Dest);

	push	125					; 0000007dH
	push	OFFSET ??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<FreeMemoryBlock>
	add	esp, 12					; 0000000cH

; 126  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 127  : 
; 128  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:

; 129  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 130  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@ABV3@@Z ; std::allocator<FreeMemoryBlock>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:

; 131  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:

; 132  : 	for (; _Next != _Dest; ++_Next)

	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 133  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VFreeMemoryBlock@@@std@@QAEXPAVFreeMemoryBlock@@@Z ; std::allocator<FreeMemoryBlock>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 134  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 135  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 136  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 137  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVFreeMemoryBlock@@PAV1@V?$allocator@VFreeMemoryBlock@@@std@@@std@@YAPAVFreeMemoryBlock@@PAV1@00AAV?$allocator@VFreeMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<FreeMemoryBlock *,FreeMemoryBlock *,std::allocator<FreeMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z PROC ; std::_Debug_pointer<FreeMemoryBlock>, COMDAT

; 1377 : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp

; 1378 : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin@2

; 1379 : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin@2:

; 1380 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Debug_pointer@VFreeMemoryBlock@@@std@@YAXPAVFreeMemoryBlock@@PB_WI@Z ENDP ; std::_Debug_pointer<FreeMemoryBlock>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >, COMDAT

; 123  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR __$EHRec$[ebp], esp

; 124  : 	_DEBUG_RANGE(_First, _Last);

	push	124					; 0000007cH
	push	OFFSET ??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAVAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@0PB_WI@Z ; std::_Debug_range<AllocatedMemoryBlock *>
	add	esp, 16					; 00000010H

; 125  : 	_DEBUG_POINTER(_Dest);

	push	125					; 0000007dH
	push	OFFSET ??_C@_1FO@MANMLIOJ@?$AAC?$AA?3?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAV?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAS?$AAt?$AAu?$AAd?$AAi?$AAo?$AA?5?$AA8?$AA?2?$AAV?$AAC?$AA?2@
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z ; std::_Debug_pointer<AllocatedMemoryBlock>
	add	esp, 12					; 0000000cH

; 126  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 127  : 
; 128  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:

; 129  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 130  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@ABV3@@Z ; std::allocator<AllocatedMemoryBlock>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:

; 131  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:

; 132  : 	for (; _Next != _Dest; ++_Next)

	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 133  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VAllocatedMemoryBlock@@@std@@QAEXPAVAllocatedMemoryBlock@@@Z ; std::allocator<AllocatedMemoryBlock>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 134  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 135  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 136  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 137  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVAllocatedMemoryBlock@@PAV1@V?$allocator@VAllocatedMemoryBlock@@@std@@@std@@YAPAVAllocatedMemoryBlock@@PAV1@00AAV?$allocator@VAllocatedMemoryBlock@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<AllocatedMemoryBlock *,AllocatedMemoryBlock *,std::allocator<AllocatedMemoryBlock> >
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z PROC ; std::_Debug_pointer<AllocatedMemoryBlock>, COMDAT

; 1377 : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp

; 1378 : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin@3

; 1379 : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	?_Debug_message@std@@YAXPB_W0I@Z	; std::_Debug_message
	add	esp, 12					; 0000000cH
$LN2@Debug_poin@3:

; 1380 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Debug_pointer@VAllocatedMemoryBlock@@@std@@YAXPAVAllocatedMemoryBlock@@PB_WI@Z ENDP ; std::_Debug_pointer<AllocatedMemoryBlock>
_TEXT	ENDS
END
