; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\bdma_type12.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12224
_DATA	ENDS
CONST	SEGMENT
$SG12224 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_0
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
EXTRN	?structMainChannel@@3UVidChannel@@A:BYTE	; structMainChannel
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\bdma_type12.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv287 = -204						; size = 4
tv274 = -200						; size = 4
tv271 = -196						; size = 4
$T43705 = -189						; size = 1
_ztransfer$41394 = -184					; size = 2
_ztarget$41393 = -172					; size = 2
_result$41392 = -162					; size = 1
_bZTestResult$ = -161					; size = 1
_bUpdateZ$ = -160					; size = 1
_bUpdatePixel$ = -159					; size = 1
_bCompareZ$ = -158					; size = 1
_bTrigger$ = -157					; size = 1
_bRemote$ = -156					; size = 1
_bDup$ = -155						; size = 1
_bDirect$ = -154					; size = 1
_bRead$ = -153						; size = 1
_mpeBase$ = -148					; size = 4
_sdramBase$ = -144					; size = 4
_mode$ = -140						; size = 4
_bva$ = -136						; size = 4
_zcompare$ = -132					; size = 4
_ypos$ = -128						; size = 4
_ylen$ = -124						; size = 4
_xpos$ = -120						; size = 4
_xlen$ = -116						; size = 4
_xsize$ = -112						; size = 4
_destBStep$ = -108					; size = 4
_destAStep$ = -104					; size = 4
_srcBStep$ = -100					; size = 4
_srcAStep$ = -96					; size = 4
_destOffset$ = -92					; size = 4
_srcOffset$ = -88					; size = 4
_destB$ = -84						; size = 4
_destA$ = -80						; size = 4
_srcB$ = -76						; size = 4
_srcA$ = -72						; size = 4
_bCount$ = -68						; size = 4
_aCount$ = -64						; size = 4
_zmap$ = -60						; size = 4
_map$ = -56						; size = 4
_directValue$ = -52					; size = 4
_pixtype$ = -48						; size = 4
_type$ = -44						; size = 4
_directColor$ = -32					; size = 2
_baseMemory$ = -24					; size = 4
_intMemory$ = -20					; size = 4
_pDestColor$ = -8					; size = 4
_pSrcColor$ = -4					; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_0

; 11   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 12   :   uint16 *pSrcColor, *pDestColor, *pSrcZ, *pDestZ;
; 13   :   void *intMemory, *baseMemory;
; 14   :   uint16 directColor, directZ;
; 15   :   uint32 type, pixtype, directValue, map, zmap;
; 16   :   uint32 aCount, bCount;
; 17   :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset;
; 18   :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 19   :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 20   :   uint32 mode, sdramBase, mpeBase, srcStrideShift;
; 21   : 
; 22   :   bool bRead, bDirect, bDup, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 23   : 
; 24   :   bRemote = flags & (1UL << 28);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bRemote$[ebp], cl

; 25   :   bDirect = flags & (1UL << 27);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 134217728				; 08000000H
	setne	al
	mov	BYTE PTR _bDirect$[ebp], al

; 26   :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 201326592				; 0c000000H
	setne	dl
	mov	BYTE PTR _bDup$[ebp], dl

; 27   :   bTrigger = flags & (1UL << 25);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 33554432				; 02000000H
	setne	cl
	mov	BYTE PTR _bTrigger$[ebp], cl

; 28   :   bRead = flags & (1UL << 13);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8192				; 00002000H
	setne	al
	mov	BYTE PTR _bRead$[ebp], al

; 29   :   xsize = (flags >> 13) & 0x7F8UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 13					; 0000000dH
	and	ecx, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], ecx

; 30   :   type = (flags >> 14) & 0x03UL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 14					; 0000000eH
	and	edx, 3
	mov	DWORD PTR _type$[ebp], edx

; 31   :   mode = flags & 0xFFFUL;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], eax

; 32   :   zcompare = (flags >> 1) & 0x07UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 1
	and	ecx, 7
	mov	DWORD PTR _zcompare$[ebp], ecx

; 33   :   pixtype = (flags >> 4) & 0x0FUL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 4
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], edx

; 34   :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 7
	and	eax, 6
	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	or	eax, ecx
	mov	DWORD PTR _bva$[ebp], eax

; 35   :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	edx, DWORD PTR _baseaddr$[ebp]
	and	edx, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], edx

; 36   :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], eax

; 37   :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	ecx, DWORD PTR _xinfo$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], ecx

; 38   :   xpos = xinfo & 0x7FFUL;

	mov	edx, DWORD PTR _xinfo$[ebp]
	and	edx, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], edx

; 39   :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	eax, DWORD PTR _yinfo$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], eax

; 40   :   ypos = yinfo & 0x7FFUL;

	mov	ecx, DWORD PTR _yinfo$[ebp]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], ecx

; 41   : 
; 42   :   directValue = intaddr;

	mov	edx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], edx

; 43   : 
; 44   :   map = 0;

	mov	DWORD PTR _map$[ebp], 0

; 45   :   zmap = 1;

	mov	DWORD PTR _zmap$[ebp], 1

; 46   : 
; 47   :   if(pixtype >= 13)

	cmp	DWORD PTR _pixtype$[ebp], 13		; 0000000dH
	jb	SHORT $LN35@BDMA_Type1

; 48   :   {
; 49   :     map = pixtype - 13;

	mov	eax, DWORD PTR _pixtype$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax

; 50   :     zmap = 2;

	mov	DWORD PTR _zmap$[ebp], 2
	jmp	SHORT $LN34@BDMA_Type1
$LN35@BDMA_Type1:

; 51   :   }
; 52   :   else if(pixtype >= 9)

	cmp	DWORD PTR _pixtype$[ebp], 9
	jb	SHORT $LN34@BDMA_Type1

; 53   :   {
; 54   :     map = pixtype - 9;

	mov	ecx, DWORD PTR _pixtype$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 55   :     zmap = 3;

	mov	DWORD PTR _zmap$[ebp], 3
$LN34@BDMA_Type1:

; 56   :   }
; 57   : 
; 58   : 
; 59   :   if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN32@BDMA_Type1

; 60   :   {
; 61   :     bCompareZ = (zcompare ? true : false);

	cmp	DWORD PTR _zcompare$[ebp], 0
	setne	dl
	mov	BYTE PTR _bCompareZ$[ebp], dl

; 62   :     //Z write, no pixel (16Z)
; 63   :     bUpdatePixel = false;

	mov	BYTE PTR _bUpdatePixel$[ebp], 0

; 64   :     bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 65   :   }
; 66   :   else

	jmp	SHORT $LN31@BDMA_Type1
$LN32@BDMA_Type1:

; 67   :   {
; 68   :     //Z write, no pixel (16Z, no compare?)
; 69   :     bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 70   :     bUpdatePixel = false;

	mov	BYTE PTR _bUpdatePixel$[ebp], 0

; 71   :     bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1
$LN31@BDMA_Type1:

; 72   :   }
; 73   : 
; 74   :   if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	SHORT $LN30@BDMA_Type1

; 75   :   {
; 76   :     //internal address is system address (but still in MPE memory)
; 77   :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	ecx, DWORD PTR _mpeBase$[ebp]
	and	ecx, 545259519				; 207fffffH
	push	ecx
	mov	edx, DWORD PTR _mpeBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 78   :   }
; 79   :   else

	jmp	SHORT $LN29@BDMA_Type1
$LN30@BDMA_Type1:

; 80   :   {
; 81   :     //internal address is local to MPE
; 82   :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase & 0x207FFFFF, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	and	edx, 545259519				; 207fffffH
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN29@BDMA_Type1:

; 83   :   }
; 84   : 
; 85   :   //base address is always a system address (absolute)
; 86   :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdramBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 87   : 
; 88   :   pSrcColor = ((uint16 *)intMemory) + 1;

	mov	edx, DWORD PTR _intMemory$[ebp]
	add	edx, 2
	mov	DWORD PTR _pSrcColor$[ebp], edx

; 89   :   pDestColor = ((uint16 *)baseMemory) + (xsize * structMainChannel.src_height * zmap);

	mov	eax, DWORD PTR _xsize$[ebp]
	imul	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	imul	eax, DWORD PTR _zmap$[ebp]
	mov	ecx, DWORD PTR _baseMemory$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pDestColor$[ebp], edx

; 90   : 
; 91   :   if(bDirect & !bDup)

	movzx	eax, BYTE PTR _bDirect$[ebp]
	movzx	ecx, BYTE PTR _bDup$[ebp]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	and	eax, ecx
	je	SHORT $LN28@BDMA_Type1

; 92   :   {
; 93   :     bDirect = true;

	mov	BYTE PTR _bDirect$[ebp], 1
$LN28@BDMA_Type1:

; 94   :   }
; 95   :   if(bDup)

	movzx	edx, BYTE PTR _bDup$[ebp]
	test	edx, edx
	je	SHORT $LN27@BDMA_Type1

; 96   :   {
; 97   :     if(bDirect)

	movzx	eax, BYTE PTR _bDirect$[ebp]
	test	eax, eax
	je	SHORT $LN26@BDMA_Type1

; 98   :     {
; 99   :       //Direct and Dup: intaddr is data.
; 100  :       directColor = intaddr >> 16;

	mov	ecx, DWORD PTR _intaddr$[ebp]
	shr	ecx, 16					; 00000010H
	mov	WORD PTR _directColor$[ebp], cx

; 101  :       //swap back to big endian format
; 102  :       SwapWordBytes(&directColor);

	lea	ecx, DWORD PTR _directColor$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 103  :     }
; 104  :     else

	jmp	SHORT $LN25@BDMA_Type1
$LN26@BDMA_Type1:

; 105  :     {
; 106  :       //Dup but not Direct: read scalar from memory, no need to swap
; 107  :       directColor = *((uint16 *)intMemory);

	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _directColor$[ebp], ax
$LN25@BDMA_Type1:

; 108  :     }
; 109  : 
; 110  :     pSrcColor = &directColor;

	lea	ecx, DWORD PTR _directColor$[ebp]
	mov	DWORD PTR _pSrcColor$[ebp], ecx

; 111  :     srcAStep = 0;

	mov	DWORD PTR _srcAStep$[ebp], 0

; 112  :     srcBStep = 0;

	mov	DWORD PTR _srcBStep$[ebp], 0

; 113  :   }
; 114  :   else

	jmp	SHORT $LN24@BDMA_Type1
$LN27@BDMA_Type1:

; 115  :   {
; 116  :     srcAStep = 1;

	mov	DWORD PTR _srcAStep$[ebp], 1

; 117  :     srcBStep = xsize;

	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], edx
$LN24@BDMA_Type1:

; 118  :   }
; 119  : 
; 120  :   srcOffset = 0;

	mov	DWORD PTR _srcOffset$[ebp], 0

; 121  :   destOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	eax, DWORD PTR _ypos$[ebp]
	imul	eax, DWORD PTR _xsize$[ebp]
	add	eax, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _destOffset$[ebp], eax

; 122  : 
; 123  :   //BVA = 000 (horizontal DMA, x increment, y increment)
; 124  :   destAStep = 1;

	mov	DWORD PTR _destAStep$[ebp], 1

; 125  :   destBStep = xsize;

	mov	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destBStep$[ebp], ecx

; 126  :   aCount = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 127  :   bCount = ylen;

	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 128  : 
; 129  :   pDestColor += destOffset;

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _pDestColor$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pDestColor$[ebp], eax

; 130  :   srcB = 0;

	mov	DWORD PTR _srcB$[ebp], 0

; 131  :   destB = 0;

	mov	DWORD PTR _destB$[ebp], 0

; 132  : 
; 133  :   if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->mainChannelUpperLimit) ||
; 134  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->mainChannelUpperLimit))

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+52]
	jb	SHORT $LN21@BDMA_Type1
	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+48]
	jbe	SHORT $LN22@BDMA_Type1
$LN21@BDMA_Type1:
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+52]
	jb	SHORT $LN23@BDMA_Type1
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+48]
	ja	SHORT $LN23@BDMA_Type1
$LN22@BDMA_Type1:

; 135  :   {
; 136  :     nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 137  :   }
; 138  :   else if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->overlayChannelUpperLimit) ||

	jmp	SHORT $LN16@BDMA_Type1
$LN23@BDMA_Type1:

; 139  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->overlayChannelUpperLimit))

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+60]
	jb	SHORT $LN17@BDMA_Type1
	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+56]
	jbe	SHORT $LN18@BDMA_Type1
$LN17@BDMA_Type1:
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+60]
	jb	SHORT $LN16@BDMA_Type1
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+56]
	ja	SHORT $LN16@BDMA_Type1
$LN18@BDMA_Type1:

; 140  :   {
; 141  :     nuonEnv->bOverlayBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+87], 1
$LN16@BDMA_Type1:

; 142  :   }
; 143  : 
; 144  :   while(bCount--)

	mov	edx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv271[ebp], edx
	mov	eax, DWORD PTR _bCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _bCount$[ebp], eax
	cmp	DWORD PTR tv271[ebp], 0
	je	$LN36@BDMA_Type1

; 145  :   {
; 146  :     srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 147  :     destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 148  :     aCount = xlen;

	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx
$LN14@BDMA_Type1:

; 149  : 
; 150  :     while(aCount--)

	mov	edx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv274[ebp], edx
	mov	eax, DWORD PTR _aCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _aCount$[ebp], eax
	cmp	DWORD PTR tv274[ebp], 0
	je	$LN13@BDMA_Type1

; 151  :     {
; 152  :       bZTestResult = false;

	mov	BYTE PTR _bZTestResult$[ebp], 0

; 153  : 
; 154  :       if(bCompareZ && (zcompare != 0))

	movzx	ecx, BYTE PTR _bCompareZ$[ebp]
	test	ecx, ecx
	je	$LN12@BDMA_Type1
	cmp	DWORD PTR _zcompare$[ebp], 0
	je	$LN12@BDMA_Type1
	mov	BYTE PTR $T43705[ebp], 0

; 155  :       {
; 156  :         bool result;
; 157  :         uint16 ztarget, ztransfer;
; 158  : 
; 159  :         ztarget = pDestColor[destA + destB];

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, DWORD PTR _destB$[ebp]
	mov	eax, DWORD PTR _pDestColor$[ebp]
	mov	cx, WORD PTR [eax+edx*2]
	mov	WORD PTR _ztarget$41393[ebp], cx

; 160  :         ztransfer = pSrcColor[srcA + srcB];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _pSrcColor$[ebp]
	mov	cx, WORD PTR [eax+edx*2]
	mov	WORD PTR _ztransfer$41394[ebp], cx

; 161  :         SwapWordBytes((uint16 *)&ztarget);

	lea	ecx, DWORD PTR _ztarget$41393[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 162  :         SwapWordBytes((uint16 *)&ztransfer);

	lea	ecx, DWORD PTR _ztransfer$41394[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 163  : 
; 164  :         switch(zcompare)

	mov	edx, DWORD PTR _zcompare$[ebp]
	mov	DWORD PTR tv287[ebp], edx
	cmp	DWORD PTR tv287[ebp], 7
	ja	$LN10@BDMA_Type1
	mov	eax, DWORD PTR tv287[ebp]
	jmp	DWORD PTR $LN45@BDMA_Type1[eax*4]
$LN9@BDMA_Type1:

; 165  :         {
; 166  :           case 0x0:
; 167  :             result = false;

	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], 0

; 168  :             break;

	jmp	$LN10@BDMA_Type1
$LN8@BDMA_Type1:

; 169  :           case 0x1:
; 170  :             result = (ztarget < ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	setl	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 171  :             break;

	jmp	$LN10@BDMA_Type1
$LN7@BDMA_Type1:

; 172  :           case 0x2:
; 173  :             result = (ztarget == ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	sete	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 174  :             break;

	jmp	$LN10@BDMA_Type1
$LN6@BDMA_Type1:

; 175  :           case 0x3:
; 176  :             result = (ztarget <= ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	setle	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 177  :             break;

	jmp	SHORT $LN10@BDMA_Type1
$LN5@BDMA_Type1:

; 178  :           case 0x4:
; 179  :             result = (ztarget > ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	setg	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 180  :             break;

	jmp	SHORT $LN10@BDMA_Type1
$LN4@BDMA_Type1:

; 181  :           case 0x5:
; 182  :             result = (ztarget != ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	setne	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 183  :             break;

	jmp	SHORT $LN10@BDMA_Type1
$LN3@BDMA_Type1:

; 184  :           case 0x6:
; 185  :             result = (ztarget >= ztransfer);

	movzx	ecx, WORD PTR _ztarget$41393[ebp]
	movzx	edx, WORD PTR _ztransfer$41394[ebp]
	xor	eax, eax
	cmp	ecx, edx
	setge	al
	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], al

; 186  :             break;

	jmp	SHORT $LN10@BDMA_Type1
$LN2@BDMA_Type1:

; 187  :           case 0x7:
; 188  :             result = false;

	mov	BYTE PTR $T43705[ebp], 1
	mov	BYTE PTR _result$41392[ebp], 0
$LN10@BDMA_Type1:

; 189  :             break;
; 190  :         }
; 191  : 
; 192  :         bZTestResult = result;

	cmp	BYTE PTR $T43705[ebp], 0
	jne	SHORT $LN38@BDMA_Type1
	push	OFFSET $LN39@BDMA_Type1
	call	__RTC_UninitUse
	add	esp, 4
$LN38@BDMA_Type1:
	mov	cl, BYTE PTR _result$41392[ebp]
	mov	BYTE PTR _bZTestResult$[ebp], cl
$LN12@BDMA_Type1:

; 193  :       }
; 194  : 
; 195  :       if(!bZTestResult)

	movzx	edx, BYTE PTR _bZTestResult$[ebp]
	test	edx, edx
	jne	SHORT $LN1@BDMA_Type1

; 196  :       {
; 197  :         pDestColor[destA + destB] = pSrcColor[srcA + srcB];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _pDestColor$[ebp]
	mov	esi, DWORD PTR _pSrcColor$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx*2], ax
$LN1@BDMA_Type1:

; 198  :       }
; 199  : 
; 200  :       srcA += srcAStep;

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcAStep$[ebp]
	mov	DWORD PTR _srcA$[ebp], ecx

; 201  :       destA += 1;

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, 1
	mov	DWORD PTR _destA$[ebp], edx

; 202  :     }

	jmp	$LN14@BDMA_Type1
$LN13@BDMA_Type1:

; 203  : 
; 204  :     srcB += srcBStep;

	mov	eax, DWORD PTR _srcB$[ebp]
	add	eax, DWORD PTR _srcBStep$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 205  :     destB += xsize;

	mov	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 206  :   }

	jmp	$LN16@BDMA_Type1
$LN36@BDMA_Type1:

; 207  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN44@BDMA_Type1
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN44@BDMA_Type1:
	DD	3
	DD	$LN43@BDMA_Type1
$LN43@BDMA_Type1:
	DD	-32					; ffffffe0H
	DD	2
	DD	$LN40@BDMA_Type1
	DD	-172					; ffffff54H
	DD	2
	DD	$LN41@BDMA_Type1
	DD	-184					; ffffff48H
	DD	2
	DD	$LN42@BDMA_Type1
$LN42@BDMA_Type1:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN41@BDMA_Type1:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN40@BDMA_Type1:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN39@BDMA_Type1:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
	npad	3
$LN45@BDMA_Type1:
	DD	$LN9@BDMA_Type1
	DD	$LN8@BDMA_Type1
	DD	$LN7@BDMA_Type1
	DD	$LN6@BDMA_Type1
	DD	$LN5@BDMA_Type1
	DD	$LN4@BDMA_Type1
	DD	$LN3@BDMA_Type1
	DD	$LN2@BDMA_Type1
?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_0
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_1@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_1

; 210  : {

	push	ebp
	mov	ebp, esp

; 211  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_1
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_2@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_2

; 214  : {

	push	ebp
	mov	ebp, esp

; 215  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_2
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_3@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_3

; 218  : {

	push	ebp
	mov	ebp, esp

; 219  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_3
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_4@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_4

; 222  : {

	push	ebp
	mov	ebp, esp

; 223  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_4
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_5@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_5

; 226  : {

	push	ebp
	mov	ebp, esp

; 227  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_5
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_6@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_6

; 230  : {

	push	ebp
	mov	ebp, esp

; 231  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_6
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Write_7@@YAXPAVMPE@@IIIII@Z	; BDMA_Type12_Write_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Write_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Write_7

; 234  : {

	push	ebp
	mov	ebp, esp

; 235  : }

	pop	ebp
	ret	0
?BDMA_Type12_Write_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Write_7
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_0@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_0
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv231 = -236						; size = 4
tv228 = -232						; size = 4
tv215 = -228						; size = 4
tv212 = -224						; size = 4
_bUpdateZ$ = -218					; size = 1
_bUpdatePixel$ = -217					; size = 1
_bCompareZ$ = -216					; size = 1
_bTrigger$ = -215					; size = 1
_bRemote$ = -214					; size = 1
_bChain$ = -213						; size = 1
_bBatch$ = -212						; size = 1
_bDup$ = -211						; size = 1
_bDirect$ = -210					; size = 1
_skipsize$ = -196					; size = 4
_mpeBase$ = -192					; size = 4
_sdramBase$ = -188					; size = 4
_mode$ = -176						; size = 4
_bva$ = -172						; size = 4
_zcompare$ = -168					; size = 4
_ypos$ = -164						; size = 4
_ylen$ = -160						; size = 4
_xpos$ = -156						; size = 4
_xlen$ = -152						; size = 4
_xsize$ = -148						; size = 4
_destBStep$ = -144					; size = 4
_destAStep$ = -140					; size = 4
_srcBStep$ = -136					; size = 4
_srcAStep$ = -132					; size = 4
_zmap$ = -128						; size = 4
_map$ = -124						; size = 4
_destOffset$ = -120					; size = 4
_srcOffset$ = -116					; size = 4
_destB$ = -112						; size = 4
_destA$ = -108						; size = 4
_srcB$ = -104						; size = 4
_srcA$ = -100						; size = 4
_aCountInit$ = -96					; size = 4
_bCount$ = -92						; size = 4
_aCount$ = -88						; size = 4
_destBStart$ = -84					; size = 4
_destAStart$ = -80					; size = 4
_srcAStart$ = -72					; size = 4
_srcStrideShift$ = -68					; size = 4
_pixtype$ = -64						; size = 4
_type$ = -60						; size = 4
_directValue$ = -56					; size = 4
_pDest32$ = -52						; size = 4
_pSrc32$ = -48						; size = 4
_pDest16$ = -44						; size = 4
_pDest$ = -40						; size = 4
_pSrc$ = -36						; size = 4
_baseMemory$ = -32					; size = 4
_intMemory$ = -28					; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_0

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 239  :   uint16 *pSrcColor, *pDestColor, *pSrcZ, *pDestZ;
; 240  :   uint16 directColor, directZ;
; 241  :   void *intMemory, *baseMemory, *pSrc, *pDest;
; 242  :   uint16 *pDest16;
; 243  :   uint32 *pSrc32, *pDest32;
; 244  :   uint32 directValue, type, pixtype, srcStrideShift;
; 245  :   uint32 srcAStart, srcBStart, destAStart, destBStart, aCount, bCount, aCountInit;
; 246  :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset, map, zmap;
; 247  :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 248  :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 249  :   uint32 mode, wordsize, pixsize, sdramBase, mpeBase, skipsize;
; 250  :   uint32 lowerLimit, upperLimit, whichRoutine;
; 251  : 
; 252  :   bool bReadZ, bDirect, bDup, bBatch, bChain, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 253  : 
; 254  :   bBatch = flags & (1UL << 30);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1073741824				; 40000000H
	setne	cl
	mov	BYTE PTR _bBatch$[ebp], cl

; 255  :   bChain = flags & (1UL << 29);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 536870912				; 20000000H
	setne	al
	mov	BYTE PTR _bChain$[ebp], al

; 256  :   bRemote = flags & (1UL << 28);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bRemote$[ebp], dl

; 257  :   bDirect = flags & (1UL << 27);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 134217728				; 08000000H
	setne	cl
	mov	BYTE PTR _bDirect$[ebp], cl

; 258  :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 201326592				; 0c000000H
	setne	al
	mov	BYTE PTR _bDup$[ebp], al

; 259  :   bTrigger = flags & (1UL << 25);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 33554432				; 02000000H
	setne	dl
	mov	BYTE PTR _bTrigger$[ebp], dl

; 260  :   xsize = (flags >> 13) & 0x7F8UL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 13					; 0000000dH
	and	eax, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], eax

; 261  :   type = (flags >> 14) & 0x03UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 14					; 0000000eH
	and	ecx, 3
	mov	DWORD PTR _type$[ebp], ecx

; 262  :   mode = flags & 0xFFFUL;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], edx

; 263  :   zcompare = (flags >> 1) & 0x07UL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 1
	and	eax, 7
	mov	DWORD PTR _zcompare$[ebp], eax

; 264  :   pixtype = (flags >> 4) & 0x0FUL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 4
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], ecx

; 265  :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 7
	and	edx, 6
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	or	edx, eax
	mov	DWORD PTR _bva$[ebp], edx

; 266  :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	ecx, DWORD PTR _baseaddr$[ebp]
	and	ecx, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], ecx

; 267  :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], edx

; 268  :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	eax, DWORD PTR _xinfo$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], eax

; 269  :   xpos = xinfo & 0x7FFUL;

	mov	ecx, DWORD PTR _xinfo$[ebp]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], ecx

; 270  :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	edx, DWORD PTR _yinfo$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], edx

; 271  :   ypos = yinfo & 0x7FFUL;

	mov	eax, DWORD PTR _yinfo$[ebp]
	and	eax, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], eax

; 272  :   skipsize = 0;

	mov	DWORD PTR _skipsize$[ebp], 0

; 273  :   bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 274  :   bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 275  :   bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 276  : 
; 277  :   directValue = intaddr;

	mov	ecx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], ecx

; 278  : 
; 279  :   if(bChain)

	movzx	edx, BYTE PTR _bChain$[ebp]
	test	edx, edx
	je	SHORT $LN18@BDMA_Type1@2

; 280  :   {
; 281  :     return;

	jmp	$LN19@BDMA_Type1@2
$LN18@BDMA_Type1@2:

; 282  :   }
; 283  : 
; 284  :   map = 0;

	mov	DWORD PTR _map$[ebp], 0

; 285  : 
; 286  :   if(pixtype >= 13)

	cmp	DWORD PTR _pixtype$[ebp], 13		; 0000000dH
	jb	SHORT $LN17@BDMA_Type1@2

; 287  :   {
; 288  :     map = pixtype - 13;

	mov	eax, DWORD PTR _pixtype$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax

; 289  :     zmap = 2;

	mov	DWORD PTR _zmap$[ebp], 2
	jmp	SHORT $LN16@BDMA_Type1@2
$LN17@BDMA_Type1@2:

; 290  :   }
; 291  :   else if(pixtype >= 9)

	cmp	DWORD PTR _pixtype$[ebp], 9
	jb	SHORT $LN16@BDMA_Type1@2

; 292  :   {
; 293  :     map = pixtype - 9;

	mov	ecx, DWORD PTR _pixtype$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 294  :     zmap = 3;

	mov	DWORD PTR _zmap$[ebp], 3
$LN16@BDMA_Type1@2:

; 295  :   }
; 296  : 
; 297  :   if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN14@BDMA_Type1@2

; 298  :   {
; 299  :     //pixel+Z write (16 + 16Z)
; 300  :     bCompareZ = (zcompare ? true : false);

	cmp	DWORD PTR _zcompare$[ebp], 0
	setne	dl
	mov	BYTE PTR _bCompareZ$[ebp], dl

; 301  :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 302  :     bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 303  :     srcStrideShift = 1;

	mov	DWORD PTR _srcStrideShift$[ebp], 1

; 304  :   }
; 305  :   else

	jmp	SHORT $LN13@BDMA_Type1@2
$LN14@BDMA_Type1@2:

; 306  :   {
; 307  :     //pixel only write (16 bit)
; 308  :     bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 309  :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 310  :     bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 311  :     srcStrideShift = 0;

	mov	DWORD PTR _srcStrideShift$[ebp], 0
$LN13@BDMA_Type1@2:

; 312  :   }
; 313  : 
; 314  :   if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	SHORT $LN12@BDMA_Type1@2

; 315  :   {
; 316  :     //internal address is system address (but still in MPE memory)
; 317  :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	ecx, DWORD PTR _mpeBase$[ebp]
	and	ecx, 545259519				; 207fffffH
	push	ecx
	mov	edx, DWORD PTR _mpeBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 318  :   }
; 319  :   else

	jmp	SHORT $LN11@BDMA_Type1@2
$LN12@BDMA_Type1@2:

; 320  :   {
; 321  :     //internal address is local to MPE
; 322  :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN11@BDMA_Type1@2:

; 323  :   }
; 324  : 
; 325  :   //base address is always a system address (absolute)
; 326  : 
; 327  :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdramBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 328  : 
; 329  :   pSrc = (void *)baseMemory;

	mov	edx, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], edx

; 330  :   pDest = (void *)intMemory;

	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], eax

; 331  :   srcOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	ecx, DWORD PTR _ypos$[ebp]
	imul	ecx, DWORD PTR _xsize$[ebp]
	add	ecx, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _srcOffset$[ebp], ecx

; 332  :   destOffset = 0;

	mov	DWORD PTR _destOffset$[ebp], 0

; 333  : 
; 334  :   destAStart = 0;

	mov	DWORD PTR _destAStart$[ebp], 0

; 335  :   destAStep = 1;

	mov	DWORD PTR _destAStep$[ebp], 1

; 336  :   destBStart = 0;

	mov	DWORD PTR _destBStart$[ebp], 0

; 337  :   destBStep = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destBStep$[ebp], edx

; 338  : 
; 339  : /*
; 340  :   if(((intaddr & MPE_LOCAL_MEMORY_MASK) >= MPE_IROM_BASE) &&
; 341  :     ((intaddr & MPE_LOCAL_MEMORY_MASK) < MPE_DTAGS_BASE))
; 342  :   {
; 343  :     //Maintain cache coherency!  This assumes that code will not be
; 344  :     //dynamically created in the dtrom/dtram section, bypassing the need
; 345  :     //to flush the cache on data writes.
; 346  :     if(bRemote)
; 347  :     {
; 348  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->InvalidateICache();
; 349  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->nativeCodeCache->Flush();
; 350  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->UpdateInvalidateRegion(MPE_IRAM_BASE, length << 2);
; 351  :     }
; 352  :     else
; 353  :     {
; 354  :       the_mpe->InvalidateICache();
; 355  :       the_mpe->nativeCodeCache->Flush();
; 356  :       the_mpe->UpdateInvalidateRegion(MPE_IRAM_BASE, length << 2)
; 357  :     }
; 358  :   }
; 359  : */
; 360  : 
; 361  :   srcAStart = 0;

	mov	DWORD PTR _srcAStart$[ebp], 0

; 362  :   srcAStep = 1;

	mov	DWORD PTR _srcAStep$[ebp], 1

; 363  :   srcBStep = xsize;

	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], eax

; 364  : 
; 365  :   bCount = ylen;

	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 366  :   aCountInit = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCountInit$[ebp], edx

; 367  : 
; 368  :   pSrc32 = (uint32 *)pSrc;

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 369  :   pSrc32 += srcOffset;

	mov	ecx, DWORD PTR _srcOffset$[ebp]
	mov	edx, DWORD PTR _pSrc32$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 370  :   pDest16 = (uint16 *)pDest;

	mov	ecx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest16$[ebp], ecx

; 371  :   pDest16 += destOffset;

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _pDest16$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pDest16$[ebp], ecx

; 372  :   pDest32 = (uint32 *)pDest;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest32$[ebp], edx

; 373  :   pDest32 += destOffset;

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _pDest32$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pDest32$[ebp], edx

; 374  :   srcB = 0;

	mov	DWORD PTR _srcB$[ebp], 0

; 375  :   destB = 0;

	mov	DWORD PTR _destB$[ebp], 0

; 376  : 
; 377  : #define GetPixBaseAddr(base,offset,shift) (base + (offset << shift))
; 378  : 
; 379  :   if(zcompare == 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	jne	$LN4@BDMA_Type1@2
$LN9@BDMA_Type1@2:

; 380  :   {
; 381  :     while(bCount--)

	mov	eax, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv212[ebp], eax
	mov	ecx, DWORD PTR _bCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _bCount$[ebp], ecx
	cmp	DWORD PTR tv212[ebp], 0
	je	SHORT $LN8@BDMA_Type1@2

; 382  :     {
; 383  :       srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 384  :       destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 385  :       aCount = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx
$LN7@BDMA_Type1@2:

; 386  : 
; 387  :       while(aCount--)

	mov	eax, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv215[ebp], eax
	mov	ecx, DWORD PTR _aCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _aCount$[ebp], ecx
	cmp	DWORD PTR tv215[ebp], 0
	je	SHORT $LN6@BDMA_Type1@2

; 388  :       {
; 389  :         pDest16[destA + destB] = ((uint16 *)(&pSrc32[srcA + srcB]))[0];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	dx, WORD PTR [esi+edx*4]
	mov	WORD PTR [ecx+eax*2], dx

; 390  : 
; 391  :         srcA += 1;

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, 1
	mov	DWORD PTR _srcA$[ebp], eax

; 392  :         destA += 1;

	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, 1
	mov	DWORD PTR _destA$[ebp], ecx

; 393  :       }

	jmp	SHORT $LN7@BDMA_Type1@2
$LN6@BDMA_Type1@2:

; 394  : 
; 395  :       srcB += xsize;

	mov	edx, DWORD PTR _srcB$[ebp]
	add	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcB$[ebp], edx

; 396  :       destB += xlen;

	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destB$[ebp], eax

; 397  :     }

	jmp	$LN9@BDMA_Type1@2
$LN8@BDMA_Type1@2:

; 398  :   }
; 399  :   else

	jmp	$LN19@BDMA_Type1@2
$LN4@BDMA_Type1@2:

; 400  :   {
; 401  :     while(bCount--)

	mov	ecx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	mov	edx, DWORD PTR _bCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _bCount$[ebp], edx
	cmp	DWORD PTR tv228[ebp], 0
	je	SHORT $LN19@BDMA_Type1@2

; 402  :     {
; 403  :       srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 404  :       destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 405  :       aCount = xlen;

	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax
$LN2@BDMA_Type1@2:

; 406  : 
; 407  :       while(aCount--)

	mov	ecx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv231[ebp], ecx
	mov	edx, DWORD PTR _aCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _aCount$[ebp], edx
	cmp	DWORD PTR tv231[ebp], 0
	je	SHORT $LN1@BDMA_Type1@2

; 408  :       {
; 409  :         pDest32[destA + destB] = pSrc32[srcA + srcB];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _pDest32$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 410  :         //((uint16 *)(&pDest32[destA + destB]))[0] = ((uint16 *)(&pSrc32[srcA + srcB]))[0];
; 411  : 
; 412  :         srcA += 1;

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, 1
	mov	DWORD PTR _srcA$[ebp], ecx

; 413  :         destA += 1;

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, 1
	mov	DWORD PTR _destA$[ebp], edx

; 414  :       }

	jmp	SHORT $LN2@BDMA_Type1@2
$LN1@BDMA_Type1@2:

; 415  : 
; 416  :       srcB += xsize;

	mov	eax, DWORD PTR _srcB$[ebp]
	add	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 417  :       destB += xlen;

	mov	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 418  :     }

	jmp	$LN4@BDMA_Type1@2
$LN19@BDMA_Type1@2:

; 419  :   }
; 420  : }

	pop	edi
	pop	esi
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?BDMA_Type12_Read_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_0
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_1@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_1

; 423  : {

	push	ebp
	mov	ebp, esp

; 424  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_1
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_2@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_2

; 427  : {

	push	ebp
	mov	ebp, esp

; 428  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_2
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_3@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_3

; 431  : {

	push	ebp
	mov	ebp, esp

; 432  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_3
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_4@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_4

; 435  : {

	push	ebp
	mov	ebp, esp

; 436  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_4
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_5@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_5

; 439  : {

	push	ebp
	mov	ebp, esp

; 440  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_5
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_6@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_6

; 443  : {

	push	ebp
	mov	ebp, esp

; 444  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_6
_TEXT	ENDS
PUBLIC	?BDMA_Type12_Read_7@@YAXPAVMPE@@IIIII@Z		; BDMA_Type12_Read_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type12_Read_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type12_Read_7

; 447  : {

	push	ebp
	mov	ebp, esp

; 448  : }

	pop	ebp
	ret	0
?BDMA_Type12_Read_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type12_Read_7
_TEXT	ENDS
END
