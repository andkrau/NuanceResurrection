; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ExecuteRCU.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?Execute_DECRc0@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DECRc0
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\executercu.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DECRc0@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DECRc0

; 5    : {

	push	ebp
	mov	ebp, esp

; 6    :   mpe.cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 7    :   
; 8    :   if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN3@Execute_DE

; 9    :   {
; 10   :     mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 11   :     if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN3@Execute_DE

; 12   :     {
; 13   :       mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_DE:

; 14   :     }
; 15   :   }
; 16   : }

	pop	ebp
	ret	0
?Execute_DECRc0@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DECRc0
_TEXT	ENDS
PUBLIC	?Execute_DECRc1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DECRc1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DECRc1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DECRc1

; 18   : {

	push	ebp
	mov	ebp, esp

; 19   :   mpe.cc |= CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 20   :   
; 21   :   if(mpe.rc1)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN3@Execute_DE@2

; 22   :   {
; 23   :     mpe.rc1--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+136], edx

; 24   :     if(mpe.rc1)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN3@Execute_DE@2

; 25   :     {
; 26   :       mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -65				; ffffffbfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_DE@2:

; 27   :     }
; 28   :   }
; 29   : }

	pop	ebp
	ret	0
?Execute_DECRc1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DECRc1
_TEXT	ENDS
PUBLIC	?Execute_DECBoth@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DECBoth
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DECBoth@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DECBoth

; 31   : {

	push	ebp
	mov	ebp, esp

; 32   :   mpe.cc |= (CC_COUNTER1_ZERO | CC_COUNTER0_ZERO);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 33   : 
; 34   :   if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN4@Execute_DE@3

; 35   :   {
; 36   :     mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 37   : 
; 38   :     if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN4@Execute_DE@3

; 39   :     {
; 40   :       mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN4@Execute_DE@3:

; 41   :     }
; 42   :   }
; 43   : 
; 44   :   if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN5@Execute_DE@3

; 45   :   {
; 46   :     mpe.rc1--;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	sub	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+136], ecx

; 47   : 
; 48   :     if(mpe.rc1)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN5@Execute_DE@3

; 49   :     {
; 50   :       mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_DE@3:

; 51   :     }
; 52   :   }
; 53   : }

	pop	ebp
	ret	0
?Execute_DECBoth@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DECBoth
_TEXT	ENDS
PUBLIC	?Execute_ADDRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDRImmediateOnly
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDRImmediateOnly

; 56   : {

	push	ebp
	mov	ebp, esp

; 57   :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] + nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _nuance$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+140], ecx

; 58   : }

	pop	ebp
	ret	0
?Execute_ADDRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDRImmediateOnly
_TEXT	ENDS
PUBLIC	?Execute_ADDRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDRImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDRImmediate

; 60   : {

	push	ebp
	mov	ebp, esp

; 61   :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] + nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _nuance$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+140], ecx

; 62   : 
; 63   :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2
	je	SHORT $LN6@Execute_AD

; 64   :   {
; 65   :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 66   : 
; 67   :     if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN6@Execute_AD

; 68   :     {
; 69   :       mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 70   :       if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_AD

; 71   :       {
; 72   :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_AD:

; 73   :       }
; 74   :     }
; 75   :   }
; 76   : 
; 77   :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	je	SHORT $LN7@Execute_AD

; 78   :   {
; 79   :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 80   : 
; 81   :     if(mpe.rc1)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN7@Execute_AD

; 82   :     {
; 83   :       mpe.rc1--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+136]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 84   :       if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN7@Execute_AD

; 85   :       {
; 86   :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_AD:

; 87   :       }
; 88   :     }
; 89   :   }
; 90   : 
; 91   : }

	pop	ebp
	ret	0
?Execute_ADDRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDRImmediate
_TEXT	ENDS
PUBLIC	?Execute_ADDRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDRScalarOnly
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDRScalarOnly

; 93   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 94   :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] + entry.pScalarRegs[nuance.fields[FIELD_RCU_SRC]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4+140], eax

; 95   : }

	pop	esi
	pop	ebp
	ret	0
?Execute_ADDRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDRScalarOnly
_TEXT	ENDS
PUBLIC	?Execute_ADDRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDRScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDRScalar

; 97   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 98   :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] + entry.pScalarRegs[nuance.fields[FIELD_RCU_SRC]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4+140], eax

; 99   :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 2
	je	SHORT $LN6@Execute_AD@2

; 100  :   {
; 101  :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 102  : 
; 103  :     if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_AD@2

; 104  :     {
; 105  :       mpe.rc0--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+132]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+132], eax

; 106  :       if(mpe.rc0)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+132], 0
	je	SHORT $LN6@Execute_AD@2

; 107  :       {
; 108  :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_AD@2:

; 109  :       }
; 110  :     }
; 111  :   }
; 112  : 
; 113  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	je	SHORT $LN7@Execute_AD@2

; 114  :   {
; 115  :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 116  : 
; 117  :     if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN7@Execute_AD@2

; 118  :     {
; 119  :       mpe.rc1--;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	sub	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+136], ecx

; 120  :       if(mpe.rc1)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN7@Execute_AD@2

; 121  :       {
; 122  :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN7@Execute_AD@2:

; 123  :       }
; 124  :     }
; 125  :   }
; 126  : }

	pop	esi
	pop	ebp
	ret	0
?Execute_ADDRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDRScalar
_TEXT	ENDS
PUBLIC	?Execute_MVRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MVRImmediateOnly
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MVRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MVRImmediateOnly

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx*4+140], eax

; 130  : }

	pop	ebp
	ret	0
?Execute_MVRImmediateOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MVRImmediateOnly
_TEXT	ENDS
PUBLIC	?Execute_MVRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MVRImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MVRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MVRImmediate

; 132  : {

	push	ebp
	mov	ebp, esp

; 133  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx*4+140], eax

; 134  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2
	je	SHORT $LN6@Execute_MV

; 135  :   {
; 136  :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 137  : 
; 138  :     if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN6@Execute_MV

; 139  :     {
; 140  :       mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 141  :       if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_MV

; 142  :       {
; 143  :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_MV:

; 144  :       }
; 145  :     }
; 146  :   }
; 147  : 
; 148  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	je	SHORT $LN7@Execute_MV

; 149  :   {
; 150  :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 151  : 
; 152  :     if(mpe.rc1)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN7@Execute_MV

; 153  :     {
; 154  :       mpe.rc1--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+136]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 155  :       if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN7@Execute_MV

; 156  :       {
; 157  :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_MV:

; 158  :       }
; 159  :     }
; 160  :   }
; 161  : }

	pop	ebp
	ret	0
?Execute_MVRImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MVRImmediate
_TEXT	ENDS
PUBLIC	?Execute_MVRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MVRScalarOnly
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MVRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MVRScalarOnly

; 163  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 164  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pScalarRegs[nuance.fields[FIELD_RCU_SRC]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+edx*4+140], eax

; 165  : }

	pop	esi
	pop	ebp
	ret	0
?Execute_MVRScalarOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MVRScalarOnly
_TEXT	ENDS
PUBLIC	?Execute_MVRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MVRScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MVRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MVRScalar

; 167  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 168  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] = entry.pScalarRegs[nuance.fields[FIELD_RCU_SRC]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+edx*4+140], eax

; 169  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2
	je	SHORT $LN6@Execute_MV@2

; 170  :   {
; 171  :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 172  : 
; 173  :     if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN6@Execute_MV@2

; 174  :     {
; 175  :       mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 176  :       if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_MV@2

; 177  :       {
; 178  :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_MV@2:

; 179  :       }
; 180  :     }
; 181  :   }
; 182  : 
; 183  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	je	SHORT $LN7@Execute_MV@2

; 184  :   {
; 185  :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 186  : 
; 187  :     if(mpe.rc1)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN7@Execute_MV@2

; 188  :     {
; 189  :       mpe.rc1--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+136]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 190  :       if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN7@Execute_MV@2

; 191  :       {
; 192  :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_MV@2:

; 193  :       }
; 194  :     }
; 195  :   }
; 196  : }

	pop	esi
	pop	ebp
	ret	0
?Execute_MVRScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MVRScalar
_TEXT	ENDS
PUBLIC	?Execute_RangeOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_RangeOnly
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv65 = -20						; size = 4
$T4827 = -13						; size = 1
_rcu_range$ = -12					; size = 4
_rcu_src$ = -8						; size = 4
_moduloResult$ = -4					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_RangeOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_RangeOnly

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	BYTE PTR $T4827[ebp], 0

; 199  :   uint32 moduloResult;
; 200  :   uint32 rcu_src, rcu_range;
; 201  : 
; 202  :   rcu_src = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 203  :   switch(rcu_src)

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 3
	ja	SHORT $LN8@Execute_Ra
	mov	eax, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN17@Execute_Ra[eax*4]
$LN7@Execute_Ra:

; 204  :   {
; 205  :     case 0:
; 206  :       //Use x range as integer portion.  Limit to 10 bits.
; 207  :       rcu_range = *entry.pXyrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4827[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 208  :       break;

	jmp	SHORT $LN8@Execute_Ra
$LN6@Execute_Ra:

; 209  :     case 1:
; 210  :       //Use y range as integer portion.  Limit to 10 bits.
; 211  :       rcu_range = (*entry.pXyrange << 16) & 0x003FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4827[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 212  :       break;

	jmp	SHORT $LN8@Execute_Ra
$LN5@Execute_Ra:

; 213  :     case 2:
; 214  :       //Use u range.  Limit to 10 bits.
; 215  :       rcu_range = *entry.pUvrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4827[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 216  :       break;

	jmp	SHORT $LN8@Execute_Ra
$LN4@Execute_Ra:

; 217  :     case 3:
; 218  :       //Use v range.  Limit to 10 bits
; 219  :       rcu_range = (*entry.pUvrange << 16) & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4827[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax
$LN8@Execute_Ra:

; 220  :       break;
; 221  :   }
; 222  : 
; 223  :   rcu_src = entry.pIndexRegs[rcu_src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _rcu_src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 224  : 
; 225  :   //clear modge and modmi conditions
; 226  :   mpe.cc &= ~(CC_MODGE | CC_MODMI);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -385				; fffffe7fH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 227  : 
; 228  :   if(((int32)(rcu_src & 0xFFFF0000UL)) >= (int32)rcu_range)

	cmp	BYTE PTR $T4827[ebp], 0
	jne	SHORT $LN12@Execute_Ra
	push	OFFSET $LN13@Execute_Ra
	call	__RTC_UninitUse
	add	esp, 4
$LN12@Execute_Ra:
	mov	edx, DWORD PTR _rcu_src$[ebp]
	and	edx, -65536				; ffff0000H
	cmp	edx, DWORD PTR _rcu_range$[ebp]
	jl	SHORT $LN3@Execute_Ra

; 229  :   {
; 230  :     moduloResult = rcu_src - rcu_range;

	cmp	BYTE PTR $T4827[ebp], 0
	jne	SHORT $LN14@Execute_Ra
	push	OFFSET $LN13@Execute_Ra
	call	__RTC_UninitUse
	add	esp, 4
$LN14@Execute_Ra:
	mov	eax, DWORD PTR _rcu_src$[ebp]
	sub	eax, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], eax

; 231  :     //set modge condition
; 232  :     mpe.cc |= CC_MODGE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN10@Execute_Ra
$LN3@Execute_Ra:

; 233  :   }
; 234  :   else if((int32)rcu_src < 0)

	cmp	DWORD PTR _rcu_src$[ebp], 0
	jge	SHORT $LN10@Execute_Ra

; 235  :   {
; 236  :     moduloResult = rcu_src + rcu_range;

	cmp	BYTE PTR $T4827[ebp], 0
	jne	SHORT $LN15@Execute_Ra
	push	OFFSET $LN13@Execute_Ra
	call	__RTC_UninitUse
	add	esp, 4
$LN15@Execute_Ra:
	mov	ecx, DWORD PTR _rcu_src$[ebp]
	add	ecx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], ecx

; 237  :     //set modmi condition
; 238  :     mpe.cc |= CC_MODMI;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN10@Execute_Ra:

; 239  :   }
; 240  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@Execute_Ra:
$LN13@Execute_Ra:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
	npad	1
$LN17@Execute_Ra:
	DD	$LN7@Execute_Ra
	DD	$LN6@Execute_Ra
	DD	$LN5@Execute_Ra
	DD	$LN4@Execute_Ra
?Execute_RangeOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_RangeOnly
_TEXT	ENDS
PUBLIC	?Execute_Range@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_Range
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv65 = -20						; size = 4
$T4837 = -13						; size = 1
_rcu_range$ = -12					; size = 4
_rcu_src$ = -8						; size = 4
_moduloResult$ = -4					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_Range@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_Range

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	BYTE PTR $T4837[ebp], 0

; 243  :   uint32 moduloResult;
; 244  :   uint32 rcu_src, rcu_range;
; 245  : 
; 246  :   rcu_src = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 247  :   switch(rcu_src)

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 3
	ja	SHORT $LN14@Execute_Ra@2
	mov	eax, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN23@Execute_Ra@2[eax*4]
$LN13@Execute_Ra@2:

; 248  :   {
; 249  :     case 0:
; 250  :       //Use x range as integer portion.  Limit to 10 bits.
; 251  :       rcu_range = *entry.pXyrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4837[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 252  :       break;

	jmp	SHORT $LN14@Execute_Ra@2
$LN12@Execute_Ra@2:

; 253  :     case 1:
; 254  :       //Use y range as integer portion.  Limit to 10 bits.
; 255  :       rcu_range = (*entry.pXyrange << 16) & 0x003FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4837[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 256  :       break;

	jmp	SHORT $LN14@Execute_Ra@2
$LN11@Execute_Ra@2:

; 257  :     case 2:
; 258  :       //Use u range.  Limit to 10 bits.
; 259  :       rcu_range = *entry.pUvrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4837[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 260  :       break;

	jmp	SHORT $LN14@Execute_Ra@2
$LN10@Execute_Ra@2:

; 261  :     case 3:
; 262  :       //Use v range.  Limit to 10 bits
; 263  :       rcu_range = (*entry.pUvrange << 16) & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4837[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax
$LN14@Execute_Ra@2:

; 264  :       break;
; 265  :   }
; 266  : 
; 267  :   rcu_src = entry.pIndexRegs[rcu_src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _rcu_src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 268  : 
; 269  :   //clear modge and modmi conditions
; 270  :   mpe.cc &= ~(CC_MODGE | CC_MODMI);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -385				; fffffe7fH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 271  : 
; 272  :   if(((int32)(rcu_src & 0xFFFF0000UL)) >= (int32)rcu_range)

	cmp	BYTE PTR $T4837[ebp], 0
	jne	SHORT $LN18@Execute_Ra@2
	push	OFFSET $LN19@Execute_Ra@2
	call	__RTC_UninitUse
	add	esp, 4
$LN18@Execute_Ra@2:
	mov	edx, DWORD PTR _rcu_src$[ebp]
	and	edx, -65536				; ffff0000H
	cmp	edx, DWORD PTR _rcu_range$[ebp]
	jl	SHORT $LN9@Execute_Ra@2

; 273  :   {
; 274  :     moduloResult = rcu_src - rcu_range;

	cmp	BYTE PTR $T4837[ebp], 0
	jne	SHORT $LN20@Execute_Ra@2
	push	OFFSET $LN19@Execute_Ra@2
	call	__RTC_UninitUse
	add	esp, 4
$LN20@Execute_Ra@2:
	mov	eax, DWORD PTR _rcu_src$[ebp]
	sub	eax, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], eax

; 275  :     //set modge condition
; 276  :     mpe.cc |= CC_MODGE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN8@Execute_Ra@2
$LN9@Execute_Ra@2:

; 277  :   }
; 278  :   else if((int32)rcu_src < 0)

	cmp	DWORD PTR _rcu_src$[ebp], 0
	jge	SHORT $LN8@Execute_Ra@2

; 279  :   {
; 280  :     moduloResult = rcu_src + rcu_range;

	cmp	BYTE PTR $T4837[ebp], 0
	jne	SHORT $LN21@Execute_Ra@2
	push	OFFSET $LN19@Execute_Ra@2
	call	__RTC_UninitUse
	add	esp, 4
$LN21@Execute_Ra@2:
	mov	ecx, DWORD PTR _rcu_src$[ebp]
	add	ecx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], ecx

; 281  :     //set modmi condition
; 282  :     mpe.cc |= CC_MODMI;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN8@Execute_Ra@2:

; 283  :   }
; 284  : 
; 285  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 2
	je	SHORT $LN6@Execute_Ra@2

; 286  :   {
; 287  :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 288  : 
; 289  :     if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_Ra@2

; 290  :     {
; 291  :       mpe.rc0--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+132]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+132], eax

; 292  :       if(mpe.rc0)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+132], 0
	je	SHORT $LN6@Execute_Ra@2

; 293  :       {
; 294  :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_Ra@2:

; 295  :       }
; 296  :     }
; 297  :   }
; 298  : 
; 299  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	je	SHORT $LN16@Execute_Ra@2

; 300  :   {
; 301  :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 302  : 
; 303  :     if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN16@Execute_Ra@2

; 304  :     {
; 305  :       mpe.rc1--;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	sub	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+136], ecx

; 306  :       if(mpe.rc1)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN16@Execute_Ra@2

; 307  :       {
; 308  :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN16@Execute_Ra@2:

; 309  :       }
; 310  :     }
; 311  :   }
; 312  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@Execute_Ra@2:
$LN19@Execute_Ra@2:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
	npad	1
$LN23@Execute_Ra@2:
	DD	$LN13@Execute_Ra@2
	DD	$LN12@Execute_Ra@2
	DD	$LN11@Execute_Ra@2
	DD	$LN10@Execute_Ra@2
?Execute_Range@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_Range
_TEXT	ENDS
PUBLIC	?Execute_ModuloOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ModuloOnly
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv65 = -20						; size = 4
$T4845 = -13						; size = 1
_rcu_range$ = -12					; size = 4
_rcu_src$ = -8						; size = 4
_moduloResult$ = -4					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ModuloOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ModuloOnly

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	BYTE PTR $T4845[ebp], 0

; 316  :   uint32 moduloResult;
; 317  :   uint32 rcu_src, rcu_range;
; 318  : 
; 319  :   rcu_src = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 320  :   switch(rcu_src)

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 3
	ja	SHORT $LN8@Execute_Mo
	mov	eax, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN17@Execute_Mo[eax*4]
$LN7@Execute_Mo:

; 321  :   {
; 322  :     case 0:
; 323  :       //Use x range as integer portion.  Limit to 10 bits.
; 324  :       rcu_range = *entry.pXyrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4845[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 325  :       break;

	jmp	SHORT $LN8@Execute_Mo
$LN6@Execute_Mo:

; 326  :     case 1:
; 327  :       //Use y range as integer portion.  Limit to 10 bits.
; 328  :       rcu_range = (*entry.pXyrange << 16) & 0x003FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4845[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 329  :       break;

	jmp	SHORT $LN8@Execute_Mo
$LN5@Execute_Mo:

; 330  :     case 2:
; 331  :       //Use u range.  Limit to 10 bits.
; 332  :       rcu_range = *entry.pUvrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4845[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 333  :       break;

	jmp	SHORT $LN8@Execute_Mo
$LN4@Execute_Mo:

; 334  :     case 3:
; 335  :       //Use v range.  Limit to 10 bits
; 336  :       rcu_range = (*entry.pUvrange << 16) & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4845[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax
$LN8@Execute_Mo:

; 337  :       break;
; 338  :   }
; 339  : 
; 340  : 
; 341  :   rcu_src = entry.pIndexRegs[rcu_src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _rcu_src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 342  : 
; 343  :   //clear modge and modmi conditions
; 344  :   mpe.cc &= ~(CC_MODGE | CC_MODMI);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -385				; fffffe7fH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 345  : 
; 346  :   moduloResult = rcu_src;

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], edx

; 347  : 
; 348  :   if(((int32)(rcu_src & 0xFFFF0000UL)) >= (int32)rcu_range)

	cmp	BYTE PTR $T4845[ebp], 0
	jne	SHORT $LN12@Execute_Mo
	push	OFFSET $LN13@Execute_Mo
	call	__RTC_UninitUse
	add	esp, 4
$LN12@Execute_Mo:
	mov	eax, DWORD PTR _rcu_src$[ebp]
	and	eax, -65536				; ffff0000H
	cmp	eax, DWORD PTR _rcu_range$[ebp]
	jl	SHORT $LN3@Execute_Mo

; 349  :   {
; 350  :     moduloResult = rcu_src - rcu_range;

	cmp	BYTE PTR $T4845[ebp], 0
	jne	SHORT $LN14@Execute_Mo
	push	OFFSET $LN13@Execute_Mo
	call	__RTC_UninitUse
	add	esp, 4
$LN14@Execute_Mo:
	mov	ecx, DWORD PTR _rcu_src$[ebp]
	sub	ecx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], ecx

; 351  :     //set modge condition
; 352  :     mpe.cc |= CC_MODGE;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	SHORT $LN2@Execute_Mo
$LN3@Execute_Mo:

; 353  :   }
; 354  :   else if((int32)rcu_src < 0)

	cmp	DWORD PTR _rcu_src$[ebp], 0
	jge	SHORT $LN2@Execute_Mo

; 355  :   {
; 356  :     moduloResult = rcu_src + rcu_range;

	cmp	BYTE PTR $T4845[ebp], 0
	jne	SHORT $LN15@Execute_Mo
	push	OFFSET $LN13@Execute_Mo
	call	__RTC_UninitUse
	add	esp, 4
$LN15@Execute_Mo:
	mov	edx, DWORD PTR _rcu_src$[ebp]
	add	edx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], edx

; 357  :     //set modmi condition
; 358  :     mpe.cc |= CC_MODMI;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_Mo:

; 359  :   }
; 360  : 
; 361  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] =
; 362  :     (entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] & 0x0000FFFFUL) |
; 363  :     (moduloResult & 0xFFFF0000UL);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _moduloResult$[ebp]
	and	edx, -65536				; ffff0000H
	or	ecx, edx
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+140], ecx

; 364  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@Execute_Mo:
$LN13@Execute_Mo:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN17@Execute_Mo:
	DD	$LN7@Execute_Mo
	DD	$LN6@Execute_Mo
	DD	$LN5@Execute_Mo
	DD	$LN4@Execute_Mo
?Execute_ModuloOnly@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ModuloOnly
_TEXT	ENDS
PUBLIC	?Execute_Modulo@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_Modulo
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv65 = -20						; size = 4
$T4853 = -13						; size = 1
_rcu_range$ = -12					; size = 4
_rcu_src$ = -8						; size = 4
_moduloResult$ = -4					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_Modulo@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_Modulo

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	BYTE PTR $T4853[ebp], 0

; 367  :   uint32 moduloResult;
; 368  :   uint32 rcu_src, rcu_range;
; 369  : 
; 370  :   rcu_src = nuance.fields[FIELD_RCU_SRC];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 371  :   switch(rcu_src)

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 3
	ja	SHORT $LN14@Execute_Mo@2
	mov	eax, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN23@Execute_Mo@2[eax*4]
$LN13@Execute_Mo@2:

; 372  :   {
; 373  :     case 0:
; 374  :       //Use x range as integer portion.  Limit to 10 bits.
; 375  :       rcu_range = *entry.pXyrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4853[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 376  :       break;

	jmp	SHORT $LN14@Execute_Mo@2
$LN12@Execute_Mo@2:

; 377  :     case 1:
; 378  :       //Use y range as integer portion.  Limit to 10 bits.
; 379  :       rcu_range = (*entry.pXyrange << 16) & 0x003FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4853[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 380  :       break;

	jmp	SHORT $LN14@Execute_Mo@2
$LN11@Execute_Mo@2:

; 381  :     case 2:
; 382  :       //Use u range.  Limit to 10 bits.
; 383  :       rcu_range = *entry.pUvrange & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4853[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax

; 384  :       break;

	jmp	SHORT $LN14@Execute_Mo@2
$LN10@Execute_Mo@2:

; 385  :     case 3:
; 386  :       //Use v range.  Limit to 10 bits
; 387  :       rcu_range = (*entry.pUvrange << 16) & 0x03FF0000UL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	shl	eax, 16					; 00000010H
	and	eax, 67043328				; 03ff0000H
	mov	BYTE PTR $T4853[ebp], 1
	mov	DWORD PTR _rcu_range$[ebp], eax
$LN14@Execute_Mo@2:

; 388  :       break;
; 389  :   }
; 390  : 
; 391  :   rcu_src = entry.pIndexRegs[rcu_src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _rcu_src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _rcu_src$[ebp], ecx

; 392  : 
; 393  :   //clear modge and modmi conditions
; 394  :   mpe.cc &= ~(CC_MODGE | CC_MODMI);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -385				; fffffe7fH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 395  : 
; 396  :   moduloResult = rcu_src;

	mov	edx, DWORD PTR _rcu_src$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], edx

; 397  : 
; 398  :   if(((int32)(rcu_src & 0xFFFF0000UL)) >= (int32)rcu_range)

	cmp	BYTE PTR $T4853[ebp], 0
	jne	SHORT $LN18@Execute_Mo@2
	push	OFFSET $LN19@Execute_Mo@2
	call	__RTC_UninitUse
	add	esp, 4
$LN18@Execute_Mo@2:
	mov	eax, DWORD PTR _rcu_src$[ebp]
	and	eax, -65536				; ffff0000H
	cmp	eax, DWORD PTR _rcu_range$[ebp]
	jl	SHORT $LN9@Execute_Mo@2

; 399  :   {
; 400  :     moduloResult = rcu_src - rcu_range;

	cmp	BYTE PTR $T4853[ebp], 0
	jne	SHORT $LN20@Execute_Mo@2
	push	OFFSET $LN19@Execute_Mo@2
	call	__RTC_UninitUse
	add	esp, 4
$LN20@Execute_Mo@2:
	mov	ecx, DWORD PTR _rcu_src$[ebp]
	sub	ecx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], ecx

; 401  :     //set modge condition
; 402  :     mpe.cc |= CC_MODGE;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	SHORT $LN8@Execute_Mo@2
$LN9@Execute_Mo@2:

; 403  :   }
; 404  :   else if((int32)rcu_src < 0)

	cmp	DWORD PTR _rcu_src$[ebp], 0
	jge	SHORT $LN8@Execute_Mo@2

; 405  :   {
; 406  :     moduloResult = rcu_src + rcu_range;

	cmp	BYTE PTR $T4853[ebp], 0
	jne	SHORT $LN21@Execute_Mo@2
	push	OFFSET $LN19@Execute_Mo@2
	call	__RTC_UninitUse
	add	esp, 4
$LN21@Execute_Mo@2:
	mov	edx, DWORD PTR _rcu_src$[ebp]
	add	edx, DWORD PTR _rcu_range$[ebp]
	mov	DWORD PTR _moduloResult$[ebp], edx

; 407  :     //set modmi condition
; 408  :     mpe.cc |= CC_MODMI;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN8@Execute_Mo@2:

; 409  :   }
; 410  : 
; 411  :   (&mpe.rx)[nuance.fields[FIELD_RCU_DEST]] =
; 412  :     (entry.pIndexRegs[nuance.fields[FIELD_RCU_DEST]] & 0x0000FFFFUL) |
; 413  :     (moduloResult & 0xFFFF0000UL);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _moduloResult$[ebp]
	and	edx, -65536				; ffff0000H
	or	ecx, edx
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+140], ecx

; 414  : 
; 415  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC0)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2
	je	SHORT $LN6@Execute_Mo@2

; 416  :   {
; 417  :     mpe.cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 418  : 
; 419  :     if(mpe.rc0)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN6@Execute_Mo@2

; 420  :     {
; 421  :       mpe.rc0--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+132], edx

; 422  :       if(mpe.rc0)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN6@Execute_Mo@2

; 423  :       {
; 424  :         mpe.cc &= ~CC_COUNTER0_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_Mo@2:

; 425  :       }
; 426  :     }
; 427  :   }
; 428  : 
; 429  :   if(nuance.fields[FIELD_RCU_INFO] & RCU_DEC_RC1)

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	je	SHORT $LN16@Execute_Mo@2

; 430  :   {
; 431  :     mpe.cc |= CC_COUNTER1_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 432  : 
; 433  :     if(mpe.rc1)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	je	SHORT $LN16@Execute_Mo@2

; 434  :     {
; 435  :       mpe.rc1--;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+136]
	sub	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 436  :       if(mpe.rc1)

	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+136], 0
	je	SHORT $LN16@Execute_Mo@2

; 437  :       {
; 438  :         mpe.cc &= ~CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN16@Execute_Mo@2:

; 439  :       }
; 440  :     }
; 441  :   }
; 442  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@Execute_Mo@2:
$LN19@Execute_Mo@2:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN23@Execute_Mo@2:
	DD	$LN13@Execute_Mo@2
	DD	$LN12@Execute_Mo@2
	DD	$LN11@Execute_Mo@2
	DD	$LN10@Execute_Mo@2
?Execute_Modulo@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_Modulo
_TEXT	ENDS
END
