; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ExecuteMUL.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_shiftTable DD	010H
	DD	08H
	DD	00H
	DD	02H
CONST	ENDS
PUBLIC	?Execute_ADDM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDM
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\executemul.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDM

; 7    : {

	push	ebp
	mov	ebp, esp
	push	esi

; 8    :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 9    :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC1]] +
; 10   :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 11   : }

	pop	esi
	pop	ebp
	ret	0
?Execute_ADDM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDM
_TEXT	ENDS
PUBLIC	?Execute_ADDMImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDMImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDMImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDMImmediate

; 13   : {

	push	ebp
	mov	ebp, esp

; 14   :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 15   :     nuance.fields[FIELD_MUL_SRC1] + 
; 16   :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 17   : }

	pop	ebp
	ret	0
?Execute_ADDMImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDMImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBM
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBM

; 20   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 21   :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 22   :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC1]] -
; 23   :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	sub	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 24   : }

	pop	esi
	pop	ebp
	ret	0
?Execute_SUBM@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBM
_TEXT	ENDS
PUBLIC	?Execute_SUBMImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBMImmediateReverse
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBMImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBMImmediateReverse

; 27   : {

	push	ebp
	mov	ebp, esp

; 28   :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 29   :     nuance.fields[FIELD_MUL_SRC1] - 
; 30   :     entry.pScalarRegs[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	sub	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 31   : }

	pop	ebp
	ret	0
?Execute_SUBMImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBMImmediateReverse
_TEXT	ENDS
PUBLIC	?Execute_MULScalarShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULScalarShiftAcshift
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__allmul:PROC
EXTRN	__allshr:PROC
EXTRN	__allshl:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv250 = -52						; size = 8
tv237 = -44						; size = 8
tv227 = -36						; size = 8
_mul_shift$ = -28					; size = 4
_mulop2$ = -24						; size = 8
_mulop1$ = -16						; size = 8
_result$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULScalarShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULScalarShiftAcshift

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 35   :   int64 result;
; 36   :   int64 mulop1 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 37   :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 38   :   uint32 mul_shift = *(entry.pAcshift) & 0x7FUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	and	edx, 127				; 0000007fH
	mov	DWORD PTR _mul_shift$[ebp], edx

; 39   : 
; 40   :   result = ((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32);

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 41   : 
; 42   :   if(mul_shift & 0x40)

	mov	eax, DWORD PTR _mul_shift$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN6@Execute_MU

; 43   :   {
; 44   :     //ASL
; 45   :     result <<= (128 - mul_shift);

	mov	ecx, 128				; 00000080H
	sub	ecx, DWORD PTR _mul_shift$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 46   :   }
; 47   :   else

	jmp	SHORT $LN5@Execute_MU
$LN6@Execute_MU:

; 48   :   {
; 49   :     //ASR
; 50   :     result >>= mul_shift;

	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	ecx, DWORD PTR _mul_shift$[ebp]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx
$LN5@Execute_MU:

; 51   :   }
; 52   : 
; 53   :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 54   :   if((result & 0x0000000080000000i64) == 0i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv227[ebp], ecx
	mov	DWORD PTR tv227[ebp+4], edx
	mov	eax, DWORD PTR tv227[ebp]
	or	eax, DWORD PTR tv227[ebp+4]
	jne	SHORT $LN4@Execute_MU

; 55   :   {
; 56   :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv237[ebp], ecx
	mov	DWORD PTR tv237[ebp+4], edx
	mov	eax, DWORD PTR tv237[ebp]
	or	eax, DWORD PTR tv237[ebp+4]
	je	SHORT $LN3@Execute_MU

; 57   :     {
; 58   :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN3@Execute_MU:

; 59   :     }
; 60   :   }
; 61   :   else

	jmp	SHORT $LN2@Execute_MU
$LN4@Execute_MU:

; 62   :   {
; 63   :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv250[ebp], ecx
	mov	DWORD PTR tv250[ebp+4], edx
	jne	SHORT $LN9@Execute_MU
	cmp	DWORD PTR tv250[ebp+4], -1
	je	SHORT $LN2@Execute_MU
$LN9@Execute_MU:

; 64   :     {
; 65   :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_MU:

; 66   :     }
; 67   :   }
; 68   : 
; 69   :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 70   : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULScalarShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULScalarShiftAcshift
_TEXT	ENDS
PUBLIC	?Execute_MULScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv232 = -48						; size = 8
tv219 = -40						; size = 8
tv209 = -32						; size = 8
_result$ = -24						; size = 8
_mulop2$ = -16						; size = 8
_mulop1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULScalarShiftRightImmediate

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 74   :   int64 mulop1 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 75   :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 76   :   int64 result;
; 77   : 
; 78   :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32)) >> nuance.fields[FIELD_MUL_INFO];

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 79   : 
; 80   :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 81   :   if((result & 0x0000000080000000i64) == 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv209[ebp], edx
	mov	DWORD PTR tv209[ebp+4], eax
	mov	ecx, DWORD PTR tv209[ebp]
	or	ecx, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN4@Execute_MU@2

; 82   :   {
; 83   :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv219[ebp], edx
	mov	DWORD PTR tv219[ebp+4], eax
	mov	ecx, DWORD PTR tv219[ebp]
	or	ecx, DWORD PTR tv219[ebp+4]
	je	SHORT $LN3@Execute_MU@2

; 84   :     {
; 85   :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_MU@2:

; 86   :     }
; 87   :   }
; 88   :   else

	jmp	SHORT $LN2@Execute_MU@2
$LN4@Execute_MU@2:

; 89   :   {
; 90   :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv232[ebp], edx
	mov	DWORD PTR tv232[ebp+4], eax
	jne	SHORT $LN7@Execute_MU@2
	cmp	DWORD PTR tv232[ebp+4], -1
	je	SHORT $LN2@Execute_MU@2
$LN7@Execute_MU@2:

; 91   :     {
; 92   :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_MU@2:

; 93   :     }
; 94   :   }
; 95   : 
; 96   :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 97   : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_MULScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv232 = -48						; size = 8
tv219 = -40						; size = 8
tv209 = -32						; size = 8
_result$ = -24						; size = 8
_mulop2$ = -16						; size = 8
_mulop1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULScalarShiftLeftImmediate

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 101  :   int64 mulop1 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 102  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 103  :   int64 result;
; 104  : 
; 105  :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32)) << nuance.fields[FIELD_MUL_INFO];

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 106  : 
; 107  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 108  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv209[ebp], edx
	mov	DWORD PTR tv209[ebp+4], eax
	mov	ecx, DWORD PTR tv209[ebp]
	or	ecx, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN4@Execute_MU@3

; 109  :   {
; 110  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv219[ebp], edx
	mov	DWORD PTR tv219[ebp+4], eax
	mov	ecx, DWORD PTR tv219[ebp]
	or	ecx, DWORD PTR tv219[ebp+4]
	je	SHORT $LN3@Execute_MU@3

; 111  :     {
; 112  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_MU@3:

; 113  :     }
; 114  :   }
; 115  :   else

	jmp	SHORT $LN2@Execute_MU@3
$LN4@Execute_MU@3:

; 116  :   {
; 117  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv232[ebp], edx
	mov	DWORD PTR tv232[ebp+4], eax
	jne	SHORT $LN7@Execute_MU@3
	cmp	DWORD PTR tv232[ebp+4], -1
	je	SHORT $LN2@Execute_MU@3
$LN7@Execute_MU@3:

; 118  :     {
; 119  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_MU@3:

; 120  :     }
; 121  :   }
; 122  : 
; 123  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 124  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MULImmediateShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULImmediateShiftAcshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv244 = -52						; size = 8
tv231 = -44						; size = 8
tv221 = -36						; size = 8
_mul_shift$ = -28					; size = 4
_mulop2$ = -24						; size = 8
_mulop1$ = -16						; size = 8
_result$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULImmediateShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULImmediateShiftAcshift

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 128  :   int64 result;
; 129  :   int64 mulop1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 130  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 131  :   uint32 mul_shift = *(entry.pAcshift) & 0x7FUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	and	edx, 127				; 0000007fH
	mov	DWORD PTR _mul_shift$[ebp], edx

; 132  : 
; 133  :   result = ((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32);

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 134  : 
; 135  :   if(mul_shift & 0x40)

	mov	eax, DWORD PTR _mul_shift$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN6@Execute_MU@4

; 136  :   {
; 137  :     //ASL
; 138  :     result <<= (128 - mul_shift);

	mov	ecx, 128				; 00000080H
	sub	ecx, DWORD PTR _mul_shift$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 139  :   }
; 140  :   else

	jmp	SHORT $LN5@Execute_MU@4
$LN6@Execute_MU@4:

; 141  :   {
; 142  :     //ASR
; 143  :     result >>= mul_shift;

	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	ecx, DWORD PTR _mul_shift$[ebp]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx
$LN5@Execute_MU@4:

; 144  :   }
; 145  : 
; 146  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 147  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv221[ebp], ecx
	mov	DWORD PTR tv221[ebp+4], edx
	mov	eax, DWORD PTR tv221[ebp]
	or	eax, DWORD PTR tv221[ebp+4]
	jne	SHORT $LN4@Execute_MU@4

; 148  :   {
; 149  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv231[ebp], ecx
	mov	DWORD PTR tv231[ebp+4], edx
	mov	eax, DWORD PTR tv231[ebp]
	or	eax, DWORD PTR tv231[ebp+4]
	je	SHORT $LN3@Execute_MU@4

; 150  :     {
; 151  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN3@Execute_MU@4:

; 152  :     }
; 153  :   }
; 154  :   else

	jmp	SHORT $LN2@Execute_MU@4
$LN4@Execute_MU@4:

; 155  :   {
; 156  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv244[ebp], ecx
	mov	DWORD PTR tv244[ebp+4], edx
	jne	SHORT $LN9@Execute_MU@4
	cmp	DWORD PTR tv244[ebp+4], -1
	je	SHORT $LN2@Execute_MU@4
$LN9@Execute_MU@4:

; 157  :     {
; 158  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_MU@4:

; 159  :     }
; 160  :   }
; 161  : 
; 162  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 163  : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULImmediateShiftAcshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULImmediateShiftAcshift
_TEXT	ENDS
PUBLIC	?Execute_MULScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULScalarShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv255 = -52						; size = 8
tv242 = -44						; size = 8
tv232 = -36						; size = 8
_mul_shift$ = -28					; size = 4
_mulop2$ = -24						; size = 8
_mulop1$ = -16						; size = 8
_result$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULScalarShiftScalar

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 167  :   int64 result;
; 168  :   int64 mulop1 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 169  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 170  :   uint32 mul_shift = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_INFO]] & 0x7FUL;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 127				; 0000007fH
	mov	DWORD PTR _mul_shift$[ebp], ecx

; 171  : 
; 172  :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32));

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 173  : 
; 174  :   if(mul_shift & 0x40)

	mov	edx, DWORD PTR _mul_shift$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN6@Execute_MU@5

; 175  :   {
; 176  :     //ASL
; 177  :     result <<= (128 - mul_shift);

	mov	ecx, 128				; 00000080H
	sub	ecx, DWORD PTR _mul_shift$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 178  :   }
; 179  :   else

	jmp	SHORT $LN5@Execute_MU@5
$LN6@Execute_MU@5:

; 180  :   {
; 181  :     //ASR
; 182  :     result >>= mul_shift;

	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	ecx, DWORD PTR _mul_shift$[ebp]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx
$LN5@Execute_MU@5:

; 183  :   }
; 184  : 
; 185  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 186  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv232[ebp], eax
	mov	DWORD PTR tv232[ebp+4], ecx
	mov	edx, DWORD PTR tv232[ebp]
	or	edx, DWORD PTR tv232[ebp+4]
	jne	SHORT $LN4@Execute_MU@5

; 187  :   {
; 188  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv242[ebp], eax
	mov	DWORD PTR tv242[ebp+4], ecx
	mov	edx, DWORD PTR tv242[ebp]
	or	edx, DWORD PTR tv242[ebp+4]
	je	SHORT $LN3@Execute_MU@5

; 189  :     {
; 190  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN3@Execute_MU@5:

; 191  :     }
; 192  :   }
; 193  :   else

	jmp	SHORT $LN2@Execute_MU@5
$LN4@Execute_MU@5:

; 194  :   {
; 195  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv255[ebp], eax
	mov	DWORD PTR tv255[ebp+4], ecx
	jne	SHORT $LN9@Execute_MU@5
	cmp	DWORD PTR tv255[ebp+4], -1
	je	SHORT $LN2@Execute_MU@5
$LN9@Execute_MU@5:

; 196  :     {
; 197  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN2@Execute_MU@5:

; 198  :     }
; 199  :   }
; 200  : 
; 201  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 202  : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULScalarShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_MULImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULImmediateShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv249 = -52						; size = 8
tv236 = -44						; size = 8
tv226 = -36						; size = 8
_mul_shift$ = -28					; size = 4
_mulop2$ = -24						; size = 8
_mulop1$ = -16						; size = 8
_result$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULImmediateShiftScalar

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 206  :   int64 result;
; 207  :   int64 mulop1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 208  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 209  :   uint32 mul_shift = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_INFO]] & 0x7FUL;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 127				; 0000007fH
	mov	DWORD PTR _mul_shift$[ebp], ecx

; 210  : 
; 211  :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32));

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 212  : 
; 213  :   if(mul_shift & 0x40)

	mov	edx, DWORD PTR _mul_shift$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN6@Execute_MU@6

; 214  :   {
; 215  :     //ASL
; 216  :     result <<= (128 - mul_shift);

	mov	ecx, 128				; 00000080H
	sub	ecx, DWORD PTR _mul_shift$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 217  :   }
; 218  :   else

	jmp	SHORT $LN5@Execute_MU@6
$LN6@Execute_MU@6:

; 219  :   {
; 220  :     //ASR
; 221  :     result >>= mul_shift;

	mov	eax, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	mov	ecx, DWORD PTR _mul_shift$[ebp]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx
$LN5@Execute_MU@6:

; 222  :   }
; 223  : 
; 224  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 225  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv226[ebp], eax
	mov	DWORD PTR tv226[ebp+4], ecx
	mov	edx, DWORD PTR tv226[ebp]
	or	edx, DWORD PTR tv226[ebp+4]
	jne	SHORT $LN4@Execute_MU@6

; 226  :   {
; 227  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv236[ebp], eax
	mov	DWORD PTR tv236[ebp+4], ecx
	mov	edx, DWORD PTR tv236[ebp]
	or	edx, DWORD PTR tv236[ebp+4]
	je	SHORT $LN3@Execute_MU@6

; 228  :     {
; 229  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN3@Execute_MU@6:

; 230  :     }
; 231  :   }
; 232  :   else

	jmp	SHORT $LN2@Execute_MU@6
$LN4@Execute_MU@6:

; 233  :   {
; 234  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv249[ebp], eax
	mov	DWORD PTR tv249[ebp+4], ecx
	jne	SHORT $LN9@Execute_MU@6
	cmp	DWORD PTR tv249[ebp+4], -1
	je	SHORT $LN2@Execute_MU@6
$LN9@Execute_MU@6:

; 235  :     {
; 236  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN2@Execute_MU@6:

; 237  :     }
; 238  :   }
; 239  : 
; 240  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 241  : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULImmediateShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_MULImmediateShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULImmediateShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv226 = -48						; size = 8
tv213 = -40						; size = 8
tv203 = -32						; size = 8
_result$ = -24						; size = 8
_mulop2$ = -16						; size = 8
_mulop1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULImmediateShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULImmediateShiftRightImmediate

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 245  :   int64 mulop1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 246  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 247  :   int64 result;
; 248  : 
; 249  :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32)) >> nuance.fields[FIELD_MUL_INFO];

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	__allshr
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 250  : 
; 251  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 252  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv203[ebp], edx
	mov	DWORD PTR tv203[ebp+4], eax
	mov	ecx, DWORD PTR tv203[ebp]
	or	ecx, DWORD PTR tv203[ebp+4]
	jne	SHORT $LN4@Execute_MU@7

; 253  :   {
; 254  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv213[ebp], edx
	mov	DWORD PTR tv213[ebp+4], eax
	mov	ecx, DWORD PTR tv213[ebp]
	or	ecx, DWORD PTR tv213[ebp+4]
	je	SHORT $LN3@Execute_MU@7

; 255  :     {
; 256  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_MU@7:

; 257  :     }
; 258  :   }
; 259  :   else

	jmp	SHORT $LN2@Execute_MU@7
$LN4@Execute_MU@7:

; 260  :   {
; 261  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv226[ebp], edx
	mov	DWORD PTR tv226[ebp+4], eax
	jne	SHORT $LN7@Execute_MU@7
	cmp	DWORD PTR tv226[ebp+4], -1
	je	SHORT $LN2@Execute_MU@7
$LN7@Execute_MU@7:

; 262  :     {
; 263  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_MU@7:

; 264  :     }
; 265  :   }
; 266  : 
; 267  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 268  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULImmediateShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULImmediateShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_MULImmediateShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MULImmediateShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv226 = -48						; size = 8
tv213 = -40						; size = 8
tv203 = -32						; size = 8
_result$ = -24						; size = 8
_mulop2$ = -16						; size = 8
_mulop1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MULImmediateShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MULImmediateShiftLeftImmediate

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 272  :   int64 mulop1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _mulop1$[ebp], ecx
	mov	DWORD PTR _mulop1$[ebp+4], edx

; 273  :   int64 mulop2 = (entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _mulop2$[ebp], ecx
	mov	DWORD PTR _mulop2$[ebp+4], edx

; 274  :   int64 result;
; 275  : 
; 276  :   result = (((mulop1 << 32) >> 32) * ((mulop2 << 32) >> 32)) << nuance.fields[FIELD_MUL_INFO];

	mov	eax, DWORD PTR _mulop1$[ebp]
	mov	edx, DWORD PTR _mulop1$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR _mulop2$[ebp]
	mov	edx, DWORD PTR _mulop2$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__allshl
	mov	cl, 32					; 00000020H
	call	__allshr
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	__allshl
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], edx

; 277  : 
; 278  :   mpe.cc &= (~CC_MUL_OVERFLOW);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 279  :   if((result & 0x0000000080000000i64) == 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv203[ebp], edx
	mov	DWORD PTR tv203[ebp+4], eax
	mov	ecx, DWORD PTR tv203[ebp]
	or	ecx, DWORD PTR tv203[ebp+4]
	jne	SHORT $LN4@Execute_MU@8

; 280  :   {
; 281  :     if((result & 0xFFFFFFFF00000000i64) != 0i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv213[ebp], edx
	mov	DWORD PTR tv213[ebp+4], eax
	mov	ecx, DWORD PTR tv213[ebp]
	or	ecx, DWORD PTR tv213[ebp+4]
	je	SHORT $LN3@Execute_MU@8

; 282  :     {
; 283  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN3@Execute_MU@8:

; 284  :     }
; 285  :   }
; 286  :   else

	jmp	SHORT $LN2@Execute_MU@8
$LN4@Execute_MU@8:

; 287  :   {
; 288  :     if((result & 0xFFFFFFFF00000000i64) != 0xFFFFFFFF00000000i64)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	mov	DWORD PTR tv226[ebp], edx
	mov	DWORD PTR tv226[ebp+4], eax
	jne	SHORT $LN7@Execute_MU@8
	cmp	DWORD PTR tv226[ebp+4], -1
	je	SHORT $LN2@Execute_MU@8
$LN7@Execute_MU@8:

; 289  :     {
; 290  :       mpe.cc |= CC_MUL_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_MU@8:

; 291  :     }
; 292  :   }
; 293  : 
; 294  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 295  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MULImmediateShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MULImmediateShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVImmediateShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVImmediateShiftImmediate

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 299  :   int32 scalar, src2, dest, shift;
; 300  : 
; 301  :   scalar = ((int32)(nuance.fields[FIELD_MUL_SRC1])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 302  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 303  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 304  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 305  : 
; 306  : //Execute
; 307  : 
; 308  :   mpe.regs[dest] =
; 309  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 310  :   mpe.regs[dest + 1] =
; 311  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 312  :   mpe.regs[dest + 2] =
; 313  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 314  :   mpe.regs[dest + 3] =
; 315  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVImmediateShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVScalarShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVScalarShiftImmediate

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 320  :   int32 scalar, src2, dest, shift;
; 321  : 
; 322  :   scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 323  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 324  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 325  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 326  : 
; 327  : //Execute
; 328  : 
; 329  :   mpe.regs[dest] =
; 330  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 331  :   mpe.regs[dest + 1] =
; 332  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 333  :   mpe.regs[dest + 2] =
; 334  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 335  :   mpe.regs[dest + 3] =
; 336  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVScalarShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVScalarShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVScalarShiftSvshift

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 341  :   int32 scalar, src2, dest, shift;
; 342  : 
; 343  :   scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 344  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 345  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 346  :   shift = shiftTable[*(entry.pSvshift)];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _shiftTable[edx*4]
	mov	DWORD PTR _shift$[ebp], eax

; 347  : 
; 348  : //Execute
; 349  : 
; 350  :   mpe.regs[dest] =
; 351  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 352  :   mpe.regs[dest + 1] =
; 353  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 354  :   mpe.regs[dest + 2] =
; 355  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 356  :   mpe.regs[dest + 3] =
; 357  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 358  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVScalarShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVRuShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVRuShiftImmediate

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 361  :   int32 scalar, src2, dest, shift;
; 362  : 
; 363  :   //? scalar = (int32)(entry.pIndexRegs[2] >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;
; 364  :   scalar = (((int32)(entry.pIndexRegs[2])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 365  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 366  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 367  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	mov	DWORD PTR _shift$[ebp], ecx

; 368  : 
; 369  : //Execute
; 370  : 
; 371  :   mpe.regs[dest] =
; 372  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 373  :   mpe.regs[dest + 1] =
; 374  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 375  :   mpe.regs[dest + 2] =
; 376  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 377  :   mpe.regs[dest + 3] =
; 378  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVRuShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVRuShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVRuShiftSvshift

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 382  :   int32 scalar, src2, dest, shift;
; 383  : 
; 384  :   scalar = (((int32)(entry.pIndexRegs[2])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 385  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 386  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 387  :   shift = shiftTable[*(entry.pSvshift)];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 388  : 
; 389  : //Execute
; 390  : 
; 391  :   mpe.regs[dest] =
; 392  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 393  :   mpe.regs[dest + 1] =
; 394  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 395  :   mpe.regs[dest + 2] =
; 396  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 397  :   mpe.regs[dest + 3] =
; 398  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVRuShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVRvShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVRvShiftImmediate

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 402  :   int32 scalar, src2, dest, shift;
; 403  : 
; 404  :   scalar = (((int32)(entry.pIndexRegs[3])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 405  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 406  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 407  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	mov	DWORD PTR _shift$[ebp], ecx

; 408  : 
; 409  : //Execute
; 410  : 
; 411  :   mpe.regs[dest] =
; 412  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 413  :   mpe.regs[dest + 1] =
; 414  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 415  :   mpe.regs[dest + 2] =
; 416  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 417  :   mpe.regs[dest + 3] =
; 418  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 419  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVRvShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVRvShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVRvShiftSvshift

; 421  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 422  :   int32 scalar, src2, dest, shift;
; 423  : 
; 424  :   scalar = (((int32)(entry.pIndexRegs[3])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 425  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 426  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 427  :   shift = shiftTable[*(entry.pSvshift)];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 428  : 
; 429  : //Execute
; 430  : 
; 431  :   mpe.regs[dest] =
; 432  :     (scalar * ((int32)((entry.pScalarRegs)[src2 + 0]) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 433  :   mpe.regs[dest + 1] =
; 434  :     (scalar * ((int32)((entry.pScalarRegs)[src2 + 1]) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 435  :   mpe.regs[dest + 2] =
; 436  :     (scalar * ((int32)((entry.pScalarRegs)[src2 + 2]) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 437  :   mpe.regs[dest + 3] =
; 438  :     (scalar * ((int32)((entry.pScalarRegs)[src2 + 3]) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 439  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_SVRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVRvShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVVectorShiftImmediate
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_src1_vector$ = -32					; size = 16
_src2$ = -12						; size = 4
_src1$ = -8						; size = 4
_shift$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVVectorShiftImmediate

; 441  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 442  :   int32 shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 443  :   uint32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 444  :   uint32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 445  :   int32 src1_vector[4];
; 446  : 
; 447  :   src1_vector[0] = ((int32)(entry.pScalarRegs[src1])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], ecx

; 448  :   src1_vector[1] = ((int32)(entry.pScalarRegs[src1 + 1])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], edx

; 449  :   src1_vector[2] = ((int32)(entry.pScalarRegs[src1 + 2])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], eax

; 450  :   src1_vector[3] = ((int32)(entry.pScalarRegs[src1 + 3])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+12], ecx

; 451  : 
; 452  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 453  :     (src1_vector[0] * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 454  :   mpe.regs[nuance.fields[FIELD_MUL_DEST] + 1] =
; 455  :     (src1_vector[1] * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _src1_vector$[ebp+4]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 456  :   mpe.regs[nuance.fields[FIELD_MUL_DEST] + 2] =
; 457  :     (src1_vector[2] * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _src1_vector$[ebp+8]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 458  :   mpe.regs[nuance.fields[FIELD_MUL_DEST] + 3] =
; 459  :     (src1_vector[3] * (((int32)(entry.pScalarRegs[src2 + 3])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _src1_vector$[ebp+12]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4+12], edx

; 460  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_MU@9
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Execute_MU@9:
	DD	1
	DD	$LN4@Execute_MU@9
$LN4@Execute_MU@9:
	DD	-32					; ffffffe0H
	DD	16					; 00000010H
	DD	$LN3@Execute_MU@9
$LN3@Execute_MU@9:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_MUL_SVVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVVectorShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_SVVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_SVVectorShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_src1_vector$ = -36					; size = 16
_dest$ = -16						; size = 4
_src2$ = -12						; size = 4
_src1$ = -8						; size = 4
_shift$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_SVVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_SVVectorShiftSvshift

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 463  :   int32 shift = shiftTable[*entry.pSvshift & 0x03UL];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	and	edx, 3
	mov	eax, DWORD PTR _shiftTable[edx*4]
	mov	DWORD PTR _shift$[ebp], eax

; 464  :   uint32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _src1$[ebp], edx

; 465  :   uint32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _src2$[ebp], ecx

; 466  :   uint32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _dest$[ebp], eax

; 467  :   int32 src1_vector[4];
; 468  : 
; 469  :   src1_vector[0] = ((int32)(entry.pScalarRegs[src1])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], ecx

; 470  :   src1_vector[1] = ((int32)(entry.pScalarRegs[src1 + 1])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], edx

; 471  :   src1_vector[2] = ((int32)(entry.pScalarRegs[src1 + 2])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], eax

; 472  :   src1_vector[3] = ((int32)(entry.pScalarRegs[src1 + 3])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+12], ecx

; 473  : 
; 474  :   mpe.regs[dest] =
; 475  :     (src1_vector[0] * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 476  :   mpe.regs[dest + 1] =
; 477  :     (src1_vector[1] * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+4]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 478  :   mpe.regs[dest + 2] =
; 479  :     (src1_vector[2] * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+8]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 480  :   mpe.regs[dest + 3] =
; 481  :     (src1_vector[3] * (((int32)(entry.pScalarRegs[src2 + 3])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+12]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 482  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_MU@10
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_MU@10:
	DD	1
	DD	$LN4@Execute_MU@10
$LN4@Execute_MU@10:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN3@Execute_MU@10
$LN3@Execute_MU@10:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_MUL_SVVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_SVVectorShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_PImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PImmediateShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PImmediateShiftImmediate

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 486  :   int32 scalar, src2, dest, shift;
; 487  : 
; 488  :   scalar = ((int32)(nuance.fields[FIELD_MUL_SRC1])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 489  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 490  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 491  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 492  : 
; 493  : //Execute
; 494  : 
; 495  :   mpe.regs[dest] =
; 496  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 497  :   mpe.regs[dest + 1] =
; 498  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 499  :   mpe.regs[dest + 2] =
; 500  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 501  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PImmediateShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PImmediateShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_PScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PScalarShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PScalarShiftImmediate

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 505  :   int32 scalar, src2, dest, shift;
; 506  : 
; 507  :   scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 508  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 509  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 510  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 511  : 
; 512  : //Execute
; 513  : 
; 514  :   mpe.regs[dest] =
; 515  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 516  :   mpe.regs[dest + 1] =
; 517  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 518  :   mpe.regs[dest + 2] =
; 519  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 520  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PScalarShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_PScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PScalarShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PScalarShiftSvshift

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 523  :   int32 scalar, src2, dest, shift;
; 524  : 
; 525  :   scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 526  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 527  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 528  :   shift = shiftTable[*(entry.pSvshift)];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _shiftTable[edx*4]
	mov	DWORD PTR _shift$[ebp], eax

; 529  : 
; 530  : //Execute
; 531  : 
; 532  :   mpe.regs[dest] =
; 533  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 534  :   mpe.regs[dest + 1] =
; 535  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 536  :   mpe.regs[dest + 2] =
; 537  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 538  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PScalarShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_PRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PRuShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PRuShiftImmediate

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 541  :   int32 scalar, src2, dest, shift;
; 542  : 
; 543  :   scalar = (((int32)(entry.pIndexRegs[2])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 544  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 545  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 546  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	mov	DWORD PTR _shift$[ebp], ecx

; 547  : 
; 548  : //Execute
; 549  : 
; 550  :   mpe.regs[dest] =
; 551  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 552  :   mpe.regs[dest + 1] =
; 553  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 554  :   mpe.regs[dest + 2] =
; 555  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 556  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PRuShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PRuShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_PRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PRuShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PRuShiftSvshift

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 559  :   int32 scalar, src2, dest, shift;
; 560  : 
; 561  :   scalar = (((int32)(entry.pIndexRegs[2])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 562  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 563  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 564  :   shift = shiftTable[*(entry.pSvshift)];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 565  : 
; 566  : //Execute
; 567  : 
; 568  :   mpe.regs[dest] =
; 569  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 570  :   mpe.regs[dest + 1] =
; 571  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 572  :   mpe.regs[dest + 2] =
; 573  :     (scalar * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 574  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PRuShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PRuShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_PRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PRvShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PRvShiftImmediate

; 576  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 577  :   int32 scalar, src2, dest, shift;
; 578  : 
; 579  :   scalar = (((int32)(entry.pIndexRegs[3])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 580  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 581  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 582  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	mov	DWORD PTR _shift$[ebp], ecx

; 583  : 
; 584  :   mpe.regs[dest] =
; 585  :     (scalar * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 586  :   mpe.regs[dest + 1] =
; 587  :     (scalar * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 588  :   mpe.regs[dest + 2] =
; 589  :     (scalar * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 590  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PRvShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PRvShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_PRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PRvShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -16						; size = 4
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PRvShiftSvshift

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 594  :   int32 scalar, src2, dest, shift;
; 595  : 
; 596  :   scalar = (((int32)(entry.pIndexRegs[3])) >> (2 + BilinearInfo_XYMipmap(*entry.pUvctl))) & 0x3FFFUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	edx, DWORD PTR [eax]
	shr	edx, 24					; 00000018H
	and	edx, 7
	add	edx, 2
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, edx
	sar	eax, cl
	and	eax, 16383				; 00003fffH
	mov	DWORD PTR _scalar$[ebp], eax

; 597  :   src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 598  :   dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 599  :   shift = shiftTable[*(entry.pSvshift)];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 600  : 
; 601  : //Execute
; 602  : 
; 603  :   mpe.regs[dest] =
; 604  :     (scalar * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 605  :   mpe.regs[dest + 1] =
; 606  :     (scalar * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 607  :   mpe.regs[dest + 2] =
; 608  :     (scalar * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 609  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MUL_PRvShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PRvShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_MUL_PVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PVectorShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_shift$ = -36						; size = 4
_dest$ = -32						; size = 4
_src2$ = -28						; size = 4
_src1$ = -24						; size = 4
_src1_vector$ = -16					; size = 12
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PVectorShiftImmediate

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 612  :   int32 src1_vector[3];
; 613  :   uint32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 614  :   uint32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 615  :   uint32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 616  :   uint32 shift;
; 617  : 
; 618  :   src1_vector[0] = ((int32)((entry.pScalarRegs)[src1])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], eax

; 619  :   src1_vector[1] = ((int32)((entry.pScalarRegs)[src1 + 1])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], ecx

; 620  :   src1_vector[2] = ((int32)((entry.pScalarRegs)[src1 + 2])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], edx

; 621  :   shift = shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _shiftTable[ecx*4]
	mov	DWORD PTR _shift$[ebp], edx

; 622  : //Execute
; 623  : 
; 624  :   mpe.regs[dest] =
; 625  :     (src1_vector[0] * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 626  :   mpe.regs[dest + 1] =
; 627  :     (src1_vector[1] * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp+4]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 628  :   mpe.regs[dest + 2] =
; 629  :     (src1_vector[2] * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp+8]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 630  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_MU@11
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_MU@11:
	DD	1
	DD	$LN4@Execute_MU@11
$LN4@Execute_MU@11:
	DD	-16					; fffffff0H
	DD	12					; 0000000cH
	DD	$LN3@Execute_MU@11
$LN3@Execute_MU@11:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_MUL_PVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PVectorShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_MUL_PVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MUL_PVectorShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -36						; size = 4
_src2$ = -32						; size = 4
_src1$ = -28						; size = 4
_src1_vector$ = -20					; size = 12
_shift$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MUL_PVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MUL_PVectorShiftSvshift

; 632  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 633  :   uint32 shift;
; 634  :   int32 src1_vector[3];
; 635  :   uint32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 636  :   uint32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 637  :   uint32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 638  : 
; 639  :   src1_vector[0] = ((int32)((entry.pScalarRegs)[src1])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], eax

; 640  :   src1_vector[1] = ((int32)((entry.pScalarRegs)[src1 + 1])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], ecx

; 641  :   src1_vector[2] = ((int32)((entry.pScalarRegs)[src1 + 2])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], edx

; 642  :   shift = shiftTable[*(entry.pSvshift)];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _shiftTable[edx*4]
	mov	DWORD PTR _shift$[ebp], eax

; 643  : //Execute
; 644  : 
; 645  :   mpe.regs[dest] =
; 646  :     (src1_vector[0] * (((int32)(entry.pScalarRegs[src2])) >> 16)) << shift;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	mov	edx, ecx
	imul	edx, DWORD PTR _src1_vector$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 647  :   mpe.regs[dest + 1] =
; 648  :     (src1_vector[1] * (((int32)(entry.pScalarRegs[src2 + 1])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+4]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 649  :   mpe.regs[dest + 2] =
; 650  :     (src1_vector[2] * (((int32)(entry.pScalarRegs[src2 + 2])) >> 16)) << shift;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+8]
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 651  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_MU@12
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_MU@12:
	DD	1
	DD	$LN4@Execute_MU@12
$LN4@Execute_MU@12:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN3@Execute_MU@12
$LN3@Execute_MU@12:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_MUL_PVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MUL_PVectorShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_DOTPScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DOTPScalarShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -36						; size = 4
_src2$ = -32						; size = 4
_scalar$ = -28						; size = 4
_products$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DOTPScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DOTPScalarShiftImmediate

; 653  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 654  :   int32 products[4];
; 655  :   int32 scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 656  :   int32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 657  :   uint32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 658  : 
; 659  :   products[0] =
; 660  :     (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16) * scalar;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp], eax

; 661  :   products[1] =
; 662  :     (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16) * scalar;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+4], ecx

; 663  :   products[2] =
; 664  :     (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16) * scalar;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+8], edx

; 665  :   products[3] =
; 666  :     (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16) * scalar;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+12], eax

; 667  : 
; 668  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 669  :     (products[0] + products[1] + products[2] + products[3]) << shiftTable[nuance.fields[FIELD_MUL_INFO]];

	mov	edx, DWORD PTR _products$[ebp]
	add	edx, DWORD PTR _products$[ebp+4]
	add	edx, DWORD PTR _products$[ebp+8]
	add	edx, DWORD PTR _products$[ebp+12]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _shiftTable[ecx*4]
	shl	edx, cl
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 670  : 
; 671  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_DO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Execute_DO:
	DD	1
	DD	$LN4@Execute_DO
$LN4@Execute_DO:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_DO
$LN3@Execute_DO:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Execute_DOTPScalarShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DOTPScalarShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_DOTPScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DOTPScalarShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_products$ = -28					; size = 16
_src2$ = -8						; size = 4
_scalar$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DOTPScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DOTPScalarShiftSvshift

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 674  :   int32 scalar = ((int32)((entry.pScalarRegs)[nuance.fields[FIELD_MUL_SRC1]])) >> 16;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _scalar$[ebp], ecx

; 675  :   int32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 676  :   int32 products[4];
; 677  : 
; 678  :   products[0] =
; 679  :     (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16) * scalar;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp], ecx

; 680  :   products[1] =
; 681  :     (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16) * scalar;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+4], edx

; 682  :   products[2] =
; 683  :     (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16) * scalar;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+8], eax

; 684  :   products[3] =
; 685  :     (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16) * scalar;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _scalar$[ebp]
	mov	DWORD PTR _products$[ebp+12], ecx

; 686  : 
; 687  :   mpe.regs[nuance.fields[FIELD_MUL_DEST]] =
; 688  :     (products[0] + products[1] + products[2] + products[3]) << shiftTable[*(entry.pSvshift)];

	mov	edx, DWORD PTR _products$[ebp]
	add	edx, DWORD PTR _products$[ebp+4]
	add	edx, DWORD PTR _products$[ebp+8]
	add	edx, DWORD PTR _products$[ebp+12]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	shl	edx, cl
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 689  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_DO@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_DO@2:
	DD	1
	DD	$LN4@Execute_DO@2
$LN4@Execute_DO@2:
	DD	-28					; ffffffe4H
	DD	16					; 00000010H
	DD	$LN3@Execute_DO@2
$LN3@Execute_DO@2:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Execute_DOTPScalarShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DOTPScalarShiftSvshift
_TEXT	ENDS
PUBLIC	?Execute_DOTPVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DOTPVectorShiftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_products$ = -60					; size = 16
_src1_vector$ = -36					; size = 16
_dest$ = -16						; size = 4
_src2$ = -12						; size = 4
_src1$ = -8						; size = 4
_shiftVal$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DOTPVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DOTPVectorShiftImmediate

; 691  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 692  :   uint32 shiftVal = nuance.fields[FIELD_MUL_INFO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _shiftVal$[ebp], ecx

; 693  :   int32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _src1$[ebp], eax

; 694  :   int32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _src2$[ebp], edx

; 695  :   int32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 696  :   int32 src1_vector[4];
; 697  :   int32 products[4];
; 698  : 
; 699  :   src1_vector[0] = ((int32)((entry.pScalarRegs)[src1 + 0])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], edx

; 700  :   src1_vector[1] = ((int32)((entry.pScalarRegs)[src1 + 1])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], eax

; 701  :   src1_vector[2] = ((int32)((entry.pScalarRegs)[src1 + 2])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], ecx

; 702  :   src1_vector[3] = ((int32)((entry.pScalarRegs)[src1 + 3])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+12]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+12], edx

; 703  : 
; 704  :   products[0] =
; 705  :     (src1_vector[0] * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16));

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp]
	mov	DWORD PTR _products$[ebp], eax

; 706  :   products[1] =
; 707  :     (src1_vector[1] * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _src1_vector$[ebp+4]
	mov	DWORD PTR _products$[ebp+4], ecx

; 708  :   products[2] =
; 709  :     (src1_vector[2] * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16));

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+8]
	mov	DWORD PTR _products$[ebp+8], edx

; 710  :   products[3] =
; 711  :     (src1_vector[3] * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16));

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp+12]
	mov	DWORD PTR _products$[ebp+12], eax

; 712  : 
; 713  :   mpe.regs[dest] = (products[0] + products[1] + products[2] + products[3]) << shiftTable[shiftVal];

	mov	edx, DWORD PTR _products$[ebp]
	add	edx, DWORD PTR _products$[ebp+4]
	add	edx, DWORD PTR _products$[ebp+8]
	add	edx, DWORD PTR _products$[ebp+12]
	mov	eax, DWORD PTR _shiftVal$[ebp]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	shl	edx, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 714  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_DO@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_DO@3:
	DD	2
	DD	$LN5@Execute_DO@3
$LN5@Execute_DO@3:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN3@Execute_DO@3
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN4@Execute_DO@3
$LN4@Execute_DO@3:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_DO@3:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_DOTPVectorShiftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DOTPVectorShiftImmediate
_TEXT	ENDS
PUBLIC	?Execute_DOTPVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_DOTPVectorShiftSvshift
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -64						; size = 4
_src2$ = -60						; size = 4
_src1$ = -56						; size = 4
_shiftVal$ = -52					; size = 4
_products$ = -44					; size = 16
_src1_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_DOTPVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_DOTPVectorShiftSvshift

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 717  :   int32 src1_vector[4];
; 718  :   int32 products[4];
; 719  :   uint32 shiftVal = *(entry.pSvshift);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _shiftVal$[ebp], edx

; 720  :   int32 src1 = nuance.fields[FIELD_MUL_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 721  :   int32 src2 = nuance.fields[FIELD_MUL_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 722  :   int32 dest = nuance.fields[FIELD_MUL_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 723  : 
; 724  :   src1_vector[0] = ((int32)((entry.pScalarRegs)[src1 + 0])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp], eax

; 725  :   src1_vector[1] = ((int32)((entry.pScalarRegs)[src1 + 1])) >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	sar	ecx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+4], ecx

; 726  :   src1_vector[2] = ((int32)((entry.pScalarRegs)[src1 + 2])) >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	sar	edx, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+8], edx

; 727  :   src1_vector[3] = ((int32)((entry.pScalarRegs)[src1 + 3])) >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _src1_vector$[ebp+12], eax

; 728  : 
; 729  :   products[0] =
; 730  :     (src1_vector[0] * (((int32)((entry.pScalarRegs)[src2 + 0])) >> 16));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _src1_vector$[ebp]
	mov	DWORD PTR _products$[ebp], ecx

; 731  :   products[1] =
; 732  :     (src1_vector[1] * (((int32)((entry.pScalarRegs)[src2 + 1])) >> 16));

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	sar	edx, 16					; 00000010H
	imul	edx, DWORD PTR _src1_vector$[ebp+4]
	mov	DWORD PTR _products$[ebp+4], edx

; 733  :   products[2] =
; 734  :     (src1_vector[2] * (((int32)((entry.pScalarRegs)[src2 + 2])) >> 16));

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _src1_vector$[ebp+8]
	mov	DWORD PTR _products$[ebp+8], eax

; 735  :   products[3] =
; 736  :     (src1_vector[3] * (((int32)((entry.pScalarRegs)[src2 + 3])) >> 16));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	sar	ecx, 16					; 00000010H
	imul	ecx, DWORD PTR _src1_vector$[ebp+12]
	mov	DWORD PTR _products$[ebp+12], ecx

; 737  : 
; 738  :   mpe.regs[dest] = (products[0] + products[1] + products[2] + products[3]) << shiftTable[shiftVal];

	mov	edx, DWORD PTR _products$[ebp]
	add	edx, DWORD PTR _products$[ebp+4]
	add	edx, DWORD PTR _products$[ebp+8]
	add	edx, DWORD PTR _products$[ebp+12]
	mov	eax, DWORD PTR _shiftVal$[ebp]
	mov	ecx, DWORD PTR _shiftTable[eax*4]
	shl	edx, cl
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 739  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_DO@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@Execute_DO@4:
	DD	2
	DD	$LN5@Execute_DO@4
$LN5@Execute_DO@4:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_DO@4
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$LN4@Execute_DO@4
$LN4@Execute_DO@4:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_DO@4:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_DOTPVectorShiftSvshift@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_DOTPVectorShiftSvshift
_TEXT	ENDS
END
