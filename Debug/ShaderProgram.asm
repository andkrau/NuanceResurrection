; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ShaderProgram.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG66506 DB	'Error', 00H
	ORG $+2
$SG66507 DB	'OpenGLShader could not allocate InfoLog buffer', 00H
	ORG $+1
$SG66520 DB	'rb', 00H
	ORG $+1
$SG66602 DB	'Fragment Shader Compile Error', 00H
	ORG $+2
$SG66605 DB	'Vertex Shader Compile Error', 00H
$SG66607 DB	'Shader Program Link Error', 00H
CONST	ENDS
PUBLIC	??0ShaderProgram@@QAE@XZ			; ShaderProgram::ShaderProgram
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\shaderprogram.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ShaderProgram@@QAE@XZ PROC				; ShaderProgram::ShaderProgram
; _this$ = ecx

; 7    : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 8    :   hProgramObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 9    :   hVertexShaderObject = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 10   :   hFragmentShaderObject = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 11   :   bVertexShaderObjectAttached = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+12], 0

; 12   :   bVertexShaderCodeLoaded = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+14], 0

; 13   :   bFragmentShaderObjectAttached = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+13], 0

; 14   :   bFragmentShaderCodeLoaded = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+15], 0

; 15   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ShaderProgram@@QAE@XZ ENDP				; ShaderProgram::ShaderProgram
_TEXT	ENDS
PUBLIC	?Uninitalize@ShaderProgram@@QAE_NXZ		; ShaderProgram::Uninitalize
PUBLIC	??1ShaderProgram@@QAE@XZ			; ShaderProgram::~ShaderProgram
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ShaderProgram@@QAE@XZ PROC				; ShaderProgram::~ShaderProgram
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 19   :   Uninitalize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninitalize@ShaderProgram@@QAE_NXZ	; ShaderProgram::Uninitalize

; 20   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1ShaderProgram@@QAE@XZ ENDP				; ShaderProgram::~ShaderProgram
_TEXT	ENDS
PUBLIC	?Initialize@ShaderProgram@@QAE_NXZ		; ShaderProgram::Initialize
EXTRN	__imp____glewCreateShaderObjectARB:DWORD
EXTRN	__imp____glewCreateProgramObjectARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@ShaderProgram@@QAE_NXZ PROC			; ShaderProgram::Initialize
; _this$ = ecx

; 23   : {  

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 24   :   if(!hProgramObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Initialize

; 25   :   {
; 26   :     hProgramObject = glCreateProgramObjectARB();

	mov	ecx, DWORD PTR __imp____glewCreateProgramObjectARB
	mov	esi, esp
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 27   :     if(!hProgramObject)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN1@Initialize

; 28   :     {
; 29   :       return false;

	xor	al, al
	jmp	SHORT $LN3@Initialize
$LN1@Initialize:

; 30   :     }
; 31   : 
; 32   :     hVertexShaderObject = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);

	mov	esi, esp
	push	35633					; 00008b31H
	mov	eax, DWORD PTR __imp____glewCreateShaderObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 33   :     hFragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

	mov	esi, esp
	push	35632					; 00008b30H
	mov	eax, DWORD PTR __imp____glewCreateShaderObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN2@Initialize:

; 34   :   }
; 35   : 
; 36   :   return true;

	mov	al, 1
$LN3@Initialize:

; 37   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Initialize@ShaderProgram@@QAE_NXZ ENDP			; ShaderProgram::Initialize
_TEXT	ENDS
EXTRN	__imp____glewDeleteObjectARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninitalize@ShaderProgram@@QAE_NXZ PROC		; ShaderProgram::Uninitalize
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 41   :   if(hProgramObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$LN3@Uninitaliz

; 42   :   {
; 43   :     if(hVertexShaderObject)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@Uninitaliz

; 44   :     {
; 45   :       glDeleteObjectARB(hVertexShaderObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp____glewDeleteObjectARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Uninitaliz:

; 46   :     }
; 47   : 
; 48   :     if(hVertexShaderObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Uninitaliz

; 49   :     {
; 50   :       glDeleteObjectARB(hVertexShaderObject);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __imp____glewDeleteObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Uninitaliz:

; 51   :     }
; 52   : 
; 53   :     glDeleteObjectARB(hProgramObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __imp____glewDeleteObjectARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 54   :     hProgramObject = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 55   :     hVertexShaderObject = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 56   :     hFragmentShaderObject = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 57   :     bVertexShaderObjectAttached = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+12], 0

; 58   :     bFragmentShaderObjectAttached = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], 0
$LN3@Uninitaliz:

; 59   :   }
; 60   : 
; 61   :   return true;

	mov	al, 1

; 62   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Uninitalize@ShaderProgram@@QAE_NXZ ENDP		; ShaderProgram::Uninitalize
_TEXT	ENDS
PUBLIC	?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z		; ShaderProgram::PrintInfoLog
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp____glewGetInfoLogARB:DWORD
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp____glewGetObjectParameterivARB:DWORD
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T66647 = -40						; size = 4
$T66646 = -36						; size = 4
_infoLog$ = -32						; size = 4
_slen$ = -24						; size = 4
_blen$ = -12						; size = 4
_this$ = -4						; size = 4
_obj$ = 8						; size = 4
_msg$ = 12						; size = 4
?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z PROC		; ShaderProgram::PrintInfoLog
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :   int32 blen = 0;   /* length of buffer to allocate */

	mov	DWORD PTR _blen$[ebp], 0

; 67   :   int32 slen = 0;   /* strlen actually written to buffer */

	mov	DWORD PTR _slen$[ebp], 0

; 68   :   GLcharARB *infoLog;
; 69   :   glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB , &blen);

	mov	esi, esp
	lea	eax, DWORD PTR _blen$[ebp]
	push	eax
	push	35716					; 00008b84H
	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 70   :   if(blen > 1)

	cmp	DWORD PTR _blen$[ebp], 1
	jle	$LN3@PrintInfoL

; 71   :   {
; 72   :     if((infoLog = new GLcharARB[blen]) == 0) 

	mov	ecx, DWORD PTR _blen$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T66646[ebp], eax
	mov	edx, DWORD PTR $T66646[ebp]
	mov	DWORD PTR _infoLog$[ebp], edx
	cmp	DWORD PTR _infoLog$[ebp], 0
	jne	SHORT $LN1@PrintInfoL

; 73   :     {
; 74   :       MessageBox(NULL,"OpenGLShader could not allocate InfoLog buffer","Error",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG66506
	push	OFFSET $SG66507
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 75   :       return;

	jmp	SHORT $LN3@PrintInfoL
$LN1@PrintInfoL:

; 76   :     }
; 77   :     glGetInfoLogARB(obj, blen, &slen, infoLog);

	mov	esi, esp
	mov	eax, DWORD PTR _infoLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _slen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blen$[ebp]
	push	edx
	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetInfoLogARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 78   :     MessageBox(NULL,infoLog,msg,MB_OK);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _infoLog$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 79   :     delete [] infoLog;

	mov	edx, DWORD PTR _infoLog$[ebp]
	mov	DWORD PTR $T66647[ebp], edx
	mov	eax, DWORD PTR $T66647[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@PrintInfoL:

; 80   :  }
; 81   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@PrintInfoL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@PrintInfoL:
	DD	2
	DD	$LN7@PrintInfoL
$LN7@PrintInfoL:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN5@PrintInfoL
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN6@PrintInfoL
$LN6@PrintInfoL:
	DB	115					; 00000073H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN5@PrintInfoL:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z ENDP		; ShaderProgram::PrintInfoLog
_TEXT	ENDS
PUBLIC	?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z ; ShaderProgram::InstallShaderSourceFromFile
EXTRN	__imp____glewShaderSourceARB:DWORD
EXTRN	_fread:PROC
EXTRN	_ftell:PROC
EXTRN	_fseek:PROC
EXTRN	_fopen:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T66655 = -48						; size = 4
$T66654 = -44						; size = 4
_bStatus$ = -37						; size = 1
_pBuffer$ = -36						; size = 4
_buffer$ = -28						; size = 4
_length$ = -16						; size = 4
_inFile$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z PROC ; ShaderProgram::InstallShaderSourceFromFile
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   :   FILE *inFile;
; 86   :   GLint length;
; 87   :   GLcharARB *buffer;
; 88   :   const GLcharARB **pBuffer = (const GLcharARB **)(&buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pBuffer$[ebp], eax

; 89   :   bool bStatus = false;

	mov	BYTE PTR _bStatus$[ebp], 0

; 90   : 
; 91   :   inFile = fopen(filename,"rb");

	push	OFFSET $SG66520
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _inFile$[ebp], eax

; 92   : 
; 93   :   if(inFile)

	cmp	DWORD PTR _inFile$[ebp], 0
	je	$LN6@InstallSha

; 94   :   {
; 95   :     fseek(inFile,0,SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _inFile$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 96   :     length = ftell(inFile);

	mov	eax, DWORD PTR _inFile$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 97   : 
; 98   :     buffer = new GLcharARB[length+1];

	mov	ecx, DWORD PTR _length$[ebp]
	add	ecx, 1
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T66654[ebp], eax
	mov	edx, DWORD PTR $T66654[ebp]
	mov	DWORD PTR _buffer$[ebp], edx

; 99   :     buffer[length] = '\0';

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax], 0

; 100  :     fseek(inFile,0,SEEK_SET);

	push	0
	push	0
	mov	ecx, DWORD PTR _inFile$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 101  :     fread(buffer,sizeof(char),length,inFile);

	mov	edx, DWORD PTR _inFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 102  : 
; 103  :     if(type == GL_FRAGMENT_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35632		; 00008b30H
	jne	SHORT $LN5@InstallSha

; 104  :     {
; 105  :       if(hFragmentShaderObject)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN4@InstallSha

; 106  :       {
; 107  :         glShaderSourceARB(hFragmentShaderObject,1,pBuffer,&length);

	mov	esi, esp
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBuffer$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewShaderSourceARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 108  :         bFragmentShaderCodeLoaded = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+15], 1

; 109  :         bStatus = true;

	mov	BYTE PTR _bStatus$[ebp], 1
$LN4@InstallSha:

; 110  :       }
; 111  :     }

	jmp	SHORT $LN3@InstallSha
$LN5@InstallSha:

; 112  :     else if(type == GL_VERTEX_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35633		; 00008b31H
	jne	SHORT $LN3@InstallSha

; 113  :     {
; 114  :       if(hVertexShaderObject)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@InstallSha

; 115  :       {
; 116  :         glShaderSourceARB(hVertexShaderObject,1,pBuffer,NULL);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _pBuffer$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp____glewShaderSourceARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 117  :         bVertexShaderCodeLoaded = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+14], 1

; 118  :         bStatus = true;

	mov	BYTE PTR _bStatus$[ebp], 1
$LN3@InstallSha:

; 119  :       }
; 120  :     }
; 121  : 
; 122  :     delete [] buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR $T66655[ebp], edx
	mov	eax, DWORD PTR $T66655[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@InstallSha:

; 123  :   }
; 124  :   
; 125  :   return bStatus;

	mov	al, BYTE PTR _bStatus$[ebp]

; 126  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@InstallSha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN12@InstallSha:
	DD	2
	DD	$LN11@InstallSha
$LN11@InstallSha:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN9@InstallSha
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN10@InstallSha
$LN10@InstallSha:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN9@InstallSha:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z ENDP ; ShaderProgram::InstallShaderSourceFromFile
_TEXT	ENDS
PUBLIC	?InstallShaderSourceFromMemory@ShaderProgram@@QAE_NPAPADIPBHI@Z ; ShaderProgram::InstallShaderSourceFromMemory
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bStatus$ = -5						; size = 1
_this$ = -4						; size = 4
_sourceStrings$ = 8					; size = 4
_count$ = 12						; size = 4
_lengths$ = 16						; size = 4
_type$ = 20						; size = 4
?InstallShaderSourceFromMemory@ShaderProgram@@QAE_NPAPADIPBHI@Z PROC ; ShaderProgram::InstallShaderSourceFromMemory
; _this$ = ecx

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 130  :   bool bStatus = false;

	mov	BYTE PTR _bStatus$[ebp], 0

; 131  : 
; 132  :   if(type == GL_FRAGMENT_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35632		; 00008b30H
	jne	SHORT $LN5@InstallSha@2

; 133  :   {
; 134  :     if(hFragmentShaderObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@InstallSha@2

; 135  :     {
; 136  :       glShaderSourceARB(hFragmentShaderObject,count,(const char **)sourceStrings,lengths);

	mov	esi, esp
	mov	ecx, DWORD PTR _lengths$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sourceStrings$[ebp]
	push	edx
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewShaderSourceARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 137  :       bFragmentShaderCodeLoaded = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+15], 1

; 138  :       bStatus = true;

	mov	BYTE PTR _bStatus$[ebp], 1
$LN4@InstallSha@2:

; 139  :     }
; 140  :   }

	jmp	SHORT $LN3@InstallSha@2
$LN5@InstallSha@2:

; 141  :   else if(type == GL_VERTEX_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35633		; 00008b31H
	jne	SHORT $LN3@InstallSha@2

; 142  :   {
; 143  :     if(hVertexShaderObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@InstallSha@2

; 144  :     {
; 145  :       glShaderSourceARB(hVertexShaderObject,1,(const char **)sourceStrings,lengths);

	mov	esi, esp
	mov	ecx, DWORD PTR _lengths$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sourceStrings$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp____glewShaderSourceARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 146  :       bVertexShaderCodeLoaded = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+14], 1

; 147  :       bStatus = true;

	mov	BYTE PTR _bStatus$[ebp], 1
$LN3@InstallSha@2:

; 148  :     }
; 149  :   } 
; 150  : 
; 151  :   return bStatus;

	mov	al, BYTE PTR _bStatus$[ebp]

; 152  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?InstallShaderSourceFromMemory@ShaderProgram@@QAE_NPAPADIPBHI@Z ENDP ; ShaderProgram::InstallShaderSourceFromMemory
_TEXT	ENDS
PUBLIC	?CompileShader@ShaderProgram@@QAE_NI@Z		; ShaderProgram::CompileShader
EXTRN	__imp____glewCompileShaderARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bCompiled$ = -16					; size = 4
_bStatus$ = -5						; size = 1
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?CompileShader@ShaderProgram@@QAE_NI@Z PROC		; ShaderProgram::CompileShader
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 156  :   bool bStatus = false;

	mov	BYTE PTR _bStatus$[ebp], 0

; 157  :   GLint bCompiled = GL_FALSE;

	mov	DWORD PTR _bCompiled$[ebp], 0

; 158  : 
; 159  :   if(type == GL_FRAGMENT_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35632		; 00008b30H
	jne	SHORT $LN5@CompileSha

; 160  :   {
; 161  :     if(hFragmentShaderObject && bFragmentShaderCodeLoaded)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@CompileSha
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+15]
	test	edx, edx
	je	SHORT $LN4@CompileSha

; 162  :     {
; 163  :       glCompileShaderARB(hFragmentShaderObject);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __imp____glewCompileShaderARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 164  :       glGetObjectParameterivARB(hFragmentShaderObject, GL_OBJECT_COMPILE_STATUS_ARB, &bCompiled);

	mov	esi, esp
	lea	ecx, DWORD PTR _bCompiled$[ebp]
	push	ecx
	push	35713					; 00008b81H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 165  :       bStatus = bCompiled;

	cmp	DWORD PTR _bCompiled$[ebp], 0
	setne	al
	mov	BYTE PTR _bStatus$[ebp], al
$LN4@CompileSha:

; 166  :     }
; 167  :   }

	jmp	SHORT $LN3@CompileSha
$LN5@CompileSha:

; 168  :   else if(type == GL_VERTEX_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35633		; 00008b31H
	jne	SHORT $LN3@CompileSha

; 169  :   {
; 170  :     if(hVertexShaderObject && bVertexShaderCodeLoaded)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@CompileSha
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	test	eax, eax
	je	SHORT $LN3@CompileSha

; 171  :     {
; 172  :       glCompileShaderARB(hVertexShaderObject);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __imp____glewCompileShaderARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 173  :       glGetObjectParameterivARB(hVertexShaderObject, GL_OBJECT_COMPILE_STATUS_ARB, &bCompiled);

	mov	esi, esp
	lea	edx, DWORD PTR _bCompiled$[ebp]
	push	edx
	push	35713					; 00008b81H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 174  :       bStatus = bCompiled;

	cmp	DWORD PTR _bCompiled$[ebp], 0
	setne	cl
	mov	BYTE PTR _bStatus$[ebp], cl
$LN3@CompileSha:

; 175  :     }
; 176  :   }
; 177  : 
; 178  :   return bStatus;

	mov	al, BYTE PTR _bStatus$[ebp]

; 179  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@CompileSha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@CompileSha:
	DD	1
	DD	$LN9@CompileSha
$LN9@CompileSha:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN8@CompileSha
$LN8@CompileSha:
	DB	98					; 00000062H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?CompileShader@ShaderProgram@@QAE_NI@Z ENDP		; ShaderProgram::CompileShader
_TEXT	ENDS
PUBLIC	?Link@ShaderProgram@@QAE_NXZ			; ShaderProgram::Link
EXTRN	__imp____glewLinkProgramARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bLinked$ = -16						; size = 4
_bStatus$ = -5						; size = 1
_this$ = -4						; size = 4
?Link@ShaderProgram@@QAE_NXZ PROC			; ShaderProgram::Link
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  :   bool bStatus = false;

	mov	BYTE PTR _bStatus$[ebp], 0

; 184  :   GLint bLinked = GL_FALSE;

	mov	DWORD PTR _bLinked$[ebp], 0

; 185  : 
; 186  :   if(!hProgramObject || !(bVertexShaderObjectAttached || bFragmentShaderObjectAttached))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@Link
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	test	edx, edx
	jne	SHORT $LN2@Link
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	test	ecx, ecx
	jne	SHORT $LN2@Link
$LN1@Link:

; 187  :   {
; 188  :     return false;

	xor	al, al
	jmp	SHORT $LN3@Link
$LN2@Link:

; 189  :   }
; 190  : 
; 191  :   glLinkProgramARB(hProgramObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __imp____glewLinkProgramARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 192  :   glGetObjectParameterivARB(hProgramObject, GL_OBJECT_LINK_STATUS_ARB, &bLinked);

	mov	esi, esp
	lea	eax, DWORD PTR _bLinked$[ebp]
	push	eax
	push	35714					; 00008b82H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 193  :   bStatus = bLinked;

	cmp	DWORD PTR _bLinked$[ebp], 0
	setne	dl
	mov	BYTE PTR _bStatus$[ebp], dl

; 194  : 
; 195  :   return bStatus;

	mov	al, BYTE PTR _bStatus$[ebp]
$LN3@Link:

; 196  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Link
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@Link:
	DD	1
	DD	$LN6@Link
$LN6@Link:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN5@Link
$LN5@Link:
	DB	98					; 00000062H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?Link@ShaderProgram@@QAE_NXZ ENDP			; ShaderProgram::Link
_TEXT	ENDS
PUBLIC	?AttachShader@ShaderProgram@@QAE_NI@Z		; ShaderProgram::AttachShader
EXTRN	__imp____glewAttachObjectARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bCompiled$ = -12					; size = 4
_status$ = -5						; size = 1
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?AttachShader@ShaderProgram@@QAE_NI@Z PROC		; ShaderProgram::AttachShader
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 200  :   bool status = false;

	mov	BYTE PTR _status$[ebp], 0

; 201  :   GLint bCompiled = GL_FALSE;

	mov	DWORD PTR _bCompiled$[ebp], 0

; 202  : 
; 203  :   if(!hProgramObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@AttachShad

; 204  :   {
; 205  :     return false;

	xor	al, al
	jmp	$LN9@AttachShad
$LN8@AttachShad:

; 206  :   }
; 207  : 
; 208  :   if(type == GL_FRAGMENT_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35632		; 00008b30H
	jne	SHORT $LN7@AttachShad

; 209  :   {
; 210  :     if(!hFragmentShaderObject)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN6@AttachShad

; 211  :     {
; 212  :       return false;

	xor	al, al
	jmp	SHORT $LN9@AttachShad
$LN6@AttachShad:

; 213  :     }
; 214  : 
; 215  :     if(!bFragmentShaderObjectAttached)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+13]
	test	eax, eax
	jne	SHORT $LN5@AttachShad

; 216  :     {
; 217  :       bFragmentShaderObjectAttached = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], 1

; 218  :       glAttachObjectARB(hProgramObject,hFragmentShaderObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __imp____glewAttachObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@AttachShad:

; 219  :     }
; 220  :   }

	jmp	SHORT $LN4@AttachShad
$LN7@AttachShad:

; 221  :   else if(type == GL_VERTEX_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35633		; 00008b31H
	jne	SHORT $LN4@AttachShad

; 222  :   {
; 223  :     if(!hVertexShaderObject)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN2@AttachShad

; 224  :     {
; 225  :       return false;

	xor	al, al
	jmp	SHORT $LN9@AttachShad
$LN2@AttachShad:

; 226  :     }
; 227  : 
; 228  :     if(!bVertexShaderObjectAttached)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN4@AttachShad

; 229  :     {
; 230  :       bVertexShaderObjectAttached = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 1

; 231  :       glAttachObjectARB(hProgramObject,hVertexShaderObject);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __imp____glewAttachObjectARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@AttachShad:

; 232  :     }
; 233  :   } 
; 234  : 
; 235  :   return true;

	mov	al, 1
$LN9@AttachShad:

; 236  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AttachShader@ShaderProgram@@QAE_NI@Z ENDP		; ShaderProgram::AttachShader
_TEXT	ENDS
PUBLIC	?DetatchShader@ShaderProgram@@QAE_NI@Z		; ShaderProgram::DetatchShader
EXTRN	__imp____glewDetachObjectARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bCompiled$ = -12					; size = 4
_status$ = -5						; size = 1
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?DetatchShader@ShaderProgram@@QAE_NI@Z PROC		; ShaderProgram::DetatchShader
; _this$ = ecx

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 240  :   bool status = false;

	mov	BYTE PTR _status$[ebp], 0

; 241  :   GLint bCompiled = GL_FALSE;

	mov	DWORD PTR _bCompiled$[ebp], 0

; 242  : 
; 243  :   if(!hProgramObject)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@DetatchSha

; 244  :   {
; 245  :     return false;

	xor	al, al
	jmp	$LN9@DetatchSha
$LN8@DetatchSha:

; 246  :   }
; 247  : 
; 248  :   if(type == GL_FRAGMENT_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35632		; 00008b30H
	jne	SHORT $LN7@DetatchSha

; 249  :   {
; 250  :     if(!hFragmentShaderObject)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN6@DetatchSha

; 251  :     {
; 252  :       return false;

	xor	al, al
	jmp	SHORT $LN9@DetatchSha
$LN6@DetatchSha:

; 253  :     }
; 254  : 
; 255  :     if(bFragmentShaderObjectAttached)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+13]
	test	eax, eax
	je	SHORT $LN5@DetatchSha

; 256  :     {
; 257  :       bFragmentShaderObjectAttached = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], 0

; 258  :       glDetachObjectARB(hProgramObject,hFragmentShaderObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __imp____glewDetachObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DetatchSha:

; 259  :     }
; 260  :   }

	jmp	SHORT $LN4@DetatchSha
$LN7@DetatchSha:

; 261  :   else if(type == GL_VERTEX_SHADER_ARB)

	cmp	DWORD PTR _type$[ebp], 35633		; 00008b31H
	jne	SHORT $LN4@DetatchSha

; 262  :   {
; 263  :     if(!hVertexShaderObject)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN2@DetatchSha

; 264  :     {
; 265  :       return false;

	xor	al, al
	jmp	SHORT $LN9@DetatchSha
$LN2@DetatchSha:

; 266  :     }
; 267  : 
; 268  :     if(!bVertexShaderObjectAttached)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN4@DetatchSha

; 269  :     {
; 270  :       bVertexShaderObjectAttached = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 0

; 271  :       glDetachObjectARB(hProgramObject,hVertexShaderObject);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __imp____glewDetachObjectARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@DetatchSha:

; 272  :     }
; 273  :   } 
; 274  : 
; 275  :   return true;

	mov	al, 1
$LN9@DetatchSha:

; 276  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DetatchShader@ShaderProgram@@QAE_NI@Z ENDP		; ShaderProgram::DetatchShader
_TEXT	ENDS
PUBLIC	?CompileAndLinkShaders@ShaderProgram@@QAE_NXZ	; ShaderProgram::CompileAndLinkShaders
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bCompiled$ = -28					; size = 4
_bLinked$ = -16						; size = 4
_bStatus$ = -5						; size = 1
_this$ = -4						; size = 4
?CompileAndLinkShaders@ShaderProgram@@QAE_NXZ PROC	; ShaderProgram::CompileAndLinkShaders
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 280  :   bool bStatus = false;

	mov	BYTE PTR _bStatus$[ebp], 0

; 281  :   GLint bLinked, bCompiled;
; 282  : 
; 283  :   if(!hProgramObject || !(bFragmentShaderCodeLoaded || bVertexShaderCodeLoaded))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@CompileAnd
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+15]
	test	edx, edx
	jne	SHORT $LN7@CompileAnd
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	test	ecx, ecx
	jne	SHORT $LN7@CompileAnd
$LN6@CompileAnd:

; 284  :   {
; 285  :     return false;

	xor	al, al
	jmp	$LN8@CompileAnd
$LN7@CompileAnd:

; 286  :   }
; 287  : 
; 288  :   if(hFragmentShaderObject && bFragmentShaderCodeLoaded)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN5@CompileAnd
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+15]
	test	ecx, ecx
	je	SHORT $LN5@CompileAnd

; 289  :   {
; 290  :     glCompileShaderARB(hFragmentShaderObject);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewCompileShaderARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 291  :     glGetObjectParameterivARB(hFragmentShaderObject, GL_OBJECT_COMPILE_STATUS_ARB, &bCompiled);

	mov	esi, esp
	lea	eax, DWORD PTR _bCompiled$[ebp]
	push	eax
	push	35713					; 00008b81H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 292  :     if(!bCompiled)

	cmp	DWORD PTR _bCompiled$[ebp], 0
	jne	SHORT $LN5@CompileAnd

; 293  :     {
; 294  :       PrintInfoLog(hFragmentShaderObject,"Fragment Shader Compile Error");

	push	OFFSET $SG66602
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z	; ShaderProgram::PrintInfoLog

; 295  :       return false;

	xor	al, al
	jmp	$LN8@CompileAnd
$LN5@CompileAnd:

; 296  :     }
; 297  :   }
; 298  : 
; 299  :   if(hVertexShaderObject && bVertexShaderCodeLoaded)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@CompileAnd
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	test	eax, eax
	je	SHORT $LN3@CompileAnd

; 300  :   {
; 301  :     glCompileShaderARB(hVertexShaderObject);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __imp____glewCompileShaderARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 302  :     glGetObjectParameterivARB(hVertexShaderObject, GL_OBJECT_COMPILE_STATUS_ARB, &bCompiled);

	mov	esi, esp
	lea	edx, DWORD PTR _bCompiled$[ebp]
	push	edx
	push	35713					; 00008b81H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 303  :     if(!bCompiled)

	cmp	DWORD PTR _bCompiled$[ebp], 0
	jne	SHORT $LN3@CompileAnd

; 304  :     {
; 305  :       PrintInfoLog(hVertexShaderObject,"Vertex Shader Compile Error");

	push	OFFSET $SG66605
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z	; ShaderProgram::PrintInfoLog

; 306  :       return false;

	xor	al, al
	jmp	SHORT $LN8@CompileAnd
$LN3@CompileAnd:

; 307  :     }
; 308  :   }
; 309  : 
; 310  :   glLinkProgramARB(hProgramObject);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __imp____glewLinkProgramARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 311  :   glGetObjectParameterivARB(hProgramObject, GL_OBJECT_LINK_STATUS_ARB, &bLinked);

	mov	esi, esp
	lea	ecx, DWORD PTR _bLinked$[ebp]
	push	ecx
	push	35714					; 00008b82H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetObjectParameterivARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 312  :   bStatus = bLinked;

	cmp	DWORD PTR _bLinked$[ebp], 0
	setne	al
	mov	BYTE PTR _bStatus$[ebp], al

; 313  :   if(!bLinked)

	cmp	DWORD PTR _bLinked$[ebp], 0
	jne	SHORT $LN1@CompileAnd

; 314  :   {
; 315  :     PrintInfoLog(hProgramObject,"Shader Program Link Error");

	push	OFFSET $SG66607
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrintInfoLog@ShaderProgram@@QAEXHPBD@Z	; ShaderProgram::PrintInfoLog
$LN1@CompileAnd:

; 316  :   }
; 317  :   return bStatus;

	mov	al, BYTE PTR _bStatus$[ebp]
$LN8@CompileAnd:

; 318  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@CompileAnd
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@CompileAnd:
	DD	2
	DD	$LN12@CompileAnd
$LN12@CompileAnd:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN10@CompileAnd
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN11@CompileAnd
$LN11@CompileAnd:
	DB	98					; 00000062H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN10@CompileAnd:
	DB	98					; 00000062H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?CompileAndLinkShaders@ShaderProgram@@QAE_NXZ ENDP	; ShaderProgram::CompileAndLinkShaders
_TEXT	ENDS
PUBLIC	?StartShaderProgram@ShaderProgram@@QAE_NXZ	; ShaderProgram::StartShaderProgram
EXTRN	__imp____glewUseProgramObjectARB:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartShaderProgram@ShaderProgram@@QAE_NXZ PROC		; ShaderProgram::StartShaderProgram
; _this$ = ecx

; 321  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 322  :   glUseProgramObjectARB(hProgramObject);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __imp____glewUseProgramObjectARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 323  :   return true;

	mov	al, 1

; 324  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StartShaderProgram@ShaderProgram@@QAE_NXZ ENDP		; ShaderProgram::StartShaderProgram
_TEXT	ENDS
PUBLIC	?StopShaderProgram@ShaderProgram@@QAE_NXZ	; ShaderProgram::StopShaderProgram
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StopShaderProgram@ShaderProgram@@QAE_NXZ PROC		; ShaderProgram::StopShaderProgram
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 328  :   glUseProgramObjectARB(0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __imp____glewUseProgramObjectARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 329  :   return true;

	mov	al, 1

; 330  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StopShaderProgram@ShaderProgram@@QAE_NXZ ENDP		; ShaderProgram::StopShaderProgram
_TEXT	ENDS
END
