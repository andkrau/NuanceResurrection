; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\DecodeRCU.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?DecodeInstruction_RCU16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ; MPE::DecodeInstruction_RCU16
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\decodercu.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv313 = -20						; size = 4
tv75 = -16						; size = 4
$T4914 = -10						; size = 1
_decInfo$ = -9						; size = 1
_rangeDependency$ = -8					; size = 4
_this$ = -4						; size = 4
_iPtr$ = 8						; size = 4
_entry$ = 12						; size = 4
_immExt$ = 16						; size = 4
?DecodeInstruction_RCU16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z PROC ; MPE::DecodeInstruction_RCU16
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T4914[ebp], 0

; 19   :   uint32 rangeDependency;
; 20   :   uint8 decInfo;
; 21   : 
; 22   :   entry->packetInfo |= PACKETINFO_RCU;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 8
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 23   : 
; 24   :   //copy dec control bits
; 25   :   decInfo = *(iPtr + 1) & 0x03;

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 3
	mov	BYTE PTR _decInfo$[ebp], cl

; 26   : 
; 27   :   entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_INFO)] = decInfo;

	movzx	edx, BYTE PTR _decInfo$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+112], edx

; 28   : 
; 29   :   switch(decInfo)

	mov	cl, BYTE PTR _decInfo$[ebp]
	mov	BYTE PTR tv75[ebp], cl
	cmp	BYTE PTR tv75[ebp], 1
	je	SHORT $LN34@DecodeInst
	cmp	BYTE PTR tv75[ebp], 2
	je	SHORT $LN33@DecodeInst
	cmp	BYTE PTR tv75[ebp], 3
	je	$LN32@DecodeInst
	jmp	$LN36@DecodeInst

; 30   :   {
; 31   :     case 0:
; 32   :       //shouldnt happen
; 33   :       break;

	jmp	$LN36@DecodeInst
$LN34@DecodeInst:

; 34   :     case 1:
; 35   :       //RC1 only
; 36   :       entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_DECRc1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 26			; 0000001aH

; 37   :       entry->miscInputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC1 | DEPENDENCY_FLAG_C1Z);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	or	ecx, 2097154				; 00200002H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+212], ecx

; 38   :       entry->miscOutputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC1 | DEPENDENCY_FLAG_C1Z);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+252]
	or	ecx, 2097154				; 00200002H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+252], ecx

; 39   :       break;

	jmp	SHORT $LN36@DecodeInst
$LN33@DecodeInst:

; 40   :     case 2:
; 41   :       //RC0 only
; 42   :       entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_DECRc0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+108], 27			; 0000001bH

; 43   :       entry->miscInputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC0 | DEPENDENCY_FLAG_C0Z);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+212]
	or	edx, 1048577				; 00100001H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+212], edx

; 44   :       entry->miscOutputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC0 | DEPENDENCY_FLAG_C0Z);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+252]
	or	edx, 1048577				; 00100001H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+252], edx

; 45   :       break;

	jmp	SHORT $LN36@DecodeInst
$LN32@DecodeInst:

; 46   :     case 3:
; 47   :       //both RC1 and RC0
; 48   :       entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_DECBoth;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+108], 28			; 0000001cH

; 49   :       entry->miscInputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC0 | DEPENDENCY_MASK_RC1 | DEPENDENCY_FLAG_C0Z | DEPENDENCY_FLAG_C1Z);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+212]
	or	eax, 3145731				; 00300003H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+212], eax

; 50   :       entry->miscOutputDependencies[SLOT_RCU] |= (DEPENDENCY_MASK_RC0 | DEPENDENCY_MASK_RC1 | DEPENDENCY_FLAG_C0Z | DEPENDENCY_FLAG_C1Z);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+252]
	or	eax, 3145731				; 00300003H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+252], eax
$LN36@DecodeInst:

; 51   :       break;
; 52   :   }
; 53   : 
; 54   :   if((*iPtr == 0xF9) && (*(iPtr + 1) & 0x04))

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 249				; 000000f9H
	jne	SHORT $LN31@DecodeInst
	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 4
	je	SHORT $LN31@DecodeInst

; 55   :   {
; 56   :     entry->packetInfo |= decOnlyFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 57   :     //DEC RC0, DEC RC1 or both
; 58   :     *immExt = 0;

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	DWORD PTR [eax], 0

; 59   :     return;

	jmp	$LN38@DecodeInst
$LN31@DecodeInst:

; 60   :   }
; 61   : 
; 62   :   //src is 0x03E0
; 63   :   entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] = ((*iPtr & 0x03) << 3) | (*(iPtr + 1) >> 5);

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 3
	shl	edx, 3
	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	sar	ecx, 5
	or	edx, ecx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+116], edx

; 64   :   //dest is 0x0018
; 65   :   entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)] = (*(iPtr + 1) >> 3) & 0x03;

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	sar	edx, 3
	and	edx, 3
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+120], edx

; 66   : 
; 67   :   //calculate remaining bits
; 68   :   if((*iPtr & 0x7C) == 0x74)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 124				; 0000007cH
	cmp	edx, 116				; 00000074H
	jne	$LN30@DecodeInst

; 69   :   {
; 70   :     if(*(iPtr + 1) & 0x04)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 4
	je	$LN29@DecodeInst

; 71   :     {
; 72   :       //addr #(n<<16), RI or addr #nnnn, RI
; 73   :       if(*immExt)

	mov	edx, DWORD PTR _immExt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN28@DecodeInst

; 74   :       {
; 75   :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] = ((*immExt & ~0xFFFF) << 5) | (entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] << 16) | (*immExt & 0xFFFF);

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -65536				; ffff0000H
	shl	ecx, 5
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+116]
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	edx, DWORD PTR _immExt$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65535				; 0000ffffH
	or	ecx, eax
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+116], ecx

; 76   :       }
; 77   :       else

	jmp	SHORT $LN27@DecodeInst
$LN28@DecodeInst:

; 78   :       {
; 79   :         //convert five bit immediate to signed 16.16 fixed point
; 80   :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] = ((int32)(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] << 27)) >> 11;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	shl	ecx, 27					; 0000001bH
	sar	ecx, 11					; 0000000bH
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+116], ecx
$LN27@DecodeInst:

; 81   :       }
; 82   : 
; 83   :       if(decInfo == 0)

	movzx	eax, BYTE PTR _decInfo$[ebp]
	test	eax, eax
	jne	SHORT $LN26@DecodeInst

; 84   :       {
; 85   :         entry->packetInfo |= addrOnlyFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 86   :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_ADDRImmediateOnly;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+108], 29			; 0000001dH

; 87   :       }
; 88   :       else

	jmp	SHORT $LN25@DecodeInst
$LN26@DecodeInst:

; 89   :       {
; 90   :         entry->packetInfo |= addrFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 91   :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_ADDRImmediate;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 30			; 0000001eH
$LN25@DecodeInst:

; 92   :       }
; 93   : 
; 94   :       entry->miscInputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	add	ecx, 2
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+212]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+212], edx

; 95   :       entry->miscOutputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+120]
	add	ecx, 2
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	or	eax, DWORD PTR [ecx+252]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+252], eax

; 96   :     }
; 97   :     else

	jmp	$LN24@DecodeInst
$LN29@DecodeInst:

; 98   :     {
; 99   :       //addr Si, RI
; 100  : 
; 101  :       if(decInfo == 0)

	movzx	eax, BYTE PTR _decInfo$[ebp]
	test	eax, eax
	jne	SHORT $LN23@DecodeInst

; 102  :       {
; 103  :         entry->packetInfo |= addrOnlyFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 104  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_ADDRScalarOnly;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+108], 31			; 0000001fH

; 105  :       }
; 106  :       else

	jmp	SHORT $LN22@DecodeInst
$LN23@DecodeInst:

; 107  :       {
; 108  :         entry->packetInfo |= addrFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 109  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_ADDRScalar;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 32			; 00000020H
$LN22@DecodeInst:

; 110  :       }
; 111  : 
; 112  :       entry->scalarInputDependencies[SLOT_RCU] |= SCALAR_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+116]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+192]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+192], edx

; 113  :       entry->miscInputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+120]
	add	ecx, 2
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	or	eax, DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+212], eax

; 114  :       entry->miscOutputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	add	ecx, 2
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+252]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+252], edx
$LN24@DecodeInst:

; 115  :     }
; 116  :   }
; 117  :   else

	jmp	$LN38@DecodeInst
$LN30@DecodeInst:

; 118  :   {
; 119  :     if(*immExt)

	mov	edx, DWORD PTR _immExt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN20@DecodeInst

; 120  :     {
; 121  :       //mvr #nnnn, RI
; 122  :       entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] = ((*immExt & ~0xFFFF) << 5) | (entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] << 16) | (*immExt & 0xFFFF);

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -65536				; ffff0000H
	shl	ecx, 5
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+116]
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	edx, DWORD PTR _immExt$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65535				; 0000ffffH
	or	ecx, eax
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+116], ecx

; 123  : 
; 124  :       if(decInfo == 0)

	movzx	eax, BYTE PTR _decInfo$[ebp]
	test	eax, eax
	jne	SHORT $LN19@DecodeInst

; 125  :       {
; 126  :         entry->packetInfo |= mvrOnlyFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 127  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_MVRImmediateOnly;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+108], 33			; 00000021H

; 128  :       }
; 129  :       else

	jmp	SHORT $LN18@DecodeInst
$LN19@DecodeInst:

; 130  :       {
; 131  :         entry->packetInfo |= mvrFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 132  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_MVRImmediate;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 34			; 00000022H
$LN18@DecodeInst:

; 133  :       }
; 134  : 
; 135  :       entry->miscOutputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	add	ecx, 2
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+252]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+252], edx
	jmp	$LN38@DecodeInst
$LN20@DecodeInst:

; 136  :     }
; 137  :     else if((*(iPtr + 1) & 0x04) == 0)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 4
	jne	SHORT $LN16@DecodeInst

; 138  :     {
; 139  :       //mvr Sj, RI
; 140  :       if(decInfo == 0)

	movzx	ecx, BYTE PTR _decInfo$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@DecodeInst

; 141  :       {
; 142  :         entry->packetInfo |= mvrOnlyFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 143  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_MVRScalarOnly;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 35			; 00000023H

; 144  :       }
; 145  :       else

	jmp	SHORT $LN14@DecodeInst
$LN15@DecodeInst:

; 146  :       {
; 147  :         entry->packetInfo |= mvrFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 148  :         entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_MVRScalar;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+108], 36			; 00000024H
$LN14@DecodeInst:

; 149  :       }
; 150  : 
; 151  :       entry->scalarInputDependencies[SLOT_RCU] |= SCALAR_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)]);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+116]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+192]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+192], edx

; 152  :       entry->miscOutputDependencies[SLOT_RCU] |= INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+120]
	add	ecx, 2
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	or	eax, DWORD PTR [ecx+252]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+252], eax

; 153  :     }
; 154  :     else

	jmp	$LN38@DecodeInst
$LN16@DecodeInst:

; 155  :     {
; 156  :       //modulo RI or range RI
; 157  :       entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)] = entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR [eax+116], edx

; 158  :       switch(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)])

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR tv313[ebp], ecx
	cmp	DWORD PTR tv313[ebp], 3
	ja	SHORT $LN11@DecodeInst
	mov	edx, DWORD PTR tv313[ebp]
	jmp	DWORD PTR $LN43@DecodeInst[edx*4]
$LN10@DecodeInst:

; 159  :       {
; 160  :         case 0:
; 161  :           rangeDependency = DEPENDENCY_MASK_XYRANGE;

	mov	BYTE PTR $T4914[ebp], 1
	mov	DWORD PTR _rangeDependency$[ebp], 2048	; 00000800H

; 162  :           break;

	jmp	SHORT $LN11@DecodeInst
$LN9@DecodeInst:

; 163  :         case 1:
; 164  :           rangeDependency = DEPENDENCY_MASK_XYRANGE;

	mov	BYTE PTR $T4914[ebp], 1
	mov	DWORD PTR _rangeDependency$[ebp], 2048	; 00000800H

; 165  :           break;

	jmp	SHORT $LN11@DecodeInst
$LN8@DecodeInst:

; 166  :         case 2:
; 167  :           rangeDependency = DEPENDENCY_MASK_UVRANGE;

	mov	BYTE PTR $T4914[ebp], 1
	mov	DWORD PTR _rangeDependency$[ebp], 4096	; 00001000H

; 168  :           break;

	jmp	SHORT $LN11@DecodeInst
$LN7@DecodeInst:

; 169  :         case 3:
; 170  :           rangeDependency = DEPENDENCY_MASK_UVRANGE;

	mov	BYTE PTR $T4914[ebp], 1
	mov	DWORD PTR _rangeDependency$[ebp], 4096	; 00001000H
$LN11@DecodeInst:

; 171  :           break;
; 172  :       }
; 173  :       entry->miscInputDependencies[SLOT_RCU] |= (INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_SRC)]) | rangeDependency);

	cmp	BYTE PTR $T4914[ebp], 0
	jne	SHORT $LN40@DecodeInst
	push	OFFSET $LN41@DecodeInst
	call	__RTC_UninitUse
	add	esp, 4
$LN40@DecodeInst:
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	add	ecx, 2
	mov	edx, 1
	shl	edx, cl
	or	edx, DWORD PTR _rangeDependency$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+212]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+212], edx

; 174  :       
; 175  :       if(*iPtr & 0x02)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 2
	je	SHORT $LN6@DecodeInst

; 176  :       {
; 177  :         //Range
; 178  :         entry->miscOutputDependencies[SLOT_RCU] |= (DEPENDENCY_FLAG_MODMI | DEPENDENCY_FLAG_MODGE);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+252]
	or	edx, 12582912				; 00c00000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+252], edx

; 179  : 
; 180  :         if(decInfo == 0)

	movzx	ecx, BYTE PTR _decInfo$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@DecodeInst

; 181  :         {
; 182  :           entry->packetInfo |= rangeOnlyFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 183  :           entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_RangeOnly;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+108], 37			; 00000025H

; 184  :         }
; 185  :         else

	jmp	SHORT $LN4@DecodeInst
$LN5@DecodeInst:

; 186  :         {
; 187  :           entry->packetInfo |= rangeFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 188  :           entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_Range;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+108], 38			; 00000026H
$LN4@DecodeInst:

; 189  :         }
; 190  :       }
; 191  :       else

	jmp	SHORT $LN38@DecodeInst
$LN6@DecodeInst:

; 192  :       {
; 193  :         //Modulo
; 194  :         entry->miscOutputDependencies[SLOT_RCU] |= (DEPENDENCY_FLAG_MODMI | DEPENDENCY_FLAG_MODGE | INDEX_REG_DEPENDENCY_MASK(entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_DEST)]));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [ecx+120]
	add	ecx, 2
	mov	edx, 1
	shl	edx, cl
	or	edx, 12582912				; 00c00000H
	mov	eax, DWORD PTR _entry$[ebp]
	or	edx, DWORD PTR [eax+252]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+252], edx

; 195  :         if(decInfo == 0)

	movzx	edx, BYTE PTR _decInfo$[ebp]
	test	edx, edx
	jne	SHORT $LN2@DecodeInst

; 196  :         {
; 197  :           entry->packetInfo |= moduloOnlyFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 198  :           entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_ModuloOnly;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+108], 39			; 00000027H

; 199  :         }
; 200  :         else

	jmp	SHORT $LN38@DecodeInst
$LN2@DecodeInst:

; 201  :         {
; 202  :           entry->packetInfo |= moduloFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 203  :           entry->nuances[FIXED_FIELD(SLOT_RCU,FIELD_RCU_HANDLER)] = Handler_Modulo;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+108], 40			; 00000028H
$LN38@DecodeInst:

; 204  :         }
; 205  :       }
; 206  :     }
; 207  :   }
; 208  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN42@DecodeInst:
$LN41@DecodeInst:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	121					; 00000079H
	DB	0
	npad	1
$LN43@DecodeInst:
	DD	$LN10@DecodeInst
	DD	$LN9@DecodeInst
	DD	$LN8@DecodeInst
	DD	$LN7@DecodeInst
?DecodeInstruction_RCU16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ENDP ; MPE::DecodeInstruction_RCU16
_TEXT	ENDS
END
