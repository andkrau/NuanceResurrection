; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\timer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?hSysTimer1@@3IA				; hSysTimer1
PUBLIC	?hSysTimer0@@3IA				; hSysTimer0
PUBLIC	?hSysTimer2@@3IA				; hSysTimer2
PUBLIC	?ticksAtBootTime@@3T_LARGE_INTEGER@@A		; ticksAtBootTime
PUBLIC	?tickCount@@3_KA				; tickCount
PUBLIC	?bHighPerformanceTimerAvailable@@3_NA		; bHighPerformanceTimerAvailable
PUBLIC	?bSysTimer0Initialized@@3_NA			; bSysTimer0Initialized
PUBLIC	?bSysTimer1Initialized@@3_NA			; bSysTimer1Initialized
PUBLIC	?bSysTimer2Initialized@@3_NA			; bSysTimer2Initialized
_BSS	SEGMENT
?hSysTimer1@@3IA DD 01H DUP (?)				; hSysTimer1
?hSysTimer0@@3IA DD 01H DUP (?)				; hSysTimer0
?hSysTimer2@@3IA DD 01H DUP (?)				; hSysTimer2
	ALIGN	8

?ticksAtBootTime@@3T_LARGE_INTEGER@@A DQ 01H DUP (?)	; ticksAtBootTime
?tickCount@@3_KA DQ 01H DUP (?)				; tickCount
?bHighPerformanceTimerAvailable@@3_NA DB 01H DUP (?)	; bHighPerformanceTimerAvailable
	ALIGN	4

?bSysTimer0Initialized@@3_NA DB 01H DUP (?)		; bSysTimer0Initialized
	ALIGN	4

?bSysTimer1Initialized@@3_NA DB 01H DUP (?)		; bSysTimer1Initialized
	ALIGN	4

?bSysTimer2Initialized@@3_NA DB 01H DUP (?)		; bSysTimer2Initialized
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG66969
_DATA	ENDS
CONST	SEGMENT
$SG66969 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?TriggerInterrupt@MPE@@QAEXI@Z			; MPE::TriggerInterrupt
PUBLIC	?SysTimer0Callback@@YGXIIHHH@Z			; SysTimer0Callback
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\timer.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_wTimerID$ = 8						; size = 4
_msg$ = 12						; size = 4
_dwUser$ = 16						; size = 4
_dw1$ = 20						; size = 4
_dw2$ = 24						; size = 4
?SysTimer0Callback@@YGXIIHHH@Z PROC			; SysTimer0Callback

; 23   : { 

	push	ebp
	mov	ebp, esp

; 24   :   nuonEnv->mpe[0]->TriggerInterrupt(INT_SYSTIMER0);

	push	536870912				; 20000000H
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 25   :   nuonEnv->mpe[1]->TriggerInterrupt(INT_SYSTIMER0);

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+4]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 26   :   nuonEnv->mpe[2]->TriggerInterrupt(INT_SYSTIMER0);

	push	536870912				; 20000000H
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+8]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 27   :   nuonEnv->mpe[3]->TriggerInterrupt(INT_SYSTIMER0);

	push	536870912				; 20000000H
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+12]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 28   : } 

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?SysTimer0Callback@@YGXIIHHH@Z ENDP			; SysTimer0Callback
_TEXT	ENDS
EXTRN	?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z:PROC	; Syscall_InterruptTriggered
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
;	COMDAT ?TriggerInterrupt@MPE@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_which$ = 8						; size = 4
?TriggerInterrupt@MPE@@QAEXI@Z PROC			; MPE::TriggerInterrupt, COMDAT
; _this$ = ecx

; 481  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 482  :     intsrc |= which;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 483  :     Syscall_InterruptTriggered(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z ; Syscall_InterruptTriggered
	add	esp, 4

; 484  :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?TriggerInterrupt@MPE@@QAEXI@Z ENDP			; MPE::TriggerInterrupt
_TEXT	ENDS
PUBLIC	?SysTimer1Callback@@YGXIIHHH@Z			; SysTimer1Callback
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\timer.cpp
_TEXT	SEGMENT
_wTimerID$ = 8						; size = 4
_msg$ = 12						; size = 4
_dwUser$ = 16						; size = 4
_dw1$ = 20						; size = 4
_dw2$ = 24						; size = 4
?SysTimer1Callback@@YGXIIHHH@Z PROC			; SysTimer1Callback

; 31   : { 

	push	ebp
	mov	ebp, esp

; 32   :   nuonEnv->mpe[0]->TriggerInterrupt(INT_SYSTIMER1);

	push	1073741824				; 40000000H
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 33   :   nuonEnv->mpe[1]->TriggerInterrupt(INT_SYSTIMER1);

	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+4]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 34   :   nuonEnv->mpe[2]->TriggerInterrupt(INT_SYSTIMER1);

	push	1073741824				; 40000000H
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+8]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 35   :   nuonEnv->mpe[3]->TriggerInterrupt(INT_SYSTIMER1);

	push	1073741824				; 40000000H
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+12]
	call	?TriggerInterrupt@MPE@@QAEXI@Z		; MPE::TriggerInterrupt

; 36   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?SysTimer1Callback@@YGXIIHHH@Z ENDP			; SysTimer1Callback
_TEXT	ENDS
PUBLIC	?SysTimer2Callback@@YGXIIHHH@Z			; SysTimer2Callback
EXTRN	?TriggerVideoInterrupt@NuonEnvironment@@QAEXXZ:PROC ; NuonEnvironment::TriggerVideoInterrupt
EXTRN	?IncrementVideoFieldCounter@@YAXXZ:PROC		; IncrementVideoFieldCounter
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_wTimerID$ = 8						; size = 4
_msg$ = 12						; size = 4
_dwUser$ = 16						; size = 4
_dw1$ = 20						; size = 4
_dw2$ = 24						; size = 4
?SysTimer2Callback@@YGXIIHHH@Z PROC			; SysTimer2Callback

; 39   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 40   :   static uint64 cycleCounter[4] = {0,0,0,0};
; 41   :   static uint64 max_delta[4] = {0,0,0,0};
; 42   :   uint64 delta;
; 43   :   uint32 i;
; 44   : 
; 45   : //  for(i = 0; i < 4; i++)
; 46   : //  {
; 47   : //    delta = nuonEnv->mpe[i]->cycleCounter - cycleCounter[i];
; 48   : //    if(delta > max_delta[i])
; 49   : //    {
; 50   : //      max_delta[i] = delta;
; 51   : //    }
; 52   : //    cycleCounter[i] = nuonEnv->mpe[i]->cycleCounter;
; 53   : //  }
; 54   :   IncrementVideoFieldCounter();

	call	?IncrementVideoFieldCounter@@YAXXZ	; IncrementVideoFieldCounter

; 55   :   nuonEnv->TriggerVideoInterrupt();

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?TriggerVideoInterrupt@NuonEnvironment@@QAEXXZ ; NuonEnvironment::TriggerVideoInterrupt

; 56   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SysTimer2Callback@@YGXIIHHH@Z ENDP			; SysTimer2Callback
_TEXT	ENDS
PUBLIC	?InitializeTimingMethod@@YAXXZ			; InitializeTimingMethod
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	?tickFrequency@@3T_LARGE_INTEGER@@A:QWORD	; tickFrequency
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
?InitializeTimingMethod@@YAXXZ PROC			; InitializeTimingMethod

; 59   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 60   :   bHighPerformanceTimerAvailable = false;

	mov	BYTE PTR ?bHighPerformanceTimerAvailable@@3_NA, 0 ; bHighPerformanceTimerAvailable

; 61   : 
; 62   :   if(QueryPerformanceFrequency((_LARGE_INTEGER *)&tickFrequency) == TRUE)

	mov	esi, esp
	push	OFFSET ?tickFrequency@@3T_LARGE_INTEGER@@A ; tickFrequency
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN2@Initialize

; 63   :   {
; 64   :     bHighPerformanceTimerAvailable = true;

	mov	BYTE PTR ?bHighPerformanceTimerAvailable@@3_NA, 1 ; bHighPerformanceTimerAvailable

; 65   :     QueryPerformanceCounter((_LARGE_INTEGER *)&ticksAtBootTime);

	mov	esi, esp
	push	OFFSET ?ticksAtBootTime@@3T_LARGE_INTEGER@@A ; ticksAtBootTime
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 66   :   }
; 67   :   else

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 68   :   {
; 69   :     ticksAtBootTime.QuadPart = time(NULL);

	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A, eax
	mov	DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A+4, edx
$LN3@Initialize:

; 70   :   }
; 71   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?InitializeTimingMethod@@YAXXZ ENDP			; InitializeTimingMethod
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 134  : {

	push	ebp
	mov	ebp, esp

; 135  :     return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 136  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
PUBLIC	?TimeOfDay@@YAXPAVMPE@@@Z			; TimeOfDay
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?SwapVectorBytes@@YIXPAI@Z:PROC			; SwapVectorBytes
EXTRN	___tzname:PROC
EXTRN	___timezone:PROC
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\timer.cpp
_TEXT	SEGMENT
_getset$ = -32						; size = 4
_ptrNuonTime$ = -28					; size = 4
_nuonTime$ = -24					; size = 4
_pcTime$ = -20						; size = 4
_currTime$ = -12					; size = 8
_mpe$ = 8						; size = 4
?TimeOfDay@@YAXPAVMPE@@@Z PROC				; TimeOfDay

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 75   :   time_t currTime;
; 76   :   tm *pcTime;
; 77   :   _currenttime *nuonTime;
; 78   :   uint32 ptrNuonTime, getset;
; 79   : 
; 80   :   ptrNuonTime = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptrNuonTime$[ebp], ecx

; 81   :   getset = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _getset$[ebp], eax

; 82   : 
; 83   :   if(getset == 0)

	cmp	DWORD PTR _getset$[ebp], 0
	jne	$LN4@TimeOfDay

; 84   :   {
; 85   :     nuonTime = (_currenttime *)nuonEnv->GetPointerToMemory(mpe,ptrNuonTime,true);

	push	1
	mov	ecx, DWORD PTR _ptrNuonTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _nuonTime$[ebp], eax

; 86   : 
; 87   :     //Get time and fill time structure
; 88   : 
; 89   :     time(&currTime);

	lea	eax, DWORD PTR _currTime$[ebp]
	push	eax
	call	_time
	add	esp, 4

; 90   :     pcTime = localtime(&currTime);

	lea	ecx, DWORD PTR _currTime$[ebp]
	push	ecx
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _pcTime$[ebp], eax

; 91   : 
; 92   :     nuonTime->sec = pcTime->tm_sec;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 93   :     nuonTime->min = pcTime->tm_min;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 94   :     nuonTime->hour = pcTime->tm_hour;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 95   :     nuonTime->wday = pcTime->tm_wday;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+12], ecx

; 96   :     nuonTime->mday = pcTime->tm_mday;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 97   :     nuonTime->month = pcTime->tm_mon + 1; //according to the SDK, january = 1

	mov	edx, DWORD PTR _pcTime$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _nuonTime$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 98   :     nuonTime->year = pcTime->tm_year + 1900; //Nuon year field is the actual year value, not a delta

	mov	edx, DWORD PTR _pcTime$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 1900				; 0000076cH
	mov	ecx, DWORD PTR _nuonTime$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 99   :     nuonTime->isdst = pcTime->tm_isdst;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	eax, DWORD PTR _pcTime$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx

; 100  :     nuonTime->timezone = _timezone/60; //Nuon timezone field is in minutes rather than seconds

	call	___timezone
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	DWORD PTR [edx+32], eax

; 101  : 
; 102  :     //A value of -1 in the Nuon field indicates that the system doesn't keep track of DST.
; 103  :     if(pcTime->tm_isdst != -1)

	mov	eax, DWORD PTR _pcTime$[ebp]
	cmp	DWORD PTR [eax+32], -1
	je	SHORT $LN3@TimeOfDay

; 104  :     {
; 105  :       nuonTime->isdst = 1;

	mov	ecx, DWORD PTR _nuonTime$[ebp]
	mov	DWORD PTR [ecx+28], 1
$LN3@TimeOfDay:

; 106  :     }
; 107  : 
; 108  :     //The pointer in _tzname[1] points to the daylight savings time zone name
; 109  :     //if available, and is set to NULL if not available.  I am assuming that
; 110  :     //if windows is not set up to keep track of DST, _tzname[1] is set to NULL.
; 111  : 
; 112  :     //Almost all windows users will allow windows to keep track of DST, so it
; 113  :     //wont hurt too much if this assumption is incorrect.  This may have to
; 114  :     //be taken care of differently on other platforms
; 115  : 
; 116  :     if(_tzname[1] == NULL)

	call	___tzname
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@TimeOfDay

; 117  :     {
; 118  :       nuonTime->isdst = -1;

	mov	edx, DWORD PTR _nuonTime$[ebp]
	mov	DWORD PTR [edx+28], -1
$LN2@TimeOfDay:

; 119  :     }
; 120  : 
; 121  :     SwapVectorBytes((uint32 *)&nuonTime->sec);

	mov	ecx, DWORD PTR _nuonTime$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 122  :     SwapVectorBytes((uint32 *)&nuonTime->mday);

	mov	ecx, DWORD PTR _nuonTime$[ebp]
	add	ecx, 16					; 00000010H
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 123  :     SwapScalarBytes((uint32 *)&nuonTime->isdst);

	mov	ecx, DWORD PTR _nuonTime$[ebp]
	add	ecx, 28					; 0000001cH
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 124  :     SwapScalarBytes((uint32 *)&nuonTime->timezone);

	mov	ecx, DWORD PTR _nuonTime$[ebp]
	add	ecx, 32					; 00000020H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 125  : 
; 126  :     mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0

; 127  :   }
; 128  :   else

	jmp	SHORT $LN5@TimeOfDay
$LN4@TimeOfDay:

; 129  :   {
; 130  :     //Set time using values in time structure
; 131  : 
; 132  :     //Not allowed to set the time
; 133  :     mpe->regs[0] = -1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], -1
$LN5@TimeOfDay:

; 134  :   }
; 135  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@TimeOfDay
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@TimeOfDay:
	DD	1
	DD	$LN8@TimeOfDay
$LN8@TimeOfDay:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN7@TimeOfDay
$LN7@TimeOfDay:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?TimeOfDay@@YAXPAVMPE@@@Z ENDP				; TimeOfDay
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\microsoft visual studio 8\vc\include\time.inl
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC

; 115  : {

	push	ebp
	mov	ebp, esp

; 116  : #pragma warning( push )
; 117  : #pragma warning( disable : 4996 )
; 118  :     return _localtime64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__localtime64
	add	esp, 4

; 119  : #pragma warning( pop )
; 120  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
PUBLIC	__real@408f400000000000
PUBLIC	__real@412e848000000000
PUBLIC	?TimeElapsed@@YAXPAVMPE@@@Z			; TimeElapsed
EXTRN	__fltused:DWORD
EXTRN	__allmul:PROC
EXTRN	__ftol2:PROC
;	COMDAT __real@408f400000000000
; File c:\nuanceexperimental\timer.cpp
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv155 = -76						; size = 8
tv152 = -68						; size = 8
_counter$ = -56						; size = 8
_float_seconds$ = -44					; size = 8
_ptrUSecs$ = -36					; size = 4
_ptrSecs$ = -32						; size = 4
_memPtr$ = -28						; size = 4
_mseconds$ = -24					; size = 8
_useconds$ = -16					; size = 8
_seconds$ = -8						; size = 8
_mpe$ = 8						; size = 4
?TimeElapsed@@YAXPAVMPE@@@Z PROC			; TimeElapsed

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 139  :   uint64 seconds, useconds, mseconds;
; 140  :   uint32 *memPtr, ptrSecs, ptrUSecs;
; 141  :   double float_seconds;
; 142  :   _LARGE_INTEGER counter;
; 143  :   
; 144  : 
; 145  :   if(bHighPerformanceTimerAvailable)

	movzx	eax, BYTE PTR ?bHighPerformanceTimerAvailable@@3_NA ; bHighPerformanceTimerAvailable
	test	eax, eax
	je	$LN4@TimeElapse

; 146  :   {
; 147  :     QueryPerformanceCounter((_LARGE_INTEGER *)&counter);

	mov	esi, esp
	lea	ecx, DWORD PTR _counter$[ebp]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 148  :     
; 149  :     counter.QuadPart -= ticksAtBootTime.QuadPart;

	mov	edx, DWORD PTR _counter$[ebp]
	sub	edx, DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A
	mov	eax, DWORD PTR _counter$[ebp+4]
	sbb	eax, DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A+4
	mov	DWORD PTR _counter$[ebp], edx
	mov	DWORD PTR _counter$[ebp+4], eax

; 150  :     float_seconds = (double)counter.QuadPart / (double)tickFrequency.QuadPart;

	fild	QWORD PTR _counter$[ebp]
	fild	QWORD PTR ?tickFrequency@@3T_LARGE_INTEGER@@A ; tickFrequency
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _float_seconds$[ebp]

; 151  :     seconds = float_seconds;

	fld	QWORD PTR _float_seconds$[ebp]
	call	__ftol2
	mov	DWORD PTR _seconds$[ebp], eax
	mov	DWORD PTR _seconds$[ebp+4], edx

; 152  :     useconds = 1000000.0 * (float_seconds - seconds);

	mov	ecx, DWORD PTR _seconds$[ebp]
	mov	edx, DWORD PTR _seconds$[ebp+4]
	mov	DWORD PTR tv152[ebp], ecx
	mov	DWORD PTR tv152[ebp+4], edx
	mov	eax, DWORD PTR tv152[ebp+4]
	mov	DWORD PTR tv155[ebp+4], eax
	and	DWORD PTR tv152[ebp+4], 2147483647	; 7fffffffH
	fild	QWORD PTR tv152[ebp]
	and	DWORD PTR tv155[ebp+4], -2147483648	; 80000000H
	mov	DWORD PTR tv155[ebp], 0
	fild	QWORD PTR tv155[ebp]
	fchs
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR _float_seconds$[ebp]
	fmul	QWORD PTR __real@412e848000000000
	call	__ftol2
	mov	DWORD PTR _useconds$[ebp], eax
	mov	DWORD PTR _useconds$[ebp+4], edx

; 153  :     mseconds = float_seconds * 1000.0;

	fld	QWORD PTR _float_seconds$[ebp]
	fmul	QWORD PTR __real@408f400000000000
	call	__ftol2
	mov	DWORD PTR _mseconds$[ebp], eax
	mov	DWORD PTR _mseconds$[ebp+4], edx

; 154  :   }
; 155  :   else

	jmp	SHORT $LN3@TimeElapse
$LN4@TimeElapse:

; 156  :   {
; 157  :     seconds = time(NULL) - ticksAtBootTime.QuadPart;

	push	0
	call	_time
	add	esp, 4
	sub	eax, DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A
	sbb	edx, DWORD PTR ?ticksAtBootTime@@3T_LARGE_INTEGER@@A+4
	mov	DWORD PTR _seconds$[ebp], eax
	mov	DWORD PTR _seconds$[ebp+4], edx

; 158  :     mseconds = seconds*1000;

	push	0
	push	1000					; 000003e8H
	mov	ecx, DWORD PTR _seconds$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _seconds$[ebp]
	push	edx
	call	__allmul
	mov	DWORD PTR _mseconds$[ebp], eax
	mov	DWORD PTR _mseconds$[ebp+4], edx

; 159  :     useconds = 0;

	mov	DWORD PTR _useconds$[ebp], 0
	mov	DWORD PTR _useconds$[ebp+4], 0
$LN3@TimeElapse:

; 160  :   }
; 161  : 
; 162  :   ptrSecs = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptrSecs$[ebp], ecx

; 163  :   ptrUSecs = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ptrUSecs$[ebp], eax

; 164  : 
; 165  :   //Store seconds if pointer is not NULL
; 166  :   if(ptrSecs)

	cmp	DWORD PTR _ptrSecs$[ebp], 0
	je	SHORT $LN2@TimeElapse

; 167  :   {
; 168  :     memPtr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,ptrSecs,true);

	push	1
	mov	ecx, DWORD PTR _ptrSecs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 169  :     *memPtr = seconds;

	mov	eax, DWORD PTR _seconds$[ebp]
	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	DWORD PTR [ecx], eax

; 170  :     SwapScalarBytes(memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes
$LN2@TimeElapse:

; 171  :   }
; 172  : 
; 173  :   //Store microseconds if pointer is not NULL
; 174  :   if(ptrUSecs)

	cmp	DWORD PTR _ptrUSecs$[ebp], 0
	je	SHORT $LN1@TimeElapse

; 175  :   {
; 176  :     memPtr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,ptrUSecs,true);

	push	1
	mov	edx, DWORD PTR _ptrUSecs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 177  :     *memPtr = useconds;

	mov	ecx, DWORD PTR _useconds$[ebp]
	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	DWORD PTR [edx], ecx

; 178  :     SwapScalarBytes(memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes
$LN1@TimeElapse:

; 179  :   }
; 180  : 
; 181  :   mpe->regs[0] = mseconds;

	mov	eax, DWORD PTR _mseconds$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], eax

; 182  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@TimeElapse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@TimeElapse:
	DD	1
	DD	$LN8@TimeElapse
$LN8@TimeElapse:
	DD	-56					; ffffffc8H
	DD	8
	DD	$LN7@TimeElapse
$LN7@TimeElapse:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?TimeElapsed@@YAXPAVMPE@@@Z ENDP			; TimeElapsed
_TEXT	ENDS
PUBLIC	?TimerInit@@YAXII@Z				; TimerInit
EXTRN	__imp__timeSetEvent@20:PROC
EXTRN	__imp__timeKillEvent@4:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv183 = -72						; size = 8
tv181 = -64						; size = 4
tv178 = -58						; size = 2
tv174 = -56						; size = 8
tv165 = -48						; size = 8
tv163 = -40						; size = 4
tv160 = -34						; size = 2
tv156 = -32						; size = 8
tv147 = -24						; size = 8
tv145 = -16						; size = 4
tv142 = -10						; size = 2
tv138 = -8						; size = 8
_whichTimer$ = 8					; size = 4
_rate$ = 12						; size = 4
?TimerInit@@YAXII@Z PROC				; TimerInit

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 186  :   if(whichTimer == 0)

	cmp	DWORD PTR _whichTimer$[ebp], 0
	jne	SHORT $LN4@TimerInit

; 187  :   {
; 188  :     timeKillEvent(hSysTimer0);

	mov	esi, esp
	mov	eax, DWORD PTR ?hSysTimer0@@3IA		; hSysTimer0
	push	eax
	call	DWORD PTR __imp__timeKillEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 189  :     hSysTimer0 = timeSetEvent(((float)rate/1000.0),0,(LPTIMECALLBACK)SysTimer0Callback,0,TIME_PERIODIC);

	mov	esi, esp
	push	1
	push	0
	push	OFFSET ?SysTimer0Callback@@YGXIIHHH@Z	; SysTimer0Callback
	push	0
	mov	ecx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv138[ebp], ecx
	mov	DWORD PTR tv138[ebp+4], 0
	fild	QWORD PTR tv138[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	fnstcw	WORD PTR tv142[ebp]
	movzx	eax, WORD PTR tv142[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv145[ebp], eax
	fldcw	WORD PTR tv145[ebp]
	fistp	QWORD PTR tv147[ebp]
	fldcw	WORD PTR tv142[ebp]
	mov	edx, DWORD PTR tv147[ebp]
	push	edx
	call	DWORD PTR __imp__timeSetEvent@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hSysTimer0@@3IA, eax		; hSysTimer0
	jmp	$LN1@TimerInit
$LN4@TimerInit:

; 190  :   }
; 191  :   else if(whichTimer == 1)

	cmp	DWORD PTR _whichTimer$[ebp], 1
	jne	SHORT $LN2@TimerInit

; 192  :   {
; 193  :     timeKillEvent(hSysTimer1);

	mov	esi, esp
	mov	eax, DWORD PTR ?hSysTimer1@@3IA		; hSysTimer1
	push	eax
	call	DWORD PTR __imp__timeKillEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 194  :     hSysTimer1 = timeSetEvent(((float)rate/1000.0),0,(LPTIMECALLBACK)SysTimer1Callback,0,TIME_PERIODIC);

	mov	esi, esp
	push	1
	push	0
	push	OFFSET ?SysTimer1Callback@@YGXIIHHH@Z	; SysTimer1Callback
	push	0
	mov	ecx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	mov	DWORD PTR tv156[ebp+4], 0
	fild	QWORD PTR tv156[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	fnstcw	WORD PTR tv160[ebp]
	movzx	eax, WORD PTR tv160[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv163[ebp], eax
	fldcw	WORD PTR tv163[ebp]
	fistp	QWORD PTR tv165[ebp]
	fldcw	WORD PTR tv160[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	push	edx
	call	DWORD PTR __imp__timeSetEvent@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hSysTimer1@@3IA, eax		; hSysTimer1

; 195  :   }
; 196  :   else

	jmp	SHORT $LN1@TimerInit
$LN2@TimerInit:

; 197  :   {
; 198  :     timeKillEvent(hSysTimer2);

	mov	esi, esp
	mov	eax, DWORD PTR ?hSysTimer2@@3IA		; hSysTimer2
	push	eax
	call	DWORD PTR __imp__timeKillEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 199  :     hSysTimer2 = timeSetEvent(((float)rate/1000.0),0,(LPTIMECALLBACK)SysTimer2Callback,0,TIME_PERIODIC);

	mov	esi, esp
	push	1
	push	0
	push	OFFSET ?SysTimer2Callback@@YGXIIHHH@Z	; SysTimer2Callback
	push	0
	mov	ecx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv174[ebp], ecx
	mov	DWORD PTR tv174[ebp+4], 0
	fild	QWORD PTR tv174[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	fnstcw	WORD PTR tv178[ebp]
	movzx	eax, WORD PTR tv178[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv181[ebp], eax
	fldcw	WORD PTR tv181[ebp]
	fistp	QWORD PTR tv183[ebp]
	fldcw	WORD PTR tv178[ebp]
	mov	edx, DWORD PTR tv183[ebp]
	push	edx
	call	DWORD PTR __imp__timeSetEvent@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hSysTimer2@@3IA, eax		; hSysTimer2
$LN1@TimerInit:

; 200  :   }
; 201  : 
; 202  : }

	pop	edi
	pop	esi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?TimerInit@@YAXII@Z ENDP				; TimerInit
_TEXT	ENDS
PUBLIC	?TimerInit@@YAXPAVMPE@@@Z			; TimerInit
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_rate$ = -8						; size = 4
_whichTimer$ = -4					; size = 4
_mpe$ = 8						; size = 4
?TimerInit@@YAXPAVMPE@@@Z PROC				; TimerInit

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 206  :   int32 whichTimer = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _whichTimer$[ebp], ecx

; 207  :   int32 rate = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _rate$[ebp], eax

; 208  : 
; 209  :   if((whichTimer) < 0 || (whichTimer > 1))

	cmp	DWORD PTR _whichTimer$[ebp], 0
	jl	SHORT $LN2@TimerInit@2
	cmp	DWORD PTR _whichTimer$[ebp], 1
	jle	SHORT $LN3@TimerInit@2
$LN2@TimerInit@2:

; 210  :   {
; 211  :     mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0

; 212  :   }
; 213  :   else

	jmp	SHORT $LN4@TimerInit@2
$LN3@TimerInit@2:

; 214  :   {
; 215  :     TimerInit(whichTimer,rate);

	mov	edx, DWORD PTR _rate$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichTimer$[ebp]
	push	eax
	call	?TimerInit@@YAXII@Z			; TimerInit
	add	esp, 8

; 216  :     mpe->regs[0] = 1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 1
$LN4@TimerInit@2:

; 217  :   }
; 218  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?TimerInit@@YAXPAVMPE@@@Z ENDP				; TimerInit
_TEXT	ENDS
END
