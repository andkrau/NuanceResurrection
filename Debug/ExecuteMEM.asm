; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ExecuteMEM.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A ; bilinearAddressInfo
PUBLIC	?mipped_xoffset@@3IA				; mipped_xoffset
_BSS	SEGMENT
?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A DB 02cH DUP (?) ; bilinearAddressInfo
?mipped_xoffset@@3IA DD 01H DUP (?)			; mipped_xoffset
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12288
_DATA	ENDS
CONST	SEGMENT
$SG12288 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?GetBilinearAddress@@YAXXZ			; GetBilinearAddress
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
EXTRN	?mirrorLookup@MPE@@2PAEA:BYTE			; MPE::mirrorLookup
EXTRN	?pixel_type_width@@3PAHA:BYTE			; pixel_type_width
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\executemem.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_address$ = -12						; size = 4
_pixwidth$ = -8						; size = 4
_control$ = -4						; size = 4
?GetBilinearAddress@@YAXXZ PROC				; GetBilinearAddress

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 172  :   uint32 control = bilinearAddressInfo.control;

	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+24
	mov	DWORD PTR _control$[ebp], eax

; 173  :   int32 pixwidth = BilinearInfo_PixelWidth(pixel_type_width,control);

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	mov	DWORD PTR _pixwidth$[ebp], edx

; 174  :   uint32 address;
; 175  : 
; 176  :   if(BilinearInfo_XRev(control))

	mov	eax, DWORD PTR _control$[ebp]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN4@GetBilinea

; 177  :   {
; 178  :     *((uint8 *)&(bilinearAddressInfo.x)) = MPE::mirrorLookup[*((uint8 *)(&bilinearAddressInfo.x))];

	movzx	ecx, BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+28
	mov	dl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[ecx]
	mov	BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+28, dl

; 179  :     *(((uint8 *)&(bilinearAddressInfo.x) + 1)) = MPE::mirrorLookup[*(((uint8 *)(&bilinearAddressInfo.x)) + 1)];

	movzx	eax, BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+29
	mov	cl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[eax]
	mov	BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+29, cl

; 180  :     SwapWordBytes((uint16 *)&bilinearAddressInfo.x);

	mov	ecx, OFFSET ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+28
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes
$LN4@GetBilinea:

; 181  :   }
; 182  : 
; 183  :   if(BilinearInfo_YRev(control))

	mov	edx, DWORD PTR _control$[ebp]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN3@GetBilinea

; 184  :   {
; 185  :     *((uint8 *)&bilinearAddressInfo.y) = MPE::mirrorLookup[*((uint8 *)(&bilinearAddressInfo.y))];

	movzx	eax, BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+32
	mov	cl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[eax]
	mov	BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+32, cl

; 186  :     *(((uint8 *)&bilinearAddressInfo.y) + 1) = MPE::mirrorLookup[*(((uint8 *)(&bilinearAddressInfo.y)) + 1)];

	movzx	edx, BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+33
	mov	al, BYTE PTR ?mirrorLookup@MPE@@2PAEA[edx]
	mov	BYTE PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+33, al

; 187  :     SwapWordBytes((uint16 *)&bilinearAddressInfo.y);

	mov	ecx, OFFSET ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+32
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes
$LN3@GetBilinea:

; 188  :   }
; 189  : 
; 190  :   //*pOffsetAddress = (((MIP(y) & SIGNMIP(YTILEMASK)) >> 16) * MIP(bi->xy_width) + ((MIP(x) & SIGNMIP(XTILEMASK)) >> 16));
; 191  :   //mipped_xoffset = ((MIP(x) & SIGNMIP(XTILEMASK)) >> 16);
; 192  :   //*pOffsetAddress = (((MIP(y) & SIGNMIP(YTILEMASK)) >> 16) * MIP(BilinearInfo_XYWidth(control)) + mipped_xoffset);
; 193  :   mipped_xoffset = (MIP((bilinearAddressInfo.x)) & SIGNMIP(XTILEMASK)) >> 16;

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+28
	shr	edx, cl
	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 15					; 0000000fH
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	mov	eax, -65536				; ffff0000H
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	sar	eax, cl
	and	edx, eax
	shr	edx, 16					; 00000010H
	mov	DWORD PTR ?mipped_xoffset@@3IA, edx	; mipped_xoffset

; 194  :   address = (((MIP((bilinearAddressInfo.y)) & SIGNMIP(YTILEMASK)) >> 16) * MIP(BilinearInfo_XYWidth(control)) + mipped_xoffset);

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+32
	shr	edx, cl
	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 12					; 0000000cH
	and	eax, 15					; 0000000fH
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	mov	eax, -65536				; ffff0000H
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	sar	eax, cl
	and	edx, eax
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR _control$[ebp]
	and	eax, 2047				; 000007ffH
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	shr	eax, cl
	imul	edx, eax
	add	edx, DWORD PTR ?mipped_xoffset@@3IA	; mipped_xoffset
	mov	DWORD PTR _address$[ebp], edx

; 195  : 
; 196  :   if(pixwidth >= 0)

	cmp	DWORD PTR _pixwidth$[ebp], 0
	jl	SHORT $LN2@GetBilinea

; 197  :   {
; 198  :     //Everything but 4-bit pixels and MPEG
; 199  :     address <<= pixel_type_width[(control >> 20) & 0x0FUL];

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	mov	DWORD PTR _address$[ebp], edx

; 200  :   }
; 201  :   else

	jmp	SHORT $LN1@GetBilinea
$LN2@GetBilinea:

; 202  :   {
; 203  :     //4-bit pixels
; 204  :     address >>= 1;

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 1
	mov	DWORD PTR _address$[ebp], eax
$LN1@GetBilinea:

; 205  :   }
; 206  : 
; 207  :   bilinearAddressInfo.offset_address = (bilinearAddressInfo.base & 0xFFFFFFFC) + address;

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+20
	and	ecx, -4					; fffffffcH
	add	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+40, ecx

; 208  :   bilinearAddressInfo.mipped_xoffset = mipped_xoffset;

	mov	edx, DWORD PTR ?mipped_xoffset@@3IA	; mipped_xoffset
	mov	DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+36, edx

; 209  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBilinearAddress@@YAXXZ ENDP				; GetBilinearAddress
_TEXT	ENDS
PUBLIC	?Execute_Mirror@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_Mirror
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_x$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_Mirror@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_Mirror

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 213  :   uint32 x = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _x$[ebp], ecx

; 214  : 
; 215  :   x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));

	mov	edx, DWORD PTR _x$[ebp]
	and	edx, -1431655766			; aaaaaaaaH
	shr	edx, 1
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 1431655765				; 55555555H
	shl	eax, 1
	or	edx, eax
	mov	DWORD PTR _x$[ebp], edx

; 216  : 	x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));

	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, -858993460				; ccccccccH
	shr	ecx, 2
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 858993459				; 33333333H
	shl	edx, 2
	or	ecx, edx
	mov	DWORD PTR _x$[ebp], ecx

; 217  : 	x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, -252645136				; f0f0f0f0H
	shr	eax, 4
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 252645135				; 0f0f0f0fH
	shl	ecx, 4
	or	eax, ecx
	mov	DWORD PTR _x$[ebp], eax

; 218  : 	x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));

	mov	edx, DWORD PTR _x$[ebp]
	and	edx, -16711936				; ff00ff00H
	shr	edx, 8
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 16711935				; 00ff00ffH
	shl	eax, 8
	or	edx, eax
	mov	DWORD PTR _x$[ebp], edx

; 219  : 	
; 220  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = ((x >> 16) | (x << 16));

	mov	ecx, DWORD PTR _x$[ebp]
	shr	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _x$[ebp]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_Mirror@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_Mirror
_TEXT	ENDS
PUBLIC	?Execute_MV_SImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MV_SImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MV_SImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MV_SImmediate

; 223  : {

	push	ebp
	mov	ebp, esp

; 224  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+ecx*4], eax

; 225  : }

	pop	ebp
	ret	0
?Execute_MV_SImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MV_SImmediate
_TEXT	ENDS
PUBLIC	?Execute_MV_SScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MV_SScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MV_SScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MV_SScalar

; 227  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 228  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+edx*4], eax

; 229  : }

	pop	esi
	pop	ebp
	ret	0
?Execute_MV_SScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MV_SScalar
_TEXT	ENDS
PUBLIC	?Execute_MV_V@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MV_V
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -8						; size = 4
_src$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MV_V@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MV_V

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 232  :   uint32 src = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _src$[ebp], ecx

; 233  :   uint32 dest = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dest$[ebp], eax

; 234  : 
; 235  :   mpe.regs[dest] = entry.pScalarRegs[src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 236  :   mpe.regs[dest + 1] = entry.pScalarRegs[src + 1];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 237  :   mpe.regs[dest + 2] = entry.pScalarRegs[src + 2];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+esi*4+8]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 238  :   mpe.regs[dest + 3] = entry.pScalarRegs[src + 3];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [edx+esi*4+12]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 239  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MV_V@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MV_V
_TEXT	ENDS
PUBLIC	?Execute_PopVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PopVector
EXTRN	?SwapVectorBytes@@YIXPAI@Z:PROC			; SwapVectorBytes
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest_vector$ = -28					; size = 16
_destPtr$ = -8						; size = 4
_srcPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PopVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PopVector

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 242  :   uint32 *srcPtr;
; 243  :   uint32 *destPtr;
; 244  :   uint32 dest_vector[4];
; 245  : 
; 246  :   srcPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _mpe$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 247  : 
; 248  :   dest_vector[0] = srcPtr[0];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest_vector$[ebp], ecx

; 249  :   dest_vector[1] = srcPtr[1];

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dest_vector$[ebp+4], eax

; 250  :   dest_vector[2] = srcPtr[2];

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dest_vector$[ebp+8], edx

; 251  :   dest_vector[3] = srcPtr[3];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dest_vector$[ebp+12], ecx

; 252  : 
; 253  :   destPtr = (uint32 *)&(mpe.regs[nuance.fields[FIELD_MEM_TO]]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _destPtr$[ebp], edx

; 254  : 
; 255  :   SwapVectorBytes(dest_vector);

	lea	ecx, DWORD PTR _dest_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 256  : 
; 257  :   destPtr[0] = dest_vector[0];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp]
	mov	DWORD PTR [eax], ecx

; 258  :   destPtr[1] = dest_vector[1];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _dest_vector$[ebp+4]
	mov	DWORD PTR [edx+4], eax

; 259  :   destPtr[2] = dest_vector[2];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 260  :   destPtr[3] = dest_vector[3];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 261  : 
; 262  :   mpe.sp += 16;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+464]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 263  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Po
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Execute_Po:
	DD	1
	DD	$LN4@Execute_Po
$LN4@Execute_Po:
	DD	-28					; ffffffe4H
	DD	16					; 00000010H
	DD	$LN3@Execute_Po
$LN3@Execute_Po:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PopVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PopVector
_TEXT	ENDS
PUBLIC	?Execute_PopVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PopVectorRz
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -32						; size = 4
_srcPtr$ = -28						; size = 4
_dest_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PopVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PopVectorRz

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 266  :   uint32 dest_vector[4];
; 267  :   uint32  *srcPtr;
; 268  :   uint32 *destPtr;
; 269  : 
; 270  :   srcPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _mpe$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 271  : 
; 272  :   dest_vector[0] = srcPtr[0];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest_vector$[ebp], ecx

; 273  :   dest_vector[1] = srcPtr[1];

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dest_vector$[ebp+4], eax

; 274  :   dest_vector[2] = srcPtr[2];

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dest_vector$[ebp+8], edx

; 275  :   dest_vector[3] = srcPtr[3];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dest_vector$[ebp+12], ecx

; 276  : 
; 277  :   destPtr = (uint32 *)&mpe.regs[nuance.fields[FIELD_MEM_TO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _destPtr$[ebp], edx

; 278  : 
; 279  :   SwapVectorBytes(dest_vector);

	lea	ecx, DWORD PTR _dest_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 280  : 
; 281  :   destPtr[0] = dest_vector[0];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp]
	mov	DWORD PTR [eax], ecx

; 282  :   destPtr[1] = dest_vector[1];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _dest_vector$[ebp+4]
	mov	DWORD PTR [edx+4], eax

; 283  :   destPtr[2] = dest_vector[2];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 284  :   mpe.rz = dest_vector[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp+12]
	mov	DWORD PTR [eax+156], ecx

; 285  : 
; 286  :   mpe.sp += 16;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+464]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 287  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Po@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_Po@2:
	DD	1
	DD	$LN4@Execute_Po@2
$LN4@Execute_Po@2:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Po@2
$LN3@Execute_Po@2:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PopVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PopVectorRz
_TEXT	ENDS
PUBLIC	?Execute_PopScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PopScalarRzi1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_srcPtr$ = -28						; size = 4
_dest_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PopScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PopScalarRzi1

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 290  :   uint32 dest_vector[4];
; 291  :   uint32  *srcPtr;
; 292  : 
; 293  :   srcPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _mpe$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 294  : 
; 295  :   dest_vector[0] = srcPtr[0];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest_vector$[ebp], ecx

; 296  :   dest_vector[1] = srcPtr[1];

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dest_vector$[ebp+4], eax

; 297  :   dest_vector[2] = srcPtr[2];

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dest_vector$[ebp+8], edx

; 298  :   dest_vector[3] = srcPtr[3];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dest_vector$[ebp+12], ecx

; 299  : 
; 300  :   SwapVectorBytes(dest_vector);

	lea	ecx, DWORD PTR _dest_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 301  : 
; 302  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = dest_vector[0];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 303  :   mpe.cc = dest_vector[1];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp+4]
	mov	DWORD PTR [eax+128], ecx

; 304  :   mpe.rzi1 = dest_vector[2];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _dest_vector$[ebp+8]
	mov	DWORD PTR [edx+160], eax

; 305  :   mpe.rz = dest_vector[3];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp+12]
	mov	DWORD PTR [ecx+156], edx

; 306  : 
; 307  :   mpe.sp += 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 308  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Po@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_Po@3:
	DD	1
	DD	$LN4@Execute_Po@3
$LN4@Execute_Po@3:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Po@3
$LN3@Execute_Po@3:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PopScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PopScalarRzi1
_TEXT	ENDS
PUBLIC	?Execute_PopScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PopScalarRzi2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_srcPtr$ = -28						; size = 4
_dest_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PopScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PopScalarRzi2

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 311  :   uint32 dest_vector[4];
; 312  :   uint32  *srcPtr;
; 313  : 
; 314  :   srcPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _mpe$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 315  : 
; 316  :   dest_vector[0] = srcPtr[0];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest_vector$[ebp], ecx

; 317  :   dest_vector[1] = srcPtr[1];

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dest_vector$[ebp+4], eax

; 318  :   dest_vector[2] = srcPtr[2];

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dest_vector$[ebp+8], edx

; 319  :   dest_vector[3] = srcPtr[3];

	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dest_vector$[ebp+12], ecx

; 320  : 
; 321  :   SwapVectorBytes(dest_vector);

	lea	ecx, DWORD PTR _dest_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 322  : 
; 323  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = dest_vector[0];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 324  :   mpe.cc = dest_vector[1];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest_vector$[ebp+4]
	mov	DWORD PTR [eax+128], ecx

; 325  :   mpe.rzi2 = dest_vector[2];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _dest_vector$[ebp+8]
	mov	DWORD PTR [edx+164], eax

; 326  :   mpe.rz = dest_vector[3];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest_vector$[ebp+12]
	mov	DWORD PTR [ecx+156], edx

; 327  : 
; 328  :   mpe.sp += 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 329  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Po@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_Po@4:
	DD	1
	DD	$LN4@Execute_Po@4
$LN4@Execute_Po@4:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Po@4
$LN3@Execute_Po@4:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PopScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PopScalarRzi2
_TEXT	ENDS
PUBLIC	?Execute_PushVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PushVector
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -32						; size = 4
_pVal$ = -28						; size = 4
_src_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PushVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PushVector

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 332  :   uint32 src_vector[4];
; 333  :   uint32 *pVal;
; 334  :   uint32 *destPtr;
; 335  : 
; 336  :   mpe.sp -= 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 337  : 
; 338  :   pVal = &(entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pVal$[ebp], ecx

; 339  : 
; 340  :   src_vector[0] = pVal[0];

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _src_vector$[ebp], eax

; 341  :   src_vector[1] = pVal[1];

	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _src_vector$[ebp+4], edx

; 342  :   src_vector[2] = pVal[2];

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src_vector$[ebp+8], ecx

; 343  :   src_vector[3] = pVal[3];

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src_vector$[ebp+12], eax

; 344  : 
; 345  :   destPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _mpe$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	DWORD PTR _destPtr$[ebp], edx

; 346  : 
; 347  :   SwapVectorBytes(src_vector);

	lea	ecx, DWORD PTR _src_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 348  : 
; 349  :   destPtr[0] = src_vector[0];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp]
	mov	DWORD PTR [ecx], edx

; 350  :   destPtr[1] = src_vector[1];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src_vector$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 351  :   destPtr[2] = src_vector[2];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src_vector$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 352  :   destPtr[3] = src_vector[3];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp+12]
	mov	DWORD PTR [ecx+12], edx

; 353  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Pu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_Pu:
	DD	1
	DD	$LN4@Execute_Pu
$LN4@Execute_Pu:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Pu
$LN3@Execute_Pu:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PushVector@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PushVector
_TEXT	ENDS
PUBLIC	?Execute_PushVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PushVectorRz
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -32						; size = 4
_pVal$ = -28						; size = 4
_src_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PushVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PushVectorRz

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 356  :   uint32 src_vector[4];
; 357  :   uint32 *pVal;
; 358  :   uint32 *destPtr;
; 359  : 
; 360  :   mpe.sp -= 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 361  : 
; 362  :   pVal = &(entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pVal$[ebp], ecx

; 363  : 
; 364  :   src_vector[0] = pVal[0];

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _src_vector$[ebp], eax

; 365  :   src_vector[1] = pVal[1];

	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _src_vector$[ebp+4], edx

; 366  :   src_vector[2] = pVal[2];

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src_vector$[ebp+8], ecx

; 367  :   src_vector[3] = entry.pRzRegs[0];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _src_vector$[ebp+12], ecx

; 368  : 
; 369  :   destPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+464]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _mpe$[ebp]
	add	eax, DWORD PTR [ecx+560]
	mov	DWORD PTR _destPtr$[ebp], eax

; 370  : 
; 371  :   SwapVectorBytes(src_vector);

	lea	ecx, DWORD PTR _src_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 372  : 
; 373  :   destPtr[0] = src_vector[0];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src_vector$[ebp]
	mov	DWORD PTR [edx], eax

; 374  :   destPtr[1] = src_vector[1];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp+4]
	mov	DWORD PTR [ecx+4], edx

; 375  :   destPtr[2] = src_vector[2];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src_vector$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 376  :   destPtr[3] = src_vector[3];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src_vector$[ebp+12]
	mov	DWORD PTR [edx+12], eax

; 377  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Pu@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Execute_Pu@2:
	DD	1
	DD	$LN4@Execute_Pu@2
$LN4@Execute_Pu@2:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Pu@2
$LN3@Execute_Pu@2:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PushVectorRz@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PushVectorRz
_TEXT	ENDS
PUBLIC	?Execute_PushScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PushScalarRzi1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -28						; size = 4
_src_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PushScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PushScalarRzi1

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 380  :   uint32 src_vector[4];
; 381  :   uint32 *destPtr;
; 382  : 
; 383  :   mpe.sp -= 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 384  : 
; 385  :   src_vector[0] = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src_vector$[ebp], ecx

; 386  :   src_vector[1] = mpe.tempCC;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+320]
	mov	DWORD PTR _src_vector$[ebp+4], eax

; 387  :   src_vector[2] = entry.pRzRegs[1];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _src_vector$[ebp+8], eax

; 388  :   src_vector[3] = entry.pRzRegs[0];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _src_vector$[ebp+12], eax

; 389  : 
; 390  :   destPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _mpe$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	DWORD PTR _destPtr$[ebp], edx

; 391  : 
; 392  :   SwapVectorBytes(src_vector);

	lea	ecx, DWORD PTR _src_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 393  : 
; 394  :   destPtr[0] = src_vector[0];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp]
	mov	DWORD PTR [ecx], edx

; 395  :   destPtr[1] = src_vector[1];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src_vector$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 396  :   destPtr[2] = src_vector[2];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src_vector$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 397  :   destPtr[3] = src_vector[3];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp+12]
	mov	DWORD PTR [ecx+12], edx

; 398  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Pu@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Execute_Pu@3:
	DD	1
	DD	$LN4@Execute_Pu@3
$LN4@Execute_Pu@3:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Pu@3
$LN3@Execute_Pu@3:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PushScalarRzi1@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PushScalarRzi1
_TEXT	ENDS
PUBLIC	?Execute_PushScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_PushScalarRzi2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -28						; size = 4
_src_vector$ = -20					; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_PushScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_PushScalarRzi2

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 401  :   uint32 src_vector[4];
; 402  :   uint32 *destPtr;
; 403  : 
; 404  :   mpe.sp -= 16;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 405  : 
; 406  :   src_vector[0] = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src_vector$[ebp], ecx

; 407  :   src_vector[1] = mpe.tempCC;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+320]
	mov	DWORD PTR _src_vector$[ebp+4], eax

; 408  :   src_vector[2] = entry.pRzRegs[2];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _src_vector$[ebp+8], eax

; 409  :   src_vector[3] = entry.pRzRegs[0];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _src_vector$[ebp+12], eax

; 410  : 
; 411  :   destPtr = (uint32 *)&(mpe.dtrom[mpe.sp & MPE_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _mpe$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	DWORD PTR _destPtr$[ebp], edx

; 412  : 
; 413  :   SwapVectorBytes(src_vector);

	lea	ecx, DWORD PTR _src_vector$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 414  : 
; 415  :   destPtr[0] = src_vector[0];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp]
	mov	DWORD PTR [ecx], edx

; 416  :   destPtr[1] = src_vector[1];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src_vector$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 417  :   destPtr[2] = src_vector[2];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src_vector$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 418  :   destPtr[3] = src_vector[3];

	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src_vector$[ebp+12]
	mov	DWORD PTR [ecx+12], edx

; 419  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Pu@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Execute_Pu@4:
	DD	1
	DD	$LN4@Execute_Pu@4
$LN4@Execute_Pu@4:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Pu@4
$LN3@Execute_Pu@4:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Execute_PushScalarRzi2@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_PushScalarRzi2
_TEXT	ENDS
PUBLIC	?Execute_LoadScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarControlRegisterAbsolute
EXTRN	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z:PROC ; MPE::ReadControlRegister
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadScalarControlRegisterAbsolute

; 421  : {

	push	ebp
	mov	ebp, esp

; 422  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = mpe.ReadControlRegister(nuance.fields[FIELD_MEM_FROM] - MPE_CTRL_BASE, &entry);

	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 542113792				; 20500000H
	push	edx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 423  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Execute_LoadScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadScalarControlRegisterAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_data$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadByteAbsolute

; 425  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 426  :   uint32 data;
; 427  :   data = *((uint8 *)nuance.fields[FIELD_MEM_POINTER]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _data$[ebp], edx

; 428  :   data <<= 24;

	mov	eax, DWORD PTR _data$[ebp]
	shl	eax, 24					; 00000018H
	mov	DWORD PTR _data$[ebp], eax

; 429  : 
; 430  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = data;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 431  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadByteAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_data$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadWordAbsolute

; 433  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 434  :   uint32 data;
; 435  :   data = ((uint32)(*((uint8 *)nuance.fields[FIELD_MEM_POINTER]))) << 24;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	shl	edx, 24					; 00000018H
	mov	DWORD PTR _data$[ebp], edx

; 436  :   data =  data | (((uint32)( *((uint8 *)(nuance.fields[FIELD_MEM_POINTER]+1)) )) << 16);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 16					; 00000010H
	or	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _data$[ebp], edx

; 437  : 
; 438  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = data;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 439  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadWordAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarAbsolute
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_data$ = -8						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadScalarAbsolute

; 441  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 442  :   uint32 data;
; 443  : 
; 444  :   data = *((uint32 *)nuance.fields[FIELD_MEM_POINTER]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _data$[ebp], edx

; 445  :   SwapScalarBytes(&data);

	lea	ecx, DWORD PTR _data$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 446  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = data;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 447  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Lo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Execute_Lo:
	DD	1
	DD	$LN4@Execute_Lo
$LN4@Execute_Lo:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN3@Execute_Lo
$LN3@Execute_Lo:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadScalarAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarLinear
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_data$ = -16						; size = 4
_address$ = -8						; size = 4
_dest$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadScalarLinear

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 450  :   uint32 dest, address, data;
; 451  :   dest = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp], ecx

; 452  :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _address$[ebp], eax

; 453  : 
; 454  :   if((address < MPE_CTRL_BASE) || (address >= MPE_RESV_BASE))

	cmp	DWORD PTR _address$[ebp], 542113792	; 20500000H
	jb	SHORT $LN4@Execute_Lo@2
	cmp	DWORD PTR _address$[ebp], 543162368	; 20600000H
	jb	SHORT $LN5@Execute_Lo@2
$LN4@Execute_Lo@2:

; 455  :   {
; 456  :     //The reserved area from $00000000 to $1FFFFFFF might always return zero
; 457  :     //Freefall has a routine which will purposely read from $0 instead of skipping directly to
; 458  :     //the epilogue code
; 459  :     if(address >= MPE_ADDR_SPACE_BASE)

	cmp	DWORD PTR _address$[ebp], 536870912	; 20000000H
	jb	SHORT $LN3@Execute_Lo@2

; 460  :     {
; 461  :       data = *((uint32 *)(nuonEnv->GetPointerToMemory(&mpe,address & 0xFFFFFFFC)));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, -4					; fffffffcH
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _data$[ebp], eax

; 462  :       SwapScalarBytes(&data);

	lea	ecx, DWORD PTR _data$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 463  :     }
; 464  :     else

	jmp	SHORT $LN2@Execute_Lo@2
$LN3@Execute_Lo@2:

; 465  :     {
; 466  :       data = 0;

	mov	DWORD PTR _data$[ebp], 0
$LN2@Execute_Lo@2:

; 467  :     }
; 468  : 
; 469  :     mpe.regs[dest] = data;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 470  :   }
; 471  :   else

	jmp	SHORT $LN6@Execute_Lo@2
$LN5@Execute_Lo@2:

; 472  :   {
; 473  :     mpe.regs[dest] = mpe.ReadControlRegister(address - MPE_CTRL_BASE, &entry);

	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _address$[ebp]
	sub	edx, 542113792				; 20500000H
	push	edx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN6@Execute_Lo@2:

; 474  :   }
; 475  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Execute_Lo@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Execute_Lo@2:
	DD	1
	DD	$LN9@Execute_Lo@2
$LN9@Execute_Lo@2:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN8@Execute_Lo@2
$LN8@Execute_Lo@2:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?Execute_LoadScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadScalarLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_srcPtr$ = -8						; size = 4
_destPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadVectorAbsolute

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 478  :   uint32 *destPtr;
; 479  :   uint32 *srcPtr = (uint32 *)nuance.fields[FIELD_MEM_POINTER];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 480  :   
; 481  :   destPtr = &mpe.regs[nuance.fields[FIELD_MEM_TO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _destPtr$[ebp], edx

; 482  : 
; 483  :   destPtr[0] = srcPtr[0];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 484  :   destPtr[1] = srcPtr[1];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 485  :   destPtr[2] = srcPtr[2];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 486  :   destPtr[3] = srcPtr[3];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 487  : 
; 488  :   SwapVectorBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 489  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadVectorAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorControlRegisterAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -8						; size = 4
_dest$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadVectorControlRegisterAbsolute

; 491  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 492  :   uint32 dest = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp], ecx

; 493  :   uint32 address = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _address$[ebp], eax

; 494  : 
; 495  :   mpe.regs[dest] = mpe.ReadControlRegister(address - MPE_CTRL_BASE, &entry);

	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _address$[ebp]
	sub	edx, 542113792				; 20500000H
	push	edx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 496  :   mpe.regs[dest + 1] = mpe.ReadControlRegister(address + 4 - MPE_CTRL_BASE, &entry);

	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113788				; 204ffffcH
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	edx, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 497  :   mpe.regs[dest + 2] = mpe.ReadControlRegister(address + 8 - MPE_CTRL_BASE, &entry);

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113784				; 204ffff8H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 498  :   mpe.regs[dest + 3] = mpe.ReadControlRegister(address + 12 - MPE_CTRL_BASE, &entry);

	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113780				; 204ffff4H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	edx, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4+12], eax

; 499  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadVectorControlRegisterAbsolute
_TEXT	ENDS
PUBLIC	?LoadPixelAbsolute@@YAXXZ			; LoadPixelAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv67 = -36						; size = 4
_memPtr$ = -32						; size = 4
_bChnorm$ = -28						; size = 4
_pixType$ = -24						; size = 4
_regs$ = -20						; size = 4
_pixelData32$ = -12					; size = 4
_control$ = -4						; size = 4
?LoadPixelAbsolute@@YAXXZ PROC				; LoadPixelAbsolute

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 503  :   uint32 control;
; 504  :   uint32 pixelData32;
; 505  :   uint32 *regs;
; 506  :   uint32 pixType;
; 507  :   uint32 bChnorm;
; 508  :   
; 509  :   void *memPtr;
; 510  :   
; 511  :   control = bilinearAddressInfo.control;

	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+24
	mov	DWORD PTR _control$[ebp], eax

; 512  :   memPtr = bilinearAddressInfo.pPixelData;

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+4
	mov	DWORD PTR _memPtr$[ebp], ecx

; 513  :   regs = bilinearAddressInfo.pRegs;

	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+8
	mov	DWORD PTR _regs$[ebp], edx

; 514  :   pixType = BilinearInfo_XYType(control);

	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 515  :   bChnorm = BilinearInfo_XYChnorm(control);

	mov	ecx, DWORD PTR _control$[ebp]
	and	ecx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], ecx

; 516  :   
; 517  :   switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 6
	ja	$LN10@LoadPixelA
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN15@LoadPixelA[eax*4]
$LN7@LoadPixelA:

; 518  :   {
; 519  :     case 0x0:
; 520  :       //MPEG
; 521  :       return;

	jmp	$LN10@LoadPixelA
$LN6@LoadPixelA:

; 522  :     case 0x1:
; 523  :       //4 bit
; 524  :       //The initial xoffset is guaranteed to start at the first pixel of a group of four.  
; 525  :       //This means that for even values of X, the pixel bits to be extracted are always [7:4]
; 526  :       //and for odd values of X, the pixel bits to be extracted are [3:0]
; 527  : 
; 528  :       pixelData32 = (*((uint8 *)memPtr) >> (4 - ((bilinearAddressInfo.mipped_xoffset & 1) << 2))) & 0x0FUL;

	mov	ecx, DWORD PTR _memPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+36
	and	eax, 1
	shl	eax, 2
	mov	ecx, 4
	sub	ecx, eax
	sar	edx, cl
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixelData32$[ebp], edx

; 529  :       regs[0] = (bilinearAddressInfo.clutBase & 0xFFFFFFC0UL) | (pixelData32 << 2);

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A
	and	ecx, -64				; ffffffc0H
	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax], ecx

; 530  :       regs[1] = 0;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 531  :       regs[2] = 0;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], 0

; 532  :       return;

	jmp	$LN10@LoadPixelA
$LN5@LoadPixelA:

; 533  :     case 0x2:
; 534  :     case 0x5:
; 535  :     {
; 536  :       //16
; 537  :       pixelData32 = *((uint32 *)memPtr);

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 538  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 539  :       regs[0] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shr	edx, 2
	and	edx, 1056964608				; 3f000000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax], edx

; 540  :       regs[1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 4
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 541  :       regs[2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 9
	and	eax, 1040187392				; 3e000000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 542  : 
; 543  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN4@LoadPixelA

; 544  :       {
; 545  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFE000000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -33554432				; fe000000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 546  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFE000000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 536870912				; 20000000H
	and	eax, -33554432				; fe000000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN4@LoadPixelA:

; 547  :       }
; 548  : 
; 549  :       return;

	jmp	$LN10@LoadPixelA
$LN3@LoadPixelA:

; 550  :     }
; 551  :     case 0x3:
; 552  :       //8 bit
; 553  :       pixelData32 = *((uint8 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 554  :       regs[0] = (bilinearAddressInfo.clutBase & 0xFFFFFC00UL) | (pixelData32 << 2);

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A
	and	ecx, -1024				; fffffc00H
	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax], ecx

; 555  :       regs[1] = 0;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 556  :       regs[2] = 0;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], 0

; 557  :       return;

	jmp	SHORT $LN10@LoadPixelA
$LN2@LoadPixelA:

; 558  :     case 0x4:
; 559  :     case 0x6:
; 560  :     {
; 561  :       //32 bit or 32+32Z (both behave the same for LD_P)
; 562  :       pixelData32 = *((uint32 *)memPtr);

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 563  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 564  :       regs[0] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shr	edx, 2
	and	edx, 1069547520				; 3fc00000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax], edx

; 565  :       regs[1] = ((pixelData32 << 6)) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 6
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 566  :       regs[2] = ((pixelData32 << 14)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 14					; 0000000eH
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 567  : 
; 568  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN10@LoadPixelA

; 569  :       {
; 570  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 571  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN10@LoadPixelA:

; 572  :       }
; 573  : 
; 574  :       return;
; 575  :     }
; 576  :   }
; 577  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@LoadPixelA
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@LoadPixelA:
	DD	1
	DD	$LN13@LoadPixelA
$LN13@LoadPixelA:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN12@LoadPixelA
$LN12@LoadPixelA:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN15@LoadPixelA:
	DD	$LN7@LoadPixelA
	DD	$LN6@LoadPixelA
	DD	$LN5@LoadPixelA
	DD	$LN3@LoadPixelA
	DD	$LN2@LoadPixelA
	DD	$LN5@LoadPixelA
	DD	$LN2@LoadPixelA
?LoadPixelAbsolute@@YAXXZ ENDP				; LoadPixelAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv91 = -32						; size = 4
_memPtr$ = -28						; size = 4
_bChnorm$ = -24						; size = 4
_pixType$ = -20						; size = 4
_dest$ = -16						; size = 4
_pixelData32$ = -8					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelAbsolute

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 581  :   uint32 pixelData32;
; 582  :   uint32 dest;
; 583  :   uint32 pixType;
; 584  :   uint32 bChnorm;
; 585  :   
; 586  :   void *memPtr;
; 587  :   
; 588  :   memPtr = (void *)((uint32 *)nuance.fields[FIELD_MEM_POINTER]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _memPtr$[ebp], ecx

; 589  :   dest = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dest$[ebp], eax

; 590  :   
; 591  :   if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_UV)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 8
	je	SHORT $LN13@Execute_Lo@3

; 592  :   {
; 593  :     pixType = BilinearInfo_XYType(*entry.pUvctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 20					; 00000014H
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], edx

; 594  :     bChnorm = BilinearInfo_XYChnorm(*entry.pUvctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	and	edx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], edx
	jmp	SHORT $LN12@Execute_Lo@3
$LN13@Execute_Lo@3:

; 595  :   }
; 596  :   else if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_XY)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 4
	je	SHORT $LN11@Execute_Lo@3

; 597  :   {
; 598  :     pixType = BilinearInfo_XYType(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 599  :     bChnorm = BilinearInfo_XYChnorm(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], ecx

; 600  :   }
; 601  :   else

	jmp	SHORT $LN12@Execute_Lo@3
$LN11@Execute_Lo@3:

; 602  :   {
; 603  :     pixType = BilinearInfo_XYType(mpe.linpixctl);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+456]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 604  :     bChnorm = BilinearInfo_XYChnorm(mpe.linpixctl);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+456]
	and	edx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], edx
$LN12@Execute_Lo@3:

; 605  :   }
; 606  : 
; 607  :   switch(pixType)

	mov	eax, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 6
	ja	$LN14@Execute_Lo@3
	mov	ecx, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN19@Execute_Lo@3[ecx*4]
$LN7@Execute_Lo@3:

; 608  :   {
; 609  :     case 0x0:
; 610  :       //MPEG
; 611  :       return;

	jmp	$LN14@Execute_Lo@3
$LN6@Execute_Lo@3:

; 612  :     case 0x1:
; 613  :       //4 bit
; 614  :       //The initial xoffset is guaranteed to start at the first pixel of a group of four.  
; 615  :       //This means that for even values of X, the pixel bits to be extracted are always [7:4]
; 616  :       //and for odd values of X, the pixel bits to be extracted are [3:0]
; 617  : 
; 618  :       pixelData32 = (*((uint8 *)memPtr) >> (4 - ((mipped_xoffset & 1) << 2))) & 0x0FUL;

	mov	edx, DWORD PTR _memPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR ?mipped_xoffset@@3IA	; mipped_xoffset
	and	ecx, 1
	shl	ecx, 2
	mov	edx, 4
	sub	edx, ecx
	mov	ecx, edx
	sar	eax, cl
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixelData32$[ebp], eax

; 619  :       mpe.regs[dest] = (mpe.clutbase & 0xFFFFFFC0UL) | (pixelData32 << 2);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+460]
	and	ecx, -64				; ffffffc0H
	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 620  :       mpe.regs[dest+1] = 0;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], 0

; 621  :       mpe.regs[dest+2] = 0;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], 0

; 622  :       return;

	jmp	$LN14@Execute_Lo@3
$LN5@Execute_Lo@3:

; 623  :     case 0x2:
; 624  :     case 0x5:
; 625  :     {
; 626  :       //16
; 627  :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 628  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 629  :       mpe.regs[dest] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1056964608				; 3f000000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 630  :       mpe.regs[dest+1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 4
	and	eax, 1040187392				; 3e000000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 631  :       mpe.regs[dest+2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 9
	and	eax, 1040187392				; 3e000000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 632  : 
; 633  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN4@Execute_Lo@3

; 634  :       {
; 635  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFE000000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	sub	edx, 536870912				; 20000000H
	and	edx, -33554432				; fe000000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 636  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFE000000UL;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	sub	ecx, 536870912				; 20000000H
	and	ecx, -33554432				; fe000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx
$LN4@Execute_Lo@3:

; 637  :       }
; 638  : 
; 639  :       return;

	jmp	$LN14@Execute_Lo@3
$LN3@Execute_Lo@3:

; 640  :     }
; 641  :     case 0x3:
; 642  :       //8 bit
; 643  :       pixelData32 = *((uint8 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 644  :       mpe.regs[dest] = (mpe.clutbase & 0xFFFFFC00UL) | (pixelData32 << 2);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+460]
	and	ecx, -1024				; fffffc00H
	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 645  :       mpe.regs[dest+1] = 0;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], 0

; 646  :       mpe.regs[dest+2] = 0;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], 0

; 647  :       return;

	jmp	$LN14@Execute_Lo@3
$LN2@Execute_Lo@3:

; 648  :     case 0x4:
; 649  :     case 0x6:
; 650  :     {
; 651  :       //32 bit or 32+32Z (both behave the same for LD_P)
; 652  :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 653  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 654  :       mpe.regs[dest] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 655  :       mpe.regs[dest+1] = ((pixelData32 << 6)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 6
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 656  :       mpe.regs[dest+2] = ((pixelData32 << 14)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 14					; 0000000eH
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 657  : 
; 658  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN14@Execute_Lo@3

; 659  :       {
; 660  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFFC00000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	sub	edx, 536870912				; 20000000H
	and	edx, -4194304				; ffc00000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 661  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	sub	ecx, 536870912				; 20000000H
	and	ecx, -4194304				; ffc00000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx
$LN14@Execute_Lo@3:

; 662  :       }
; 663  : 
; 664  :       return;
; 665  :     }
; 666  :   }
; 667  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@Execute_Lo@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@Execute_Lo@3:
	DD	1
	DD	$LN17@Execute_Lo@3
$LN17@Execute_Lo@3:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN16@Execute_Lo@3
$LN16@Execute_Lo@3:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN19@Execute_Lo@3:
	DD	$LN7@Execute_Lo@3
	DD	$LN6@Execute_Lo@3
	DD	$LN5@Execute_Lo@3
	DD	$LN3@Execute_Lo@3
	DD	$LN2@Execute_Lo@3
	DD	$LN5@Execute_Lo@3
	DD	$LN2@Execute_Lo@3
?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelAbsolute
_TEXT	ENDS
PUBLIC	?LoadPixelZAbsolute@@YAXXZ			; LoadPixelZAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv67 = -48						; size = 4
_memPtr$ = -44						; size = 4
_bChnorm$ = -40						; size = 4
_pixType$ = -36						; size = 4
_regs$ = -32						; size = 4
_zData32$ = -24						; size = 4
_pixelData32$ = -12					; size = 4
_control$ = -4						; size = 4
?LoadPixelZAbsolute@@YAXXZ PROC				; LoadPixelZAbsolute

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 671  :   uint32 control;
; 672  :   uint32 pixelData32, zData32;
; 673  :   uint32 *regs;
; 674  :   uint32 pixType;
; 675  :   uint32 bChnorm;
; 676  :   
; 677  :   void *memPtr;
; 678  :   
; 679  :   control = bilinearAddressInfo.control;

	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+24
	mov	DWORD PTR _control$[ebp], eax

; 680  :   memPtr = bilinearAddressInfo.pPixelData;

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+4
	mov	DWORD PTR _memPtr$[ebp], ecx

; 681  :   regs = bilinearAddressInfo.pRegs;

	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+8
	mov	DWORD PTR _regs$[ebp], edx

; 682  :   pixType = BilinearInfo_XYType(control);

	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 683  :   bChnorm = BilinearInfo_XYChnorm(control);

	mov	ecx, DWORD PTR _control$[ebp]
	and	ecx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], ecx

; 684  : 
; 685  :   switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 6
	ja	$LN14@LoadPixelZ
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN20@LoadPixelZ[eax*4]
$LN11@LoadPixelZ:

; 686  :   {
; 687  :     case 0x0:
; 688  :       //MPEG
; 689  :       return;

	jmp	$LN14@LoadPixelZ
$LN10@LoadPixelZ:

; 690  :     case 0x1:
; 691  :       //4 bit
; 692  :       return;

	jmp	$LN14@LoadPixelZ
$LN9@LoadPixelZ:

; 693  :     case 0x2:
; 694  :     {
; 695  :       //16
; 696  :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 697  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 698  :       regs[0] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1056964608				; 3f000000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx], eax

; 699  :       regs[1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 4
	and	edx, 1040187392				; 3e000000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+4], edx

; 700  :       regs[2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 9
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 701  : 
; 702  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN8@LoadPixelZ

; 703  :       {
; 704  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFE000000UL;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 536870912				; 20000000H
	and	ecx, -33554432				; fe000000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 705  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFE000000UL;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 536870912				; 20000000H
	and	ecx, -33554432				; fe000000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN8@LoadPixelZ:

; 706  :       }
; 707  : 
; 708  :       return;

	jmp	$LN14@LoadPixelZ
$LN7@LoadPixelZ:

; 709  :     }
; 710  :     case 0x5:
; 711  :     {
; 712  :       //16+16Z
; 713  :       pixelData32 = *((uint32 *)memPtr);

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 714  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 715  :       regs[0] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shr	edx, 2
	and	edx, 1056964608				; 3f000000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax], edx

; 716  :       regs[1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 4
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 717  :       regs[2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 9
	and	eax, 1040187392				; 3e000000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 718  :       regs[3] = (pixelData32 << 16);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+12], edx

; 719  : 
; 720  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN6@LoadPixelZ

; 721  :       {
; 722  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFE000000UL;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 536870912				; 20000000H
	and	edx, -33554432				; fe000000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+4], edx

; 723  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFE000000UL;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 536870912				; 20000000H
	and	edx, -33554432				; fe000000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN6@LoadPixelZ:

; 724  :       }
; 725  : 
; 726  :       return;

	jmp	$LN14@LoadPixelZ
$LN5@LoadPixelZ:

; 727  :     }
; 728  :     case 0x3:
; 729  :       //8 bit
; 730  :       return;

	jmp	$LN14@LoadPixelZ
$LN4@LoadPixelZ:

; 731  :     case 0x4:
; 732  :     {
; 733  :       //32 bit
; 734  : 
; 735  :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 736  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 737  : 
; 738  :       regs[0] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx], eax

; 739  :       regs[1] = ((pixelData32 << 6)) & (0xFFUL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 6
	and	edx, 1069547520				; 3fc00000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+4], edx

; 740  :       regs[2] = ((pixelData32 << 14)) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 14					; 0000000eH
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 741  :       regs[3] = (pixelData32 << 24);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 742  : 
; 743  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN3@LoadPixelZ

; 744  :       {
; 745  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 746  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN3@LoadPixelZ:

; 747  :       }
; 748  : 
; 749  :       return;

	jmp	$LN14@LoadPixelZ
$LN2@LoadPixelZ:

; 750  :     }
; 751  :     case 0x6:
; 752  :     {
; 753  :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 754  :       zData32 = *(((uint32 *)memPtr) + 1);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _zData32$[ebp], edx

; 755  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 756  :       SwapScalarBytes(&zData32);

	lea	ecx, DWORD PTR _zData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 757  :       regs[0] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx], eax

; 758  :       regs[1] = (pixelData32 << 6) & (0xFFUL << 22);

	mov	edx, DWORD PTR _pixelData32$[ebp]
	shl	edx, 6
	and	edx, 1069547520				; 3fc00000H
	mov	eax, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [eax+4], edx

; 759  :       regs[2] = (pixelData32 << 14) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 14					; 0000000eH
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 760  :       regs[3] = zData32;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR _zData32$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 761  : 
; 762  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN14@LoadPixelZ

; 763  :       {
; 764  :         regs[1] = (regs[1] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 765  :         regs[2] = (regs[2] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN14@LoadPixelZ:

; 766  :       }
; 767  :       return;
; 768  :     }
; 769  :   }
; 770  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@LoadPixelZ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN19@LoadPixelZ:
	DD	2
	DD	$LN18@LoadPixelZ
$LN18@LoadPixelZ:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN16@LoadPixelZ
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN17@LoadPixelZ
$LN17@LoadPixelZ:
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN16@LoadPixelZ:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN20@LoadPixelZ:
	DD	$LN11@LoadPixelZ
	DD	$LN10@LoadPixelZ
	DD	$LN9@LoadPixelZ
	DD	$LN5@LoadPixelZ
	DD	$LN4@LoadPixelZ
	DD	$LN7@LoadPixelZ
	DD	$LN2@LoadPixelZ
?LoadPixelZAbsolute@@YAXXZ ENDP				; LoadPixelZAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv91 = -52						; size = 4
_memPtr$ = -48						; size = 4
_bChnorm$ = -36						; size = 4
_pixType$ = -32						; size = 4
_dest$ = -28						; size = 4
_zData32$ = -20						; size = 4
_pixelData32$ = -8					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelZAbsolute

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 774  :   uint32 pixelData32, zData32;
; 775  :   uint32 dest;
; 776  :   uint32 pixType;
; 777  :   uint32 bChnorm;
; 778  :   uint16 pixelData16, zData16;
; 779  :   void *memPtr;
; 780  : 
; 781  :   memPtr = (void *)((uint32 *)nuance.fields[FIELD_MEM_POINTER]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _memPtr$[ebp], ecx

; 782  :   dest = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dest$[ebp], eax

; 783  :   
; 784  :   if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_UV)

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 8
	je	SHORT $LN17@Execute_Lo@4

; 785  :   {
; 786  :     pixType = BilinearInfo_XYType(*entry.pUvctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 20					; 00000014H
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], edx

; 787  :     bChnorm = BilinearInfo_XYChnorm(*entry.pUvctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	and	edx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], edx
	jmp	SHORT $LN16@Execute_Lo@4
$LN17@Execute_Lo@4:

; 788  :   }
; 789  :   else if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_XY)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 4
	je	SHORT $LN15@Execute_Lo@4

; 790  :   {
; 791  :     pixType = BilinearInfo_XYType(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 792  :     bChnorm = BilinearInfo_XYChnorm(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], ecx

; 793  :   }
; 794  :   else

	jmp	SHORT $LN16@Execute_Lo@4
$LN15@Execute_Lo@4:

; 795  :   {
; 796  :     pixType = BilinearInfo_XYType(mpe.linpixctl);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+456]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 797  :     bChnorm = BilinearInfo_XYChnorm(mpe.linpixctl);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+456]
	and	edx, 268435456				; 10000000H
	mov	DWORD PTR _bChnorm$[ebp], edx
$LN16@Execute_Lo@4:

; 798  :   }
; 799  : 
; 800  :   switch(pixType)

	mov	eax, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 6
	ja	$LN18@Execute_Lo@4
	mov	ecx, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN24@Execute_Lo@4[ecx*4]
$LN11@Execute_Lo@4:

; 801  :   {
; 802  :     case 0x0:
; 803  :       //MPEG
; 804  :       return;

	jmp	$LN18@Execute_Lo@4
$LN10@Execute_Lo@4:

; 805  :     case 0x1:
; 806  :       //4 bit
; 807  :       return;

	jmp	$LN18@Execute_Lo@4
$LN9@Execute_Lo@4:

; 808  :     case 0x2:
; 809  :     {
; 810  :       //16
; 811  :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 812  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 813  :       mpe.regs[dest] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shr	ecx, 2
	and	ecx, 1056964608				; 3f000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 814  :       mpe.regs[dest+1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 4
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 815  :       mpe.regs[dest+2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 9
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 816  : 
; 817  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN8@Execute_Lo@4

; 818  :       {
; 819  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFE000000UL;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -33554432				; fe000000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 820  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFE000000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	sub	edx, 536870912				; 20000000H
	and	edx, -33554432				; fe000000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx
$LN8@Execute_Lo@4:

; 821  :       }
; 822  : 
; 823  :       return;

	jmp	$LN18@Execute_Lo@4
$LN7@Execute_Lo@4:

; 824  :     }
; 825  :     case 0x5:
; 826  :     {
; 827  :       //16+16Z
; 828  :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 829  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 830  :       mpe.regs[dest] = (pixelData32 >> 2) & (0xFCUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shr	ecx, 2
	and	ecx, 1056964608				; 3f000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 831  :       mpe.regs[dest+1] = (pixelData32 << 4) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 4
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 832  :       mpe.regs[dest+2] = (pixelData32 << 9) & (0xF8UL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 9
	and	ecx, 1040187392				; 3e000000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 833  :       mpe.regs[dest+3] = (pixelData32 << 16);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+12], ecx

; 834  : 
; 835  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN6@Execute_Lo@4

; 836  :       {
; 837  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFE000000UL;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -33554432				; fe000000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 838  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFE000000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	sub	edx, 536870912				; 20000000H
	and	edx, -33554432				; fe000000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx
$LN6@Execute_Lo@4:

; 839  :       }
; 840  : 
; 841  :       return;

	jmp	$LN18@Execute_Lo@4
$LN5@Execute_Lo@4:

; 842  :     }
; 843  :     case 0x3:
; 844  :       //8 bit
; 845  :       return;

	jmp	$LN18@Execute_Lo@4
$LN4@Execute_Lo@4:

; 846  :     case 0x4:
; 847  :     {
; 848  :       //32 bit
; 849  : 
; 850  :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 851  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 852  : 
; 853  :       mpe.regs[dest] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shr	ecx, 2
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 854  :       mpe.regs[dest+1] = ((pixelData32 << 6)) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 6
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 855  :       mpe.regs[dest+2] = ((pixelData32 << 14)) & (0xFFUL << 22);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 14					; 0000000eH
	and	ecx, 1069547520				; 3fc00000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 856  :       mpe.regs[dest+3] = (pixelData32 << 24);

	mov	ecx, DWORD PTR _pixelData32$[ebp]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+12], ecx

; 857  : 
; 858  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN3@Execute_Lo@4

; 859  :       {
; 860  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFFC00000UL;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	sub	eax, 536870912				; 20000000H
	and	eax, -4194304				; ffc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 861  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFFC00000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	sub	edx, 536870912				; 20000000H
	and	edx, -4194304				; ffc00000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx
$LN3@Execute_Lo@4:

; 862  :       }
; 863  : 
; 864  :       return;

	jmp	$LN18@Execute_Lo@4
$LN2@Execute_Lo@4:

; 865  :     }
; 866  :     case 0x6:
; 867  :     {
; 868  :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 869  :       zData32 = *(((uint32 *)memPtr) + 1);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _zData32$[ebp], edx

; 870  :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 871  :       SwapScalarBytes(&zData32);

	lea	ecx, DWORD PTR _zData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 872  :       mpe.regs[dest] = ((pixelData32 >> 2)) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shr	eax, 2
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 873  :       mpe.regs[dest+1] = (pixelData32 << 6) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 6
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 874  :       mpe.regs[dest+2] = (pixelData32 << 14) & (0xFFUL << 22);

	mov	eax, DWORD PTR _pixelData32$[ebp]
	shl	eax, 14					; 0000000eH
	and	eax, 1069547520				; 3fc00000H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 875  :       mpe.regs[dest+3] = zData32;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _zData32$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 876  : 
; 877  :       if(bChnorm)

	cmp	DWORD PTR _bChnorm$[ebp], 0
	je	SHORT $LN18@Execute_Lo@4

; 878  :       {
; 879  :         mpe.regs[dest+1] = (mpe.regs[dest+1] - 0x20000000UL) & 0xFFC00000UL;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	sub	edx, 536870912				; 20000000H
	and	edx, -4194304				; ffc00000H
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 880  :         mpe.regs[dest+2] = (mpe.regs[dest+2] - 0x20000000UL) & 0xFFC00000UL;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	sub	ecx, 536870912				; 20000000H
	and	ecx, -4194304				; ffc00000H
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx
$LN18@Execute_Lo@4:

; 881  :       }
; 882  :       return;
; 883  :     }
; 884  :   }
; 885  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Execute_Lo@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN23@Execute_Lo@4:
	DD	2
	DD	$LN22@Execute_Lo@4
$LN22@Execute_Lo@4:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN20@Execute_Lo@4
	DD	-20					; ffffffecH
	DD	4
	DD	$LN21@Execute_Lo@4
$LN21@Execute_Lo@4:
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN20@Execute_Lo@4:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN24@Execute_Lo@4:
	DD	$LN11@Execute_Lo@4
	DD	$LN10@Execute_Lo@4
	DD	$LN9@Execute_Lo@4
	DD	$LN5@Execute_Lo@4
	DD	$LN4@Execute_Lo@4
	DD	$LN7@Execute_Lo@4
	DD	$LN2@Execute_Lo@4
?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelZAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadByteLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_data$ = -12						; size = 4
_address$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadByteLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadByteLinear

; 888  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 889  :   uint32 address, offset, data;
; 890  :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 891  : 
; 892  :   data = *((uint8 *)(nuonEnv->GetPointerToMemory(&mpe,address)));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _data$[ebp], ecx

; 893  :   mpe.regs[nuance.fields[FIELD_MEM_TO]] = data << 24;

	mov	edx, DWORD PTR _data$[ebp]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 894  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadByteLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadByteLinear
_TEXT	ENDS
PUBLIC	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z	; CalculateBilinearAddress
PUBLIC	?Execute_LoadByteBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadByteBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadByteBilinearUV

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 898  :   Nuance newNuance;
; 899  :   uint32 address;
; 900  :   
; 901  :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 902  :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 903  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadByteAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteAbsolute

; 904  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 905  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 906  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 907  :   Execute_LoadByteAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteAbsolute
	add	esp, 12					; 0000000cH

; 908  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@5
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@5:
	DD	2
	DD	$LN5@Execute_Lo@5
$LN5@Execute_Lo@5:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@5
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@5
$LN4@Execute_Lo@5:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@5:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadByteBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadByteBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_pOffsetAddress$ = 12					; size = 4
_control$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z PROC	; CalculateBilinearAddress, COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp

; 147  :   if(BilinearInfo_XRev(control))

	mov	eax, DWORD PTR _control$[ebp]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN2@CalculateB

; 148  :   {
; 149  :     *((uint8 *)&x) = mpe.mirrorLookup[*((uint8 *)&x)];

	movzx	ecx, BYTE PTR _x$[ebp]
	mov	dl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[ecx]
	mov	BYTE PTR _x$[ebp], dl

; 150  :     *(((uint8 *)&x) + 1) = mpe.mirrorLookup[*(((uint8 *)&x) + 1)];

	movzx	eax, BYTE PTR _x$[ebp+1]
	mov	cl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[eax]
	mov	BYTE PTR _x$[ebp+1], cl

; 151  :     SwapWordBytes((uint16 *)&x);

	lea	ecx, DWORD PTR _x$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes
$LN2@CalculateB:

; 152  :   }
; 153  : 
; 154  :   if(BilinearInfo_YRev(control))

	mov	edx, DWORD PTR _control$[ebp]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN1@CalculateB

; 155  :   {
; 156  :     *((uint8 *)&y) = mpe.mirrorLookup[*((uint8 *)&y)];

	movzx	eax, BYTE PTR _y$[ebp]
	mov	cl, BYTE PTR ?mirrorLookup@MPE@@2PAEA[eax]
	mov	BYTE PTR _y$[ebp], cl

; 157  :     *(((uint8 *)&y) + 1) = mpe.mirrorLookup[*(((uint8 *)&y) + 1)];

	movzx	edx, BYTE PTR _y$[ebp+1]
	mov	al, BYTE PTR ?mirrorLookup@MPE@@2PAEA[edx]
	mov	BYTE PTR _y$[ebp+1], al

; 158  :     SwapWordBytes((uint16 *)&y);

	lea	ecx, DWORD PTR _y$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes
$LN1@CalculateB:

; 159  :   }
; 160  : 
; 161  :   //*pOffsetAddress = (((MIP(y) & SIGNMIP(YTILEMASK)) >> 16) * MIP(bi->xy_width) + ((MIP(x) & SIGNMIP(XTILEMASK)) >> 16));
; 162  :   //mipped_xoffset = ((MIP(x) & SIGNMIP(XTILEMASK)) >> 16);
; 163  :   //*pOffsetAddress = (((MIP(y) & SIGNMIP(YTILEMASK)) >> 16) * MIP(BilinearInfo_XYWidth(control)) + mipped_xoffset);
; 164  :   mipped_xoffset = (MIP((x)) & SIGNMIP(XTILEMASK)) >> 16;

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	mov	edx, DWORD PTR _x$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 15					; 0000000fH
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	mov	eax, -65536				; ffff0000H
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	sar	eax, cl
	and	edx, eax
	shr	edx, 16					; 00000010H
	mov	DWORD PTR ?mipped_xoffset@@3IA, edx	; mipped_xoffset

; 165  :   *pOffsetAddress = (((MIP((y)) & SIGNMIP(YTILEMASK)) >> 16) * MIP(BilinearInfo_XYWidth(control)) + mipped_xoffset);

	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	mov	edx, DWORD PTR _y$[ebp]
	shr	edx, cl
	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 12					; 0000000cH
	and	eax, 15					; 0000000fH
	mov	ecx, 16					; 00000010H
	sub	ecx, eax
	mov	eax, -65536				; ffff0000H
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	sar	eax, cl
	and	edx, eax
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR _control$[ebp]
	and	eax, 2047				; 000007ffH
	mov	ecx, DWORD PTR _control$[ebp]
	shr	ecx, 24					; 00000018H
	and	ecx, 7
	shr	eax, cl
	imul	edx, eax
	add	edx, DWORD PTR ?mipped_xoffset@@3IA	; mipped_xoffset
	mov	ecx, DWORD PTR _pOffsetAddress$[ebp]
	mov	DWORD PTR [ecx], edx

; 166  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ENDP	; CalculateBilinearAddress
_TEXT	ENDS
PUBLIC	?Execute_LoadByteBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadByteBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadByteBilinearXY

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 911  :   Nuance newNuance;
; 912  :   uint32 address;
; 913  : 
; 914  :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 915  :   address = (mpe.xybase & 0xFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, 268435452				; 0ffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 916  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadByteAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteAbsolute

; 917  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 918  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 919  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 920  :   Execute_LoadByteAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadByteAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadByteAbsolute
	add	esp, 12					; 0000000cH

; 921  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@6
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@Execute_Lo@6:
	DD	2
	DD	$LN5@Execute_Lo@6
$LN5@Execute_Lo@6:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@6
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@6
$LN4@Execute_Lo@6:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@6:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadByteBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadByteBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_LoadWordLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_memPtr$ = -20						; size = 4
_data$ = -16						; size = 4
_address$ = -8						; size = 4
_dest$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadWordLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadWordLinear

; 923  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 924  :   uint32 dest, address, offset, data;
; 925  :   uint8* memPtr;
; 926  :   dest = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp], ecx

; 927  :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _address$[ebp], eax

; 928  : 
; 929  :   memPtr = (uint8 *)(nuonEnv->GetPointerToMemory(&mpe,address & 0xFFFFFFFE));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, -2					; fffffffeH
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 930  :   data = ((uint32)(*memPtr)) << 24;

	mov	eax, DWORD PTR _memPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 24					; 00000018H
	mov	DWORD PTR _data$[ebp], ecx

; 931  :   data = data | (((uint32)(*(memPtr + 1))) << 16);

	mov	edx, DWORD PTR _memPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	shl	eax, 16					; 00000010H
	or	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 932  : 
; 933  :   mpe.regs[dest] = data;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 934  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadWordLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadWordLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadWordBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadWordBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadWordBilinearUV

; 936  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 937  :   Nuance newNuance;
; 938  :   uint32 address;
; 939  : 
; 940  :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 941  :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 942  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadWordAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordAbsolute

; 943  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 944  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 945  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 946  :   Execute_LoadWordAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordAbsolute
	add	esp, 12					; 0000000cH

; 947  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@7
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@7:
	DD	2
	DD	$LN5@Execute_Lo@7
$LN5@Execute_Lo@7:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@7
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@7
$LN4@Execute_Lo@7:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@7:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadWordBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadWordBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_LoadWordBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadWordBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadWordBilinearXY

; 949  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 950  :   Nuance newNuance;
; 951  :   uint32 address;
; 952  : 
; 953  :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 954  :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 955  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadWordAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordAbsolute

; 956  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 957  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 958  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 959  :   Execute_LoadWordAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadWordAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadWordAbsolute
	add	esp, 12					; 0000000cH

; 960  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@8
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_Lo@8:
	DD	2
	DD	$LN5@Execute_Lo@8
$LN5@Execute_Lo@8:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@8
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@8
$LN4@Execute_Lo@8:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@8:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadWordBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadWordBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_LoadScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadScalarBilinearUV

; 962  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 963  :   Nuance newNuance;
; 964  :   uint32 address;
; 965  : 
; 966  :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 967  :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 968  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadScalarAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarAbsolute

; 969  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 970  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 971  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 972  :   Execute_LoadScalarAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarAbsolute
	add	esp, 12					; 0000000cH

; 973  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@9
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@9:
	DD	2
	DD	$LN5@Execute_Lo@9
$LN5@Execute_Lo@9:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@9
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@9
$LN4@Execute_Lo@9:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@9:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadScalarBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_LoadScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadScalarBilinearXY

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 976  :   Nuance newNuance;
; 977  :   uint32 address;
; 978  : 
; 979  :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 980  :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 981  :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadScalarAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarAbsolute

; 982  :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 983  :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 984  :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 985  :   Execute_LoadScalarAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadScalarAbsolute
	add	esp, 12					; 0000000cH

; 986  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@10
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_Lo@10:
	DD	2
	DD	$LN5@Execute_Lo@10
$LN5@Execute_Lo@10:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@10
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@10
$LN4@Execute_Lo@10:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@10:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadScalarBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_ptr$ = -36						; size = 4
_address$ = -32						; size = 4
_dest$ = -28						; size = 4
_data$ = -20						; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadShortVectorAbsolute

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 989  :   uint32 data[4];
; 990  :   uint32 dest = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp], ecx

; 991  :   uint32 address = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _address$[ebp], eax

; 992  :   uint8 *ptr = (uint8 *)nuance.fields[FIELD_MEM_POINTER]; 

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _ptr$[ebp], edx

; 993  : 
; 994  :   data[0] = *((uint32 *)(ptr + 0));

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _data$[ebp], ecx

; 995  :   data[1] = *((uint32 *)(ptr + 2));

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _data$[ebp+4], eax

; 996  :   data[2] = *((uint32 *)(ptr + 4));

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _data$[ebp+8], edx

; 997  :   data[3] = *((uint32 *)(ptr + 6));

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _data$[ebp+12], ecx

; 998  :   SwapVectorBytes(data);

	lea	ecx, DWORD PTR _data$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 999  :   data[0] &= 0xFFFF0000;

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp], edx

; 1000 :   data[1] &= 0xFFFF0000;

	mov	eax, DWORD PTR _data$[ebp+4]
	and	eax, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+4], eax

; 1001 :   data[2] &= 0xFFFF0000;

	mov	ecx, DWORD PTR _data$[ebp+8]
	and	ecx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+8], ecx

; 1002 :   data[3] &= 0xFFFF0000;

	mov	edx, DWORD PTR _data$[ebp+12]
	and	edx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+12], edx

; 1003 : 
; 1004 :   mpe.regs[dest] = data[0];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1005 :   mpe.regs[dest + 1] = data[1];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _data$[ebp+4]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 1006 :   mpe.regs[dest + 2] = data[2];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _data$[ebp+8]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 1007 :   mpe.regs[dest + 3] = data[3];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _data$[ebp+12]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 1008 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Lo@11
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Execute_Lo@11:
	DD	1
	DD	$LN4@Execute_Lo@11
$LN4@Execute_Lo@11:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Lo@11
$LN3@Execute_Lo@11:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadShortVectorAbsolute
_TEXT	ENDS
PUBLIC	?Execute_LoadShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_ptr$ = -32						; size = 4
_dest$ = -28						; size = 4
_data$ = -20						; size = 16
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadShortVectorLinear

; 1010 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1011 :   uint32 data[4];
; 1012 :   uint32 dest = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dest$[ebp], ecx

; 1013 :   uint8 *ptr = (uint8 *)(nuonEnv->GetPointerToMemory(&mpe,entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]] & 0xFFFFFFF8));

	push	1
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	and	eax, -8					; fffffff8H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _ptr$[ebp], eax

; 1014 :   
; 1015 :   data[0] = *((uint32 *)(ptr + 0));

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _data$[ebp], eax

; 1016 :   data[1] = *((uint32 *)(ptr + 2));

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR _data$[ebp+4], edx

; 1017 :   data[2] = *((uint32 *)(ptr + 4));

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _data$[ebp+8], ecx

; 1018 :   data[3] = *((uint32 *)(ptr + 6));

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _data$[ebp+12], eax

; 1019 :   SwapVectorBytes(data);

	lea	ecx, DWORD PTR _data$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1020 :   data[0] &= 0xFFFF0000;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp], ecx

; 1021 :   data[1] &= 0xFFFF0000;

	mov	edx, DWORD PTR _data$[ebp+4]
	and	edx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+4], edx

; 1022 :   data[2] &= 0xFFFF0000;

	mov	eax, DWORD PTR _data$[ebp+8]
	and	eax, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+8], eax

; 1023 :   data[3] &= 0xFFFF0000;

	mov	ecx, DWORD PTR _data$[ebp+12]
	and	ecx, -65536				; ffff0000H
	mov	DWORD PTR _data$[ebp+12], ecx

; 1024 : 
; 1025 :   mpe.regs[dest] = data[0];

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1026 :   mpe.regs[dest + 1] = data[1];

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _data$[ebp+4]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 1027 :   mpe.regs[dest + 2] = data[2];

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _data$[ebp+8]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 1028 :   mpe.regs[dest + 3] = data[3];

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _data$[ebp+12]
	mov	DWORD PTR [eax+edx*4+12], ecx

; 1029 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Lo@12
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Execute_Lo@12:
	DD	1
	DD	$LN4@Execute_Lo@12
$LN4@Execute_Lo@12:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN3@Execute_Lo@12
$LN3@Execute_Lo@12:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?Execute_LoadShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadShortVectorLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadShortVectorBilinearUV

; 1031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1032 :   Nuance newNuance;
; 1033 :   uint32 address;
; 1034 : 
; 1035 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1036 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1037 :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadShortVectorAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorAbsolute

; 1038 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1039 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 1040 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1041 :   Execute_LoadShortVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorAbsolute
	add	esp, 12					; 0000000cH

; 1042 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@13
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@13:
	DD	2
	DD	$LN5@Execute_Lo@13
$LN5@Execute_Lo@13:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@13
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@13
$LN4@Execute_Lo@13:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@13:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadShortVectorBilinearUV
_TEXT	ENDS
PUBLIC	?GetPointerToMemoryBank@MPE@@QAEPAEI@Z		; MPE::GetPointerToMemoryBank
PUBLIC	?Execute_LoadShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadShortVectorBilinearXY

; 1044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1045 :   Nuance newNuance;
; 1046 :   uint32 address;
; 1047 : 
; 1048 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1049 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1050 :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadShortVectorAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorAbsolute

; 1051 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(mpe.GetPointerToMemoryBank(address));

	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?GetPointerToMemoryBank@MPE@@QAEPAEI@Z	; MPE::GetPointerToMemoryBank
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1052 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1053 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _newNuance$[ebp+8], eax

; 1054 :   Execute_LoadShortVectorAbsolute(mpe,entry,newNuance);

	lea	ecx, DWORD PTR _newNuance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Execute_LoadShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadShortVectorAbsolute
	add	esp, 12					; 0000000cH

; 1055 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@14
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@Execute_Lo@14:
	DD	2
	DD	$LN5@Execute_Lo@14
$LN5@Execute_Lo@14:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@14
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@14
$LN4@Execute_Lo@14:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@14:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadShortVectorBilinearXY
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
_TEXT	ENDS
;	COMDAT ?GetPointerToMemoryBank@MPE@@QAEPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 4
?GetPointerToMemoryBank@MPE@@QAEPAEI@Z PROC		; MPE::GetPointerToMemoryBank, COMDAT
; _this$ = ecx

; 492  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 493  :     return bankPtrTable[address >> 28] + (address & MPE_VALID_MEMORY_MASK);

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+eax*4+688]
	mov	eax, ecx

; 494  :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPointerToMemoryBank@MPE@@QAEPAEI@Z ENDP		; MPE::GetPointerToMemoryBank
_TEXT	ENDS
PUBLIC	?Execute_LoadVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorLinear
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\executemem.cpp
_TEXT	SEGMENT
_srcPtr$ = -16						; size = 4
_destPtr$ = -12						; size = 4
_address$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadVectorLinear

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1058 :   uint32 address, offset;
; 1059 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 1060 :   uint32 *destPtr = &mpe.regs[nuance.fields[FIELD_MEM_TO]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _mpe$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _destPtr$[ebp], edx

; 1061 :   uint32 *srcPtr = (uint32 *)(nuonEnv->GetPointerToMemory(&mpe,address & 0xFFFFFFF0));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	and	eax, -16				; fffffff0H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _srcPtr$[ebp], eax

; 1062 : 
; 1063 :   if((address < MPE_CTRL_BASE) || (address >= MPE_RESV_BASE))

	cmp	DWORD PTR _address$[ebp], 542113792	; 20500000H
	jb	SHORT $LN2@Execute_Lo@15
	cmp	DWORD PTR _address$[ebp], 543162368	; 20600000H
	jb	SHORT $LN3@Execute_Lo@15
$LN2@Execute_Lo@15:

; 1064 :   {
; 1065 :     destPtr[0] = srcPtr[0];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 1066 :     destPtr[1] = srcPtr[1];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1067 :     destPtr[2] = srcPtr[2];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 1068 :     destPtr[3] = srcPtr[3];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _srcPtr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx

; 1069 :     SwapVectorBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1070 :   }
; 1071 :   else

	jmp	SHORT $LN4@Execute_Lo@15
$LN3@Execute_Lo@15:

; 1072 :   {
; 1073 :     destPtr[0] = mpe.ReadControlRegister(address - MPE_CTRL_BASE, &entry);

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113792				; 20500000H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	DWORD PTR [ecx], eax

; 1074 :     destPtr[1] = mpe.ReadControlRegister(address + 4 - MPE_CTRL_BASE, &entry);

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113788				; 204ffffcH
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1075 :     destPtr[2] = mpe.ReadControlRegister(address + 8 - MPE_CTRL_BASE, &entry);

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113784				; 204ffff8H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1076 :     destPtr[3] = mpe.ReadControlRegister(address + 12 - MPE_CTRL_BASE, &entry);

	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113780				; 204ffff4H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN4@Execute_Lo@15:

; 1077 :   }
; 1078 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LoadVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadVectorLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadVectorBilinearUV

; 1080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1081 :   Nuance newNuance;
; 1082 :   uint32 address;
; 1083 : 
; 1084 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1085 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1086 :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadVectorAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorAbsolute

; 1087 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1088 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 1089 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1090 :   Execute_LoadVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorAbsolute
	add	esp, 12					; 0000000cH

; 1091 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@16
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@16:
	DD	2
	DD	$LN5@Execute_Lo@16
$LN5@Execute_Lo@16:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@16
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@16
$LN4@Execute_Lo@16:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@16:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadVectorBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_LoadVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadVectorBilinearXY

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1094 :   Nuance newNuance;
; 1095 :   uint32 address;
; 1096 : 
; 1097 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1098 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1099 :   newNuance.fields[FIELD_MEM_HANDLER] = (uint32)Execute_LoadVectorAbsolute;

	mov	DWORD PTR _newNuance$[ebp], OFFSET ?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorAbsolute

; 1100 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1101 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 1102 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1103 :   Execute_LoadVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadVectorAbsolute
	add	esp, 12					; 0000000cH

; 1104 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@17
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_Lo@17:
	DD	2
	DD	$LN5@Execute_Lo@17
$LN5@Execute_Lo@17:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@17
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@17
$LN4@Execute_Lo@17:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@17:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadVectorBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -32						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelLinear

; 1106 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1107 :   Nuance newNuance;
; 1108 :   uint32 address;
; 1109 : 
; 1110 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 1111 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_LINEAR_INDIRECT;

	mov	DWORD PTR _newNuance$[ebp+4], 2

; 1112 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _newNuance$[ebp+8], eax

; 1113 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1114 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1115 :   Execute_LoadPixelAbsolute(mpe,entry,newNuance);

	lea	ecx, DWORD PTR _newNuance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelAbsolute
	add	esp, 12					; 0000000cH

; 1116 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Lo@18
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_Lo@18:
	DD	1
	DD	$LN4@Execute_Lo@18
$LN4@Execute_Lo@18:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@18
$LN3@Execute_Lo@18:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pixwidth$ = -44					; size = 4
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelBilinearUV

; 1118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1119 :   Nuance newNuance;
; 1120 :   uint32 address;
; 1121 :   int32 pixwidth = BilinearInfo_PixelWidth(pixel_type_width,*entry.pUvctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 20					; 00000014H
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR ?pixel_type_width@@3PAHA[edx*4]
	mov	DWORD PTR _pixwidth$[ebp], eax

; 1122 : 
; 1123 :   pixwidth = pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [edx]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[eax*4]
	mov	DWORD PTR _pixwidth$[ebp], ecx

; 1124 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1125 :   if(pixwidth >= 0)

	cmp	DWORD PTR _pixwidth$[ebp], 0
	jl	SHORT $LN2@Execute_Lo@19

; 1126 :   {
; 1127 :     address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixwidth);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+452]
	and	edx, -4					; fffffffcH
	mov	eax, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR _pixwidth$[ebp]
	shl	eax, cl
	add	edx, eax
	mov	DWORD PTR _address$[ebp], edx

; 1128 :   }
; 1129 :   else

	jmp	SHORT $LN1@Execute_Lo@19
$LN2@Execute_Lo@19:

; 1130 :   {
; 1131 :     //type1: 4-bit pixels
; 1132 :     address = (mpe.uvbase & 0xFFFFFFFC) + (address >> 1);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+452]
	and	edx, -4					; fffffffcH
	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 1
	add	edx, eax
	mov	DWORD PTR _address$[ebp], edx
$LN1@Execute_Lo@19:

; 1133 :   }
; 1134 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1135 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1136 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	eax, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], eax

; 1137 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1138 :   Execute_LoadPixelAbsolute(mpe,entry,newNuance);

	lea	eax, DWORD PTR _newNuance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	call	?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelAbsolute
	add	esp, 12					; 0000000cH

; 1139 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Execute_Lo@19
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@Execute_Lo@19:
	DD	2
	DD	$LN7@Execute_Lo@19
$LN7@Execute_Lo@19:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN5@Execute_Lo@19
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN6@Execute_Lo@19
$LN6@Execute_Lo@19:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN5@Execute_Lo@19:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pixwidth$ = -44					; size = 4
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelBilinearXY

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1142 :   Nuance newNuance;
; 1143 :   uint32 address;
; 1144 :   int32 pixwidth = BilinearInfo_PixelWidth(pixel_type_width,*entry.pXyctl);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 20					; 00000014H
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR ?pixel_type_width@@3PAHA[edx*4]
	mov	DWORD PTR _pixwidth$[ebp], eax

; 1145 : 
; 1146 :   pixwidth = pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[eax*4]
	mov	DWORD PTR _pixwidth$[ebp], ecx

; 1147 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1148 :   if(pixwidth >= 0)

	cmp	DWORD PTR _pixwidth$[ebp], 0
	jl	SHORT $LN2@Execute_Lo@20

; 1149 :   {
; 1150 :     address = (mpe.xybase & 0xFFFFFFFC) + (address << pixwidth);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+448]
	and	edx, -4					; fffffffcH
	mov	eax, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR _pixwidth$[ebp]
	shl	eax, cl
	add	edx, eax
	mov	DWORD PTR _address$[ebp], edx

; 1151 :   }
; 1152 :   else

	jmp	SHORT $LN1@Execute_Lo@20
$LN2@Execute_Lo@20:

; 1153 :   {
; 1154 :     //type1: 4-bit pixels
; 1155 :     address = (mpe.xybase & 0xFFFFFFFC) + (address >> 1);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+448]
	and	edx, -4					; fffffffcH
	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 1
	add	edx, eax
	mov	DWORD PTR _address$[ebp], edx
$LN1@Execute_Lo@20:

; 1156 :   }
; 1157 : 
; 1158 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1159 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1160 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	eax, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], eax

; 1161 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1162 :   Execute_LoadPixelAbsolute(mpe,entry,newNuance);

	lea	eax, DWORD PTR _newNuance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	call	?Execute_LoadPixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelAbsolute
	add	esp, 12					; 0000000cH

; 1163 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Execute_Lo@20
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@Execute_Lo@20:
	DD	2
	DD	$LN7@Execute_Lo@20
$LN7@Execute_Lo@20:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN5@Execute_Lo@20
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN6@Execute_Lo@20
$LN6@Execute_Lo@20:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN5@Execute_Lo@20:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -32						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelZLinear

; 1165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1166 :   Nuance newNuance;
; 1167 :   uint32 address;
; 1168 : 
; 1169 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 1170 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_LINEAR_INDIRECT;

	mov	DWORD PTR _newNuance$[ebp+4], 2

; 1171 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _newNuance$[ebp+8], eax

; 1172 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1173 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1174 :   Execute_LoadPixelZAbsolute(mpe,entry,newNuance);

	lea	ecx, DWORD PTR _newNuance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZAbsolute
	add	esp, 12					; 0000000cH

; 1175 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_Lo@21
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_Lo@21:
	DD	1
	DD	$LN4@Execute_Lo@21
$LN4@Execute_Lo@21:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@21
$LN3@Execute_Lo@21:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelZLinear
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelZBilinearUV

; 1177 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1178 :   Nuance newNuance;
; 1179 :   uint32 address;
; 1180 : 
; 1181 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1182 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pUvctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1183 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1184 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1185 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 1186 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1187 :   Execute_LoadPixelZAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZAbsolute
	add	esp, 12					; 0000000cH

; 1188 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@22
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_Lo@22:
	DD	2
	DD	$LN5@Execute_Lo@22
$LN5@Execute_Lo@22:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@22
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@22
$LN4@Execute_Lo@22:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@22:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelZBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_LoadPixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LoadPixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LoadPixelZBilinearXY

; 1190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1191 :   Nuance newNuance;
; 1192 :   uint32 address;
; 1193 : 
; 1194 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1195 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pXyctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1196 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1197 :   newNuance.fields[FIELD_MEM_TO] = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1198 :   newNuance.fields[FIELD_MEM_FROM] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+12], edx

; 1199 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1200 :   Execute_LoadPixelZAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_LoadPixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LoadPixelZAbsolute
	add	esp, 12					; 0000000cH

; 1201 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_Lo@23
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_Lo@23:
	DD	2
	DD	$LN5@Execute_Lo@23
$LN5@Execute_Lo@23:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_Lo@23
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_Lo@23
$LN4@Execute_Lo@23:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_Lo@23:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_LoadPixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LoadPixelZBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarImmediate

; 1203 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1204 :   uint32 *destPtr = (uint32 *)nuance.fields[FIELD_MEM_POINTER];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _destPtr$[ebp], ecx

; 1205 :   *destPtr = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ecx

; 1206 :   SwapScalarBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1207 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarImmediate
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarAbsolute

; 1209 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1210 :   uint32 *destPtr = (uint32 *)nuance.fields[FIELD_MEM_POINTER];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _destPtr$[ebp], ecx

; 1211 :   *destPtr = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx

; 1212 :   SwapScalarBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1213 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarControlRegisterImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarControlRegisterImmediate
EXTRN	?WriteControlRegister@MPE@@QAEXII@Z:PROC	; MPE::WriteControlRegister
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_reg$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarControlRegisterImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarControlRegisterImmediate

; 1215 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1216 :   uint32 reg = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _reg$[ebp], ecx

; 1217 : 
; 1218 :   //normal control register write
; 1219 :   mpe.WriteControlRegister(reg - MPE_CTRL_BASE, nuance.fields[FIELD_MEM_FROM]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _reg$[ebp]
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1220 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarControlRegisterImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarControlRegisterImmediate
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -12						; size = 4
_address$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarLinear

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1224 :   uint32 address, offset, *destPtr;
; 1225 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_TO]] & 0xFFFFFFFC;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, -4					; fffffffcH
	mov	DWORD PTR _address$[ebp], ecx

; 1226 : 
; 1227 :   if((address < MPE_ITAGS_BASE) || (address >= MPE_RESV_BASE))

	cmp	DWORD PTR _address$[ebp], 541589504	; 20480000H
	jb	SHORT $LN4@Execute_St
	cmp	DWORD PTR _address$[ebp], 543162368	; 20600000H
	jb	SHORT $LN5@Execute_St
$LN4@Execute_St:

; 1228 :   {
; 1229 :     destPtr = (uint32 *)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _destPtr$[ebp], eax

; 1230 :     *destPtr = entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax], ecx

; 1231 :     SwapScalarBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1232 :   }
; 1233 :   else

	jmp	SHORT $LN6@Execute_St
$LN5@Execute_St:

; 1234 :   {
; 1235 :     if((address & 0xFFFF0000) == MPE_ITAGS_BASE)

	mov	edx, DWORD PTR _address$[ebp]
	and	edx, -65536				; ffff0000H
	cmp	edx, 541589504				; 20480000H
	jne	SHORT $LN2@Execute_St

; 1236 :     {
; 1237 :       mpe.bInvalidateInstructionCaches = true;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	BYTE PTR [eax+641], 1

; 1238 :     }
; 1239 :     else

	jmp	SHORT $LN6@Execute_St
$LN2@Execute_St:

; 1240 :     {
; 1241 :       mpe.WriteControlRegister(address - MPE_CTRL_BASE, entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]]);

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113792				; 20500000H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister
$LN6@Execute_St:

; 1242 :     }
; 1243 :   }
; 1244 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarLinear
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarBilinearUV

; 1246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1247 :   Nuance newNuance;
; 1248 :   uint32 address;
; 1249 : 
; 1250 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1251 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1252 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1253 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1254 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1255 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1256 :   Execute_StoreScalarAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarAbsolute
	add	esp, 12					; 0000000cH

; 1257 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_St@2:
	DD	2
	DD	$LN5@Execute_St@2
$LN5@Execute_St@2:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@2
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@2
$LN4@Execute_St@2:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@2:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreScalarBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarBilinearXY

; 1259 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1260 :   Nuance newNuance;
; 1261 :   uint32 address;
; 1262 : 
; 1263 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1264 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1265 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1266 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1267 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1268 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1269 :   Execute_StoreScalarAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreScalarAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarAbsolute
	add	esp, 12					; 0000000cH

; 1270 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_St@3:
	DD	2
	DD	$LN5@Execute_St@3
$LN5@Execute_St@3:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@3
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@3
$LN4@Execute_St@3:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@3:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreScalarBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarControlRegisterAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_reg$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarControlRegisterAbsolute

; 1273 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1274 :   uint32 reg = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _reg$[ebp], ecx

; 1275 : 
; 1276 :   if(reg != 0x20500FF0)

	cmp	DWORD PTR _reg$[ebp], 542117872		; 20500ff0H
	je	SHORT $LN3@Execute_St@4

; 1277 :   {
; 1278 :     mpe.WriteControlRegister(reg - MPE_CTRL_BASE, entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _reg$[ebp]
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister
$LN3@Execute_St@4:

; 1279 :   }
; 1280 :   else
; 1281 :   {
; 1282 :     //syscall
; 1283 :   }
; 1284 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarControlRegisterAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StoreVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorControlRegisterAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_srcPtr$ = -8						; size = 4
_address$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreVectorControlRegisterAbsolute

; 1286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1287 :   uint32 address = nuance.fields[FIELD_MEM_TO];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _address$[ebp], ecx

; 1288 :   uint32 *srcPtr = &(entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _srcPtr$[ebp], eax

; 1289 : 
; 1290 :   mpe.WriteControlRegister(address - MPE_CTRL_BASE, srcPtr[0]);

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113792				; 20500000H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1291 :   mpe.WriteControlRegister(address + 4 - MPE_CTRL_BASE, srcPtr[1]);

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113788				; 204ffffcH
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1292 :   mpe.WriteControlRegister(address + 8 - MPE_CTRL_BASE, srcPtr[2]);

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113784				; 204ffff8H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1293 :   mpe.WriteControlRegister(address + 12 - MPE_CTRL_BASE, srcPtr[3]);

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	sub	eax, 542113780				; 204ffff4H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1294 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreVectorControlRegisterAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreVectorControlRegisterAbsolute
_TEXT	ENDS
PUBLIC	?SaturateColorComponents@@YAXPAI00_N@Z		; SaturateColorComponents
PUBLIC	?StorePixelAbsolute@@YAXXZ			; StorePixelAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv69 = -104						; size = 4
_memPtr$ = -100						; size = 4
_bChnorm$ = -93						; size = 1
_pixType$ = -92						; size = 4
_regs$ = -88						; size = 4
_control$ = -84						; size = 4
_pixelData16$ = -60					; size = 2
_cb32$ = -44						; size = 4
_cr32$ = -32						; size = 4
_y32$ = -20						; size = 4
_pixelData32$ = -8					; size = 4
?StorePixelAbsolute@@YAXXZ PROC				; StorePixelAbsolute

; 1297 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1298 :   uint32 pixelData32, y32, cr32, cb32, z32;
; 1299 :   uint16 pixelData16, y16, cr16, cb16, z16;
; 1300 :   uint32 control = bilinearAddressInfo.control;

	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+24
	mov	DWORD PTR _control$[ebp], eax

; 1301 :   uint32 *regs = bilinearAddressInfo.pRegs;

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+8
	mov	DWORD PTR _regs$[ebp], ecx

; 1302 :   uint32 pixType;
; 1303 :   bool bChnorm;
; 1304 : 
; 1305 :   void *memPtr;
; 1306 : 
; 1307 :   memPtr = (void *)bilinearAddressInfo.pPixelData;

	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+4
	mov	DWORD PTR _memPtr$[ebp], edx

; 1308 : 
; 1309 :   pixType = BilinearInfo_XYType(control);

	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 1310 :   bChnorm = BilinearInfo_XYChnorm(control);

	mov	ecx, DWORD PTR _control$[ebp]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl

; 1311 : 
; 1312 :   switch(pixType)

	mov	eax, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 6
	ja	$LN8@StorePixel
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN17@StorePixel[ecx*4]
$LN5@StorePixel:

; 1313 :   {
; 1314 :     case 0x0:
; 1315 :       //MPEG
; 1316 :       return;

	jmp	$LN8@StorePixel
$LN4@StorePixel:

; 1317 :     case 0x1:
; 1318 :       //4 bit
; 1319 :       return;

	jmp	$LN8@StorePixel
$LN3@StorePixel:

; 1320 :     case 0x2:
; 1321 :     case 0x5:
; 1322 :     {
; 1323 :       //16 bit
; 1324 :       y32 = regs[0] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1325 :       cr32 = regs[1] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1326 :       cb32 = regs[2] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], ecx

; 1327 : 
; 1328 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	dl, BYTE PTR _bChnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _cb32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cr32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y32$[ebp]
	push	edx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1329 : 
; 1330 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	eax, DWORD PTR _y32$[ebp]
	and	eax, 252				; 000000fcH
	shl	eax, 8
	mov	ecx, DWORD PTR _cr32$[ebp]
	and	ecx, 248				; 000000f8H
	shl	ecx, 2
	or	eax, ecx
	mov	edx, DWORD PTR _cb32$[ebp]
	and	edx, 248				; 000000f8H
	shr	edx, 3
	or	eax, edx
	mov	WORD PTR _pixelData16$[ebp], ax

; 1331 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1332 :       *((uint16 *)memPtr) = pixelData16;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	cx, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [eax], cx

; 1333 :       return;

	jmp	$LN8@StorePixel
$LN2@StorePixel:

; 1334 :     }
; 1335 :     case 0x3:
; 1336 :       //8 bit
; 1337 :       return;

	jmp	SHORT $LN8@StorePixel
$LN1@StorePixel:

; 1338 :     case 0x4:
; 1339 :     case 0x6:
; 1340 :     {
; 1341 :       //32 bit
; 1342 : 
; 1343 :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 1344 : 
; 1345 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1346 : 
; 1347 :       y32 = regs[0] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], edx

; 1348 :       cr32 = regs[1] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], ecx

; 1349 :       cb32 = regs[2] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], eax

; 1350 : 
; 1351 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	cl, BYTE PTR _bChnorm$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cb32$[ebp]
	push	edx
	lea	eax, DWORD PTR _cr32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y32$[ebp]
	push	ecx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1352 : 
; 1353 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8) | (pixelData32 & 0xFF);

	mov	edx, DWORD PTR _y32$[ebp]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _cr32$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	mov	ecx, DWORD PTR _cb32$[ebp]
	shl	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _pixelData32$[ebp]
	and	eax, 255				; 000000ffH
	or	edx, eax
	mov	DWORD PTR _pixelData32$[ebp], edx

; 1354 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1355 :       *((uint32 *)memPtr) = pixelData32;

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [ecx], edx
$LN8@StorePixel:

; 1356 :     }
; 1357 :   }
; 1358 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@StorePixel
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@StorePixel:
	DD	5
	DD	$LN15@StorePixel
$LN15@StorePixel:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN10@StorePixel
	DD	-20					; ffffffecH
	DD	4
	DD	$LN11@StorePixel
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN12@StorePixel
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN13@StorePixel
	DD	-60					; ffffffc4H
	DD	2
	DD	$LN14@StorePixel
$LN14@StorePixel:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN13@StorePixel:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN12@StorePixel:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN11@StorePixel:
	DB	121					; 00000079H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN10@StorePixel:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
	npad	2
$LN17@StorePixel:
	DD	$LN5@StorePixel
	DD	$LN4@StorePixel
	DD	$LN3@StorePixel
	DD	$LN2@StorePixel
	DD	$LN1@StorePixel
	DD	$LN3@StorePixel
	DD	$LN1@StorePixel
?StorePixelAbsolute@@YAXXZ ENDP				; StorePixelAbsolute
_TEXT	ENDS
PUBLIC	?YLookup@?1??SaturateColorComponents@@YAXPAI00_N@Z@4PAIA ; `SaturateColorComponents'::`2'::YLookup
;	COMDAT ?YLookup@?1??SaturateColorComponents@@YAXPAI00_N@Z@4PAIA
_DATA	SEGMENT
?YLookup@?1??SaturateColorComponents@@YAXPAI00_N@Z@4PAIA DD 00H ; `SaturateColorComponents'::`2'::YLookup
	DD	0ffH
	DD	00H
	DD	00H
; Function compile flags: /Odtp /RTCsu
_DATA	ENDS
;	COMDAT ?SaturateColorComponents@@YAXPAI00_N@Z
_TEXT	SEGMENT
tv89 = -8						; size = 4
tv70 = -4						; size = 4
_Y$ = 8							; size = 4
_Cr$ = 12						; size = 4
_Cb$ = 16						; size = 4
_bChnorm$ = 20						; size = 1
?SaturateColorComponents@@YAXPAI00_N@Z PROC		; SaturateColorComponents, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 27   :   static uint32 YLookup[] = {0x00UL,0xFFUL,0x00UL,0x00UL};
; 28   : 
; 29   :   YLookup[0] = (*Y >> (13 - 7)) & 0xFFUL;

	mov	eax, DWORD PTR _Y$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 6
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR ?YLookup@?1??SaturateColorComponents@@YAXPAI00_N@Z@4PAIA, ecx

; 30   :   *Y = YLookup[*Y >> 14];

	mov	edx, DWORD PTR _Y$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 14					; 0000000eH
	mov	ecx, DWORD PTR _Y$[ebp]
	mov	edx, DWORD PTR ?YLookup@?1??SaturateColorComponents@@YAXPAI00_N@Z@4PAIA[eax*4]
	mov	DWORD PTR [ecx], edx

; 31   : 
; 32   :   switch(*Cr >> 14)

	mov	eax, DWORD PTR _Cr$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR tv70[ebp], ecx
	cmp	DWORD PTR tv70[ebp], 3
	ja	$LN30@SaturateCo
	mov	edx, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN34@SaturateCo[edx*4]
$LN29@SaturateCo:

; 33   :   {
; 34   :     case 0:
; 35   :       //If chnorm bit is set, clamp to 0x7F
; 36   :       if(bChnorm && (*Cr > 0x1FFF))

	movzx	eax, BYTE PTR _bChnorm$[ebp]
	test	eax, eax
	je	SHORT $LN28@SaturateCo
	mov	ecx, DWORD PTR _Cr$[ebp]
	cmp	DWORD PTR [ecx], 8191			; 00001fffH
	jbe	SHORT $LN28@SaturateCo

; 37   :       {
; 38   :         *Cr = 0x7F;

	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], 127			; 0000007fH

; 39   :       }
; 40   :       else

	jmp	SHORT $LN27@SaturateCo
$LN28@SaturateCo:

; 41   :       {
; 42   :         *Cr = (*Cr >> (13 - 7)) & 0xFFUL;

	mov	eax, DWORD PTR _Cr$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 6
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN27@SaturateCo:

; 43   :       }
; 44   :       break;

	jmp	SHORT $LN30@SaturateCo
$LN26@SaturateCo:

; 45   :     case 1:
; 46   :       //clamp to 0x7F or 0xFF
; 47   :       if(bChnorm)

	movzx	eax, BYTE PTR _bChnorm$[ebp]
	test	eax, eax
	je	SHORT $LN25@SaturateCo

; 48   :       {
; 49   :         *Cr = 0x7F;

	mov	ecx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [ecx], 127			; 0000007fH

; 50   :       }
; 51   :       else

	jmp	SHORT $LN24@SaturateCo
$LN25@SaturateCo:

; 52   :       {
; 53   :         *Cr = 0xFF;

	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], 255			; 000000ffH
$LN24@SaturateCo:

; 54   :       }
; 55   :       break;

	jmp	SHORT $LN30@SaturateCo
$LN23@SaturateCo:

; 56   :     case 2:
; 57   :       //clamp to 0x80 or 0x00
; 58   :       if(bChnorm)

	movzx	eax, BYTE PTR _bChnorm$[ebp]
	test	eax, eax
	je	SHORT $LN22@SaturateCo

; 59   :       {
; 60   :         *Cr = 0x80;

	mov	ecx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [ecx], 128			; 00000080H

; 61   :       }
; 62   :       else

	jmp	SHORT $LN21@SaturateCo
$LN22@SaturateCo:

; 63   :       {
; 64   :         *Cr = 0x00;

	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], 0
$LN21@SaturateCo:

; 65   :       }
; 66   :       break;

	jmp	SHORT $LN30@SaturateCo
$LN20@SaturateCo:

; 67   :     case 3:
; 68   :       //Clamp to 0x80 or 0x00
; 69   :       if(bChnorm && (*Cr < 0xE000))

	movzx	eax, BYTE PTR _bChnorm$[ebp]
	test	eax, eax
	je	SHORT $LN19@SaturateCo
	mov	ecx, DWORD PTR _Cr$[ebp]
	cmp	DWORD PTR [ecx], 57344			; 0000e000H
	jae	SHORT $LN19@SaturateCo

; 70   :       {
; 71   :         *Cr = 0x80;

	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], 128			; 00000080H

; 72   :       }
; 73   :       else

	jmp	SHORT $LN30@SaturateCo
$LN19@SaturateCo:

; 74   :       {
; 75   :         *Cr = (*Cr >> (13 - 7)) & 0xFFUL;

	mov	eax, DWORD PTR _Cr$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 6
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [edx], ecx

; 76   :         if(!bChnorm)

	movzx	eax, BYTE PTR _bChnorm$[ebp]
	test	eax, eax
	jne	SHORT $LN30@SaturateCo

; 77   :         {
; 78   :           *Cr = 0x00;

	mov	ecx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [ecx], 0
$LN30@SaturateCo:

; 79   :         }
; 80   :       }
; 81   :       break;
; 82   :   }
; 83   : 
; 84   :   switch(*Cb >> 14)

	mov	edx, DWORD PTR _Cb$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 14					; 0000000eH
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 3
	ja	$LN15@SaturateCo
	mov	ecx, DWORD PTR tv89[ebp]
	jmp	DWORD PTR $LN35@SaturateCo[ecx*4]
$LN14@SaturateCo:

; 85   :   {
; 86   :     case 0:
; 87   :       //If chnorm bit is set, clamp to 0x7F
; 88   :       if(bChnorm && (*Cb > 0x1FFF))

	movzx	edx, BYTE PTR _bChnorm$[ebp]
	test	edx, edx
	je	SHORT $LN13@SaturateCo
	mov	eax, DWORD PTR _Cb$[ebp]
	cmp	DWORD PTR [eax], 8191			; 00001fffH
	jbe	SHORT $LN13@SaturateCo

; 89   :       {
; 90   :         *Cb = 0x7F;

	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], 127			; 0000007fH

; 91   :       }
; 92   :       else

	jmp	SHORT $LN12@SaturateCo
$LN13@SaturateCo:

; 93   :       {
; 94   :         *Cb = (*Cb >> (13 - 7)) & 0xFFUL;

	mov	edx, DWORD PTR _Cb$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 6
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@SaturateCo:

; 95   :       }
; 96   :       break;

	jmp	SHORT $LN15@SaturateCo
$LN11@SaturateCo:

; 97   :     case 1:
; 98   :       //clamp to 0x7F or 0xFF
; 99   :       if(bChnorm)

	movzx	edx, BYTE PTR _bChnorm$[ebp]
	test	edx, edx
	je	SHORT $LN10@SaturateCo

; 100  :       {
; 101  :         *Cb = 0x7F;

	mov	eax, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [eax], 127			; 0000007fH

; 102  :       }
; 103  :       else

	jmp	SHORT $LN9@SaturateCo
$LN10@SaturateCo:

; 104  :       {
; 105  :         *Cb = 0xFF;

	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], 255			; 000000ffH
$LN9@SaturateCo:

; 106  :       }
; 107  :       break;

	jmp	SHORT $LN15@SaturateCo
$LN8@SaturateCo:

; 108  :     case 2:
; 109  :       //clamp to 0x80 or 0x00
; 110  :       if(bChnorm)

	movzx	edx, BYTE PTR _bChnorm$[ebp]
	test	edx, edx
	je	SHORT $LN7@SaturateCo

; 111  :       {
; 112  :         *Cb = 0x80;

	mov	eax, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [eax], 128			; 00000080H

; 113  :       }
; 114  :       else

	jmp	SHORT $LN6@SaturateCo
$LN7@SaturateCo:

; 115  :       {
; 116  :         *Cb = 0x00;

	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], 0
$LN6@SaturateCo:

; 117  :       }
; 118  :       break;

	jmp	SHORT $LN15@SaturateCo
$LN5@SaturateCo:

; 119  :     case 3:
; 120  :       //Clamp to 0x80 or 0x00
; 121  :       if(bChnorm && (*Cb < 0xE000))

	movzx	edx, BYTE PTR _bChnorm$[ebp]
	test	edx, edx
	je	SHORT $LN4@SaturateCo
	mov	eax, DWORD PTR _Cb$[ebp]
	cmp	DWORD PTR [eax], 57344			; 0000e000H
	jae	SHORT $LN4@SaturateCo

; 122  :       {
; 123  :         *Cb = 0x80;

	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], 128			; 00000080H

; 124  :       }
; 125  :       else

	jmp	SHORT $LN15@SaturateCo
$LN4@SaturateCo:

; 126  :       {
; 127  :         *Cb = (*Cb >> (13 - 7)) & 0xFFUL;

	mov	edx, DWORD PTR _Cb$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 6
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], eax

; 128  :         if(!bChnorm)

	movzx	edx, BYTE PTR _bChnorm$[ebp]
	test	edx, edx
	jne	SHORT $LN15@SaturateCo

; 129  :         {
; 130  :           *Cb = 0x00;

	mov	eax, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [eax], 0
$LN15@SaturateCo:

; 131  :         }
; 132  :       }
; 133  :       break;
; 134  :   }
; 135  : 
; 136  :   if(bChnorm)

	movzx	ecx, BYTE PTR _bChnorm$[ebp]
	test	ecx, ecx
	je	SHORT $LN32@SaturateCo

; 137  :   {
; 138  :     *Cr = (*Cr + 0x80) & 0xFFUL;

	mov	edx, DWORD PTR _Cr$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 128				; 00000080H
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Cr$[ebp]
	mov	DWORD PTR [ecx], eax

; 139  :     *Cb = (*Cb + 0x80) & 0xFFUL;

	mov	edx, DWORD PTR _Cb$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 128				; 00000080H
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Cb$[ebp]
	mov	DWORD PTR [ecx], eax
$LN32@SaturateCo:

; 140  :   }
; 141  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN34@SaturateCo:
	DD	$LN29@SaturateCo
	DD	$LN26@SaturateCo
	DD	$LN23@SaturateCo
	DD	$LN20@SaturateCo
$LN35@SaturateCo:
	DD	$LN14@SaturateCo
	DD	$LN11@SaturateCo
	DD	$LN8@SaturateCo
	DD	$LN5@SaturateCo
?SaturateColorComponents@@YAXPAI00_N@Z ENDP		; SaturateColorComponents
_TEXT	ENDS
PUBLIC	?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv134 = -104						; size = 4
_memPtr$ = -100						; size = 4
_bChnorm$ = -93						; size = 1
_pixelData16$ = -72					; size = 2
_cb32$ = -56						; size = 4
_cr32$ = -44						; size = 4
_y32$ = -32						; size = 4
_pixelData32$ = -20					; size = 4
_pixType$ = -12						; size = 4
_address$ = -8						; size = 4
_src$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelAbsolute

; 1361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1362 :   uint32 src = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _src$[ebp], ecx

; 1363 :   uint32 address = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _address$[ebp], eax

; 1364 :   uint32 pixType;
; 1365 :   uint32 pixelData32, y32, cr32, cb32, z32;
; 1366 :   uint16 pixelData16, y16, cr6, cb16, z16;
; 1367 :   bool bChnorm;
; 1368 : 
; 1369 :   void *memPtr;
; 1370 : 
; 1371 :   memPtr = (void *)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 1372 : 
; 1373 :   if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_UV)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 8
	je	SHORT $LN11@Execute_St@5

; 1374 :   {
; 1375 :     pixType = BilinearInfo_XYType(*entry.pUvctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1376 :     bChnorm = BilinearInfo_XYChnorm(*entry.pUvctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl
	jmp	SHORT $LN10@Execute_St@5
$LN11@Execute_St@5:

; 1377 :   }
; 1378 :   else if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_XY)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 4
	je	SHORT $LN9@Execute_St@5

; 1379 :   {
; 1380 :     pixType = BilinearInfo_XYType(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1381 :     bChnorm = BilinearInfo_XYChnorm(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl

; 1382 :   }
; 1383 :   else

	jmp	SHORT $LN10@Execute_St@5
$LN9@Execute_St@5:

; 1384 :   {
; 1385 :     pixType = BilinearInfo_XYType(mpe.linpixctl);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+456]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1386 :     bChnorm = BilinearInfo_XYChnorm(mpe.linpixctl);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+456]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bChnorm$[ebp], cl
$LN10@Execute_St@5:

; 1387 :   }
; 1388 : 
; 1389 :   switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 6
	ja	$LN12@Execute_St@5
	mov	eax, DWORD PTR tv134[ebp]
	jmp	DWORD PTR $LN21@Execute_St@5[eax*4]
$LN5@Execute_St@5:

; 1390 :   {
; 1391 :     case 0x0:
; 1392 :       //MPEG
; 1393 :       return;

	jmp	$LN12@Execute_St@5
$LN4@Execute_St@5:

; 1394 :     case 0x1:
; 1395 :       //4 bit
; 1396 :       return;

	jmp	$LN12@Execute_St@5
$LN3@Execute_St@5:

; 1397 :     case 0x2:
; 1398 :     case 0x5:
; 1399 :     {
; 1400 :       //16 bit
; 1401 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], ecx

; 1402 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1403 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], eax

; 1404 : 
; 1405 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	cl, BYTE PTR _bChnorm$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cb32$[ebp]
	push	edx
	lea	eax, DWORD PTR _cr32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y32$[ebp]
	push	ecx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1406 : 
; 1407 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	edx, DWORD PTR _y32$[ebp]
	and	edx, 252				; 000000fcH
	shl	edx, 8
	mov	eax, DWORD PTR _cr32$[ebp]
	and	eax, 248				; 000000f8H
	shl	eax, 2
	or	edx, eax
	mov	ecx, DWORD PTR _cb32$[ebp]
	and	ecx, 248				; 000000f8H
	shr	ecx, 3
	or	edx, ecx
	mov	WORD PTR _pixelData16$[ebp], dx

; 1408 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1409 :       *((uint16 *)memPtr) = pixelData16;

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	ax, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [edx], ax

; 1410 :       return;

	jmp	$LN12@Execute_St@5
$LN2@Execute_St@5:

; 1411 :     }
; 1412 :     case 0x3:
; 1413 :       //8 bit
; 1414 :       return;

	jmp	$LN12@Execute_St@5
$LN1@Execute_St@5:

; 1415 :     case 0x4:
; 1416 :     case 0x6:
; 1417 :     {
; 1418 :       //32 bit
; 1419 : 
; 1420 :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 1421 : 
; 1422 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1423 : 
; 1424 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1425 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], ecx

; 1426 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], edx

; 1427 : 
; 1428 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	al, BYTE PTR _bChnorm$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cb32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cr32$[ebp]
	push	edx
	lea	eax, DWORD PTR _y32$[ebp]
	push	eax
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1429 : 
; 1430 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8) | (pixelData32 & 0xFF);

	mov	ecx, DWORD PTR _y32$[ebp]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _cr32$[ebp]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	mov	eax, DWORD PTR _cb32$[ebp]
	shl	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _pixelData32$[ebp]
	and	edx, 255				; 000000ffH
	or	ecx, edx
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 1431 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1432 :       *((uint32 *)memPtr) = pixelData32;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@Execute_St@5:

; 1433 :     }
; 1434 :   }
; 1435 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@Execute_St@5
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@Execute_St@5:
	DD	5
	DD	$LN19@Execute_St@5
$LN19@Execute_St@5:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN14@Execute_St@5
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN15@Execute_St@5
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN16@Execute_St@5
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN17@Execute_St@5
	DD	-72					; ffffffb8H
	DD	2
	DD	$LN18@Execute_St@5
$LN18@Execute_St@5:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN17@Execute_St@5:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN16@Execute_St@5:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN15@Execute_St@5:
	DB	121					; 00000079H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN14@Execute_St@5:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
	npad	2
$LN21@Execute_St@5:
	DD	$LN5@Execute_St@5
	DD	$LN4@Execute_St@5
	DD	$LN3@Execute_St@5
	DD	$LN2@Execute_St@5
	DD	$LN1@Execute_St@5
	DD	$LN3@Execute_St@5
	DD	$LN1@Execute_St@5
?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelAbsolute
_TEXT	ENDS
PUBLIC	?StorePixelZAbsolute@@YAXXZ			; StorePixelZAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv69 = -120						; size = 4
_memPtr$ = -116						; size = 4
_bChnorm$ = -109					; size = 1
_regs$ = -108						; size = 4
_control$ = -104					; size = 4
_z16$ = -96						; size = 2
_pixelData16$ = -72					; size = 2
_z32$ = -60						; size = 4
_cb32$ = -48						; size = 4
_cr32$ = -36						; size = 4
_y32$ = -24						; size = 4
_pixelData32$ = -12					; size = 4
_pixType$ = -4						; size = 4
?StorePixelZAbsolute@@YAXXZ PROC			; StorePixelZAbsolute

; 1438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	edi
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1439 :   uint32 pixType;
; 1440 :   uint32 pixelData32, y32, cr32, cb32, z32;
; 1441 :   uint16 pixelData16, y16, cr16, cb16, z16;
; 1442 :   uint32 control = bilinearAddressInfo.control;

	mov	eax, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+24
	mov	DWORD PTR _control$[ebp], eax

; 1443 :   uint32 *regs = bilinearAddressInfo.pRegs;

	mov	ecx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+8
	mov	DWORD PTR _regs$[ebp], ecx

; 1444 :   bool bChnorm;
; 1445 : 
; 1446 :   void *memPtr;
; 1447 : 
; 1448 :   memPtr = (void *)bilinearAddressInfo.pPixelData;

	mov	edx, DWORD PTR ?bilinearAddressInfo@@3UstructBilinearAddressInfo@@A+4
	mov	DWORD PTR _memPtr$[ebp], edx

; 1449 : 
; 1450 :   pixType = BilinearInfo_XYType(control);

	mov	eax, DWORD PTR _control$[ebp]
	shr	eax, 20					; 00000014H
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 1451 :   bChnorm = BilinearInfo_XYChnorm(control);

	mov	ecx, DWORD PTR _control$[ebp]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl

; 1452 : 
; 1453 :   switch(pixType)

	mov	eax, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 6
	ja	$LN10@StorePixel@2
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN21@StorePixel@2[ecx*4]
$LN7@StorePixel@2:

; 1454 :   {
; 1455 :     case 0x0:
; 1456 :       //MPEG
; 1457 :       return;

	jmp	$LN10@StorePixel@2
$LN6@StorePixel@2:

; 1458 :     case 0x1:
; 1459 :       //4 bit
; 1460 :       return;

	jmp	$LN10@StorePixel@2
$LN5@StorePixel@2:

; 1461 :     case 0x2:
; 1462 :     {
; 1463 :       //16 bit
; 1464 :       y32 = regs[0] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1465 :       cr32 = regs[1] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1466 :       cb32 = regs[2] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], ecx

; 1467 : 
; 1468 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	dl, BYTE PTR _bChnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _cb32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cr32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y32$[ebp]
	push	edx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1469 : 
; 1470 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	eax, DWORD PTR _y32$[ebp]
	and	eax, 252				; 000000fcH
	shl	eax, 8
	mov	ecx, DWORD PTR _cr32$[ebp]
	and	ecx, 248				; 000000f8H
	shl	ecx, 2
	or	eax, ecx
	mov	edx, DWORD PTR _cb32$[ebp]
	and	edx, 248				; 000000f8H
	shr	edx, 3
	or	eax, edx
	mov	WORD PTR _pixelData16$[ebp], ax

; 1471 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1472 :       *((uint16 *)memPtr) = pixelData16;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	cx, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [eax], cx

; 1473 :       return;

	jmp	$LN10@StorePixel@2
$LN4@StorePixel@2:

; 1474 :     }
; 1475 :     case 0x5:
; 1476 :     {
; 1477 :       //16 bit
; 1478 :       y32 = regs[0] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1479 :       cr32 = regs[1] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1480 :       cb32 = regs[2] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], ecx

; 1481 :       z16 = regs[3] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 16					; 00000010H
	mov	WORD PTR _z16$[ebp], ax

; 1482 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	cl, BYTE PTR _bChnorm$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cb32$[ebp]
	push	edx
	lea	eax, DWORD PTR _cr32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y32$[ebp]
	push	ecx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1483 : 
; 1484 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	edx, DWORD PTR _y32$[ebp]
	and	edx, 252				; 000000fcH
	shl	edx, 8
	mov	eax, DWORD PTR _cr32$[ebp]
	and	eax, 248				; 000000f8H
	shl	eax, 2
	or	edx, eax
	mov	ecx, DWORD PTR _cb32$[ebp]
	and	ecx, 248				; 000000f8H
	shr	ecx, 3
	or	edx, ecx
	mov	WORD PTR _pixelData16$[ebp], dx

; 1485 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1486 :       SwapWordBytes(&z16);

	lea	ecx, DWORD PTR _z16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1487 :       *((uint16 *)memPtr) = pixelData16;

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	ax, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [edx], ax

; 1488 :       *((uint16 *)memPtr + 1) = z16;

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	dx, WORD PTR _z16$[ebp]
	mov	WORD PTR [ecx+2], dx

; 1489 :       return;

	jmp	$LN10@StorePixel@2
$LN3@StorePixel@2:

; 1490 :     }
; 1491 :     case 0x3:
; 1492 :       //8 bit
; 1493 :       return;

	jmp	$LN10@StorePixel@2
$LN2@StorePixel@2:

; 1494 :     case 0x4:
; 1495 :     {
; 1496 :       //32 bit
; 1497 : 
; 1498 :       pixelData32 = *((uint32 *)memPtr);

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 1499 : 
; 1500 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1501 : 
; 1502 :       y32 = regs[0] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1503 :       cr32 = regs[1] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1504 :       cb32 = regs[2] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], ecx

; 1505 : 
; 1506 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	dl, BYTE PTR _bChnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _cb32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cr32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y32$[ebp]
	push	edx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1507 : 
; 1508 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8) | (regs[3] >> 24);

	mov	eax, DWORD PTR _y32$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _cr32$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _cb32$[ebp]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 24					; 00000018H
	or	eax, edx
	mov	DWORD PTR _pixelData32$[ebp], eax

; 1509 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1510 :       *((uint32 *)memPtr) = pixelData32;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [eax], ecx

; 1511 :       return;

	jmp	SHORT $LN10@StorePixel@2
$LN1@StorePixel@2:

; 1512 :     }
; 1513 :     case 0x6:
; 1514 :     {
; 1515 :       //32+32Z
; 1516 : 
; 1517 :       pixelData32 = *((uint32 *)memPtr);

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pixelData32$[ebp], eax

; 1518 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1519 : 
; 1520 :       y32 = regs[0] >> 16;

	mov	ecx, DWORD PTR _regs$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], edx

; 1521 :       cr32 = regs[1] >> 16;

	mov	eax, DWORD PTR _regs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], ecx

; 1522 :       cb32 = regs[2] >> 16;

	mov	edx, DWORD PTR _regs$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], eax

; 1523 :       //z32 = entry.pScalarRegs[src+3];
; 1524 : 
; 1525 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	cl, BYTE PTR _bChnorm$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cb32$[ebp]
	push	edx
	lea	eax, DWORD PTR _cr32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y32$[ebp]
	push	ecx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1526 : 
; 1527 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8);

	mov	edx, DWORD PTR _y32$[ebp]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _cr32$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	mov	ecx, DWORD PTR _cb32$[ebp]
	shl	ecx, 8
	or	edx, ecx
	mov	DWORD PTR _pixelData32$[ebp], edx

; 1528 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1529 :       SwapScalarBytes(&z32);

	lea	ecx, DWORD PTR _z32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1530 :       *((uint32 *)memPtr) = pixelData32;

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [edx], eax
$LN10@StorePixel@2:

; 1531 :       //*(((uint32 *)memPtr) + 1) = z32;
; 1532 :       return;
; 1533 :     }
; 1534 :   }
; 1535 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@StorePixel@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@StorePixel@2:
	DD	7
	DD	$LN19@StorePixel@2
$LN19@StorePixel@2:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN12@StorePixel@2
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN13@StorePixel@2
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN14@StorePixel@2
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN15@StorePixel@2
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN16@StorePixel@2
	DD	-72					; ffffffb8H
	DD	2
	DD	$LN17@StorePixel@2
	DD	-96					; ffffffa0H
	DD	2
	DD	$LN18@StorePixel@2
$LN18@StorePixel@2:
	DB	122					; 0000007aH
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN17@StorePixel@2:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN16@StorePixel@2:
	DB	122					; 0000007aH
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN15@StorePixel@2:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN14@StorePixel@2:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN13@StorePixel@2:
	DB	121					; 00000079H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN12@StorePixel@2:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
	npad	2
$LN21@StorePixel@2:
	DD	$LN7@StorePixel@2
	DD	$LN6@StorePixel@2
	DD	$LN5@StorePixel@2
	DD	$LN3@StorePixel@2
	DD	$LN2@StorePixel@2
	DD	$LN4@StorePixel@2
	DD	$LN1@StorePixel@2
?StorePixelZAbsolute@@YAXXZ ENDP			; StorePixelZAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv138 = -128						; size = 4
_memPtr$ = -124						; size = 4
_bChnorm$ = -117					; size = 1
_destPtr$ = -116					; size = 4
_srcPtr$ = -112						; size = 4
_z16$ = -104						; size = 2
_pixelData16$ = -80					; size = 2
_z32$ = -68						; size = 4
_cb32$ = -56						; size = 4
_cr32$ = -44						; size = 4
_y32$ = -32						; size = 4
_pixelData32$ = -20					; size = 4
_address$ = -12						; size = 4
_src$ = -8						; size = 4
_pixType$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelZAbsolute

; 1538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	edi
	lea	edi, DWORD PTR [ebp-128]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1539 :   uint32 pixType;
; 1540 :   uint32 src = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _src$[ebp], ecx

; 1541 :   uint32 address = nuance.fields[FIELD_MEM_TO];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _address$[ebp], eax

; 1542 :   uint32 pixelData32, y32, cr32, cb32, z32;
; 1543 :   uint16 pixelData16, y16, cr6, cb16, z16;
; 1544 :   uint32 *srcPtr;
; 1545 :   uint16 *destPtr;
; 1546 :   bool bChnorm;
; 1547 : 
; 1548 :   srcPtr = &((entry.pScalarRegs)[src]);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 1549 :   destPtr = (uint16 *)nuance.fields[FIELD_MEM_POINTER];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _destPtr$[ebp], eax

; 1550 : 
; 1551 :   void *memPtr;
; 1552 : 
; 1553 :   memPtr = (void *)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 1554 : 
; 1555 :   if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_UV)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 8
	je	SHORT $LN13@Execute_St@6

; 1556 :   {
; 1557 :     pixType = BilinearInfo_XYType(*entry.pUvctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1558 :     bChnorm = BilinearInfo_XYChnorm(*entry.pUvctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl
	jmp	SHORT $LN12@Execute_St@6
$LN13@Execute_St@6:

; 1559 :   }
; 1560 :   else if(nuance.fields[FIELD_MEM_INFO] & MEM_INFO_BILINEAR_XY)

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 4
	je	SHORT $LN11@Execute_St@6

; 1561 :   {
; 1562 :     pixType = BilinearInfo_XYType(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1563 :     bChnorm = BilinearInfo_XYChnorm(*entry.pXyctl);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bChnorm$[ebp], dl

; 1564 :   }
; 1565 :   else

	jmp	SHORT $LN12@Execute_St@6
$LN11@Execute_St@6:

; 1566 :   {
; 1567 :     pixType = BilinearInfo_XYType(mpe.linpixctl);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+456]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], ecx

; 1568 :     bChnorm = BilinearInfo_XYChnorm(mpe.linpixctl);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+456]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bChnorm$[ebp], cl
$LN12@Execute_St@6:

; 1569 :   }
; 1570 : 
; 1571 :   switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv138[ebp], edx
	cmp	DWORD PTR tv138[ebp], 6
	ja	$LN14@Execute_St@6
	mov	eax, DWORD PTR tv138[ebp]
	jmp	DWORD PTR $LN25@Execute_St@6[eax*4]
$LN7@Execute_St@6:

; 1572 :   {
; 1573 :     case 0x0:
; 1574 :       //MPEG
; 1575 :       return;

	jmp	$LN14@Execute_St@6
$LN6@Execute_St@6:

; 1576 :     case 0x1:
; 1577 :       //4 bit
; 1578 :       return;

	jmp	$LN14@Execute_St@6
$LN5@Execute_St@6:

; 1579 :     case 0x2:
; 1580 :     {
; 1581 :       //16 bit
; 1582 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], ecx

; 1583 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1584 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], eax

; 1585 : 
; 1586 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	cl, BYTE PTR _bChnorm$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cb32$[ebp]
	push	edx
	lea	eax, DWORD PTR _cr32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y32$[ebp]
	push	ecx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1587 : 
; 1588 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	edx, DWORD PTR _y32$[ebp]
	and	edx, 252				; 000000fcH
	shl	edx, 8
	mov	eax, DWORD PTR _cr32$[ebp]
	and	eax, 248				; 000000f8H
	shl	eax, 2
	or	edx, eax
	mov	ecx, DWORD PTR _cb32$[ebp]
	and	ecx, 248				; 000000f8H
	shr	ecx, 3
	or	edx, ecx
	mov	WORD PTR _pixelData16$[ebp], dx

; 1589 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1590 :       *((uint16 *)memPtr) = pixelData16;

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	ax, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [edx], ax

; 1591 :       return;

	jmp	$LN14@Execute_St@6
$LN4@Execute_St@6:

; 1592 :     }
; 1593 :     case 0x5:
; 1594 :     {
; 1595 :       //16 bit
; 1596 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], ecx

; 1597 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], edx

; 1598 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], eax

; 1599 :       z16 = entry.pScalarRegs[src+3] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+12]
	shr	ecx, 16					; 00000010H
	mov	WORD PTR _z16$[ebp], cx

; 1600 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	dl, BYTE PTR _bChnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _cb32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cr32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y32$[ebp]
	push	edx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1601 : 
; 1602 :       pixelData16 = ((y32 & 0xFC) << (15-7)) | ((cr32 & 0xF8) << (9-7)) | ((cb32 & 0xF8) >> 3);

	mov	eax, DWORD PTR _y32$[ebp]
	and	eax, 252				; 000000fcH
	shl	eax, 8
	mov	ecx, DWORD PTR _cr32$[ebp]
	and	ecx, 248				; 000000f8H
	shl	ecx, 2
	or	eax, ecx
	mov	edx, DWORD PTR _cb32$[ebp]
	and	edx, 248				; 000000f8H
	shr	edx, 3
	or	eax, edx
	mov	WORD PTR _pixelData16$[ebp], ax

; 1603 :       SwapWordBytes(&pixelData16);

	lea	ecx, DWORD PTR _pixelData16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1604 :       SwapWordBytes(&z16);

	lea	ecx, DWORD PTR _z16$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1605 :       *((uint16 *)memPtr) = pixelData16;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	cx, WORD PTR _pixelData16$[ebp]
	mov	WORD PTR [eax], cx

; 1606 :       *((uint16 *)memPtr + 1) = z16;

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	ax, WORD PTR _z16$[ebp]
	mov	WORD PTR [edx+2], ax

; 1607 :       return;

	jmp	$LN14@Execute_St@6
$LN3@Execute_St@6:

; 1608 :     }
; 1609 :     case 0x3:
; 1610 :       //8 bit
; 1611 :       return;

	jmp	$LN14@Execute_St@6
$LN2@Execute_St@6:

; 1612 :     case 0x4:
; 1613 :     {
; 1614 :       //32 bit
; 1615 : 
; 1616 :       pixelData32 = *((uint32 *)memPtr);

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pixelData32$[ebp], edx

; 1617 : 
; 1618 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1619 : 
; 1620 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], eax

; 1621 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], ecx

; 1622 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], edx

; 1623 : 
; 1624 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	al, BYTE PTR _bChnorm$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cb32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cr32$[ebp]
	push	edx
	lea	eax, DWORD PTR _y32$[ebp]
	push	eax
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1625 : 
; 1626 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8) | (entry.pScalarRegs[src+3] >> 24);

	mov	ecx, DWORD PTR _y32$[ebp]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _cr32$[ebp]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	mov	eax, DWORD PTR _cb32$[ebp]
	shl	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+12]
	shr	eax, 24					; 00000018H
	or	ecx, eax
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 1627 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1628 :       *((uint32 *)memPtr) = pixelData32;

	mov	ecx, DWORD PTR _memPtr$[ebp]
	mov	edx, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [ecx], edx

; 1629 :       return;

	jmp	$LN14@Execute_St@6
$LN1@Execute_St@6:

; 1630 :     }
; 1631 :     case 0x6:
; 1632 :     {
; 1633 :       //32+32Z
; 1634 : 
; 1635 :       pixelData32 = *((uint32 *)memPtr);

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pixelData32$[ebp], ecx

; 1636 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1637 : 
; 1638 :       y32 = entry.pScalarRegs[src] >> 16;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	shr	edx, 16					; 00000010H
	mov	DWORD PTR _y32$[ebp], edx

; 1639 :       cr32 = entry.pScalarRegs[src+1] >> 16;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _cr32$[ebp], eax

; 1640 :       cb32 = entry.pScalarRegs[src+2] >> 16;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	shr	ecx, 16					; 00000010H
	mov	DWORD PTR _cb32$[ebp], ecx

; 1641 :       //z32 = entry.pScalarRegs[src+3];
; 1642 : 
; 1643 :       SaturateColorComponents(&y32, &cr32, &cb32, bChnorm);

	mov	dl, BYTE PTR _bChnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _cb32$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cr32$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y32$[ebp]
	push	edx
	call	?SaturateColorComponents@@YAXPAI00_N@Z	; SaturateColorComponents
	add	esp, 16					; 00000010H

; 1644 : 
; 1645 :       pixelData32 = (y32 << 24) | (cr32 << 16) | (cb32 << 8);

	mov	eax, DWORD PTR _y32$[ebp]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _cr32$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _cb32$[ebp]
	shl	edx, 8
	or	eax, edx
	mov	DWORD PTR _pixelData32$[ebp], eax

; 1646 :       SwapScalarBytes(&pixelData32);

	lea	ecx, DWORD PTR _pixelData32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1647 :       SwapScalarBytes(&z32);

	lea	ecx, DWORD PTR _z32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1648 :       *((uint32 *)memPtr) = pixelData32;

	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR _pixelData32$[ebp]
	mov	DWORD PTR [eax], ecx
$LN14@Execute_St@6:

; 1649 :       //*(((uint32 *)memPtr) + 1) = z32;
; 1650 :       return;
; 1651 :     }
; 1652 :   }
; 1653 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@Execute_St@6
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 128				; 00000080H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@Execute_St@6:
	DD	7
	DD	$LN23@Execute_St@6
$LN23@Execute_St@6:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN16@Execute_St@6
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN17@Execute_St@6
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN18@Execute_St@6
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN19@Execute_St@6
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN20@Execute_St@6
	DD	-80					; ffffffb0H
	DD	2
	DD	$LN21@Execute_St@6
	DD	-104					; ffffff98H
	DD	2
	DD	$LN22@Execute_St@6
$LN22@Execute_St@6:
	DB	122					; 0000007aH
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN21@Execute_St@6:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
$LN20@Execute_St@6:
	DB	122					; 0000007aH
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN19@Execute_St@6:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN18@Execute_St@6:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN17@Execute_St@6:
	DB	121					; 00000079H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
$LN16@Execute_St@6:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
	npad	2
$LN25@Execute_St@6:
	DD	$LN7@Execute_St@6
	DD	$LN6@Execute_St@6
	DD	$LN5@Execute_St@6
	DD	$LN3@Execute_St@6
	DD	$LN2@Execute_St@6
	DD	$LN4@Execute_St@6
	DD	$LN1@Execute_St@6
?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelZAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StoreShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorAbsolute
EXTRN	?SwapShortVectorBytes@@YIXPAG@Z:PROC		; SwapShortVectorBytes
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -8						; size = 4
_srcPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreShortVectorAbsolute

; 1656 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1657 :   int32 *srcPtr;
; 1658 :   int16 *destPtr;
; 1659 : 
; 1660 :   srcPtr = (int32 *)&entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 1661 :   destPtr = (int16 *)nuance.fields[FIELD_MEM_POINTER];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _destPtr$[ebp], eax

; 1662 : 
; 1663 :   destPtr[0] = srcPtr[0] >> 16UL;

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	sar	edx, 16					; 00000010H
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [eax], dx

; 1664 :   destPtr[1] = srcPtr[1] >> 16UL;

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sar	edx, 16					; 00000010H
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [eax+2], dx

; 1665 :   destPtr[2] = srcPtr[2] >> 16UL;

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sar	edx, 16					; 00000010H
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [eax+4], dx

; 1666 :   destPtr[3] = srcPtr[3] >> 16UL;

	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sar	edx, 16					; 00000010H
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [eax+6], dx

; 1667 :   SwapShortVectorBytes((uint16 *)destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapShortVectorBytes@@YIXPAG@Z		; SwapShortVectorBytes

; 1668 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreShortVectorAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StoreShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -8						; size = 4
_srcPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreShortVectorLinear

; 1670 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1671 :   uint32 *srcPtr;
; 1672 :   uint16 *destPtr;
; 1673 : 
; 1674 :   srcPtr = &entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _srcPtr$[ebp], ecx

; 1675 :   destPtr = (uint16 *)(nuonEnv->GetPointerToMemory(&mpe,entry.pScalarRegs[nuance.fields[FIELD_MEM_TO]] & 0xFFFFFFF8));

	push	1
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	and	eax, -8					; fffffff8H
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _destPtr$[ebp], eax

; 1676 : 
; 1677 :   destPtr[0] = srcPtr[0] >> 16UL;

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [ecx], ax

; 1678 :   destPtr[1] = srcPtr[1] >> 16UL;

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1679 :   destPtr[2] = srcPtr[2] >> 16UL;

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1680 :   destPtr[3] = srcPtr[3] >> 16UL;

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	WORD PTR [ecx+6], ax

; 1681 :   SwapShortVectorBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapShortVectorBytes@@YIXPAG@Z		; SwapShortVectorBytes

; 1682 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreShortVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreShortVectorLinear
_TEXT	ENDS
PUBLIC	?Execute_StoreShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreShortVectorBilinearUV

; 1684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1685 :   Nuance newNuance;
; 1686 :   uint32 address;
; 1687 : 
; 1688 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1689 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1690 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1691 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1692 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1693 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1694 :   Execute_StoreShortVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorAbsolute
	add	esp, 12					; 0000000cH

; 1695 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@7
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_St@7:
	DD	2
	DD	$LN5@Execute_St@7
$LN5@Execute_St@7:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@7
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@7
$LN4@Execute_St@7:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@7:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreShortVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreShortVectorBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_StoreShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreShortVectorBilinearXY

; 1697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1698 :   Nuance newNuance;
; 1699 :   uint32 address;
; 1700 : 
; 1701 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1702 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1703 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1704 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1705 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1706 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1707 :   Execute_StoreShortVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreShortVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreShortVectorAbsolute
	add	esp, 12					; 0000000cH

; 1708 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@8
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_St@8:
	DD	2
	DD	$LN5@Execute_St@8
$LN5@Execute_St@8:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@8
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@8
$LN4@Execute_St@8:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@8:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreShortVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreShortVectorBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_StoreVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorAbsolute
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_src$ = -8						; size = 4
_destPtr$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreVectorAbsolute

; 1710 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1711 :   uint32 *destPtr = (uint32 *)nuance.fields[FIELD_MEM_POINTER];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _destPtr$[ebp], ecx

; 1712 :   uint32 src = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src$[ebp], eax

; 1713 :   destPtr[0] = entry.pScalarRegs[src];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx

; 1714 :   destPtr[1] = entry.pScalarRegs[src+1];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _destPtr$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR [edx+4], ecx

; 1715 :   destPtr[2] = entry.pScalarRegs[src+2];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _destPtr$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+8]
	mov	DWORD PTR [ecx+8], eax

; 1716 :   destPtr[3] = entry.pScalarRegs[src+3];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR [eax+12], edx

; 1717 :   SwapVectorBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1718 : 
; 1719 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreVectorAbsolute
_TEXT	ENDS
PUBLIC	?Execute_StoreVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_destPtr$ = -16						; size = 4
_srcPtr$ = -12						; size = 4
_address$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreVectorLinear

; 1721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1722 :   uint32 address, offset;
; 1723 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_TO]] & 0xFFFFFFF0;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, -16				; fffffff0H
	mov	DWORD PTR _address$[ebp], ecx

; 1724 :   uint32 *srcPtr = &entry.pScalarRegs[nuance.fields[FIELD_MEM_FROM]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _srcPtr$[ebp], eax

; 1725 :   uint32 *destPtr = (uint32 *)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _destPtr$[ebp], eax

; 1726 : 
; 1727 :   if((address < MPE_ITAGS_BASE) || (address >= MPE_RESV_BASE))

	cmp	DWORD PTR _address$[ebp], 541589504	; 20480000H
	jb	SHORT $LN4@Execute_St@9
	cmp	DWORD PTR _address$[ebp], 543162368	; 20600000H
	jb	SHORT $LN5@Execute_St@9
$LN4@Execute_St@9:

; 1728 :   {
; 1729 :     destPtr[0] = srcPtr[0];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1730 :     destPtr[1] = srcPtr[1];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1731 :     destPtr[2] = srcPtr[2];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1732 :     destPtr[3] = srcPtr[3];

	mov	eax, DWORD PTR _destPtr$[ebp]
	mov	ecx, DWORD PTR _srcPtr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1733 :     SwapVectorBytes(destPtr);

	mov	ecx, DWORD PTR _destPtr$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1734 :   }
; 1735 :   else

	jmp	SHORT $LN6@Execute_St@9
$LN5@Execute_St@9:

; 1736 :   {
; 1737 :     if((address & 0xFFFF0000) == MPE_ITAGS_BASE)

	mov	eax, DWORD PTR _address$[ebp]
	and	eax, -65536				; ffff0000H
	cmp	eax, 541589504				; 20480000H
	jne	SHORT $LN2@Execute_St@9

; 1738 :     {
; 1739 :       mpe.bInvalidateInstructionCaches = true;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	BYTE PTR [ecx+641], 1

; 1740 :     }
; 1741 :     else

	jmp	SHORT $LN6@Execute_St@9
$LN2@Execute_St@9:

; 1742 :     {
; 1743 :       mpe.WriteControlRegister(address - MPE_CTRL_BASE, srcPtr[0]);

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1744 :       mpe.WriteControlRegister(address + 4 - MPE_CTRL_BASE, srcPtr[1]);

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113788				; 204ffffcH
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1745 :       mpe.WriteControlRegister(address + 8 - MPE_CTRL_BASE, srcPtr[2]);

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113784				; 204ffff8H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 1746 :       mpe.WriteControlRegister(address + 12 - MPE_CTRL_BASE, srcPtr[3]);

	mov	edx, DWORD PTR _srcPtr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _address$[ebp]
	sub	ecx, 542113780				; 204ffff4H
	push	ecx
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister
$LN6@Execute_St@9:

; 1747 :     }
; 1748 :   }
; 1749 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreVectorLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreVectorLinear
_TEXT	ENDS
PUBLIC	?Execute_StoreVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreVectorBilinearUV

; 1751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1752 :   Nuance newNuance;
; 1753 :   uint32 address;
; 1754 : 
; 1755 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1756 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pUvctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1757 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1758 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1759 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1760 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1761 :   Execute_StoreVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorAbsolute
	add	esp, 12					; 0000000cH

; 1762 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@10
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_St@10:
	DD	2
	DD	$LN5@Execute_St@10
$LN5@Execute_St@10:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@10
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@10
$LN4@Execute_St@10:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@10:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreVectorBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreVectorBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_StoreVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreVectorBilinearXY

; 1764 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1765 :   Nuance newNuance;
; 1766 :   uint32 address;
; 1767 : 
; 1768 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1769 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << pixel_type_width[(*entry.pXyctl >> 20) & 0x0FUL]);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1770 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1771 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1772 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1773 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1774 :   Execute_StoreVectorAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StoreVectorAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreVectorAbsolute
	add	esp, 12					; 0000000cH

; 1775 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@11
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_St@11:
	DD	2
	DD	$LN5@Execute_St@11
$LN5@Execute_St@11:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@11
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@11
$LN4@Execute_St@11:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@11:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StoreVectorBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreVectorBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_StorePixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -32						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelLinear

; 1777 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1778 :   Nuance newNuance;
; 1779 :   uint32 address;
; 1780 : 
; 1781 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_TO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 1782 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_LINEAR_INDIRECT;

	mov	DWORD PTR _newNuance$[ebp+4], 2

; 1783 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _newNuance$[ebp+12], eax

; 1784 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1785 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1786 :   Execute_StorePixelAbsolute(mpe,entry,newNuance);

	lea	ecx, DWORD PTR _newNuance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelAbsolute
	add	esp, 12					; 0000000cH

; 1787 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_St@12
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_St@12:
	DD	1
	DD	$LN4@Execute_St@12
$LN4@Execute_St@12:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@12
$LN3@Execute_St@12:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelLinear
_TEXT	ENDS
PUBLIC	?Execute_StorePixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelBilinearUV

; 1789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1790 :   Nuance newNuance;
; 1791 :   uint32 address;
; 1792 : 
; 1793 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1794 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pUvctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1795 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1796 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1797 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1798 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1799 :   Execute_StorePixelAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelAbsolute
	add	esp, 12					; 0000000cH

; 1800 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@13
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_St@13:
	DD	2
	DD	$LN5@Execute_St@13
$LN5@Execute_St@13:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@13
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@13
$LN4@Execute_St@13:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@13:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_StorePixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelBilinearXY

; 1802 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1803 :   Nuance newNuance;
; 1804 :   uint32 address;
; 1805 : 
; 1806 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1807 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pXyctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1808 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1809 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1810 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1811 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1812 :   Execute_StorePixelAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StorePixelAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelAbsolute
	add	esp, 12					; 0000000cH

; 1813 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@14
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_St@14:
	DD	2
	DD	$LN5@Execute_St@14
$LN5@Execute_St@14:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@14
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@14
$LN4@Execute_St@14:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@14:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelBilinearXY
_TEXT	ENDS
PUBLIC	?Execute_StorePixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -32						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelZLinear

; 1815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1816 :   Nuance newNuance;
; 1817 :   uint32 address;
; 1818 : 
; 1819 :   address = entry.pScalarRegs[nuance.fields[FIELD_MEM_TO]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _address$[ebp], ecx

; 1820 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_LINEAR_INDIRECT;

	mov	DWORD PTR _newNuance$[ebp+4], 2

; 1821 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _newNuance$[ebp+12], eax

; 1822 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	ecx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], ecx

; 1823 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1824 :   Execute_StorePixelZAbsolute(mpe,entry,newNuance);

	lea	ecx, DWORD PTR _newNuance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZAbsolute
	add	esp, 12					; 0000000cH

; 1825 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Execute_St@15
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Execute_St@15:
	DD	1
	DD	$LN4@Execute_St@15
$LN4@Execute_St@15:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@15
$LN3@Execute_St@15:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelZLinear@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelZLinear
_TEXT	ENDS
PUBLIC	?Execute_StorePixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZBilinearUV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelZBilinearUV

; 1827 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1828 :   Nuance newNuance;
; 1829 :   uint32 address;
; 1830 : 
; 1831 :   CalculateBilinearAddress(mpe,&address,*entry.pUvctl,entry.pIndexRegs[REG_U],entry.pIndexRegs[REG_V]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1832 :   address = (mpe.uvbase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pUvctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+452]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1833 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_UV;

	mov	DWORD PTR _newNuance$[ebp+4], 8

; 1834 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1835 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1836 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1837 :   Execute_StorePixelZAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZAbsolute
	add	esp, 12					; 0000000cH

; 1838 : 
; 1839 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@16
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Execute_St@16:
	DD	2
	DD	$LN5@Execute_St@16
$LN5@Execute_St@16:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@16
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@16
$LN4@Execute_St@16:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@16:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelZBilinearUV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelZBilinearUV
_TEXT	ENDS
PUBLIC	?Execute_StorePixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZBilinearXY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -36						; size = 4
_newNuance$ = -24					; size = 20
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StorePixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StorePixelZBilinearXY

; 1841 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1842 :   Nuance newNuance;
; 1843 :   uint32 address;
; 1844 : 
; 1845 :   CalculateBilinearAddress(mpe,&address,*entry.pXyctl,entry.pIndexRegs[REG_X],entry.pIndexRegs[REG_Y]);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?CalculateBilinearAddress@@YAXAAVMPE@@PAIIII@Z ; CalculateBilinearAddress
	add	esp, 20					; 00000014H

; 1846 :   address = (mpe.xybase & 0xFFFFFFFC) + (address << BilinearInfo_PixelWidth(pixel_type_width,*entry.pXyctl));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+448]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	ecx, DWORD PTR [edx]
	shr	ecx, 20					; 00000014H
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _address$[ebp]
	mov	ecx, DWORD PTR ?pixel_type_width@@3PAHA[ecx*4]
	shl	edx, cl
	add	eax, edx
	mov	DWORD PTR _address$[ebp], eax

; 1847 :   newNuance.fields[FIELD_MEM_INFO] = MEM_INFO_BILINEAR_XY;

	mov	DWORD PTR _newNuance$[ebp+4], 4

; 1848 :   newNuance.fields[FIELD_MEM_FROM] = nuance.fields[FIELD_MEM_FROM];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newNuance$[ebp+12], ecx

; 1849 :   newNuance.fields[FIELD_MEM_TO] = address;

	mov	edx, DWORD PTR _address$[ebp]
	mov	DWORD PTR _newNuance$[ebp+8], edx

; 1850 :   newNuance.fields[FIELD_MEM_POINTER] = (uint32)(nuonEnv->GetPointerToMemory(&mpe,address));

	push	1
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _newNuance$[ebp+16], eax

; 1851 :   Execute_StorePixelZAbsolute(mpe,entry,newNuance);

	lea	edx, DWORD PTR _newNuance$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Execute_StorePixelZAbsolute@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StorePixelZAbsolute
	add	esp, 12					; 0000000cH

; 1852 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Execute_St@17
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@Execute_St@17:
	DD	2
	DD	$LN5@Execute_St@17
$LN5@Execute_St@17:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN3@Execute_St@17
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Execute_St@17
$LN4@Execute_St@17:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN3@Execute_St@17:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?Execute_StorePixelZBilinearXY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StorePixelZBilinearXY
_TEXT	ENDS
END
