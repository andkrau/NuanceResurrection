; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\nuonrom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG6795	DB	00H, 00H, 00H, 00H, 00H
	ORG $+3
$SG6805	DB	'Bles', 00H
	ORG $+3
$SG6811	DB	'NUONROM-DISK', 00H
	ORG $+3
$SG6815	DB	'cd_app.cof', 00H
	ORG $+1
$SG6823	DB	'nuon.run', 00H
CONST	ENDS
PUBLIC	?LoadNuonRomFile@MPE@@QAE_NPAD@Z		; MPE::LoadNuonRomFile
EXTRN	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z:PROC		; MPE::LoadCoffFile
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	_lseek:PROC
EXTRN	_tell:PROC
EXTRN	_strncmp:PROC
EXTRN	_read:PROC
EXTRN	_open:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\nuonrom.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_where$ = -128						; size = 4
_length$ = -120						; size = 4
_offset$ = -108						; size = 4
_bytesRead$ = -100					; size = 4
_handle$ = -96						; size = 4
_intbuf$ = -88						; size = 5
_linebuf$ = -72						; size = 64
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadNuonRomFile@MPE@@QAE_NPAD@Z PROC			; MPE::LoadNuonRomFile
; _this$ = ecx

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-128]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11   :   char linebuf[64];
; 12   :   char intbuf[5] = "\0\0\0\0";

	mov	eax, DWORD PTR $SG6795
	mov	DWORD PTR _intbuf$[ebp], eax
	mov	cl, BYTE PTR $SG6795+4
	mov	BYTE PTR _intbuf$[ebp+4], cl

; 13   :   int handle, bytesRead;
; 14   :   uint32 offset, length;
; 15   :   long where;
; 16   : 
; 17   :   handle = open(filename,O_RDONLY|O_BINARY,0);

	push	0
	push	32768					; 00008000H
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _handle$[ebp], eax

; 18   :   if(handle >= 0)

	cmp	DWORD PTR _handle$[ebp], 0
	jl	$failure$6819
$check_for_bles$6802:

; 19   :   {
; 20   : check_for_bles:
; 21   :     bytesRead = read(handle, &linebuf, 16);

	push	16					; 00000010H
	lea	eax, DWORD PTR _linebuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 22   :     if(bytesRead == 16)

	cmp	DWORD PTR _bytesRead$[ebp], 16		; 00000010H
	jne	$LN31@LoadNuonRo

; 23   :     {
; 24   :       if(strncmp(linebuf,"Bles",4) == 0)

	push	4
	push	OFFSET $SG6805
	lea	edx, DWORD PTR _linebuf$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@LoadNuonRo

; 25   :       {
; 26   :         where = tell(handle) - 16;

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_tell
	add	esp, 4
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _where$[ebp], eax

; 27   :         //This is a BLES file, not a NUONROM-DISK file.
; 28   :         if((linebuf[4] == 0) && linebuf[5] == 1)

	movsx	ecx, BYTE PTR _linebuf$[ebp+4]
	test	ecx, ecx
	jne	SHORT $LN30@LoadNuonRo
	movsx	edx, BYTE PTR _linebuf$[ebp+5]
	cmp	edx, 1
	jne	SHORT $LN30@LoadNuonRo

; 29   :         {
; 30   :           //Version 1?  COFF offset value is at offset 0x52
; 31   :           bytesRead = lseek(handle, 0x52 - 0x10, SEEK_CUR);

	push	1
	push	66					; 00000042H
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 32   :           
; 33   :           read(handle, &linebuf, 2);

	push	2
	lea	ecx, DWORD PTR _linebuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH

; 34   :           intbuf[0] = linebuf[1];

	mov	al, BYTE PTR _linebuf$[ebp+1]
	mov	BYTE PTR _intbuf$[ebp], al

; 35   :           intbuf[1] = linebuf[0];

	mov	cl, BYTE PTR _linebuf$[ebp]
	mov	BYTE PTR _intbuf$[ebp+1], cl

; 36   :           offset = *((unsigned __int32 *)intbuf);

	mov	edx, DWORD PTR _intbuf$[ebp]
	mov	DWORD PTR _offset$[ebp], edx

; 37   :           lseek(handle,where,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	jmp	$load_coff_file$6808

; 38   :           goto load_coff_file;

	jmp	$load_coff_file$6808
$LN30@LoadNuonRo:

; 39   :         }
; 40   :       }
; 41   :       if(strncmp(linebuf,"NUONROM-DISK",12) == 0)

	push	12					; 0000000cH
	push	OFFSET $SG6811
	lea	edx, DWORD PTR _linebuf$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN27@LoadNuonRo

; 42   :       {
; 43   :         //skip to line containing "cd_app.cof"
; 44   :         bytesRead = read(handle, &linebuf, 48);

	push	48					; 00000030H
	lea	eax, DWORD PTR _linebuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 45   :         if(bytesRead == 48)

	cmp	DWORD PTR _bytesRead$[ebp], 48		; 00000030H
	jne	$LN26@LoadNuonRo

; 46   :         {
; 47   :           bytesRead = read(handle, &linebuf, 16);

	push	16					; 00000010H
	lea	edx, DWORD PTR _linebuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 48   :           if(bytesRead == 16)

	cmp	DWORD PTR _bytesRead$[ebp], 16		; 00000010H
	jne	$LN25@LoadNuonRo

; 49   :           {
; 50   :             if(strncmp(linebuf,"cd_app.cof",10) == 0)

	push	10					; 0000000aH
	push	OFFSET $SG6815
	lea	ecx, DWORD PTR _linebuf$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN24@LoadNuonRo

; 51   :             {
; 52   :               bytesRead = read(handle, &offset, 4);

	push	4
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 53   :               SwapScalarBytes(&offset);

	lea	ecx, DWORD PTR _offset$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 54   :               bytesRead = read(handle, &length, 4);

	push	4
	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 55   :               SwapScalarBytes(&length);

	lea	ecx, DWORD PTR _length$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 56   :               bytesRead = read(handle, &linebuf, 8);

	push	8
	lea	eax, DWORD PTR _linebuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 57   :               lseek(handle, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH

; 58   : 
; 59   :               if(bytesRead == 8)

	cmp	DWORD PTR _bytesRead$[ebp], 8
	jne	SHORT $LN23@LoadNuonRo
$load_coff_file$6808:

; 60   :               {
; 61   :                 //seek to the file offset point
; 62   : load_coff_file:
; 63   :                 bytesRead = lseek(handle, offset, SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 64   :                 if(bytesRead != -1)

	cmp	DWORD PTR _bytesRead$[ebp], -1
	je	SHORT $LN22@LoadNuonRo

; 65   :                 {
; 66   :                   return LoadCoffFile(filename,true,handle);

	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z	; MPE::LoadCoffFile
	jmp	$LN33@LoadNuonRo

; 67   :                 }
; 68   :                 else

	jmp	SHORT $LN23@LoadNuonRo
$LN22@LoadNuonRo:

; 69   :                 {
; 70   :                   goto failure;

	jmp	$failure$6819
	jmp	$failure$6819
$LN23@LoadNuonRo:

; 71   :                 }
; 72   :               }
; 73   :             }

	jmp	$LN19@LoadNuonRo
$LN24@LoadNuonRo:

; 74   :             else if(strncmp(linebuf,"nuon.run",8) == 0)

	push	8
	push	OFFSET $SG6823
	lea	ecx, DWORD PTR _linebuf$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN18@LoadNuonRo

; 75   :             {
; 76   :               bytesRead = read(handle, &offset, 4);

	push	4
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 77   :               SwapScalarBytes(&offset);

	lea	ecx, DWORD PTR _offset$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 78   :               bytesRead = read(handle, &length, 4);

	push	4
	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 79   :               SwapScalarBytes(&length);

	lea	ecx, DWORD PTR _length$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 80   :               bytesRead = read(handle, &linebuf, 8);

	push	8
	lea	eax, DWORD PTR _linebuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 81   :               if(bytesRead == 8)

	cmp	DWORD PTR _bytesRead$[ebp], 8
	jne	SHORT $LN17@LoadNuonRo

; 82   :               {
; 83   :                 bytesRead = lseek(handle, offset, SEEK_SET);

	push	0
	mov	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bytesRead$[ebp], eax

; 84   :                 if(bytesRead != -1)

	cmp	DWORD PTR _bytesRead$[ebp], -1
	je	SHORT $LN16@LoadNuonRo

; 85   :                 {
; 86   :                   goto check_for_bles;

	jmp	$check_for_bles$6802

; 87   :                 }
; 88   :                 else

	jmp	SHORT $LN15@LoadNuonRo
$LN16@LoadNuonRo:

; 89   :                 {
; 90   :                   goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN15@LoadNuonRo:

; 91   :                 }
; 92   :               }
; 93   :               else

	jmp	SHORT $LN13@LoadNuonRo
$LN17@LoadNuonRo:

; 94   :               {
; 95   :                 goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN13@LoadNuonRo:

; 96   :               }
; 97   :             }
; 98   :             else

	jmp	SHORT $LN19@LoadNuonRo
$LN18@LoadNuonRo:

; 99   :             {
; 100  :               goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN19@LoadNuonRo:

; 101  :             }
; 102  :           }
; 103  :           else

	jmp	SHORT $LN9@LoadNuonRo
$LN25@LoadNuonRo:

; 104  :           {
; 105  :             goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN9@LoadNuonRo:

; 106  :           }
; 107  :         }
; 108  :         else

	jmp	SHORT $LN7@LoadNuonRo
$LN26@LoadNuonRo:

; 109  :         {
; 110  :           goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN7@LoadNuonRo:

; 111  :         }
; 112  :       }
; 113  :       else

	jmp	SHORT $LN5@LoadNuonRo
$LN27@LoadNuonRo:

; 114  :       {
; 115  :         goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN5@LoadNuonRo:

; 116  :       }
; 117  :     }
; 118  :     else

	jmp	SHORT $LN3@LoadNuonRo
$LN31@LoadNuonRo:

; 119  :     {
; 120  :       goto failure;

	jmp	SHORT $failure$6819
	jmp	SHORT $failure$6819
$LN3@LoadNuonRo:

; 121  :     }
; 122  :   }
; 123  :   else

	jmp	SHORT $LN33@LoadNuonRo
$failure$6819:

; 124  :   {
; 125  : failure:
; 126  :     return false;

	xor	al, al
$LN33@LoadNuonRo:

; 127  :   }
; 128  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@LoadNuonRo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 128				; 00000080H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN40@LoadNuonRo:
	DD	4
	DD	$LN39@LoadNuonRo
$LN39@LoadNuonRo:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN35@LoadNuonRo
	DD	-88					; ffffffa8H
	DD	5
	DD	$LN36@LoadNuonRo
	DD	-108					; ffffff94H
	DD	4
	DD	$LN37@LoadNuonRo
	DD	-120					; ffffff88H
	DD	4
	DD	$LN38@LoadNuonRo
$LN38@LoadNuonRo:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN37@LoadNuonRo:
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN36@LoadNuonRo:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN35@LoadNuonRo:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?LoadNuonRomFile@MPE@@QAE_NPAD@Z ENDP			; MPE::LoadNuonRomFile
_TEXT	ENDS
END
