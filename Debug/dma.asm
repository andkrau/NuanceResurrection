; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\dma.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z ; UnimplementedBilinearDMAHandler
PUBLIC	?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA	; BilinearDMAHandlers
EXTRN	?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type12_Write_0
EXTRN	?BDMA_Type8_Read_7@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_7
EXTRN	?BDMA_Type8_Read_6@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_6
EXTRN	?BDMA_Type8_Read_5@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_5
EXTRN	?BDMA_Type8_Read_4@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_4
EXTRN	?BDMA_Type8_Read_3@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_3
EXTRN	?BDMA_Type8_Read_2@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_2
EXTRN	?BDMA_Type8_Read_1@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_1
EXTRN	?BDMA_Type8_Read_0@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Read_0
EXTRN	?BDMA_Type8_Write_7@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_7
EXTRN	?BDMA_Type8_Write_6@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_6
EXTRN	?BDMA_Type8_Write_5@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_5
EXTRN	?BDMA_Type8_Write_4@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_4
EXTRN	?BDMA_Type8_Write_3@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_3
EXTRN	?BDMA_Type8_Write_2@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_2
EXTRN	?BDMA_Type8_Write_1@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_1
EXTRN	?BDMA_Type8_Write_0@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type8_Write_0
EXTRN	?BDMA_Type5_Read_7@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_7
EXTRN	?BDMA_Type5_Read_6@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_6
EXTRN	?BDMA_Type5_Read_5@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_5
EXTRN	?BDMA_Type5_Read_4@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_4
EXTRN	?BDMA_Type5_Read_3@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_3
EXTRN	?BDMA_Type5_Read_2@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_2
EXTRN	?BDMA_Type5_Read_1@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_1
EXTRN	?BDMA_Type5_Read_0@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Read_0
EXTRN	?BDMA_Type5_Write_7@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_7
EXTRN	?BDMA_Type5_Write_6@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_6
EXTRN	?BDMA_Type5_Write_5@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_5
EXTRN	?BDMA_Type5_Write_4@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_4
EXTRN	?BDMA_Type5_Write_3@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_3
EXTRN	?BDMA_Type5_Write_2@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_2
EXTRN	?BDMA_Type5_Write_1@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_1
EXTRN	?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z:PROC	; BDMA_Type5_Write_0
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG66886
	ORG $+4
?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA DD FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z ; BilinearDMAHandlers
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_1@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_2@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_3@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_4@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_5@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_6@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_7@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_1@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_2@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_3@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_4@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_5@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_6@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Read_7@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_1@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_2@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_3@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_4@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_5@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_6@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Write_7@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_1@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_2@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_3@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_4@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_5@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_6@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type8_Read_7@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?BDMA_Type12_Write_0@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
	DD	FLAT:?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z
_DATA	ENDS
CONST	SEGMENT
$SG66886 DB	'bad allocation', 00H
	ORG $+1
$SG77857 DB	'DMABiLinear Error', 00H
	ORG $+2
$SG77858 DB	'Chained DMA not supported', 00H
	ORG $+2
$SG77898 DB	'sdramBase is out of range on mpe%d: 0x%lx', 0aH, 00H
	ORG $+1
$SG77899 DB	'DMABiLinear error', 00H
CONST	ENDS
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\dma.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z PROC ; UnimplementedBilinearDMAHandler

; 610  : {

	push	ebp
	mov	ebp, esp

; 611  :   return;
; 612  : }

	pop	ebp
	ret	0
?UnimplementedBilinearDMAHandler@@YAXPAVMPE@@IIIII@Z ENDP ; UnimplementedBilinearDMAHandler
_TEXT	ENDS
PUBLIC	?DMALinear@@YAXPAVMPE@@III@Z			; DMALinear
EXTRN	?UpdateInvalidateRegion@MPE@@QAEXII@Z:PROC	; MPE::UpdateInvalidateRegion
EXTRN	?WriteData@FlashEEPROM@@QAEXII@Z:PROC		; FlashEEPROM::WriteData
EXTRN	?ReadData@FlashEEPROM@@QAEXIPAI@Z:PROC		; FlashEEPROM::ReadData
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?WriteControlRegister@MPE@@QAEXII@Z:PROC	; MPE::WriteControlRegister
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z:PROC ; MPE::ReadControlRegister
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv390 = -316						; size = 4
tv387 = -312						; size = 4
tv379 = -308						; size = 4
tv372 = -304						; size = 4
tv290 = -300						; size = 4
tv282 = -296						; size = 4
$T80121 = -292						; size = 1
$T80120 = -291						; size = 1
$T80119 = -290						; size = 1
$T80118 = -289						; size = 1
_mask$77742 = -288					; size = 2
_tempScalars$ = -216					; size = 16
_bFlushCache$ = -58					; size = 1
_bRemote$ = -57						; size = 1
_bDup$ = -56						; size = 1
_bDirect$ = -55						; size = 1
_bByteMode$ = -54					; size = 1
_bRead$ = -53						; size = 1
_pSrc32$ = -52						; size = 4
_pDest32$ = -48						; size = 4
_pDest$ = -44						; size = 4
_pSrc$ = -40						; size = 4
_baseMemory$ = -36					; size = 4
_intMemory$ = -32					; size = 4
_wordSize$ = -28					; size = 4
_length$ = -24						; size = 4
_srcStride$ = -20					; size = 4
_destStride$ = -16					; size = 4
_directValue$ = -8					; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_intaddr$ = 20						; size = 4
?DMALinear@@YAXPAVMPE@@III@Z PROC			; DMALinear

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T80119[ebp], 0
	mov	BYTE PTR $T80120[ebp], 0
	mov	BYTE PTR $T80118[ebp], 0

; 616  :   uint32 directValue;
; 617  :   uint32 destStride, srcStride, length, wordSize;
; 618  :   void *intMemory, *baseMemory, *pSrc, *pDest;
; 619  :   uint32 *pDest32, *pSrc32;
; 620  :   bool bRead, bByteMode, bDirect, bDup, bRemote, bFlushCache;
; 621  :   char tempBuf[128];
; 622  :   uint32 tempScalars[4];
; 623  :   LARGE_INTEGER timeStart, timeEnd, timeFreq, timeOverhead;
; 624  : 
; 625  :   bByteMode = false;

	mov	BYTE PTR _bByteMode$[ebp], 0

; 626  :   bRemote = flags & (1UL << 28);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bRemote$[ebp], cl

; 627  :   bDirect = flags & (1UL << 27);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 134217728				; 08000000H
	setne	al
	mov	BYTE PTR _bDirect$[ebp], al

; 628  :   bDup = (flags & (3UL << 26));

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 201326592				; 0c000000H
	setne	dl
	mov	BYTE PTR _bDup$[ebp], dl

; 629  :   length = (flags >> 16) & 0xFF; //Only 1-127 is valid according to docs but field is 8 bits

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _length$[ebp], eax

; 630  :   bRead = flags & (1 << 13);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 8192				; 00002000H
	setne	dl
	mov	BYTE PTR _bRead$[ebp], dl

; 631  : 
; 632  :   if(baseaddr < 0xF0000000)

	cmp	DWORD PTR _baseaddr$[ebp], -268435456	; f0000000H
	jae	$LN63@DMALinear

; 633  :   {
; 634  :     if((baseaddr & 0xF0700000) == MPE_CTRL_BASE)

	mov	eax, DWORD PTR _baseaddr$[ebp]
	and	eax, -261095424				; f0700000H
	cmp	eax, 542113792				; 20500000H
	jne	$LN62@DMALinear

; 635  :     {
; 636  :       if(bRead)

	movzx	ecx, BYTE PTR _bRead$[ebp]
	test	ecx, ecx
	je	$LN61@DMALinear

; 637  :       {
; 638  :         directValue = nuonEnv->mpe[(baseaddr >> 23) & 0x1FUL]->ReadControlRegister((baseaddr & 0x207FFFFCUL) - MPE_CTRL_BASE,&the_mpe->ICacheEntry_SaveFlags);

	mov	edx, DWORD PTR _the_mpe$[ebp]
	add	edx, 1076				; 00000434H
	push	edx
	mov	eax, DWORD PTR _baseaddr$[ebp]
	and	eax, 545259516				; 207ffffcH
	sub	eax, 542113792				; 20500000H
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	DWORD PTR _directValue$[ebp], eax

; 639  :         SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 640  : 
; 641  :         if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	$LN60@DMALinear

; 642  :         {
; 643  :           if((intaddr & MPE_CTRL_BASE) == MPE_CTRL_BASE)

	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 542113792				; 20500000H
	cmp	ecx, 542113792				; 20500000H
	jne	SHORT $LN59@DMALinear

; 644  :           {
; 645  :             nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->WriteControlRegister(intaddr & 0x207FFFFC - MPE_CTRL_BASE,directValue);

	mov	edx, DWORD PTR _directValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 3145724				; 002ffffcH
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 646  :           }
; 647  :           else

	jmp	SHORT $LN58@DMALinear
$LN59@DMALinear:

; 648  :           {
; 649  :             intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 545259516				; 207ffffcH
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 650  :             *((uint32 *)intMemory) = directValue;

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN68@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN68@DMALinear:
	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	edx, DWORD PTR _directValue$[ebp]
	mov	DWORD PTR [ecx], edx
$LN58@DMALinear:

; 651  :           }
; 652  :         }
; 653  :         else

	jmp	SHORT $LN57@DMALinear
$LN60@DMALinear:

; 654  :         {          
; 655  :           if((intaddr & MPE_CTRL_BASE) == MPE_CTRL_BASE)

	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 542113792				; 20500000H
	cmp	eax, 542113792				; 20500000H
	jne	SHORT $LN56@DMALinear

; 656  :           {
; 657  :             the_mpe->WriteControlRegister(intaddr & 0x207FFFFC, directValue);

	mov	ecx, DWORD PTR _directValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 658  :           }
; 659  :           else

	jmp	SHORT $LN57@DMALinear
$LN56@DMALinear:

; 660  :           {
; 661  :             intMemory = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC));

	push	1
	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 545259516				; 207ffffcH
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 662  :             *((uint32 *)intMemory) = directValue;

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN70@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN70@DMALinear:
	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	eax, DWORD PTR _directValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN57@DMALinear:

; 663  :           }
; 664  :         }
; 665  :       }
; 666  :       else

	jmp	$LN54@DMALinear
$LN61@DMALinear:

; 667  :       {
; 668  :         if(bRemote)

	movzx	ecx, BYTE PTR _bRemote$[ebp]
	test	ecx, ecx
	je	$LN53@DMALinear

; 669  :         {
; 670  :           if((intaddr & 0xF0700000) == MPE_CTRL_BASE)

	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, -261095424				; f0700000H
	cmp	edx, 542113792				; 20500000H
	jne	SHORT $LN52@DMALinear

; 671  :           {
; 672  :             directValue = nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->ReadControlRegister((intaddr & 0x207FFFFC) - MPE_CTRL_BASE,&the_mpe->ICacheEntry_SaveFlags);

	mov	eax, DWORD PTR _the_mpe$[ebp]
	add	eax, 1076				; 00000434H
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	edx, DWORD PTR _intaddr$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	DWORD PTR _directValue$[ebp], eax

; 673  :           }
; 674  :           else

	jmp	SHORT $LN51@DMALinear
$LN52@DMALinear:

; 675  :           {
; 676  :             intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	push	ecx
	mov	edx, DWORD PTR _intaddr$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 677  :             directValue = *((uint32 *)intMemory);

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN71@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN71@DMALinear:
	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _directValue$[ebp], eax
$LN51@DMALinear:

; 678  :           }
; 679  :           SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 680  :           nuonEnv->mpe[(baseaddr >> 23) & 0x1FUL]->WriteControlRegister((baseaddr & 0x207FFFF) - MPE_CTRL_BASE, directValue);

	mov	ecx, DWORD PTR _directValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	and	edx, 34078719				; 0207ffffH
	sub	edx, 542113792				; 20500000H
	push	edx
	mov	eax, DWORD PTR _baseaddr$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister

; 681  :         }
; 682  :         else

	jmp	$LN54@DMALinear
$LN53@DMALinear:

; 683  :         {          
; 684  :           if((intaddr & MPE_CTRL_BASE) == MPE_CTRL_BASE)

	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 542113792				; 20500000H
	cmp	edx, 542113792				; 20500000H
	jne	SHORT $LN49@DMALinear

; 685  :           {
; 686  :             directValue = the_mpe->ReadControlRegister((intaddr & 0x207FFFFC) - MPE_CTRL_BASE,&the_mpe->ICacheEntry_SaveFlags);

	mov	eax, DWORD PTR _the_mpe$[ebp]
	add	eax, 1076				; 00000434H
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	DWORD PTR _directValue$[ebp], eax

; 687  :           }
; 688  :           else

	jmp	SHORT $LN48@DMALinear
$LN49@DMALinear:

; 689  :           {
; 690  :             intMemory = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC));

	push	1
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 691  :             directValue = *((uint32 *)intMemory);

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN72@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN72@DMALinear:
	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _directValue$[ebp], edx
$LN48@DMALinear:

; 692  :           }
; 693  :           SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 694  :           nuonEnv->mpe[(baseaddr >> 23) & 0x1FUL]->WriteControlRegister((baseaddr & 0x207FFFFC) - MPE_CTRL_BASE,directValue);

	mov	eax, DWORD PTR _directValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister
$LN54@DMALinear:

; 695  :         }
; 696  :       }
; 697  : 
; 698  :       return;

	jmp	$LN64@DMALinear

; 699  :     }
; 700  :     else

	jmp	SHORT $LN47@DMALinear
$LN62@DMALinear:

; 701  :     {
; 702  :       baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(baseaddr >> 23) & 0x1FUL], (baseaddr & 0xFFFFFFFC));

	push	1
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	and	ecx, -4					; fffffffcH
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax
$LN47@DMALinear:

; 703  :     }
; 704  :   }
; 705  :   else

	jmp	$LN46@DMALinear
$LN63@DMALinear:

; 706  :   {
; 707  :     if(bRead)

	movzx	edx, BYTE PTR _bRead$[ebp]
	test	edx, edx
	je	$LN45@DMALinear

; 708  :     {
; 709  :       if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	SHORT $LN44@DMALinear

; 710  :       {
; 711  :         //internal address is system address (but still in MPE memory)
; 712  :         intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	push	ecx
	mov	edx, DWORD PTR _intaddr$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 713  :       }
; 714  :       else

	jmp	SHORT $LN43@DMALinear
$LN44@DMALinear:

; 715  :       {
; 716  :         //internal address is local to MPE
; 717  :         intMemory = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC), false);

	push	0
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax
$LN43@DMALinear:

; 718  :       }
; 719  :       pDest32 = (uint32 *)intMemory;

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN73@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN73@DMALinear:
	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pDest32$[ebp], ecx

; 720  :       nuonEnv->flashEEPROM->ReadData(baseaddr - 0xF0000000,pDest32);

	mov	edx, DWORD PTR _pDest32$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseaddr$[ebp]
	add	eax, 268435456				; 10000000H
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+32]
	call	?ReadData@FlashEEPROM@@QAEXIPAI@Z	; FlashEEPROM::ReadData

; 721  : #ifdef LITTLE_ENDIAN
; 722  :       SwapScalarBytes(pDest32);

	mov	ecx, DWORD PTR _pDest32$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 723  : #endif
; 724  :     }
; 725  :     else

	jmp	$LN42@DMALinear
$LN45@DMALinear:

; 726  :     {
; 727  :       if(bRemote)

	movzx	edx, BYTE PTR _bRemote$[ebp]
	test	edx, edx
	je	SHORT $LN41@DMALinear

; 728  :       {
; 729  :         //internal address is system address (but still in MPE memory)
; 730  :         intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 545259516				; 207ffffcH
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 731  :       }
; 732  :       else

	jmp	SHORT $LN40@DMALinear
$LN41@DMALinear:

; 733  :       {
; 734  :         //internal address is local to MPE
; 735  :         intMemory = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC), false);

	push	0
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax
$LN40@DMALinear:

; 736  :       }
; 737  :       pSrc32 = (uint32 *)intMemory;

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN74@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN74@DMALinear:
	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 738  :       tempScalars[0] = pSrc32[0];

	mov	ecx, DWORD PTR _pSrc32$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tempScalars$[ebp], edx

; 739  : #ifdef LITTLE_ENDIAN
; 740  :       SwapScalarBytes(tempScalars);

	lea	ecx, DWORD PTR _tempScalars$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 741  : #endif
; 742  :       nuonEnv->flashEEPROM->WriteData(baseaddr - 0xF0000000,tempScalars[0]);

	mov	eax, DWORD PTR _tempScalars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	add	ecx, 268435456				; 10000000H
	push	ecx
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+32]
	call	?WriteData@FlashEEPROM@@QAEXII@Z	; FlashEEPROM::WriteData
$LN42@DMALinear:

; 743  :     }
; 744  :     return;

	jmp	$LN64@DMALinear
$LN46@DMALinear:

; 745  :   }
; 746  : 
; 747  :   //wordSize is the size of the atomic data transfer unit as a multiple of a 16-bit word: (word = 1, scalar = 2)
; 748  : 
; 749  :   //source stride specifies the spacing between each atomic data item to be transfered from the source
; 750  :   //this is normally set to one to indicate contiguous items, but will be set to zero for direct data
; 751  :   //where the source pointer is not incremented between data transfers
; 752  :   
; 753  :   //dest stride specifies the stride in 32-bit scalars from the start of one written data item to the next
; 754  :   //for example, alternate word write locations are spaced 32-bits apart, for a stride of one
; 755  : 
; 756  :   srcStride = 1;

	mov	DWORD PTR _srcStride$[ebp], 1

; 757  :   switch(flags & 0x07)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 7
	mov	DWORD PTR tv282[ebp], eax
	cmp	DWORD PTR tv282[ebp], 7
	ja	$LN38@DMALinear
	mov	ecx, DWORD PTR tv282[ebp]
	jmp	DWORD PTR $LN94@DMALinear[ecx*4]
$LN37@DMALinear:

; 758  :   {
; 759  :     //Determine stride in scalars, or in words for byte mode
; 760  :     case 0:
; 761  :       //contiguous scalars
; 762  :       wordSize = 2;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 2

; 763  :       destStride = 1;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 1

; 764  :       break;

	jmp	$LN38@DMALinear
$LN36@DMALinear:

; 765  :     case 1:
; 766  :       //byte mode
; 767  :       bByteMode = true;

	mov	BYTE PTR _bByteMode$[ebp], 1

; 768  :       wordSize = 1;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 1

; 769  :       destStride = 1;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 1

; 770  :       break;

	jmp	$LN38@DMALinear
$LN35@DMALinear:

; 771  :     case 2:
; 772  :       //alternate scalars
; 773  :       wordSize = 2;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 2

; 774  :       destStride = 2;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 2

; 775  :       break;

	jmp	$LN38@DMALinear
$LN34@DMALinear:

; 776  :     case 3:
; 777  :       //alternate words
; 778  :       wordSize = 1;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 1

; 779  :       destStride = 1;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 1

; 780  :       break;

	jmp	SHORT $LN38@DMALinear
$LN33@DMALinear:

; 781  :     case 4:
; 782  :       //every fourth scalar
; 783  :       wordSize = 2;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 2

; 784  :       destStride = 4;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 4

; 785  :       break;

	jmp	SHORT $LN38@DMALinear
$LN32@DMALinear:

; 786  :     case 5:
; 787  :       //every fourth word
; 788  :       wordSize = 1;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 1

; 789  :       destStride = 2;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 2

; 790  :       break;

	jmp	SHORT $LN38@DMALinear
$LN31@DMALinear:

; 791  :     case 6:
; 792  :       //every eighth scalar
; 793  :       wordSize = 2;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 2

; 794  :       destStride = 8;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 8

; 795  :       break;

	jmp	SHORT $LN38@DMALinear
$LN30@DMALinear:

; 796  :     case 7:
; 797  :       //every eighth word
; 798  :       wordSize = 1;

	mov	BYTE PTR $T80119[ebp], 1
	mov	DWORD PTR _wordSize$[ebp], 1

; 799  :       destStride = 4;

	mov	BYTE PTR $T80120[ebp], 1
	mov	DWORD PTR _destStride$[ebp], 4
$LN38@DMALinear:

; 800  :       break;
; 801  :   }
; 802  : 
; 803  :   if(bRead)

	movzx	edx, BYTE PTR _bRead$[ebp]
	test	edx, edx
	je	$LN29@DMALinear

; 804  :   {
; 805  :     //Read: base -> internal
; 806  :     pSrc = baseMemory;

	mov	eax, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax

; 807  : 
; 808  :     bFlushCache = 
; 809  :       ((intaddr & MPE_LOCAL_MEMORY_MASK) >= MPE_IRAM_BASE) &&
; 810  :       ((intaddr & MPE_LOCAL_MEMORY_MASK) < MPE_DTAGS_BASE);

	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259519				; 207fffffH
	cmp	ecx, 540016640				; 20300000H
	jb	SHORT $LN66@DMALinear
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259519				; 207fffffH
	cmp	edx, 541065216				; 20400000H
	jae	SHORT $LN66@DMALinear
	mov	DWORD PTR tv290[ebp], 1
	jmp	SHORT $LN67@DMALinear
$LN66@DMALinear:
	mov	DWORD PTR tv290[ebp], 0
$LN67@DMALinear:
	mov	al, BYTE PTR tv290[ebp]
	mov	BYTE PTR _bFlushCache$[ebp], al

; 811  : 
; 812  :     if(bRemote)

	movzx	ecx, BYTE PTR _bRemote$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@DMALinear

; 813  :     {
; 814  :       //internal address is system address (but still in MPE memory)
; 815  :       pDest = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	eax, DWORD PTR _intaddr$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pDest$[ebp], eax

; 816  :       if(bFlushCache)

	movzx	eax, BYTE PTR _bFlushCache$[ebp]
	test	eax, eax
	je	SHORT $LN27@DMALinear

; 817  :       {
; 818  :         //Maintain cache coherency!  This assumes that code will not be
; 819  :         //dynamically created in the dtrom/dtram section, bypassing the need
; 820  :         //to flush the cache on data writes.
; 821  : 
; 822  :         /*
; 823  : 
; 824  :         Critical TO DO: Many games such as T3K switch between overlays on a very frequent basis because they cannot fit all of the needed
; 825  :         code into a single overlay.  For example, T3K switches overlays several times per frame with each overlay rendering a different
; 826  :         set of playfield objects.  Not only does this cause an unyielding barage of requests to invalidate the interpreter cache and
; 827  :         native code cache but it also means that the native code cache will fill up with multiple copies of overlay code that is compiled
; 828  :         and then forgotten when an invalidation occurs.  This causes additional code cache flushes.  In T3K, the code cache is being
; 829  :         flushed almost non-stop.  This is a serious, serious bottleneck. T3K flushes the cache at an unnerving pace.
; 830  : 
; 831  :         */
; 832  : 
; 833  :         //QueryPerformanceCounter(&timeStart);
; 834  :         //QueryPerformanceCounter(&timeEnd);
; 835  : 
; 836  :         //timeOverhead.QuadPart = timeEnd.QuadPart - timeStart.QuadPart;
; 837  : 
; 838  :         //QueryPerformanceFrequency(&timeFreq);
; 839  :         //QueryPerformanceCounter(&timeStart);
; 840  :         //nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->InvalidateICacheRegion((intaddr & 0xF07FFFFF), (intaddr & 0xF07FFFFF) + (length << 2) - 1);
; 841  :         //nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->InvalidateICache();
; 842  :         //nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->nativeCodeCache->FlushRegion(intaddr & 0xF07FFFFF, (intaddr & 0xF07FFFFF) + (length << 2) - 1);
; 843  :       
; 844  :         nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->UpdateInvalidateRegion(intaddr & 0xF07FFFFF, length << 2);

	mov	ecx, DWORD PTR _length$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, -260046849				; f07fffffH
	push	edx
	mov	eax, DWORD PTR _intaddr$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion
$LN27@DMALinear:

; 845  :         //nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->UpdateInvalidateRegion(MPE_IRAM_BASE, OVERLAY_SIZE);
; 846  :         //nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->nativeCodeCache->FlushRegion(0x20300000, (intaddr & 0xF07FFFFF) + ((length - 1) << 2));
; 847  :         //QueryPerformanceCounter(&timeEnd);
; 848  :         //sprintf(tempBuf,"DMA caused cache invalidations: %lf seconds wasted.",((double)(timeEnd.QuadPart - timeStart.QuadPart - timeOverhead.QuadPart)) / ((double)timeFreq.QuadPart));
; 849  :         //MessageBox(NULL,tempBuf,"DMALinear",MB_OK);
; 850  :       }
; 851  :     }
; 852  :     else

	jmp	SHORT $LN26@DMALinear
$LN28@DMALinear:

; 853  :     {
; 854  :       //internal address is local to MPE
; 855  :       pDest = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC), false);

	push	0
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pDest$[ebp], eax

; 856  :       if(bFlushCache)

	movzx	ecx, BYTE PTR _bFlushCache$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@DMALinear

; 857  :       {
; 858  :         //Maintain cache coherency!  This assumes that code will not be
; 859  :         //dynamically created in the dtrom/dtram section, bypassing the need
; 860  :         //to flush the cache on data writes.
; 861  :         //the_mpe->InvalidateICacheRegion(intaddr, intaddr + (length << 2) - 1);
; 862  :         //the_mpe->InvalidateICache();
; 863  :         //the_mpe->nativeCodeCache->FlushRegion(intaddr, intaddr + (length << 2) - 1);
; 864  :         the_mpe->UpdateInvalidateRegion(intaddr,length << 2);

	mov	edx, DWORD PTR _length$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _intaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion
$LN26@DMALinear:

; 865  :         //the_mpe->UpdateInvalidateRegion(MPE_IRAM_BASE,OVERLAY_SIZE);
; 866  :         //the_mpe->nativeCodeCache->FlushRegion(0x20300000, intaddr + ((length - 1) << 2));
; 867  :       }
; 868  :     }
; 869  :   }
; 870  :   else

	jmp	$LN24@DMALinear
$LN29@DMALinear:

; 871  :   {
; 872  :     //Write: internal -> base
; 873  :     if(bDup)

	movzx	ecx, BYTE PTR _bDup$[ebp]
	test	ecx, ecx
	je	$LN23@DMALinear

; 874  :     {
; 875  :       if(bDirect)

	movzx	edx, BYTE PTR _bDirect$[ebp]
	test	edx, edx
	je	SHORT $LN22@DMALinear

; 876  :       {
; 877  :         directValue = intaddr;

	mov	eax, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], eax

; 878  : #ifdef LITTLE_ENDIAN
; 879  :         //swap back to big endian format
; 880  :         SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 881  : #else
; 882  :         if(wordSize == 1)
; 883  :         {
; 884  :           directValue >>= 16;
; 885  :         }
; 886  : #endif
; 887  :       }
; 888  :       else

	jmp	SHORT $LN21@DMALinear
$LN22@DMALinear:

; 889  :       {
; 890  :         //Dup but not Direct: read scalar from memory, no need to swap
; 891  :         if(bRemote)

	movzx	ecx, BYTE PTR _bRemote$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@DMALinear

; 892  :         {
; 893  :           //internal address is system address (but still in MPE memory)
; 894  :           directValue = *((uint32 *)nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC)));

	push	1
	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 545259516				; 207ffffcH
	push	edx
	mov	eax, DWORD PTR _intaddr$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _directValue$[ebp], eax

; 895  :         }
; 896  :         else

	jmp	SHORT $LN19@DMALinear
$LN20@DMALinear:

; 897  :         {
; 898  :           //internal address is local to MPE
; 899  :           directValue = *((uint32 *)nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC), false));

	push	0
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _directValue$[ebp], eax
$LN19@DMALinear:

; 900  :         }
; 901  : 
; 902  :         //change srcStride to 0 to keep pSrc pointed at directValue
; 903  :         srcStride = 0;

	mov	DWORD PTR _srcStride$[ebp], 0

; 904  :         intMemory = (void *)&directValue;

	mov	BYTE PTR $T80118[ebp], 1
	lea	ecx, DWORD PTR _directValue$[ebp]
	mov	DWORD PTR _intMemory$[ebp], ecx
$LN21@DMALinear:

; 905  : 
; 906  : #ifndef LITTLE_ENDIAN
; 907  :         if(wordSize == 1)
; 908  :         {
; 909  :           directValue >>= 16;
; 910  :           intMemory = (void *)((uint8 *)&directValue + 2);
; 911  :         }
; 912  : #endif
; 913  :       }
; 914  :     }
; 915  :     else

	jmp	SHORT $LN18@DMALinear
$LN23@DMALinear:

; 916  :     {
; 917  :       if(bRemote)

	movzx	edx, BYTE PTR _bRemote$[ebp]
	test	edx, edx
	je	SHORT $LN17@DMALinear

; 918  :       {
; 919  :         //internal address is system address (but still in MPE memory)
; 920  :         intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(intaddr >> 23) & 0x1FUL], (intaddr & 0x207FFFFC));

	push	1
	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 545259516				; 207ffffcH
	push	eax
	mov	ecx, DWORD PTR _intaddr$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax

; 921  :       }
; 922  :       else

	jmp	SHORT $LN18@DMALinear
$LN17@DMALinear:

; 923  :       {
; 924  :         //internal address is local to MPE
; 925  :         intMemory = nuonEnv->GetPointerToMemory(the_mpe, (intaddr & 0x207FFFFC), false);

	push	0
	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 545259516				; 207ffffcH
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	BYTE PTR $T80118[ebp], 1
	mov	DWORD PTR _intMemory$[ebp], eax
$LN18@DMALinear:

; 926  :       }
; 927  :     }
; 928  : 
; 929  :     pSrc = intMemory;

	cmp	BYTE PTR $T80118[ebp], 0
	jne	SHORT $LN75@DMALinear
	push	OFFSET $LN69@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN75@DMALinear:
	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax

; 930  :     pDest = baseMemory;

	mov	ecx, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], ecx
$LN24@DMALinear:

; 931  :   }
; 932  : 
; 933  :   if(!bByteMode)

	movzx	edx, BYTE PTR _bByteMode$[ebp]
	test	edx, edx
	jne	$LN15@DMALinear

; 934  :   {
; 935  :     if(wordSize == 2)

	cmp	BYTE PTR $T80119[ebp], 0
	jne	SHORT $LN76@DMALinear
	push	OFFSET $LN77@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN76@DMALinear:
	cmp	DWORD PTR _wordSize$[ebp], 2
	jne	SHORT $LN10@DMALinear
$LN13@DMALinear:

; 936  :     {
; 937  :       while(length--)

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR tv372[ebp], eax
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _length$[ebp], ecx
	cmp	DWORD PTR tv372[ebp], 0
	je	SHORT $LN12@DMALinear

; 938  :       {
; 939  :         *((uint32 *)pDest) = *((uint32 *)pSrc);

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 940  :         pSrc = ((uint32 *)pSrc) + srcStride;

	mov	edx, DWORD PTR _srcStride$[ebp]
	mov	eax, DWORD PTR _pSrc$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pSrc$[ebp], ecx

; 941  :         pDest = ((uint32 *)pDest) + destStride;

	cmp	BYTE PTR $T80120[ebp], 0
	jne	SHORT $LN78@DMALinear
	push	OFFSET $LN79@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN78@DMALinear:
	mov	edx, DWORD PTR _destStride$[ebp]
	mov	eax, DWORD PTR _pDest$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pDest$[ebp], ecx

; 942  :       }

	jmp	SHORT $LN13@DMALinear
$LN12@DMALinear:

; 943  :     }
; 944  :     else

	jmp	SHORT $LN11@DMALinear
$LN10@DMALinear:

; 945  :     {
; 946  :       while(length--)

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR tv379[ebp], edx
	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 1
	mov	DWORD PTR _length$[ebp], eax
	cmp	DWORD PTR tv379[ebp], 0
	je	SHORT $LN11@DMALinear

; 947  :       {
; 948  :         *((uint16 *)pDest) = *((uint16 *)pSrc);

	mov	ecx, DWORD PTR _pDest$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax

; 949  :         pSrc = ((uint16 *)pSrc) + srcStride;

	mov	ecx, DWORD PTR _srcStride$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pSrc$[ebp], eax

; 950  :         pDest = ((uint32 *)pDest) + destStride;

	cmp	BYTE PTR $T80120[ebp], 0
	jne	SHORT $LN80@DMALinear
	push	OFFSET $LN79@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN80@DMALinear:
	mov	ecx, DWORD PTR _destStride$[ebp]
	mov	edx, DWORD PTR _pDest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pDest$[ebp], eax

; 951  :       }

	jmp	SHORT $LN10@DMALinear
$LN11@DMALinear:

; 952  :     }
; 953  :   }
; 954  :   else

	jmp	$LN64@DMALinear
$LN15@DMALinear:
	mov	BYTE PTR $T80121[ebp], 0

; 955  :   {
; 956  :     uint16 mask;
; 957  : 
; 958  :     switch((flags >> 3) & 0x3)

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 3
	and	ecx, 3
	mov	DWORD PTR tv387[ebp], ecx
	cmp	DWORD PTR tv387[ebp], 3
	ja	SHORT $LN2@DMALinear
	mov	edx, DWORD PTR tv387[ebp]
	jmp	DWORD PTR $LN95@DMALinear[edx*4]
$LN5@DMALinear:

; 959  :     {
; 960  :       case 0: //illegal, but fall through to case 1 anyway
; 961  :       case 1: //Byte 1 only (LSB bits [7:0] of each word)
; 962  : #ifdef LITTLE_ENDIAN
; 963  :         mask = 0xFF00;

	mov	BYTE PTR $T80121[ebp], 1
	mov	WORD PTR _mask$77742[ebp], 65280	; 0000ff00H

; 964  : #else
; 965  :         mask = 0x00FF;
; 966  : #endif
; 967  :         break;

	jmp	SHORT $LN2@DMALinear
$LN4@DMALinear:

; 968  :       case 2: //Byte 0 only (MSB bits [15:8] of each word)
; 969  : #ifdef LITTLE_ENDIAN
; 970  :         mask = 0x00FF;

	mov	BYTE PTR $T80121[ebp], 1
	mov	WORD PTR _mask$77742[ebp], 255		; 000000ffH

; 971  : #else
; 972  :         mask = 0xFF00;
; 973  : #endif
; 974  :         break;

	jmp	SHORT $LN2@DMALinear
$LN3@DMALinear:

; 975  :       case 3: //Contiguous words
; 976  :         mask = 0xFFFF;

	mov	BYTE PTR $T80121[ebp], 1
	mov	WORD PTR _mask$77742[ebp], 65535	; 0000ffffH
$LN2@DMALinear:

; 977  :         break;
; 978  :     }
; 979  : 
; 980  :     while(length--)

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR tv390[ebp], eax
	mov	ecx, DWORD PTR _length$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _length$[ebp], ecx
	cmp	DWORD PTR tv390[ebp], 0
	je	$LN64@DMALinear

; 981  :     {
; 982  :       *((uint16 *)pDest) &= ~mask;

	cmp	BYTE PTR $T80121[ebp], 0
	jne	SHORT $LN81@DMALinear
	push	OFFSET $LN82@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN81@DMALinear:
	movzx	edx, WORD PTR _mask$77742[ebp]
	not	edx
	mov	eax, DWORD PTR _pDest$[ebp]
	movzx	ecx, WORD PTR [eax]
	and	ecx, edx
	mov	edx, DWORD PTR _pDest$[ebp]
	mov	WORD PTR [edx], cx

; 983  :       *((uint16 *)pDest) |= (*((uint16 *)pSrc) & mask);

	cmp	BYTE PTR $T80121[ebp], 0
	jne	SHORT $LN83@DMALinear
	push	OFFSET $LN82@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN83@DMALinear:
	mov	eax, DWORD PTR _pSrc$[ebp]
	movzx	ecx, WORD PTR [eax]
	movzx	edx, WORD PTR _mask$77742[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _pDest$[ebp]
	movzx	edx, WORD PTR [eax]
	or	edx, ecx
	mov	eax, DWORD PTR _pDest$[ebp]
	mov	WORD PTR [eax], dx

; 984  :        pSrc = ((uint16 *)pSrc) + srcStride;

	mov	ecx, DWORD PTR _srcStride$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pSrc$[ebp], eax

; 985  :        pDest = ((uint16 *)pDest) + destStride;

	cmp	BYTE PTR $T80120[ebp], 0
	jne	SHORT $LN84@DMALinear
	push	OFFSET $LN79@DMALinear
	call	__RTC_UninitUse
	add	esp, 4
$LN84@DMALinear:
	mov	ecx, DWORD PTR _destStride$[ebp]
	mov	edx, DWORD PTR _pDest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pDest$[ebp], eax

; 986  :     }

	jmp	$LN2@DMALinear
$LN64@DMALinear:

; 987  :   }
; 988  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN93@DMALinear
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@DMALinear:
	DD	7
	DD	$LN92@DMALinear
$LN92@DMALinear:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN85@DMALinear
	DD	-192					; ffffff40H
	DD	128					; 00000080H
	DD	$LN86@DMALinear
	DD	-216					; ffffff28H
	DD	16					; 00000010H
	DD	$LN87@DMALinear
	DD	-232					; ffffff18H
	DD	8
	DD	$LN88@DMALinear
	DD	-248					; ffffff08H
	DD	8
	DD	$LN89@DMALinear
	DD	-264					; fffffef8H
	DD	8
	DD	$LN90@DMALinear
	DD	-280					; fffffee8H
	DD	8
	DD	$LN91@DMALinear
$LN91@DMALinear:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$LN90@DMALinear:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	113					; 00000071H
	DB	0
$LN89@DMALinear:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN88@DMALinear:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN87@DMALinear:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN86@DMALinear:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN85@DMALinear:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN82@DMALinear:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	0
$LN79@DMALinear:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN77@DMALinear:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN69@DMALinear:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
	npad	1
$LN94@DMALinear:
	DD	$LN37@DMALinear
	DD	$LN36@DMALinear
	DD	$LN35@DMALinear
	DD	$LN34@DMALinear
	DD	$LN33@DMALinear
	DD	$LN32@DMALinear
	DD	$LN31@DMALinear
	DD	$LN30@DMALinear
$LN95@DMALinear:
	DD	$LN5@DMALinear
	DD	$LN5@DMALinear
	DD	$LN4@DMALinear
	DD	$LN3@DMALinear
?DMALinear@@YAXPAVMPE@@III@Z ENDP			; DMALinear
_TEXT	ENDS
PUBLIC	?DMALinear@@YAXPAVMPE@@@Z			; DMALinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_intaddr$ = -12						; size = 4
_baseaddr$ = -8						; size = 4
_flags$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?DMALinear@@YAXPAVMPE@@@Z PROC				; DMALinear

; 991  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 992  :   uint32 flags = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _flags$[ebp], ecx

; 993  :   uint32 baseaddr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _baseaddr$[ebp], eax

; 994  :   uint32 intaddr = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _intaddr$[ebp], edx

; 995  : 
; 996  :   //For the BIOS call, simulate the latency of the call assuming
; 997  :   //40 cycles of setup time (copying to command buffer, determining
; 998  :   //which bus to write to, etc) plus one cycle per long transfered
; 999  :   nuonEnv->cycleCounter += (40 + (flags >> 16) & 0xFF); //Only 1-127 is valid according to docs but field is 8 bits

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 16					; 00000010H
	add	eax, 40					; 00000028H
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	add	eax, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [edx+36], eax

; 1000 : 
; 1001 :   DMALinear(the_mpe,flags,baseaddr,intaddr);

	mov	eax, DWORD PTR _intaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	call	?DMALinear@@YAXPAVMPE@@III@Z		; DMALinear
	add	esp, 16					; 00000010H

; 1002 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DMALinear@@YAXPAVMPE@@@Z ENDP				; DMALinear
_TEXT	ENDS
PUBLIC	?DMABiLinear@@YAXPAVMPE@@IIIII@Z		; DMABiLinear
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
EXTRN	_sprintf:PROC
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv529 = -800						; size = 4
tv526 = -796						; size = 4
tv425 = -792						; size = 4
tv410 = -788						; size = 4
tv407 = -784						; size = 4
tv331 = -780						; size = 4
tv306 = -776						; size = 4
tv214 = -772						; size = 4
tv78 = -768						; size = 4
tv74 = -764						; size = 4
tv72 = -760						; size = 4
$T80166 = -756						; size = 1
$T80165 = -755						; size = 1
$T80164 = -754						; size = 1
$T80163 = -753						; size = 1
$T80162 = -752						; size = 1
$T80161 = -751						; size = 1
$T80160 = -750						; size = 1
$T80159 = -749						; size = 1
$T80158 = -748						; size = 1
$T80157 = -747						; size = 1
$T80156 = -746						; size = 1
$T80155 = -745						; size = 1
_ztransfer$77957 = -740					; size = 2
_ztarget$77956 = -728					; size = 2
_result$77955 = -717					; size = 1
_msgBuf$77897 = -712					; size = 512
_bZTestResult$ = -195					; size = 1
_bUpdateZ$ = -194					; size = 1
_bUpdatePixel$ = -193					; size = 1
_bCompareZ$ = -192					; size = 1
_bTrigger$ = -191					; size = 1
_bRemote$ = -190					; size = 1
_bChain$ = -189						; size = 1
_bBatch$ = -188						; size = 1
_bDup$ = -187						; size = 1
_bDirect$ = -186					; size = 1
_bRead$ = -185						; size = 1
_whichRoutine$ = -184					; size = 4
_skipsize$ = -172					; size = 4
_mpeBase$ = -168					; size = 4
_sdramBase$ = -164					; size = 4
_pixsize$ = -160					; size = 4
_wordsize$ = -156					; size = 4
_mode$ = -152						; size = 4
_bva$ = -148						; size = 4
_zcompare$ = -144					; size = 4
_ypos$ = -140						; size = 4
_ylen$ = -136						; size = 4
_xpos$ = -132						; size = 4
_xlen$ = -128						; size = 4
_xsize$ = -124						; size = 4
_destBStep$ = -120					; size = 4
_destAStep$ = -116					; size = 4
_srcBStep$ = -112					; size = 4
_srcAStep$ = -108					; size = 4
_destOffset$ = -104					; size = 4
_srcOffset$ = -100					; size = 4
_destB$ = -96						; size = 4
_destA$ = -92						; size = 4
_srcB$ = -88						; size = 4
_srcA$ = -84						; size = 4
_aCountInit$ = -80					; size = 4
_bCount$ = -76						; size = 4
_aCount$ = -72						; size = 4
_destBStart$ = -68					; size = 4
_destAStart$ = -64					; size = 4
_srcBStart$ = -60					; size = 4
_srcAStart$ = -56					; size = 4
_pixtype$ = -52						; size = 4
_type$ = -48						; size = 4
_directValue$ = -40					; size = 4
_pDest$ = -32						; size = 4
_pSrc$ = -28						; size = 4
_baseMemory$ = -24					; size = 4
_intMemory$ = -20					; size = 4
_pDest16$ = -16						; size = 4
_pSrc16$ = -12						; size = 4
_pDest32$ = -8						; size = 4
_pSrc32$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?DMABiLinear@@YAXPAVMPE@@IIIII@Z PROC			; DMABiLinear

; 1005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 800				; 00000320H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-800]
	mov	ecx, 200				; 000000c8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T80156[ebp], 0
	mov	BYTE PTR $T80162[ebp], 0
	mov	BYTE PTR $T80157[ebp], 0
	mov	BYTE PTR $T80158[ebp], 0
	mov	BYTE PTR $T80164[ebp], 0
	mov	BYTE PTR $T80163[ebp], 0
	mov	BYTE PTR $T80159[ebp], 0
	mov	BYTE PTR $T80165[ebp], 0
	mov	BYTE PTR $T80155[ebp], 0
	mov	BYTE PTR $T80161[ebp], 0
	mov	BYTE PTR $T80160[ebp], 0

; 1006 :   uint32 *pSrc32, *pDest32;
; 1007 :   uint16 *pSrc16, *pDest16;
; 1008 :   void *intMemory, *baseMemory, *pSrc, *pDest;
; 1009 :   uint32 directValue, type, pixtype;
; 1010 :   uint32 srcAStart, srcBStart, destAStart, destBStart, aCount, bCount, aCountInit;
; 1011 :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset;
; 1012 :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 1013 :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 1014 :   uint32 mode, wordsize, pixsize, sdramBase, mpeBase, skipsize;
; 1015 :   uint32 lowerLimit, upperLimit, whichRoutine;
; 1016 : 
; 1017 :   bool bRead, bDirect, bDup, bBatch, bChain, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 1018 : 
; 1019 :   //pixel flags + backwards flag a (PPPP):(xxxA) 
; 1020 :   whichRoutine = flags & 0xF1;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 241				; 000000f1H
	mov	DWORD PTR _whichRoutine$[ebp], eax

; 1021 :   //read flag (PPPP):(RxxA)
; 1022 :   whichRoutine |= ((flags >> (13 - 3)) & 0x08UL);

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 8
	or	ecx, DWORD PTR _whichRoutine$[ebp]
	mov	DWORD PTR _whichRoutine$[ebp], ecx

; 1023 :   //vertical flag and backwards flag b (PPPP):(RBVA)
; 1024 :   whichRoutine |= ((flags >> (9 - 2)) & 0x06UL);

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 7
	and	edx, 6
	or	edx, DWORD PTR _whichRoutine$[ebp]
	mov	DWORD PTR _whichRoutine$[ebp], edx

; 1025 : 
; 1026 :   switch(whichRoutine >> 4)

	mov	eax, DWORD PTR _whichRoutine$[ebp]
	shr	eax, 4
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 15			; 0000000fH
	ja	$LN103@DMABiLinea
	mov	ecx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN173@DMABiLinea[ecx*4]
$LN123@DMABiLinea:

; 1027 :   {
; 1028 :     case 0:
; 1029 :       whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0

; 1030 :       return;

	jmp	$LN126@DMABiLinea

; 1031 :       break;

	jmp	$LN124@DMABiLinea
$LN122@DMABiLinea:

; 1032 :     case 1:
; 1033 :       whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0

; 1034 :       //return;
; 1035 :       break;

	jmp	$LN124@DMABiLinea
$LN121@DMABiLinea:

; 1036 :     case 2:
; 1037 :       whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0

; 1038 :       break;

	jmp	$LN124@DMABiLinea
$LN120@DMABiLinea:

; 1039 :     case 3:
; 1040 :       whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0

; 1041 :       //return;
; 1042 :       break;

	jmp	$LN124@DMABiLinea
$LN119@DMABiLinea:

; 1043 :     case 4:
; 1044 :       switch(whichRoutine & 0x0FUL)

	mov	edx, DWORD PTR _whichRoutine$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR tv74[ebp], edx
	je	SHORT $LN116@DMABiLinea
	cmp	DWORD PTR tv74[ebp], 8
	je	SHORT $LN116@DMABiLinea
	jmp	SHORT $LN115@DMABiLinea
$LN116@DMABiLinea:

; 1045 :       {
; 1046 :         case 0:
; 1047 :         case 8:
; 1048 :           break;

	jmp	SHORT $LN117@DMABiLinea
$LN115@DMABiLinea:

; 1049 :         default:
; 1050 :           whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0
$LN117@DMABiLinea:

; 1051 :       }
; 1052 :       break;

	jmp	$LN124@DMABiLinea
$LN114@DMABiLinea:

; 1053 :     case 5:
; 1054 :       switch(whichRoutine & 0x0FUL)

	mov	eax, DWORD PTR _whichRoutine$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv78[ebp], eax
	je	SHORT $LN111@DMABiLinea
	cmp	DWORD PTR tv78[ebp], 8
	je	SHORT $LN111@DMABiLinea
	jmp	SHORT $LN110@DMABiLinea
$LN111@DMABiLinea:

; 1055 :       {
; 1056 :         case 0:
; 1057 :         case 8:
; 1058 :           BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	ecx, DWORD PTR _intaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _yinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _xinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichRoutine$[ebp]
	mov	edx, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[ecx*4]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1059 :           return;

	jmp	$LN126@DMABiLinea

; 1060 :           break;

	jmp	SHORT $LN112@DMABiLinea
$LN110@DMABiLinea:

; 1061 :         default:
; 1062 :           whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0
$LN112@DMABiLinea:

; 1063 :           break;
; 1064 :       }
; 1065 :       break;

	jmp	$LN124@DMABiLinea
$LN109@DMABiLinea:

; 1066 :     case 6:
; 1067 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	eax, DWORD PTR _intaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _yinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichRoutine$[ebp]
	mov	ecx, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[eax*4]
	call	ecx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1068 :       return;

	jmp	$LN126@DMABiLinea

; 1069 :       break;

	jmp	$LN124@DMABiLinea
$LN108@DMABiLinea:

; 1070 :     case 8:
; 1071 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	edx, DWORD PTR _intaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _yinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichRoutine$[ebp]
	mov	eax, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[edx*4]
	call	eax
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1072 :       return;

	jmp	$LN126@DMABiLinea

; 1073 :       break;

	jmp	$LN124@DMABiLinea
$LN107@DMABiLinea:

; 1074 :     case 9:
; 1075 :     case 10:
; 1076 :     case 11:
; 1077 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	ecx, DWORD PTR _intaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _yinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _xinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichRoutine$[ebp]
	mov	edx, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[ecx*4]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1078 :       return;

	jmp	$LN126@DMABiLinea

; 1079 :       break;

	jmp	$LN124@DMABiLinea
$LN106@DMABiLinea:

; 1080 :     case 12:
; 1081 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	eax, DWORD PTR _intaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _yinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _baseaddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	eax, DWORD PTR _whichRoutine$[ebp]
	mov	ecx, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[eax*4]
	call	ecx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1082 :       return;

	jmp	$LN126@DMABiLinea

; 1083 :       break;

	jmp	$LN124@DMABiLinea
$LN105@DMABiLinea:

; 1084 :     case 13:
; 1085 :     case 14:
; 1086 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	edx, DWORD PTR _intaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _yinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _whichRoutine$[ebp]
	mov	eax, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[edx*4]
	call	eax
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1087 :       return;

	jmp	$LN126@DMABiLinea

; 1088 :       break;

	jmp	SHORT $LN124@DMABiLinea
$LN104@DMABiLinea:

; 1089 :     case 15:
; 1090 :       BilinearDMAHandlers[whichRoutine](the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	esi, esp
	mov	ecx, DWORD PTR _intaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _yinfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _xinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _baseaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _whichRoutine$[ebp]
	mov	edx, DWORD PTR ?BilinearDMAHandlers@@3PAP6AXPAVMPE@@IIIII@ZA[ecx*4]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1091 :       return;

	jmp	$LN126@DMABiLinea

; 1092 :       break;

	jmp	SHORT $LN124@DMABiLinea
$LN103@DMABiLinea:

; 1093 :     default:
; 1094 :       whichRoutine = 0;

	mov	DWORD PTR _whichRoutine$[ebp], 0

; 1095 :       return;

	jmp	$LN126@DMABiLinea
$LN124@DMABiLinea:

; 1096 :       break;
; 1097 :   }
; 1098 : 
; 1099 :   bBatch = flags & (1UL << 30);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1073741824				; 40000000H
	setne	cl
	mov	BYTE PTR _bBatch$[ebp], cl

; 1100 :   bChain = flags & (1UL << 29);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 536870912				; 20000000H
	setne	al
	mov	BYTE PTR _bChain$[ebp], al

; 1101 :   bRemote = flags & (1UL << 28);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bRemote$[ebp], dl

; 1102 :   bDirect = flags & (1UL << 27);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 134217728				; 08000000H
	setne	cl
	mov	BYTE PTR _bDirect$[ebp], cl

; 1103 :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 201326592				; 0c000000H
	setne	al
	mov	BYTE PTR _bDup$[ebp], al

; 1104 :   bTrigger = flags & (1UL << 25);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 33554432				; 02000000H
	setne	dl
	mov	BYTE PTR _bTrigger$[ebp], dl

; 1105 :   bRead = flags & (1UL << 13);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8192				; 00002000H
	setne	cl
	mov	BYTE PTR _bRead$[ebp], cl

; 1106 :   xsize = (flags >> 13) & 0x7F8UL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 13					; 0000000dH
	and	edx, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], edx

; 1107 :   type = (flags >> 14) & 0x03UL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 14					; 0000000eH
	and	eax, 3
	mov	DWORD PTR _type$[ebp], eax

; 1108 :   mode = flags & 0xFFFUL;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], ecx

; 1109 :   zcompare = (flags >> 1) & 0x07UL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 1
	and	edx, 7
	mov	DWORD PTR _zcompare$[ebp], edx

; 1110 :   pixtype = (flags >> 4) & 0x0FUL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 4
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], eax

; 1111 :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 7
	and	ecx, 6
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 1
	or	ecx, edx
	mov	DWORD PTR _bva$[ebp], ecx

; 1112 :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	eax, DWORD PTR _baseaddr$[ebp]
	and	eax, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], eax

; 1113 :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	ecx, DWORD PTR _intaddr$[ebp]
	and	ecx, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], ecx

; 1114 :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	edx, DWORD PTR _xinfo$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], edx

; 1115 :   xpos = xinfo & 0x7FFUL;

	mov	eax, DWORD PTR _xinfo$[ebp]
	and	eax, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], eax

; 1116 :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	ecx, DWORD PTR _yinfo$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], ecx

; 1117 :   ypos = yinfo & 0x7FFUL;

	mov	edx, DWORD PTR _yinfo$[ebp]
	and	edx, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], edx

; 1118 :   skipsize = 0;

	mov	DWORD PTR _skipsize$[ebp], 0

; 1119 :   bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1120 :   bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 1121 :   bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 1122 : 
; 1123 :   directValue = intaddr;

	mov	eax, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], eax

; 1124 : 
; 1125 :   if(bChain)

	movzx	ecx, BYTE PTR _bChain$[ebp]
	test	ecx, ecx
	je	SHORT $LN102@DMABiLinea

; 1126 :   {
; 1127 :     MessageBox(NULL,"Chained DMA not supported","DMABiLinear Error",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG77857
	push	OFFSET $SG77858
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1128 :     return;

	jmp	$LN126@DMABiLinea
$LN102@DMABiLinea:

; 1129 :   }
; 1130 : 
; 1131 :   switch(pixtype)

	mov	edx, DWORD PTR _pixtype$[ebp]
	mov	DWORD PTR tv214[ebp], edx
	cmp	DWORD PTR tv214[ebp], 15		; 0000000fH
	ja	$LN100@DMABiLinea
	mov	eax, DWORD PTR tv214[ebp]
	jmp	DWORD PTR $LN174@DMABiLinea[eax*4]
$LN99@DMABiLinea:

; 1132 :   {
; 1133 :     //4 bit, 8 bit, 16 bit, and 16 bit Z-field only modes
; 1134 :     case 0:
; 1135 :       //16 bit Z field only
; 1136 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1137 :       break;

	jmp	$LN100@DMABiLinea
$LN98@DMABiLinea:

; 1138 :     case 1:
; 1139 :       //4 bit
; 1140 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1141 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1142 :       xlen >>= 2;

	mov	ecx, DWORD PTR _xlen$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _xlen$[ebp], ecx

; 1143 :       xsize >>= 2;

	mov	edx, DWORD PTR _xsize$[ebp]
	sar	edx, 2
	mov	DWORD PTR _xsize$[ebp], edx

; 1144 :       xpos >>= 2;

	mov	eax, DWORD PTR _xpos$[ebp]
	shr	eax, 2
	mov	DWORD PTR _xpos$[ebp], eax

; 1145 :       break;

	jmp	$LN100@DMABiLinea
$LN97@DMABiLinea:

; 1146 :     case 2:
; 1147 :       //16 bit
; 1148 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1149 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1150 :       break;

	jmp	$LN100@DMABiLinea
$LN96@DMABiLinea:

; 1151 :     case 3:
; 1152 :       //8 bit
; 1153 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1154 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1155 :       xlen >>= 1;

	mov	ecx, DWORD PTR _xlen$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _xlen$[ebp], ecx

; 1156 :       xsize >>= 1;

	mov	edx, DWORD PTR _xsize$[ebp]
	sar	edx, 1
	mov	DWORD PTR _xsize$[ebp], edx

; 1157 :       xpos >>= 1;

	mov	eax, DWORD PTR _xpos$[ebp]
	shr	eax, 1
	mov	DWORD PTR _xpos$[ebp], eax

; 1158 :       break;

	jmp	$LN100@DMABiLinea
$LN95@DMABiLinea:

; 1159 :     //32 bit, 32 bit + 32 bit Z, and 32 bit Z-field only modes
; 1160 :     case 4:
; 1161 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1162 :       pixsize = 2;

	mov	DWORD PTR _pixsize$[ebp], 2

; 1163 :       break;

	jmp	$LN100@DMABiLinea
$LN94@DMABiLinea:

; 1164 :     case 5:
; 1165 :     {
; 1166 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1167 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1168 : 
; 1169 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN93@DMABiLinea

; 1170 :       {
; 1171 :         //pixel+Z write (16 + 16Z)
; 1172 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1173 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1174 :       }
; 1175 :       else

	jmp	SHORT $LN92@DMABiLinea
$LN93@DMABiLinea:

; 1176 :       {
; 1177 :         //pixel only write (16 bit)
; 1178 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1179 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN92@DMABiLinea:

; 1180 :       }
; 1181 :       break;

	jmp	$LN100@DMABiLinea
$LN91@DMABiLinea:

; 1182 :     }
; 1183 :     case 6:
; 1184 :     {
; 1185 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1186 :       pixsize = 2;

	mov	DWORD PTR _pixsize$[ebp], 2

; 1187 : 
; 1188 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN90@DMABiLinea

; 1189 :       {
; 1190 :         //pixel+Z write (32 + 32Z)
; 1191 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1192 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1193 :       }
; 1194 :       else

	jmp	SHORT $LN89@DMABiLinea
$LN90@DMABiLinea:

; 1195 :       {
; 1196 :         //pixel only write (32 bit)
; 1197 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1198 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN89@DMABiLinea:

; 1199 :       }
; 1200 :       break;

	jmp	$LN100@DMABiLinea
$LN88@DMABiLinea:

; 1201 :     }
; 1202 :     case 7:
; 1203 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1204 :       break;

	jmp	$LN100@DMABiLinea
$LN87@DMABiLinea:

; 1205 :     //16 bit + 16 bit Z, single, double and triple buffer modes
; 1206 :     case 8:
; 1207 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1208 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1209 :       break;

	jmp	$LN100@DMABiLinea
$LN86@DMABiLinea:

; 1210 :     case 9:
; 1211 :     {
; 1212 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1213 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1214 : 
; 1215 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN85@DMABiLinea

; 1216 :       {
; 1217 :         //pixel+Z write (16 + 16Z)
; 1218 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1219 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1220 :       }
; 1221 :       else

	jmp	SHORT $LN84@DMABiLinea
$LN85@DMABiLinea:

; 1222 :       {
; 1223 :         //pixel only write (16 bit)
; 1224 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1225 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN84@DMABiLinea:

; 1226 :       }
; 1227 :       break;

	jmp	$LN100@DMABiLinea
$LN83@DMABiLinea:

; 1228 :     }
; 1229 :     case 10:
; 1230 :     {
; 1231 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1232 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1233 : 
; 1234 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN82@DMABiLinea

; 1235 :       {
; 1236 :         //pixel+Z write (16 + 16Z)
; 1237 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1238 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1239 :       }
; 1240 :       else

	jmp	SHORT $LN81@DMABiLinea
$LN82@DMABiLinea:

; 1241 :       {
; 1242 :         //pixel only write (16 bit)
; 1243 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1244 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN81@DMABiLinea:

; 1245 :       }
; 1246 :       break;

	jmp	$LN100@DMABiLinea
$LN80@DMABiLinea:

; 1247 :     }
; 1248 :     case 11:
; 1249 :     {
; 1250 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1251 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1252 : 
; 1253 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN79@DMABiLinea

; 1254 :       {
; 1255 :         //pixel+Z write (16 + 16Z)
; 1256 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1257 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1258 :       }
; 1259 :       else

	jmp	SHORT $LN78@DMABiLinea
$LN79@DMABiLinea:

; 1260 :       {
; 1261 :         //pixel only write (16 bit)
; 1262 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1263 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN78@DMABiLinea:

; 1264 :       }
; 1265 :       break;

	jmp	$LN100@DMABiLinea
$LN77@DMABiLinea:

; 1266 :     }
; 1267 :     case 12:
; 1268 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1269 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1270 :       break;

	jmp	$LN100@DMABiLinea
$LN76@DMABiLinea:

; 1271 :     case 13:
; 1272 :     {
; 1273 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1274 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1

; 1275 : 
; 1276 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN75@DMABiLinea

; 1277 :       {
; 1278 :         //pixel+Z write (16 + 16Z)
; 1279 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1280 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1281 :       }
; 1282 :       else

	jmp	SHORT $LN74@DMABiLinea
$LN75@DMABiLinea:

; 1283 :       {
; 1284 :         //pixel only write (16 bit)
; 1285 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1286 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN74@DMABiLinea:

; 1287 :       }
; 1288 :       break;

	jmp	SHORT $LN100@DMABiLinea
$LN73@DMABiLinea:

; 1289 :     }
; 1290 :     case 14:
; 1291 :     {
; 1292 :       wordsize = 2;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 2

; 1293 : 
; 1294 :       if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN72@DMABiLinea

; 1295 :       {
; 1296 :         //pixel+Z write (16 + 16Z)
; 1297 :         bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 1298 :         bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 1299 :       }
; 1300 :       else

	jmp	SHORT $LN71@DMABiLinea
$LN72@DMABiLinea:

; 1301 :       {      
; 1302 :         bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 1303 :         bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0
$LN71@DMABiLinea:

; 1304 :       }
; 1305 :       break;

	jmp	SHORT $LN100@DMABiLinea
$LN70@DMABiLinea:

; 1306 :     }
; 1307 :     case 15:
; 1308 :       wordsize = 1;

	mov	BYTE PTR $T80155[ebp], 1
	mov	DWORD PTR _wordsize$[ebp], 1

; 1309 :       pixsize = 1;

	mov	DWORD PTR _pixsize$[ebp], 1
$LN100@DMABiLinea:

; 1310 :       break;
; 1311 :   }
; 1312 : 
; 1313 :   if(bRemote)

	movzx	ecx, BYTE PTR _bRemote$[ebp]
	test	ecx, ecx
	je	SHORT $LN69@DMABiLinea

; 1314 :   {
; 1315 :     //internal address is system address (but still in MPE memory)
; 1316 :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	and	edx, 545259519				; 207fffffH
	push	edx
	mov	eax, DWORD PTR _mpeBase$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 1317 :   }
; 1318 :   else

	jmp	SHORT $LN68@DMABiLinea
$LN69@DMABiLinea:

; 1319 :   {
; 1320 :     //internal address is local to MPE
; 1321 :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase, false);

	push	0
	mov	eax, DWORD PTR _mpeBase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN68@DMABiLinea:

; 1322 :   }
; 1323 : 
; 1324 :   //base address is always a system address (absolute)
; 1325 : 
; 1326 :   if((sdramBase < 0x40000000) || (sdramBase > 0x407FFFFF))

	cmp	DWORD PTR _sdramBase$[ebp], 1073741824	; 40000000H
	jb	SHORT $LN66@DMABiLinea
	cmp	DWORD PTR _sdramBase$[ebp], 1082130431	; 407fffffH
	jbe	SHORT $LN65@DMABiLinea
$LN66@DMABiLinea:

; 1327 :   {
; 1328 :     char msgBuf[512];
; 1329 :     sprintf(msgBuf,"sdramBase is out of range on mpe%d: 0x%lx\n",the_mpe->mpeIndex,sdramBase);

	mov	edx, DWORD PTR _sdramBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	push	ecx
	push	OFFSET $SG77898
	lea	edx, DWORD PTR _msgBuf$77897[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1330 :     ::MessageBox(NULL,msgBuf,"DMABiLinear error",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG77899
	lea	eax, DWORD PTR _msgBuf$77897[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN65@DMABiLinea:

; 1331 :   }
; 1332 :   else
; 1333 :   {
; 1334 : 
; 1335 :   }
; 1336 : 
; 1337 :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdramBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 1338 : 
; 1339 :   if(bRead)

	movzx	edx, BYTE PTR _bRead$[ebp]
	test	edx, edx
	je	$LN64@DMABiLinea

; 1340 :   {
; 1341 :     pSrc = (void *)baseMemory;

	mov	eax, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax

; 1342 :     pDest = (void *)intMemory;

	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], ecx

; 1343 :     srcOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	edx, DWORD PTR _ypos$[ebp]
	imul	edx, DWORD PTR _xsize$[ebp]
	add	edx, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _srcOffset$[ebp], edx

; 1344 :     destOffset = 0;

	mov	DWORD PTR _destOffset$[ebp], 0

; 1345 : 
; 1346 :     destAStart = 0;

	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], 0

; 1347 :     destAStep = 1;

	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], 1

; 1348 :     destBStart = 0;

	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], 0

; 1349 :     destBStep = xlen;

	mov	BYTE PTR $T80159[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destBStep$[ebp], eax

; 1350 : 
; 1351 :     switch(bva)

	mov	ecx, DWORD PTR _bva$[ebp]
	mov	DWORD PTR tv306[ebp], ecx
	cmp	DWORD PTR tv306[ebp], 7
	ja	$LN62@DMABiLinea
	mov	edx, DWORD PTR tv306[ebp]
	jmp	DWORD PTR $LN175@DMABiLinea[edx*4]
$LN61@DMABiLinea:

; 1352 :     {
; 1353 :       case 0:
; 1354 :         //BVA = 000 (horizontal DMA, x increment, y increment)
; 1355 :         srcAStart = 0;

	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], 0

; 1356 :         srcAStep = 1;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], 1

; 1357 :         srcBStart = 0;

	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], 0

; 1358 :         srcBStep = xsize;

	mov	BYTE PTR $T80163[ebp], 1
	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], eax

; 1359 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx

; 1360 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], edx

; 1361 :         break;

	jmp	$LN62@DMABiLinea
$LN60@DMABiLinea:

; 1362 :       case 1:
; 1363 :         //BVA = 001 (horizontal DMA, x decrement, y increment)
; 1364 :         srcAStart = xlen - 1;

	mov	eax, DWORD PTR _xlen$[ebp]
	sub	eax, 1
	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], eax

; 1365 :         srcAStep = -1;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], -1

; 1366 :         srcBStart = 0;

	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], 0

; 1367 :         srcBStep = xsize;

	mov	BYTE PTR $T80163[ebp], 1
	mov	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], ecx

; 1368 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 1369 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 1370 :         break;

	jmp	$LN62@DMABiLinea
$LN59@DMABiLinea:

; 1371 :       case 2:
; 1372 :         //BVA = 010 (vertical DMA, y increment, x increment)
; 1373 :         srcAStart = 0;

	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], 0

; 1374 :         srcAStep = xsize;

	mov	BYTE PTR $T80161[ebp], 1
	mov	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcAStep$[ebp], ecx

; 1375 :         srcBStart = 0;

	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], 0

; 1376 :         srcBStep = 1;

	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], 1

; 1377 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 1378 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 1379 :         break;

	jmp	$LN62@DMABiLinea
$LN58@DMABiLinea:

; 1380 :       case 3:
; 1381 :         //BVA = 011 (vertical DMA, y decrement, x increment)
; 1382 :         srcAStart = (ylen - 1) * xsize;

	mov	ecx, DWORD PTR _ylen$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], ecx

; 1383 :         srcAStep = -xsize;

	mov	edx, DWORD PTR _xsize$[ebp]
	neg	edx
	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], edx

; 1384 :         srcBStart = 0;

	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], 0

; 1385 :         srcBStep = 1;

	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], 1

; 1386 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1387 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 1388 :         break;

	jmp	$LN62@DMABiLinea
$LN57@DMABiLinea:

; 1389 :       case 4:
; 1390 :         //BVA = 100 (horizontal DMA, x increment, y decrement)
; 1391 :         srcAStart = 0;

	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], 0

; 1392 :         srcAStep = 1;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], 1

; 1393 :         srcBStart = (ylen - 1) * xsize;

	mov	edx, DWORD PTR _ylen$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], edx

; 1394 :         srcBStep = -xsize;

	mov	eax, DWORD PTR _xsize$[ebp]
	neg	eax
	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], eax

; 1395 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx

; 1396 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], edx

; 1397 :         break;

	jmp	$LN62@DMABiLinea
$LN56@DMABiLinea:

; 1398 :       case 5:
; 1399 :         //BVA = 101 (horizontal DMA, x decrement, y decrement)
; 1400 :         srcAStart = xlen - 1;

	mov	eax, DWORD PTR _xlen$[ebp]
	sub	eax, 1
	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], eax

; 1401 :         srcAStep = -1;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], -1

; 1402 :         srcBStart = (ylen - 1) * xsize;

	mov	ecx, DWORD PTR _ylen$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], ecx

; 1403 :         srcBStep = -xsize;

	mov	edx, DWORD PTR _xsize$[ebp]
	neg	edx
	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], edx

; 1404 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1405 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 1406 :         break;

	jmp	$LN62@DMABiLinea
$LN55@DMABiLinea:

; 1407 :       case 6:
; 1408 :         //BVA = 110 (vertical DMA, y increment, x decrement)
; 1409 :         srcAStart = 0;

	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], 0

; 1410 :         srcAStep = xsize;

	mov	BYTE PTR $T80161[ebp], 1
	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcAStep$[ebp], edx

; 1411 :         srcBStart = xlen - 1;

	mov	eax, DWORD PTR _xlen$[ebp]
	sub	eax, 1
	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], eax

; 1412 :         srcBStep = -1;

	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], -1

; 1413 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx

; 1414 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], edx

; 1415 :         break;

	jmp	SHORT $LN62@DMABiLinea
$LN54@DMABiLinea:

; 1416 :       case 7:
; 1417 :         //BVA = 111 (vertical DMA, y decrement, x decrement)
; 1418 :         srcAStart = (ylen - 1) * xsize;

	mov	eax, DWORD PTR _ylen$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], eax

; 1419 :         srcAStep = -xsize;

	mov	ecx, DWORD PTR _xsize$[ebp]
	neg	ecx
	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], ecx

; 1420 :         srcBStart = xlen - 1;

	mov	edx, DWORD PTR _xlen$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], edx

; 1421 :         srcBStep = -1;

	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], -1

; 1422 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1423 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx
$LN62@DMABiLinea:

; 1424 :         break;
; 1425 :     }
; 1426 :   }
; 1427 :   else

	jmp	$LN53@DMABiLinea
$LN64@DMABiLinea:

; 1428 :   {
; 1429 :     pSrc = intMemory;

	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], edx

; 1430 :     pDest = baseMemory;

	mov	eax, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], eax

; 1431 : 
; 1432 :     if(bDup)

	movzx	ecx, BYTE PTR _bDup$[ebp]
	test	ecx, ecx
	je	SHORT $LN52@DMABiLinea

; 1433 :     {
; 1434 :       if(bDirect)

	movzx	edx, BYTE PTR _bDirect$[ebp]
	test	edx, edx
	je	SHORT $LN51@DMABiLinea

; 1435 :       {
; 1436 :         //Direct and Dup: intaddr is data.
; 1437 :         directValue = intaddr;

	mov	eax, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], eax

; 1438 : #ifdef LITTLE_ENDIAN
; 1439 :         //swap back to big endian format
; 1440 :         SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1441 : #else
; 1442 : 	      if(wordsize == 1)
; 1443 : 	      {
; 1444 :           directValue >>= 16;
; 1445 : 	      }
; 1446 : #endif
; 1447 :       }
; 1448 :       else

	jmp	SHORT $LN50@DMABiLinea
$LN51@DMABiLinea:

; 1449 :       {
; 1450 :         //Dup but not Direct: read scalar from memory, no need to swap
; 1451 :         directValue = *(uint32 *)intMemory;

	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _directValue$[ebp], edx
$LN50@DMABiLinea:

; 1452 : #ifndef LITTLE_ENDIAN
; 1453 :         if(wordsize == 1)
; 1454 :         {
; 1455 :           directValue >>= 16;
; 1456 :         }
; 1457 : #endif
; 1458 :       }
; 1459 : 
; 1460 :       pSrc = (void *)&directValue;

	lea	eax, DWORD PTR _directValue$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax

; 1461 :       srcAStep = 0;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], 0

; 1462 :       srcBStep = 0;

	mov	BYTE PTR $T80163[ebp], 1
	mov	DWORD PTR _srcBStep$[ebp], 0

; 1463 :     }
; 1464 :     else

	jmp	SHORT $LN49@DMABiLinea
$LN52@DMABiLinea:

; 1465 :     {
; 1466 :       srcAStep = 1;

	mov	BYTE PTR $T80161[ebp], 1
	mov	DWORD PTR _srcAStep$[ebp], 1

; 1467 :       srcBStep = xlen;

	mov	BYTE PTR $T80163[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], ecx
$LN49@DMABiLinea:

; 1468 :     }
; 1469 : 
; 1470 :     srcAStart = 0;

	mov	BYTE PTR $T80160[ebp], 1
	mov	DWORD PTR _srcAStart$[ebp], 0

; 1471 :     srcBStart = 0;

	mov	BYTE PTR $T80162[ebp], 1
	mov	DWORD PTR _srcBStart$[ebp], 0

; 1472 :     srcOffset = 0;

	mov	DWORD PTR _srcOffset$[ebp], 0

; 1473 :     destOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	edx, DWORD PTR _ypos$[ebp]
	imul	edx, DWORD PTR _xsize$[ebp]
	add	edx, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _destOffset$[ebp], edx

; 1474 : 
; 1475 :     switch(bva)

	mov	eax, DWORD PTR _bva$[ebp]
	mov	DWORD PTR tv331[ebp], eax
	cmp	DWORD PTR tv331[ebp], 7
	ja	$LN53@DMABiLinea
	mov	ecx, DWORD PTR tv331[ebp]
	jmp	DWORD PTR $LN176@DMABiLinea[ecx*4]
$LN46@DMABiLinea:

; 1476 :     {
; 1477 :       case 0:
; 1478 :         //BVA = 000 (horizontal DMA, x increment, y increment)
; 1479 :         destAStart = 0;

	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], 0

; 1480 :         destAStep = 1;

	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], 1

; 1481 :         destBStart = 0;

	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], 0

; 1482 :         destBStep = xsize;

	mov	BYTE PTR $T80159[ebp], 1
	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destBStep$[ebp], edx

; 1483 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1484 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 1485 :         break;

	jmp	$LN53@DMABiLinea
$LN45@DMABiLinea:

; 1486 :       case 1:
; 1487 :         //BVA = 001 (horizontal DMA, x decrement, y increment)
; 1488 :         destAStart = xlen - 1;

	mov	edx, DWORD PTR _xlen$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], edx

; 1489 :         destAStep = -1;

	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], -1

; 1490 :         destBStart = 0;

	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], 0

; 1491 :         destBStep = xsize;

	mov	BYTE PTR $T80159[ebp], 1
	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destBStep$[ebp], eax

; 1492 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx

; 1493 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], edx

; 1494 :         break;

	jmp	$LN53@DMABiLinea
$LN44@DMABiLinea:

; 1495 :       case 2:
; 1496 :         //BVA = 010 (vertical DMA, y increment, x increment)
; 1497 :         destAStart = 0;

	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], 0

; 1498 :         destAStep = xsize;

	mov	BYTE PTR $T80157[ebp], 1
	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destAStep$[ebp], eax

; 1499 :         destBStart = 0;

	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], 0

; 1500 :         destBStep = 1;

	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], 1

; 1501 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx

; 1502 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], edx

; 1503 :         break;

	jmp	$LN53@DMABiLinea
$LN43@DMABiLinea:

; 1504 :       case 3:
; 1505 :         //BVA = 011 (vertical DMA, y decrement, x increment)
; 1506 :         destAStart = (ylen - 1) * xsize;

	mov	eax, DWORD PTR _ylen$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], eax

; 1507 :         destAStep = -xsize;

	mov	ecx, DWORD PTR _xsize$[ebp]
	neg	ecx
	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], ecx

; 1508 :         destBStart = 0;

	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], 0

; 1509 :         destBStep = 1;

	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], 1

; 1510 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 1511 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 1512 :         break;

	jmp	$LN53@DMABiLinea
$LN42@DMABiLinea:

; 1513 :       case 4:
; 1514 :         //BVA = 100 (horizontal DMA, x increment, y decrement)
; 1515 :         destAStart = 0;

	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], 0

; 1516 :         destAStep = 1;

	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], 1

; 1517 :         destBStart = (ylen - 1) * xsize;

	mov	ecx, DWORD PTR _ylen$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], ecx

; 1518 :         destBStep = -xsize;

	mov	edx, DWORD PTR _xsize$[ebp]
	neg	edx
	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], edx

; 1519 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1520 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 1521 :         break;

	jmp	$LN53@DMABiLinea
$LN41@DMABiLinea:

; 1522 :       case 5:
; 1523 :         //BVA = 101 (horizontal DMA, x decrement, y decrement)
; 1524 :         destAStart = xlen - 1;

	mov	edx, DWORD PTR _xlen$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], edx

; 1525 :         destAStep = -1;

	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], -1

; 1526 :         destBStart = (ylen - 1) * xsize;

	mov	eax, DWORD PTR _ylen$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], eax

; 1527 :         destBStep = -xsize;

	mov	ecx, DWORD PTR _xsize$[ebp]
	neg	ecx
	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], ecx

; 1528 :         aCount = xlen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 1529 :         bCount = ylen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 1530 :         break;

	jmp	$LN53@DMABiLinea
$LN40@DMABiLinea:

; 1531 :       case 6:
; 1532 :         //BVA = 110 (vertical DMA, y increment, x decrement)
; 1533 :         destAStart = 0;

	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], 0

; 1534 :         destAStep = xsize;

	mov	BYTE PTR $T80157[ebp], 1
	mov	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destAStep$[ebp], ecx

; 1535 :         destBStart = xlen - 1;

	mov	edx, DWORD PTR _xlen$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], edx

; 1536 :         destBStep = -1;

	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], -1

; 1537 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 1538 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 1539 :         break;

	jmp	SHORT $LN53@DMABiLinea
$LN39@DMABiLinea:

; 1540 :       case 7:
; 1541 :         //BVA = 111 (vertical DMA, y decrement, x decrement)
; 1542 :         destAStart = (ylen - 1) * xsize;

	mov	edx, DWORD PTR _ylen$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _xsize$[ebp]
	mov	BYTE PTR $T80156[ebp], 1
	mov	DWORD PTR _destAStart$[ebp], edx

; 1543 :         destAStep = -xsize;

	mov	eax, DWORD PTR _xsize$[ebp]
	neg	eax
	mov	BYTE PTR $T80157[ebp], 1
	mov	DWORD PTR _destAStep$[ebp], eax

; 1544 :         destBStart = xlen - 1;

	mov	ecx, DWORD PTR _xlen$[ebp]
	sub	ecx, 1
	mov	BYTE PTR $T80158[ebp], 1
	mov	DWORD PTR _destBStart$[ebp], ecx

; 1545 :         destBStep = -1;

	mov	BYTE PTR $T80159[ebp], 1
	mov	DWORD PTR _destBStep$[ebp], -1

; 1546 :         aCount = ylen;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 1547 :         bCount = xlen;

	mov	BYTE PTR $T80165[ebp], 1
	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax
$LN53@DMABiLinea:

; 1548 :         break;
; 1549 :     }
; 1550 :   }
; 1551 : 
; 1552 :   aCountInit = aCount;

	cmp	BYTE PTR $T80164[ebp], 0
	jne	SHORT $LN128@DMABiLinea
	push	OFFSET $LN129@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN128@DMABiLinea:
	mov	ecx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR _aCountInit$[ebp], ecx

; 1553 : 
; 1554 :   if(wordsize == 2)

	cmp	BYTE PTR $T80155[ebp], 0
	jne	SHORT $LN130@DMABiLinea
	push	OFFSET $LN131@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN130@DMABiLinea:
	cmp	DWORD PTR _wordsize$[ebp], 2
	jne	$LN38@DMABiLinea

; 1555 :   {
; 1556 :     pSrc32 = (uint32 *)pSrc;

	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _pSrc32$[ebp], edx

; 1557 :     pSrc32 += srcOffset;

	mov	eax, DWORD PTR _srcOffset$[ebp]
	mov	ecx, DWORD PTR _pSrc32$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pSrc32$[ebp], edx

; 1558 :     pDest32 = (uint32 *)pDest;

	mov	eax, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest32$[ebp], eax

; 1559 :     pDest32 += destOffset;

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _pDest32$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pDest32$[ebp], eax

; 1560 :     srcB = srcBStart;

	cmp	BYTE PTR $T80162[ebp], 0
	jne	SHORT $LN132@DMABiLinea
	push	OFFSET $LN133@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN132@DMABiLinea:
	mov	ecx, DWORD PTR _srcBStart$[ebp]
	mov	DWORD PTR _srcB$[ebp], ecx

; 1561 :     destB = destBStart;

	cmp	BYTE PTR $T80158[ebp], 0
	jne	SHORT $LN134@DMABiLinea
	push	OFFSET $LN135@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN134@DMABiLinea:
	mov	edx, DWORD PTR _destBStart$[ebp]
	mov	DWORD PTR _destB$[ebp], edx

; 1562 : 
; 1563 : #define GetPixBaseAddr(base,offset,shift) (base + (offset << shift))
; 1564 : 
; 1565 :     if(!bRead)

	movzx	eax, BYTE PTR _bRead$[ebp]
	test	eax, eax
	jne	$LN29@DMABiLinea

; 1566 :     {
; 1567 :       if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->mainChannelUpperLimit) ||
; 1568 :          (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->mainChannelUpperLimit))

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+52]
	jb	SHORT $LN34@DMABiLinea
	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+48]
	jbe	SHORT $LN35@DMABiLinea
$LN34@DMABiLinea:
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+52]
	jb	SHORT $LN36@DMABiLinea
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+48]
	ja	SHORT $LN36@DMABiLinea
$LN35@DMABiLinea:

; 1569 :       {
; 1570 :         nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 1571 :       }
; 1572 :       else if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->overlayChannelUpperLimit) ||

	jmp	$LN29@DMABiLinea
$LN36@DMABiLinea:

; 1573 :          (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->overlayChannelUpperLimit))

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+60]
	jb	SHORT $LN30@DMABiLinea
	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+56]
	jbe	SHORT $LN31@DMABiLinea
$LN30@DMABiLinea:
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+60]
	jb	SHORT $LN29@DMABiLinea
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+56]
	ja	SHORT $LN29@DMABiLinea
$LN31@DMABiLinea:

; 1574 :       {
; 1575 :         nuonEnv->bOverlayBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+87], 1
$LN29@DMABiLinea:

; 1576 :       }
; 1577 :     }
; 1578 : 
; 1579 :     while(bCount--)

	cmp	BYTE PTR $T80165[ebp], 0
	jne	SHORT $LN136@DMABiLinea
	push	OFFSET $LN137@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN136@DMABiLinea:
	mov	edx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv407[ebp], edx
	cmp	BYTE PTR $T80165[ebp], 0
	jne	SHORT $LN138@DMABiLinea
	push	OFFSET $LN137@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN138@DMABiLinea:
	mov	eax, DWORD PTR _bCount$[ebp]
	sub	eax, 1
	mov	BYTE PTR $T80165[ebp], 1
	mov	DWORD PTR _bCount$[ebp], eax
	cmp	DWORD PTR tv407[ebp], 0
	je	$LN28@DMABiLinea

; 1580 :     {
; 1581 :       srcA = srcAStart;

	cmp	BYTE PTR $T80160[ebp], 0
	jne	SHORT $LN139@DMABiLinea
	push	OFFSET $LN140@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN139@DMABiLinea:
	mov	ecx, DWORD PTR _srcAStart$[ebp]
	mov	DWORD PTR _srcA$[ebp], ecx

; 1582 :       destA = destAStart;

	cmp	BYTE PTR $T80156[ebp], 0
	jne	SHORT $LN141@DMABiLinea
	push	OFFSET $LN142@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN141@DMABiLinea:
	mov	edx, DWORD PTR _destAStart$[ebp]
	mov	DWORD PTR _destA$[ebp], edx

; 1583 :       aCount = aCountInit;

	mov	BYTE PTR $T80164[ebp], 1
	mov	eax, DWORD PTR _aCountInit$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax
$LN27@DMABiLinea:

; 1584 : 
; 1585 :       while(aCount--)

	cmp	BYTE PTR $T80164[ebp], 0
	jne	SHORT $LN143@DMABiLinea
	push	OFFSET $LN129@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN143@DMABiLinea:
	mov	ecx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv410[ebp], ecx
	cmp	BYTE PTR $T80164[ebp], 0
	jne	SHORT $LN144@DMABiLinea
	push	OFFSET $LN129@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN144@DMABiLinea:
	mov	edx, DWORD PTR _aCount$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80164[ebp], 1
	mov	DWORD PTR _aCount$[ebp], edx
	cmp	DWORD PTR tv410[ebp], 0
	je	$LN26@DMABiLinea

; 1586 :       {
; 1587 :         bZTestResult = false;

	mov	BYTE PTR _bZTestResult$[ebp], 0

; 1588 : 
; 1589 :         if(bCompareZ && (zcompare != 0))

	movzx	eax, BYTE PTR _bCompareZ$[ebp]
	test	eax, eax
	je	$LN25@DMABiLinea
	cmp	DWORD PTR _zcompare$[ebp], 0
	je	$LN25@DMABiLinea
	mov	BYTE PTR $T80166[ebp], 0

; 1590 :         {
; 1591 :           bool result;
; 1592 :           uint16 ztarget, ztransfer;
; 1593 : 
; 1594 :           ztarget = ((uint16 *)&pDest32[destA + destB])[1];

	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _pDest32$[ebp]
	mov	ax, WORD PTR [edx+ecx*4+2]
	mov	WORD PTR _ztarget$77956[ebp], ax

; 1595 :           ztransfer = ((uint16 *)&pSrc32[srcA + srcB])[1];

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcB$[ebp]
	mov	edx, DWORD PTR _pSrc32$[ebp]
	mov	ax, WORD PTR [edx+ecx*4+2]
	mov	WORD PTR _ztransfer$77957[ebp], ax

; 1596 :           SwapWordBytes((uint16 *)&ztarget);

	lea	ecx, DWORD PTR _ztarget$77956[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1597 :           SwapWordBytes((uint16 *)&ztransfer);

	lea	ecx, DWORD PTR _ztransfer$77957[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1598 : 
; 1599 :           switch(zcompare)

	mov	ecx, DWORD PTR _zcompare$[ebp]
	mov	DWORD PTR tv425[ebp], ecx
	cmp	DWORD PTR tv425[ebp], 7
	ja	$LN23@DMABiLinea
	mov	edx, DWORD PTR tv425[ebp]
	jmp	DWORD PTR $LN177@DMABiLinea[edx*4]
$LN22@DMABiLinea:

; 1600 :           {
; 1601 :             case 0x0:
; 1602 :               result = false;

	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], 0

; 1603 :               break;

	jmp	$LN23@DMABiLinea
$LN21@DMABiLinea:

; 1604 :             case 0x1:
; 1605 :               result = (ztarget < ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setl	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1606 :               break;

	jmp	$LN23@DMABiLinea
$LN20@DMABiLinea:

; 1607 :             case 0x2:
; 1608 :               result = (ztarget == ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	sete	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1609 :               break;

	jmp	$LN23@DMABiLinea
$LN19@DMABiLinea:

; 1610 :             case 0x3:
; 1611 :               result = (ztarget <= ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setle	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1612 :               break;

	jmp	SHORT $LN23@DMABiLinea
$LN18@DMABiLinea:

; 1613 :             case 0x4:
; 1614 :               result = (ztarget > ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1615 :               break;

	jmp	SHORT $LN23@DMABiLinea
$LN17@DMABiLinea:

; 1616 :             case 0x5:
; 1617 :               result = (ztarget != ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setne	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1618 :               break;

	jmp	SHORT $LN23@DMABiLinea
$LN16@DMABiLinea:

; 1619 :             case 0x6:
; 1620 :               result = (ztarget >= ztransfer);

	movzx	eax, WORD PTR _ztarget$77956[ebp]
	movzx	ecx, WORD PTR _ztransfer$77957[ebp]
	xor	edx, edx
	cmp	eax, ecx
	setge	dl
	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], dl

; 1621 :               break;

	jmp	SHORT $LN23@DMABiLinea
$LN15@DMABiLinea:

; 1622 :             case 0x7:
; 1623 :               result = false;

	mov	BYTE PTR $T80166[ebp], 1
	mov	BYTE PTR _result$77955[ebp], 0
$LN23@DMABiLinea:

; 1624 :               break;
; 1625 :           }
; 1626 : 
; 1627 :           bZTestResult = result;

	cmp	BYTE PTR $T80166[ebp], 0
	jne	SHORT $LN145@DMABiLinea
	push	OFFSET $LN146@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN145@DMABiLinea:
	mov	al, BYTE PTR _result$77955[ebp]
	mov	BYTE PTR _bZTestResult$[ebp], al
$LN25@DMABiLinea:

; 1628 :         }
; 1629 : 
; 1630 :         if(!bZTestResult)

	movzx	ecx, BYTE PTR _bZTestResult$[ebp]
	test	ecx, ecx
	jne	SHORT $LN14@DMABiLinea

; 1631 :         {
; 1632 :           pDest32[destA + destB] = pSrc32[srcA + srcB];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pDest32$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
$LN14@DMABiLinea:

; 1633 :         }
; 1634 : 
; 1635 :         srcA += srcAStep;

	cmp	BYTE PTR $T80161[ebp], 0
	jne	SHORT $LN147@DMABiLinea
	push	OFFSET $LN148@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN147@DMABiLinea:
	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcAStep$[ebp]
	mov	DWORD PTR _srcA$[ebp], eax

; 1636 :         destA += destAStep;

	cmp	BYTE PTR $T80157[ebp], 0
	jne	SHORT $LN149@DMABiLinea
	push	OFFSET $LN150@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN149@DMABiLinea:
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destAStep$[ebp]
	mov	DWORD PTR _destA$[ebp], ecx

; 1637 :       }

	jmp	$LN27@DMABiLinea
$LN26@DMABiLinea:

; 1638 : 
; 1639 :       srcB += srcBStep;

	cmp	BYTE PTR $T80163[ebp], 0
	jne	SHORT $LN151@DMABiLinea
	push	OFFSET $LN152@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN151@DMABiLinea:
	mov	edx, DWORD PTR _srcB$[ebp]
	add	edx, DWORD PTR _srcBStep$[ebp]
	mov	DWORD PTR _srcB$[ebp], edx

; 1640 :       destB += destBStep;

	cmp	BYTE PTR $T80159[ebp], 0
	jne	SHORT $LN153@DMABiLinea
	push	OFFSET $LN154@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN153@DMABiLinea:
	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, DWORD PTR _destBStep$[ebp]
	mov	DWORD PTR _destB$[ebp], eax

; 1641 :     }

	jmp	$LN29@DMABiLinea
$LN28@DMABiLinea:

; 1642 :   }
; 1643 :   else

	jmp	$LN126@DMABiLinea
$LN38@DMABiLinea:

; 1644 :   {
; 1645 :     pSrc16 = (uint16 *)pSrc;

	mov	ecx, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _pSrc16$[ebp], ecx

; 1646 :     pSrc16 += srcOffset;

	mov	edx, DWORD PTR _srcOffset$[ebp]
	mov	eax, DWORD PTR _pSrc16$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pSrc16$[ebp], ecx

; 1647 :     pDest16 = (uint16 *)pDest;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest16$[ebp], edx

; 1648 :     pDest16 += destOffset;

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _pDest16$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pDest16$[ebp], edx

; 1649 :     srcB = srcBStart;

	cmp	BYTE PTR $T80162[ebp], 0
	jne	SHORT $LN155@DMABiLinea
	push	OFFSET $LN133@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN155@DMABiLinea:
	mov	eax, DWORD PTR _srcBStart$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 1650 :     destB = destBStart;

	cmp	BYTE PTR $T80158[ebp], 0
	jne	SHORT $LN156@DMABiLinea
	push	OFFSET $LN135@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN156@DMABiLinea:
	mov	ecx, DWORD PTR _destBStart$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 1651 : 
; 1652 :     if(!bRead)

	movzx	edx, BYTE PTR _bRead$[ebp]
	test	edx, edx
	jne	$LN4@DMABiLinea

; 1653 :     {
; 1654 :       if((GetPixBaseAddr(sdramBase,destOffset,1) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,1) <= nuonEnv->mainChannelUpperLimit) ||
; 1655 :          (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),1) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),1) <= nuonEnv->mainChannelUpperLimit))

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+52]
	jb	SHORT $LN9@DMABiLinea
	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+48]
	jbe	SHORT $LN10@DMABiLinea
$LN9@DMABiLinea:
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+52]
	jb	SHORT $LN11@DMABiLinea
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+48]
	ja	SHORT $LN11@DMABiLinea
$LN10@DMABiLinea:

; 1656 :       {
; 1657 :         nuonEnv->bMainBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+86], 1

; 1658 :       }
; 1659 :       else if((GetPixBaseAddr(sdramBase,destOffset,1) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,1) <= nuonEnv->overlayChannelUpperLimit) ||

	jmp	$LN4@DMABiLinea
$LN11@DMABiLinea:

; 1660 :          (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),1) <= nuonEnv->overlayChannelUpperLimit))

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+60]
	jb	SHORT $LN5@DMABiLinea
	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+56]
	jbe	SHORT $LN6@DMABiLinea
$LN5@DMABiLinea:
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+60]
	jb	SHORT $LN4@DMABiLinea
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+56]
	ja	SHORT $LN4@DMABiLinea
$LN6@DMABiLinea:

; 1661 :       {
; 1662 :         nuonEnv->bOverlayBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 1
$LN4@DMABiLinea:

; 1663 :       }
; 1664 :     }
; 1665 : 
; 1666 :     while(bCount--)

	cmp	BYTE PTR $T80165[ebp], 0
	jne	SHORT $LN157@DMABiLinea
	push	OFFSET $LN137@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN157@DMABiLinea:
	mov	ecx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv526[ebp], ecx
	cmp	BYTE PTR $T80165[ebp], 0
	jne	SHORT $LN158@DMABiLinea
	push	OFFSET $LN137@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN158@DMABiLinea:
	mov	edx, DWORD PTR _bCount$[ebp]
	sub	edx, 1
	mov	BYTE PTR $T80165[ebp], 1
	mov	DWORD PTR _bCount$[ebp], edx
	cmp	DWORD PTR tv526[ebp], 0
	je	$LN126@DMABiLinea

; 1667 :     {
; 1668 :       srcA = srcAStart;

	cmp	BYTE PTR $T80160[ebp], 0
	jne	SHORT $LN159@DMABiLinea
	push	OFFSET $LN140@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN159@DMABiLinea:
	mov	eax, DWORD PTR _srcAStart$[ebp]
	mov	DWORD PTR _srcA$[ebp], eax

; 1669 :       destA = destAStart;

	cmp	BYTE PTR $T80156[ebp], 0
	jne	SHORT $LN160@DMABiLinea
	push	OFFSET $LN142@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN160@DMABiLinea:
	mov	ecx, DWORD PTR _destAStart$[ebp]
	mov	DWORD PTR _destA$[ebp], ecx

; 1670 :       aCount = aCountInit;

	mov	BYTE PTR $T80164[ebp], 1
	mov	edx, DWORD PTR _aCountInit$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx
$LN2@DMABiLinea:

; 1671 : 
; 1672 :       while(aCount--)

	cmp	BYTE PTR $T80164[ebp], 0
	jne	SHORT $LN161@DMABiLinea
	push	OFFSET $LN129@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN161@DMABiLinea:
	mov	eax, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv529[ebp], eax
	cmp	BYTE PTR $T80164[ebp], 0
	jne	SHORT $LN162@DMABiLinea
	push	OFFSET $LN129@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN162@DMABiLinea:
	mov	ecx, DWORD PTR _aCount$[ebp]
	sub	ecx, 1
	mov	BYTE PTR $T80164[ebp], 1
	mov	DWORD PTR _aCount$[ebp], ecx
	cmp	DWORD PTR tv529[ebp], 0
	je	SHORT $LN1@DMABiLinea

; 1673 :       {
; 1674 :         pDest16[destA + destB] = pSrc16[srcA + srcB];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc16$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax*2], dx

; 1675 : 
; 1676 :         srcA += srcAStep;

	cmp	BYTE PTR $T80161[ebp], 0
	jne	SHORT $LN163@DMABiLinea
	push	OFFSET $LN148@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN163@DMABiLinea:
	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcAStep$[ebp]
	mov	DWORD PTR _srcA$[ebp], eax

; 1677 :         destA += destAStep;

	cmp	BYTE PTR $T80157[ebp], 0
	jne	SHORT $LN164@DMABiLinea
	push	OFFSET $LN150@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN164@DMABiLinea:
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destAStep$[ebp]
	mov	DWORD PTR _destA$[ebp], ecx

; 1678 :       }

	jmp	$LN2@DMABiLinea
$LN1@DMABiLinea:

; 1679 : 
; 1680 :       srcB += srcBStep;

	cmp	BYTE PTR $T80163[ebp], 0
	jne	SHORT $LN165@DMABiLinea
	push	OFFSET $LN152@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN165@DMABiLinea:
	mov	edx, DWORD PTR _srcB$[ebp]
	add	edx, DWORD PTR _srcBStep$[ebp]
	mov	DWORD PTR _srcB$[ebp], edx

; 1681 :       destB += destBStep;

	cmp	BYTE PTR $T80159[ebp], 0
	jne	SHORT $LN166@DMABiLinea
	push	OFFSET $LN154@DMABiLinea
	call	__RTC_UninitUse
	add	esp, 4
$LN166@DMABiLinea:
	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, DWORD PTR _destBStep$[ebp]
	mov	DWORD PTR _destB$[ebp], eax

; 1682 :     }

	jmp	$LN4@DMABiLinea
$LN126@DMABiLinea:

; 1683 :   }
; 1684 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN172@DMABiLinea
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 800				; 00000320H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN172@DMABiLinea:
	DD	4
	DD	$LN171@DMABiLinea
$LN171@DMABiLinea:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN167@DMABiLinea
	DD	-712					; fffffd38H
	DD	512					; 00000200H
	DD	$LN168@DMABiLinea
	DD	-728					; fffffd28H
	DD	2
	DD	$LN169@DMABiLinea
	DD	-740					; fffffd1cH
	DD	2
	DD	$LN170@DMABiLinea
$LN170@DMABiLinea:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN169@DMABiLinea:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN168@DMABiLinea:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN167@DMABiLinea:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN154@DMABiLinea:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN152@DMABiLinea:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN150@DMABiLinea:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN148@DMABiLinea:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN146@DMABiLinea:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN142@DMABiLinea:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN140@DMABiLinea:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN137@DMABiLinea:
	DB	98					; 00000062H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN135@DMABiLinea:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN133@DMABiLinea:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN131@DMABiLinea:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN129@DMABiLinea:
	DB	97					; 00000061H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
	npad	1
$LN173@DMABiLinea:
	DD	$LN123@DMABiLinea
	DD	$LN122@DMABiLinea
	DD	$LN121@DMABiLinea
	DD	$LN120@DMABiLinea
	DD	$LN119@DMABiLinea
	DD	$LN114@DMABiLinea
	DD	$LN109@DMABiLinea
	DD	$LN103@DMABiLinea
	DD	$LN108@DMABiLinea
	DD	$LN107@DMABiLinea
	DD	$LN107@DMABiLinea
	DD	$LN107@DMABiLinea
	DD	$LN106@DMABiLinea
	DD	$LN105@DMABiLinea
	DD	$LN105@DMABiLinea
	DD	$LN104@DMABiLinea
$LN174@DMABiLinea:
	DD	$LN99@DMABiLinea
	DD	$LN98@DMABiLinea
	DD	$LN97@DMABiLinea
	DD	$LN96@DMABiLinea
	DD	$LN95@DMABiLinea
	DD	$LN94@DMABiLinea
	DD	$LN91@DMABiLinea
	DD	$LN88@DMABiLinea
	DD	$LN87@DMABiLinea
	DD	$LN86@DMABiLinea
	DD	$LN83@DMABiLinea
	DD	$LN80@DMABiLinea
	DD	$LN77@DMABiLinea
	DD	$LN76@DMABiLinea
	DD	$LN73@DMABiLinea
	DD	$LN70@DMABiLinea
$LN175@DMABiLinea:
	DD	$LN61@DMABiLinea
	DD	$LN60@DMABiLinea
	DD	$LN59@DMABiLinea
	DD	$LN58@DMABiLinea
	DD	$LN57@DMABiLinea
	DD	$LN56@DMABiLinea
	DD	$LN55@DMABiLinea
	DD	$LN54@DMABiLinea
$LN176@DMABiLinea:
	DD	$LN46@DMABiLinea
	DD	$LN45@DMABiLinea
	DD	$LN44@DMABiLinea
	DD	$LN43@DMABiLinea
	DD	$LN42@DMABiLinea
	DD	$LN41@DMABiLinea
	DD	$LN40@DMABiLinea
	DD	$LN39@DMABiLinea
$LN177@DMABiLinea:
	DD	$LN22@DMABiLinea
	DD	$LN21@DMABiLinea
	DD	$LN20@DMABiLinea
	DD	$LN19@DMABiLinea
	DD	$LN18@DMABiLinea
	DD	$LN17@DMABiLinea
	DD	$LN16@DMABiLinea
	DD	$LN15@DMABiLinea
?DMABiLinear@@YAXPAVMPE@@IIIII@Z ENDP			; DMABiLinear
_TEXT	ENDS
PUBLIC	?DMABiLinear@@YAXPAVMPE@@@Z			; DMABiLinear
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_intaddr$ = -20						; size = 4
_yinfo$ = -16						; size = 4
_xinfo$ = -12						; size = 4
_baseaddr$ = -8						; size = 4
_flags$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?DMABiLinear@@YAXPAVMPE@@@Z PROC			; DMABiLinear

; 1687 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1688 :   uint32 flags, baseaddr, xinfo, yinfo, intaddr;
; 1689 : 
; 1690 :   flags = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _flags$[ebp], ecx

; 1691 :   baseaddr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _baseaddr$[ebp], eax

; 1692 :   xinfo = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _xinfo$[ebp], edx

; 1693 :   yinfo = the_mpe->regs[3];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _yinfo$[ebp], ecx

; 1694 :   intaddr = the_mpe->regs[4];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _intaddr$[ebp], eax

; 1695 : 
; 1696 :   //For the BIOS call, simulate the latency of the call assuming
; 1697 :   //25 cycles of setup time plus 1 cycle per pixel transfered (xlen * ylen)
; 1698 :   nuonEnv->cycleCounter += (25 + (((xinfo >> 16) & 0x3FFUL) * ((yinfo >> 16) & 0x3FFUL)));

	mov	ecx, DWORD PTR _xinfo$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 1023				; 000003ffH
	mov	edx, DWORD PTR _yinfo$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	imul	ecx, edx
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [eax+36]
	lea	eax, DWORD PTR [ecx+edx+25]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [ecx+36], eax

; 1699 : 
; 1700 :   DMABiLinear(the_mpe,flags,baseaddr,xinfo,yinfo,intaddr);

	mov	edx, DWORD PTR _intaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _yinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	call	?DMABiLinear@@YAXPAVMPE@@IIIII@Z	; DMABiLinear
	add	esp, 24					; 00000018H

; 1701 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DMABiLinear@@YAXPAVMPE@@@Z ENDP			; DMABiLinear
_TEXT	ENDS
PUBLIC	?DMADo@@YAXPAVMPE@@@Z				; DMADo
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv133 = -72						; size = 4
_cmdptr$ = -68						; size = 4
_yptr$ = -60						; size = 4
_xptr$ = -52						; size = 4
_baseaddr$ = -44					; size = 4
_intaddr$ = -32						; size = 4
_dmaflags$ = -20					; size = 4
_waitFlag$ = -12					; size = 4
_cmdBlock$ = -8						; size = 4
_ctrl$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?DMADo@@YAXPAVMPE@@@Z PROC				; DMADo

; 1704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1705 :   uint32 ctrl, cmdBlock, waitFlag, dmaflags, intaddr, baseaddr, xptr, yptr;
; 1706 :   uint32 *cmdptr;
; 1707 : 
; 1708 :   ctrl = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ctrl$[ebp], ecx

; 1709 :   cmdBlock = the_mpe->regs[1] & 0x3FFFFFF0UL;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1073741808				; 3ffffff0H
	mov	DWORD PTR _cmdBlock$[ebp], eax

; 1710 :   waitFlag = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _waitFlag$[ebp], edx

; 1711 : 
; 1712 :   if(ctrl == 0x20500500)

	cmp	DWORD PTR _ctrl$[ebp], 542115072	; 20500500H
	jne	$LN11@DMADo

; 1713 :   {
; 1714 :     the_mpe->odmacptr = cmdBlock;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR _cmdBlock$[ebp]
	mov	DWORD PTR [eax+476], ecx

; 1715 : 
; 1716 :     if(the_mpe->odmactl & 0x60UL)

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+472]
	and	eax, 96					; 00000060H
	je	SHORT $LN10@DMADo

; 1717 :     {
; 1718 :       //other bus DMA is enabled so do it!
; 1719 :       cmdptr = (uint32 *)nuonEnv->GetPointerToMemory(the_mpe,cmdBlock);

	push	1
	mov	ecx, DWORD PTR _cmdBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _cmdptr$[ebp], eax

; 1720 :       dmaflags = *cmdptr;

	mov	eax, DWORD PTR _cmdptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dmaflags$[ebp], ecx

; 1721 :       baseaddr = *(cmdptr + 1);

	mov	edx, DWORD PTR _cmdptr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _baseaddr$[ebp], eax

; 1722 :       intaddr = *(cmdptr + 2);

	mov	ecx, DWORD PTR _cmdptr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _intaddr$[ebp], edx

; 1723 :       SwapScalarBytes(&dmaflags);

	lea	ecx, DWORD PTR _dmaflags$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1724 :       SwapScalarBytes(&baseaddr);

	lea	ecx, DWORD PTR _baseaddr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1725 :       SwapScalarBytes(&intaddr);

	lea	ecx, DWORD PTR _intaddr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1726 :       //clear all bits except bits 13, 16 - 23, and 28
; 1727 :       dmaflags &= ((1UL << 13) | (0xFFUL << 16) | (1 << 28));

	mov	eax, DWORD PTR _dmaflags$[ebp]
	and	eax, 285155328				; 10ff2000H
	mov	DWORD PTR _dmaflags$[ebp], eax

; 1728 :       DMALinear(the_mpe,dmaflags,baseaddr,intaddr);

	mov	ecx, DWORD PTR _intaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dmaflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	call	?DMALinear@@YAXPAVMPE@@III@Z		; DMALinear
	add	esp, 16					; 00000010H
$LN10@DMADo:

; 1729 :     }
; 1730 :   }

	jmp	$LN12@DMADo
$LN11@DMADo:

; 1731 :   else if(ctrl == 0x20500600)

	cmp	DWORD PTR _ctrl$[ebp], 542115328	; 20500600H
	jne	$LN12@DMADo

; 1732 :   {
; 1733 :     //mdmacptr
; 1734 :     the_mpe->mdmacptr = cmdBlock;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR _cmdBlock$[ebp]
	mov	DWORD PTR [edx+484], eax
$do_mdmacmd$78017:

; 1735 : 
; 1736 : do_mdmacmd:
; 1737 :     cmdptr = (uint32 *)nuonEnv->GetPointerToMemory(the_mpe,cmdBlock,false);

	push	0
	mov	ecx, DWORD PTR _cmdBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _the_mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _cmdptr$[ebp], eax

; 1738 :     dmaflags = *cmdptr;

	mov	eax, DWORD PTR _cmdptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dmaflags$[ebp], ecx

; 1739 :     baseaddr = *(cmdptr + 1);

	mov	edx, DWORD PTR _cmdptr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _baseaddr$[ebp], eax

; 1740 :     intaddr = *(cmdptr + 2);

	mov	ecx, DWORD PTR _cmdptr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _intaddr$[ebp], edx

; 1741 :     SwapScalarBytes(&dmaflags);

	lea	ecx, DWORD PTR _dmaflags$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1742 :     SwapScalarBytes(&baseaddr);

	lea	ecx, DWORD PTR _baseaddr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1743 :     SwapScalarBytes(&intaddr);

	lea	ecx, DWORD PTR _intaddr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1744 : 
; 1745 :     switch((dmaflags >> 14) & 0x03UL)

	mov	eax, DWORD PTR _dmaflags$[ebp]
	shr	eax, 14					; 0000000eH
	and	eax, 3
	mov	DWORD PTR tv133[ebp], eax
	je	SHORT $LN5@DMADo
	cmp	DWORD PTR tv133[ebp], 3
	je	SHORT $LN3@DMADo
	jmp	$LN12@DMADo
$LN5@DMADo:

; 1746 :     {
; 1747 :       case 0:
; 1748 :         //linear DMA
; 1749 :         DMALinear(the_mpe,dmaflags,baseaddr,intaddr);

	mov	ecx, DWORD PTR _intaddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dmaflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	call	?DMALinear@@YAXPAVMPE@@III@Z		; DMALinear
	add	esp, 16					; 00000010H

; 1750 :         if(dmaflags & (1UL << 30))

	mov	edx, DWORD PTR _dmaflags$[ebp]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN4@DMADo

; 1751 :         {
; 1752 :           the_mpe->mdmacptr += 16;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+484]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [edx+484], ecx

; 1753 :           goto do_mdmacmd;

	jmp	$do_mdmacmd$78017
$LN4@DMADo:

; 1754 :         }
; 1755 :         return;

	jmp	SHORT $LN12@DMADo
$LN3@DMADo:

; 1756 :       case 3:
; 1757 :         //bilinear pixel DMA
; 1758 :         xptr = intaddr;

	mov	eax, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _xptr$[ebp], eax

; 1759 :         yptr = *(cmdptr + 3);

	mov	ecx, DWORD PTR _cmdptr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _yptr$[ebp], edx

; 1760 :         intaddr = *(cmdptr + 4);

	mov	eax, DWORD PTR _cmdptr$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _intaddr$[ebp], ecx

; 1761 :         SwapScalarBytes(&yptr);

	lea	ecx, DWORD PTR _yptr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1762 :         SwapScalarBytes(&intaddr);

	lea	ecx, DWORD PTR _intaddr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1763 :         DMABiLinear(the_mpe,dmaflags,baseaddr,xptr,yptr,intaddr);

	mov	edx, DWORD PTR _intaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _yptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _baseaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dmaflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	call	?DMABiLinear@@YAXPAVMPE@@IIIII@Z	; DMABiLinear
	add	esp, 24					; 00000018H

; 1764 :         if(dmaflags & (1UL << 30))

	mov	edx, DWORD PTR _dmaflags$[ebp]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN12@DMADo

; 1765 :         {
; 1766 :           the_mpe->mdmacptr += 16;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+484]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [edx+484], ecx

; 1767 :           goto do_mdmacmd;

	jmp	$do_mdmacmd$78017
$LN12@DMADo:

; 1768 :         }
; 1769 :         return;
; 1770 :       default:
; 1771 :         return;
; 1772 :     }
; 1773 :   }
; 1774 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@DMADo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@DMADo:
	DD	4
	DD	$LN19@DMADo
$LN19@DMADo:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN15@DMADo
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN16@DMADo
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN17@DMADo
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN18@DMADo
$LN18@DMADo:
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN17@DMADo:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	0
$LN16@DMADo:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	0
$LN15@DMADo:
	DB	100					; 00000064H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
?DMADo@@YAXPAVMPE@@@Z ENDP				; DMADo
_TEXT	ENDS
PUBLIC	?DMAWait@@YAXPAVMPE@@@Z				; DMAWait
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
?DMAWait@@YAXPAVMPE@@@Z PROC				; DMAWait

; 1777 : {

	push	ebp
	mov	ebp, esp

; 1778 :   return;
; 1779 : }

	pop	ebp
	ret	0
?DMAWait@@YAXPAVMPE@@@Z ENDP				; DMAWait
_TEXT	ENDS
END
