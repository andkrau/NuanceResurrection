; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\DecodeMEM.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12404
_DATA	ENDS
CONST	SEGMENT
$SG12404 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterOutputDependencies
PUBLIC	?GetControlRegisterInputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterInputDependencies
PUBLIC	?DecodeInstruction_MEM16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ; MPE::DecodeInstruction_MEM16
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\decodemem.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv369 = -40						; size = 4
tv328 = -36						; size = 4
tv192 = -32						; size = 4
tv81 = -28						; size = 4
_bException$ = -17					; size = 1
_field_1F$ = -12					; size = 4
_field_3E0$ = -8					; size = 4
_this$ = -4						; size = 4
_iPtr$ = 8						; size = 4
_entry$ = 12						; size = 4
_immExt$ = 16						; size = 4
?DecodeInstruction_MEM16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z PROC ; MPE::DecodeInstruction_MEM16
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   :   uint32 field_3E0 = ((*iPtr & 0x03) << 3) | ((*(iPtr + 1) & 0xE0) >> 5);

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 3
	shl	ecx, 3
	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 224				; 000000e0H
	sar	eax, 5
	or	ecx, eax
	mov	DWORD PTR _field_3E0$[ebp], ecx

; 64   :   uint32 field_1F = *(iPtr + 1) & 0x1F;

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _field_1F$[ebp], edx

; 65   :   bool bException = false;

	mov	BYTE PTR _bException$[ebp], 0

; 66   : 
; 67   :   entry->packetInfo |= PACKETINFO_MEM;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 68   : 
; 69   :   switch((*iPtr & 0x7C) >> 2)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 124				; 0000007cH
	sar	ecx, 2
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR tv81[ebp]
	sub	edx, 18					; 00000012H
	mov	DWORD PTR tv81[ebp], edx
	cmp	DWORD PTR tv81[ebp], 6
	ja	$LN41@DecodeInst
	mov	eax, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN47@DecodeInst[eax*4]
$LN38@DecodeInst:

; 70   :   {
; 71   :     case (0x48 >> 2):
; 72   :       //ld_s (Si),Sk
; 73   :       entry->packetInfo |= PACKETINFO_MEMORY_INDIRECT;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 16777216				; 01000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 74   :       entry->packetInfo |= loadScalarLinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 75   :       if(nuonEnv->compilerOptions.bT3KCompilerHack)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+116]
	test	edx, edx
	je	SHORT $LN37@DecodeInst

; 76   :       {
; 77   :         entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN37@DecodeInst:

; 78   :       }
; 79   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarLinear;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 163		; 000000a3H

; 80   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_3E0;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR [ecx+180], edx

; 81   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 82   : 
; 83   :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E0);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 84   :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 85   :       entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_MEM_LOAD;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 67108864		; 04000000H

; 86   :       break;

	jmp	$LN41@DecodeInst
$LN36@DecodeInst:

; 87   :     case (0x4C >> 2):
; 88   :       //st_s Sj,(Si)
; 89   :       entry->packetInfo |= PACKETINFO_MEMORY_INDIRECT;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 90   :       entry->packetInfo |= storeScalarLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 91   :       if(nuonEnv->compilerOptions.bT3KCompilerHack)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+116]
	test	eax, eax
	je	SHORT $LN35@DecodeInst

; 92   :       {
; 93   :         entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN35@DecodeInst:

; 94   :       }
; 95   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarLinear;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 200		; 000000c8H

; 96   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [edx+180], eax

; 97   :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E0;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR [ecx+176], edx

; 98   : 
; 99   :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E0) | SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	shl	eax, cl
	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	or	eax, edx
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 100  :       entry->miscOutputDependencies[SLOT_MEM] = DEPENDENCY_MASK_MEM_STORE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+264], 134217728		; 08000000H

; 101  :       break;

	jmp	$LN41@DecodeInst
$LN34@DecodeInst:

; 102  :     case (0x50 >> 2):
; 103  :       //ld_s <label A> , Sk
; 104  :       //address is a 5 bit offset in vectors from the base of the local control registers
; 105  :       entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 106  :       entry->packetInfo |= loadScalarControlRegisterFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 107  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarControlRegisterAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 164		; 000000a4H

; 108  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = (field_3E0 << 4) + MPE_CTRL_BASE;

	mov	ecx, DWORD PTR _field_3E0$[ebp]
	shl	ecx, 4
	add	ecx, 542113792				; 20500000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 109  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 110  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 111  :       entry->miscInputDependencies[SLOT_MEM] = GetControlRegisterInputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)],bException);

	lea	ecx, DWORD PTR _bException$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterInputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterInputDependencies
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], eax

; 112  : 
; 113  :       switch(field_3E0)

	mov	edx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR tv192[ebp], edx
	mov	eax, DWORD PTR tv192[ebp]
	sub	eax, 4
	mov	DWORD PTR tv192[ebp], eax
	cmp	DWORD PTR tv192[ebp], 27		; 0000001bH
	ja	SHORT $LN32@DecodeInst
	mov	ecx, DWORD PTR tv192[ebp]
	movzx	edx, BYTE PTR $LN43@DecodeInst[ecx]
	jmp	DWORD PTR $LN48@DecodeInst[edx*4]
$LN31@DecodeInst:

; 114  :       {
; 115  :         case (0x40 >> 4):
; 116  :           entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_FLAG_ALLFLAGS;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 67076096		; 03ff8000H

; 117  :           break;

	jmp	SHORT $LN32@DecodeInst
$LN30@DecodeInst:

; 118  :         case (0x80 >> 4):
; 119  :           entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 64			; 00000040H

; 120  :           break;

	jmp	SHORT $LN32@DecodeInst
$LN29@DecodeInst:

; 121  :         case (0x1E0 >> 4):
; 122  :           entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RC0;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1

; 123  :           break;

	jmp	SHORT $LN32@DecodeInst
$LN28@DecodeInst:

; 124  :         case (0x1F0 >> 4):
; 125  :           entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RC1;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 2
$LN32@DecodeInst:

; 126  :           break;
; 127  :       }
; 128  : 
; 129  :       if(bException)

	movzx	ecx, BYTE PTR _bException$[ebp]
	test	ecx, ecx
	je	SHORT $LN27@DecodeInst

; 130  :       {
; 131  :         entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN27@DecodeInst:

; 132  :       }
; 133  :       break;

	jmp	$LN41@DecodeInst
$LN26@DecodeInst:

; 134  :     case (0x54 >> 2):
; 135  :       //st_s Sj, <label A>
; 136  :       //address is a 5 bit offset in vectors from the base of the local control registers
; 137  :       entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 138  :       entry->packetInfo |= storeControlRegisterFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 139  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarControlRegisterAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 194		; 000000c2H

; 140  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 141  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = (field_3E0 << 4) + MPE_CTRL_BASE;

	mov	edx, DWORD PTR _field_3E0$[ebp]
	shl	edx, 4
	add	edx, 542113792				; 20500000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 142  :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 143  : 
; 144  :       entry->miscOutputDependencies[SLOT_MEM] = GetControlRegisterOutputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)],bException);

	lea	ecx, DWORD PTR _bException$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterOutputDependencies
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 145  :       if(bException)

	movzx	edx, BYTE PTR _bException$[ebp]
	test	edx, edx
	je	SHORT $LN25@DecodeInst

; 146  :       {
; 147  :         entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN25@DecodeInst:

; 148  :       }
; 149  :       break;

	jmp	$LN41@DecodeInst
$LN24@DecodeInst:

; 150  :     case (0x58 >> 2):
; 151  :       //mv_s Si, Sk
; 152  :       entry->packetInfo |= moveScalarFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 153  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_MV_SScalar;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 153		; 00000099H

; 154  :       //src is 0x1F
; 155  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [ecx+180], edx

; 156  :       //dest is 0x3E0
; 157  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 158  :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 159  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E0);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 160  :       break;

	jmp	$LN41@DecodeInst
$LN23@DecodeInst:

; 161  :     case (0x5C >> 2):
; 162  :       //mv_s #n or mv_s #nnnn
; 163  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_MV_SImmediate;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 152		; 00000098H

; 164  :       entry->packetInfo |= moveImmediateFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 165  :       //src is 0x1F
; 166  :       if(*immExt)

	mov	edx, DWORD PTR _immExt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN22@DecodeInst

; 167  :       {
; 168  :         //#nnnn: no sign extend
; 169  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = ((*immExt & 0x7FFFFFF) << 5) | field_1F;

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 134217727				; 07ffffffH
	shl	ecx, 5
	or	ecx, DWORD PTR _field_1F$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 170  :         //dest is 0x3E0
; 171  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E0;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 172  :       }
; 173  :       else

	jmp	SHORT $LN21@DecodeInst
$LN22@DecodeInst:

; 174  :       {
; 175  :         //#n: sign extend
; 176  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = ((int32)(field_1F << 27)) >> 27;

	mov	edx, DWORD PTR _field_1F$[ebp]
	shl	edx, 27					; 0000001bH
	sar	edx, 27					; 0000001bH
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 177  :         //dest is 0x3E0
; 178  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E0;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_3E0$[ebp]
	mov	DWORD PTR [ecx+176], edx
$LN21@DecodeInst:

; 179  :       }
; 180  : 
; 181  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E0);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_3E0$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 182  :       break;

	jmp	$LN41@DecodeInst
$LN20@DecodeInst:

; 183  :     case (0x60 >> 2):
; 184  :       //mv_v Vi, Vk, or push/pop Vk
; 185  :       if((*(iPtr + 1) & 0x60) == 0)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 96					; 00000060H
	jne	SHORT $LN19@DecodeInst

; 186  :       {
; 187  :         //mv_v Vi, Vk
; 188  :         entry->packetInfo |= moveVectorFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 189  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_MV_V;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 154		; 0000009aH

; 190  :         //src is 0x1C
; 191  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F & 0x1CUL;

	mov	edx, DWORD PTR _field_1F$[ebp]
	and	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 192  :         //dest is 0x380
; 193  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E0 & 0x1CUL;

	mov	ecx, DWORD PTR _field_3E0$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 194  : 
; 195  :         entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F & 0x1CUL));

	mov	ecx, DWORD PTR _field_1F$[ebp]
	and	ecx, 28					; 0000001cH
	mov	eax, 15					; 0000000fH
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 196  :         entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_3E0 & 0x1CUL));

	mov	ecx, DWORD PTR _field_3E0$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 197  :       }
; 198  :       else

	jmp	$LN41@DecodeInst
$LN19@DecodeInst:

; 199  :       {
; 200  :         if(nuonEnv->compilerOptions.bT3KCompilerHack)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+116]
	test	edx, edx
	je	SHORT $LN17@DecodeInst

; 201  :         {
; 202  :           entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN17@DecodeInst:

; 203  :         }
; 204  : 
; 205  :         if(*(iPtr + 1) & 0x20)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 32					; 00000020H
	je	$LN16@DecodeInst

; 206  :         {
; 207  :           //push
; 208  :           entry->packetInfo |= pushFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 209  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_PushVector + (*iPtr & 0x03);

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 3
	add	eax, 159				; 0000009fH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 210  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [edx+180], eax

; 211  :           if((*iPtr & 0x02) == 0)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 2
	jne	SHORT $LN15@DecodeInst

; 212  :           {
; 213  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] &= 0x1CUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx
$LN15@DecodeInst:

; 214  :           }
; 215  : 
; 216  :           switch(*iPtr & 0x03)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 3
	mov	DWORD PTR tv328[ebp], ecx
	cmp	DWORD PTR tv328[ebp], 3
	ja	$LN13@DecodeInst
	mov	edx, DWORD PTR tv328[ebp]
	jmp	DWORD PTR $LN49@DecodeInst[edx*4]
$LN12@DecodeInst:

; 217  :           {
; 218  :             case 0:
; 219  :               //push Vk
; 220  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F & 0x1CUL);

	mov	ecx, DWORD PTR _field_1F$[ebp]
	and	ecx, 28					; 0000001cH
	mov	eax, 15					; 0000000fH
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 221  :               break;

	jmp	SHORT $LN13@DecodeInst
$LN11@DecodeInst:

; 222  :             case 1:
; 223  :               //push Vk, rz
; 224  :               entry->scalarInputDependencies[SLOT_MEM] = SHORT_VECTOR_REG_DEPENDENCY_MASK(field_1F & 0x1CUL);

	mov	ecx, DWORD PTR _field_1F$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 225  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 64			; 00000040H

; 226  :               break;

	jmp	SHORT $LN13@DecodeInst
$LN10@DecodeInst:

; 227  :             case 2:
; 228  :               //push Sk, cc, rzi1, rz
; 229  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 230  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ | DEPENDENCY_MASK_RZI1 | DEPENDENCY_FLAG_ALLFLAGS;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 67076288		; 03ff80c0H

; 231  :               break;

	jmp	SHORT $LN13@DecodeInst
$LN9@DecodeInst:

; 232  :             case 3:
; 233  :               //push Sk, cc, rzi2, rz
; 234  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 235  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ | DEPENDENCY_MASK_RZI2 | DEPENDENCY_FLAG_ALLFLAGS;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 67076416		; 03ff8140H
$LN13@DecodeInst:

; 236  :               break;
; 237  :           }
; 238  :         }
; 239  :         else

	jmp	$LN41@DecodeInst
$LN16@DecodeInst:

; 240  :         {
; 241  :           //pop
; 242  :           entry->packetInfo |= popFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 243  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_PopVector + (*iPtr & 0x03);

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 3
	add	eax, 155				; 0000009bH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 244  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_1F$[ebp]
	mov	DWORD PTR [edx+176], eax

; 245  :           if((*iPtr & 0x02) == 0)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 2
	jne	SHORT $LN7@DecodeInst

; 246  :           {
; 247  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] &= 0x1CUL;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx
$LN7@DecodeInst:

; 248  :           }
; 249  : 
; 250  :           switch(*iPtr & 0x03)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 3
	mov	DWORD PTR tv369[ebp], ecx
	cmp	DWORD PTR tv369[ebp], 3
	ja	$LN41@DecodeInst
	mov	edx, DWORD PTR tv369[ebp]
	jmp	DWORD PTR $LN50@DecodeInst[edx*4]
$LN4@DecodeInst:

; 251  :           {
; 252  :             case 0:
; 253  :               //pop Vk
; 254  :               entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F & 0x1CUL);

	mov	ecx, DWORD PTR _field_1F$[ebp]
	and	ecx, 28					; 0000001cH
	mov	eax, 15					; 0000000fH
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 255  :               break;

	jmp	SHORT $LN41@DecodeInst
$LN3@DecodeInst:

; 256  :             case 1:
; 257  :               //pop Vk, rz
; 258  :               entry->scalarOutputDependencies[SLOT_MEM] = SHORT_VECTOR_REG_DEPENDENCY_MASK(field_1F & 0x1CUL);

	mov	ecx, DWORD PTR _field_1F$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 259  :               entry->miscOutputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], 64			; 00000040H

; 260  :               break;

	jmp	SHORT $LN41@DecodeInst
$LN2@DecodeInst:

; 261  :             case 2:
; 262  :               //pop Sk, cc, rzi1, rz
; 263  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 264  :               entry->miscOutputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ | DEPENDENCY_MASK_RZI1 | DEPENDENCY_FLAG_ALLFLAGS;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], 67076288		; 03ff80c0H

; 265  :               break;

	jmp	SHORT $LN41@DecodeInst
$LN1@DecodeInst:

; 266  :             case 3:
; 267  :               //pop Sk, cc, rzi2, rz
; 268  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 269  :               entry->miscOutputDependencies[SLOT_MEM] = DEPENDENCY_MASK_RZ | DEPENDENCY_MASK_RZI2 | DEPENDENCY_FLAG_ALLFLAGS;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], 67076416		; 03ff8140H
$LN41@DecodeInst:

; 270  :               break;
; 271  :           }
; 272  :         }
; 273  :       }
; 274  :       break;
; 275  :   }
; 276  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN46@DecodeInst
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN46@DecodeInst:
	DD	1
	DD	$LN45@DecodeInst
$LN45@DecodeInst:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN44@DecodeInst
$LN44@DecodeInst:
	DB	98					; 00000062H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
	npad	1
$LN47@DecodeInst:
	DD	$LN38@DecodeInst
	DD	$LN36@DecodeInst
	DD	$LN34@DecodeInst
	DD	$LN26@DecodeInst
	DD	$LN24@DecodeInst
	DD	$LN23@DecodeInst
	DD	$LN20@DecodeInst
$LN48@DecodeInst:
	DD	$LN31@DecodeInst
	DD	$LN30@DecodeInst
	DD	$LN29@DecodeInst
	DD	$LN28@DecodeInst
	DD	$LN32@DecodeInst
$LN43@DecodeInst:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	3
$LN49@DecodeInst:
	DD	$LN12@DecodeInst
	DD	$LN11@DecodeInst
	DD	$LN10@DecodeInst
	DD	$LN9@DecodeInst
$LN50@DecodeInst:
	DD	$LN4@DecodeInst
	DD	$LN3@DecodeInst
	DD	$LN2@DecodeInst
	DD	$LN1@DecodeInst
?DecodeInstruction_MEM16@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ENDP ; MPE::DecodeInstruction_MEM16
_TEXT	ENDS
PUBLIC	?DecodeInstruction_MEM32@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ; MPE::DecodeInstruction_MEM32
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv1228 = -120						; size = 4
tv1073 = -116						; size = 4
tv1017 = -112						; size = 4
tv1013 = -108						; size = 4
tv980 = -104						; size = 4
tv937 = -100						; size = 4
tv872 = -96						; size = 4
tv834 = -92						; size = 4
tv817 = -88						; size = 4
tv746 = -84						; size = 4
tv616 = -80						; size = 4
tv493 = -76						; size = 4
tv489 = -72						; size = 4
tv456 = -68						; size = 4
tv414 = -64						; size = 4
tv348 = -60						; size = 4
tv312 = -56						; size = 4
tv295 = -52						; size = 4
tv224 = -48						; size = 4
tv186 = -44						; size = 4
tv143 = -40						; size = 4
tv93 = -36						; size = 4
_bException$ = -25					; size = 1
_field_3F$ = -20					; size = 4
_field_1E0$ = -16					; size = 4
_field_1F0000$ = -12					; size = 4
_field_3E00000$ = -8					; size = 4
_this$ = -4						; size = 4
_iPtr$ = 8						; size = 4
_entry$ = 12						; size = 4
_immExt$ = 16						; size = 4
?DecodeInstruction_MEM32@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z PROC ; MPE::DecodeInstruction_MEM32
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  :   uint32 field_3E00000 = ((*iPtr & 0x03) << 3) | ((*(iPtr + 1) & 0xE0) >> 5);

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 3
	shl	ecx, 3
	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 224				; 000000e0H
	sar	eax, 5
	or	ecx, eax
	mov	DWORD PTR _field_3E00000$[ebp], ecx

; 281  :   uint32 field_1F0000 = *(iPtr + 1) & 0x1F;

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _field_1F0000$[ebp], edx

; 282  :   uint32 field_1E0 = ((*(iPtr + 2) & 0x01) << 3) | ((*(iPtr + 3) & 0xE0) >> 5);

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 1
	shl	ecx, 3
	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 224				; 000000e0H
	sar	eax, 5
	or	ecx, eax
	mov	DWORD PTR _field_1E0$[ebp], ecx

; 283  :   uint32 field_3F = *(iPtr + 3) & 0x3F;

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _field_3F$[ebp], edx

; 284  :   bool bException = false;

	mov	BYTE PTR _bException$[ebp], 0

; 285  : 
; 286  :   entry->packetInfo |= PACKETINFO_MEM;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 287  : 
; 288  :   switch(*(iPtr + 2) & 0x0F)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR tv93[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 15			; 0000000fH
	ja	$LN159@DecodeInst@2
	mov	edx, DWORD PTR tv93[ebp]
	jmp	DWORD PTR $LN164@DecodeInst@2[edx*4]
$LN156@DecodeInst@2:

; 289  :   {
; 290  :     case 0x0:
; 291  :     {
; 292  :       //ld_b <label>, Sk
; 293  :       entry->packetInfo |= loadByteAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 294  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadByteAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 165		; 000000a5H

; 295  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = (field_3F << 5) | field_3E00000;

	mov	ecx, DWORD PTR _field_3F$[ebp]
	shl	ecx, 5
	or	ecx, DWORD PTR _field_3E00000$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 296  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F0000;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 297  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 298  : 
; 299  :       switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv143[ebp], edx
	je	SHORT $LN153@DecodeInst@2
	cmp	DWORD PTR tv143[ebp], 1
	je	SHORT $LN152@DecodeInst@2
	jmp	SHORT $LN154@DecodeInst@2
$LN153@DecodeInst@2:

; 300  :       {
; 301  :         case 0:
; 302  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 303  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 304  :           return;

	jmp	$LN159@DecodeInst@2
$LN152@DecodeInst@2:

; 305  :         case 1:
; 306  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 307  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 308  :           return;

	jmp	$LN159@DecodeInst@2
$LN154@DecodeInst@2:

; 309  :       }
; 310  :       break;

	jmp	$LN159@DecodeInst@2
$LN151@DecodeInst@2:

; 311  :     }
; 312  :     case 0x1:
; 313  :     {
; 314  :       //ld_w <label>, Sk
; 315  :       entry->packetInfo |= loadWordAbsoluteFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 316  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadWordAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 166		; 000000a6H

; 317  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = ((field_3F << 5) | field_3E00000) << 1;

	mov	eax, DWORD PTR _field_3F$[ebp]
	shl	eax, 5
	or	eax, DWORD PTR _field_3E00000$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 318  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F0000;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [edx+176], eax

; 319  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 320  : 
; 321  :       switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv186[ebp], edx
	je	SHORT $LN148@DecodeInst@2
	cmp	DWORD PTR tv186[ebp], 1
	je	SHORT $LN147@DecodeInst@2
	jmp	SHORT $LN149@DecodeInst@2
$LN148@DecodeInst@2:

; 322  :       {
; 323  :         case 0:
; 324  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 325  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 326  :           return;

	jmp	$LN159@DecodeInst@2
$LN147@DecodeInst@2:

; 327  :         case 1:
; 328  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 329  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 330  :           return;

	jmp	$LN159@DecodeInst@2
$LN149@DecodeInst@2:

; 331  :       }
; 332  :       break;

	jmp	$LN159@DecodeInst@2
$LN146@DecodeInst@2:

; 333  :     }
; 334  :     case 0x2:
; 335  :     {
; 336  :       //ld_s <label B>, Sk
; 337  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = ((field_3F << 5) | field_3E00000) << 2;

	mov	edx, DWORD PTR _field_3F$[ebp]
	shl	edx, 5
	or	edx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 338  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F0000;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [ecx+176], edx

; 339  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 340  : 
; 341  :       switch(*(iPtr + 3) >> 6)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	sar	eax, 6
	mov	DWORD PTR tv224[ebp], eax
	je	SHORT $LN143@DecodeInst@2
	cmp	DWORD PTR tv224[ebp], 1
	je	SHORT $LN142@DecodeInst@2
	cmp	DWORD PTR tv224[ebp], 2
	je	$LN141@DecodeInst@2
	jmp	$LN144@DecodeInst@2
$LN143@DecodeInst@2:

; 342  :       {
; 343  :         case 0:
; 344  :           entry->packetInfo |= loadScalarAbsoluteFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 345  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarAbsolute;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 167		; 000000a7H

; 346  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, 536870912				; 20000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 347  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+180]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+560]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+184], eax

; 348  :           return;

	jmp	$LN159@DecodeInst@2
$LN142@DecodeInst@2:

; 349  :         case 1:
; 350  :           entry->packetInfo |= loadScalarAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 351  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 167		; 000000a7H

; 352  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 353  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 354  :           return;

	jmp	$LN159@DecodeInst@2
$LN141@DecodeInst@2:

; 355  :         case 2:
; 356  :           entry->packetInfo |= loadScalarControlRegisterFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 357  :           entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 358  :           entry->miscInputDependencies[SLOT_MEM] = GetControlRegisterInputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)], bException);

	lea	edx, DWORD PTR _bException$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterInputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterInputDependencies
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], eax

; 359  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarControlRegisterAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 164		; 000000a4H

; 360  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_CTRL_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 542113792				; 20500000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 361  :           if(bException)

	movzx	ecx, BYTE PTR _bException$[ebp]
	test	ecx, ecx
	je	SHORT $LN140@DecodeInst@2

; 362  :           {
; 363  :             entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN140@DecodeInst@2:

; 364  :           }
; 365  :           return;

	jmp	$LN159@DecodeInst@2
$LN144@DecodeInst@2:

; 366  :       }
; 367  :       break;

	jmp	$LN159@DecodeInst@2
$LN139@DecodeInst@2:

; 368  :     }
; 369  :     case 0x3:
; 370  :     {
; 371  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = (field_3F << 5) | field_3E00000;

	mov	edx, DWORD PTR _field_3F$[ebp]
	shl	edx, 5
	or	edx, DWORD PTR _field_3E00000$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 372  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F0000 & 0x1C;

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 373  : 
; 374  :       switch(*(iPtr + 1) & 0x03)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 3
	mov	DWORD PTR tv295[ebp], ecx
	cmp	DWORD PTR tv295[ebp], 3
	ja	$LN115@DecodeInst@2
	mov	edx, DWORD PTR tv295[ebp]
	jmp	DWORD PTR $LN165@DecodeInst@2[edx*4]
$LN136@DecodeInst@2:

; 375  :       {
; 376  :         case 0:
; 377  :         {
; 378  :           //ld_sv <label>, Vk
; 379  :           entry->packetInfo |= loadShortVectorAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 380  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadShortVectorAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 168		; 000000a8H

; 381  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] <<= 3;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	shl	edx, 3
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 382  :           entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 383  : 
; 384  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv312[ebp], edx
	je	SHORT $LN133@DecodeInst@2
	cmp	DWORD PTR tv312[ebp], 1
	je	SHORT $LN132@DecodeInst@2
	jmp	SHORT $LN134@DecodeInst@2
$LN133@DecodeInst@2:

; 385  :           {
; 386  :             case 0:
; 387  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 388  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 389  :               return;

	jmp	$LN159@DecodeInst@2
$LN132@DecodeInst@2:

; 390  :             case 1:
; 391  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 392  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 393  :               return;

	jmp	$LN159@DecodeInst@2
$LN134@DecodeInst@2:

; 394  :           }
; 395  :           break;

	jmp	$LN115@DecodeInst@2
$LN131@DecodeInst@2:

; 396  :         }
; 397  :         case 1:
; 398  :         {
; 399  :           //ld_v <label>, Vk
; 400  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] <<= 4;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+180]
	shl	eax, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 401  :           entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 402  : 
; 403  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv348[ebp], edx
	je	SHORT $LN128@DecodeInst@2
	cmp	DWORD PTR tv348[ebp], 1
	je	SHORT $LN127@DecodeInst@2
	cmp	DWORD PTR tv348[ebp], 2
	je	$LN126@DecodeInst@2
	jmp	$LN129@DecodeInst@2
$LN128@DecodeInst@2:

; 404  :           {
; 405  :             case 0:
; 406  :               entry->packetInfo |= loadVectorAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 407  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 169		; 000000a9H

; 408  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 536870912				; 20000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 409  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 410  :               return;

	jmp	$LN159@DecodeInst@2
$LN127@DecodeInst@2:

; 411  :             case 1:
; 412  :               entry->packetInfo |= loadVectorAbsoluteFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 413  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 169		; 000000a9H

; 414  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 537919488				; 20100000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 415  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 416  :               return;

	jmp	$LN159@DecodeInst@2
$LN126@DecodeInst@2:

; 417  :             case 2:
; 418  :               entry->packetInfo |= loadVectorControlRegisterFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 419  :               entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 8388608				; 00800000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 420  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorControlRegisterAbsolute;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 170		; 000000aaH

; 421  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_CTRL_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, 542113792				; 20500000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 422  :               return;

	jmp	$LN159@DecodeInst@2
$LN129@DecodeInst@2:

; 423  :           }
; 424  :           break;

	jmp	$LN115@DecodeInst@2
$LN125@DecodeInst@2:

; 425  :         }
; 426  :         case 2:
; 427  :         {
; 428  :           //ld_p <label>, Vk
; 429  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 171		; 000000abH

; 430  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_INFO)] = MEM_INFO_LINEAR_ABSOLUTE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+172], 1

; 431  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] <<= 1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	shl	edx, 1
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 432  :           entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 433  :           entry->packetInfo |= loadPixelAbsoluteFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 434  : 
; 435  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv414[ebp], edx
	je	SHORT $LN122@DecodeInst@2
	cmp	DWORD PTR tv414[ebp], 1
	je	SHORT $LN121@DecodeInst@2
	jmp	SHORT $LN123@DecodeInst@2
$LN122@DecodeInst@2:

; 436  :           {
; 437  :             case 0:
; 438  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 439  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 440  :               return;

	jmp	$LN159@DecodeInst@2
$LN121@DecodeInst@2:

; 441  :             case 1:
; 442  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 443  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 444  :               return;

	jmp	$LN159@DecodeInst@2
$LN123@DecodeInst@2:

; 445  :           }
; 446  :           break;

	jmp	$LN115@DecodeInst@2
$LN120@DecodeInst@2:

; 447  :         }
; 448  :         case 3:
; 449  :         {
; 450  :           //ld_pz <label>, Vk
; 451  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelZAbsolute;          

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 172		; 000000acH

; 452  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_INFO)] = MEM_INFO_LINEAR_ABSOLUTE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+172], 1

; 453  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] <<= 1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	shl	edx, 1
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 454  :           entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 455  :           entry->packetInfo |= loadPixelZAbsoluteFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 456  : 
; 457  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv456[ebp], edx
	je	SHORT $LN117@DecodeInst@2
	cmp	DWORD PTR tv456[ebp], 1
	je	SHORT $LN116@DecodeInst@2
	jmp	SHORT $LN115@DecodeInst@2
$LN117@DecodeInst@2:

; 458  :           {
; 459  :             case 0:
; 460  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 461  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 462  :               return;

	jmp	$LN159@DecodeInst@2
$LN116@DecodeInst@2:

; 463  :             case 1:
; 464  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+180], edx

; 465  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 466  :               return;

	jmp	$LN159@DecodeInst@2
$LN115@DecodeInst@2:

; 467  :           }
; 468  :           break;
; 469  :         }
; 470  :       }
; 471  :     }
; 472  :     case 0x4:
; 473  :     {
; 474  :       //load
; 475  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_3E00000;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_3E00000$[ebp]
	mov	DWORD PTR [edx+180], eax

; 476  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_1F0000;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [ecx+176], edx

; 477  : 
; 478  :       switch(*(iPtr + 3) >> 4)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	sar	ecx, 4
	mov	DWORD PTR tv489[ebp], ecx
	je	SHORT $LN112@DecodeInst@2
	cmp	DWORD PTR tv489[ebp], 1
	je	$LN93@DecodeInst@2
	jmp	$LN113@DecodeInst@2
$LN112@DecodeInst@2:

; 479  :       {
; 480  :         case 0x00:
; 481  :         {
; 482  :           switch(*(iPtr + 3) & 0x0F)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv493[ebp], eax
	cmp	DWORD PTR tv493[ebp], 15		; 0000000fH
	ja	$LN110@DecodeInst@2
	mov	ecx, DWORD PTR tv493[ebp]
	jmp	DWORD PTR $LN166@DecodeInst@2[ecx*4]
$LN109@DecodeInst@2:

; 483  :           {
; 484  :             case 0x00:
; 485  :               //ld_b (Si),Sk
; 486  :               entry->packetInfo |= loadByteLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 487  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadByteLinear;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 173		; 000000adH

; 488  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 489  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 490  :               break;

	jmp	$LN110@DecodeInst@2

; 491  :             case 0x01:
; 492  :               break;

	jmp	$LN110@DecodeInst@2
$LN107@DecodeInst@2:

; 493  :             case 0x02:
; 494  :               //ld_b (uv),Sk
; 495  :               entry->packetInfo |= loadByteBilinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 496  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadByteBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 174		; 000000aeH

; 497  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 498  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 499  :               break;

	jmp	$LN110@DecodeInst@2
$LN106@DecodeInst@2:

; 500  :             case 0x03:
; 501  :               //ld_b (xy),Sk
; 502  :               entry->packetInfo |= loadByteBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 503  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadByteBilinearXY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 175		; 000000afH

; 504  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 524		; 0000020cH

; 505  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 506  :               break;

	jmp	$LN110@DecodeInst@2
$LN105@DecodeInst@2:

; 507  :             case 0x04:
; 508  :               //ld_w (Si),Sk
; 509  :               entry->packetInfo |= loadWordLinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 510  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadWordLinear;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 176		; 000000b0H

; 511  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 512  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 513  :               break;

	jmp	$LN110@DecodeInst@2

; 514  :             case 0x05:
; 515  :               break;

	jmp	$LN110@DecodeInst@2
$LN103@DecodeInst@2:

; 516  :             case 0x06:
; 517  :               //ld_w (uv),Sk
; 518  :               entry->packetInfo |= loadWordBilinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 519  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadWordBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 177		; 000000b1H

; 520  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 521  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 522  :               break;

	jmp	$LN110@DecodeInst@2
$LN102@DecodeInst@2:

; 523  :             case 0x07:
; 524  :               //ld_w (xy),Sk
; 525  :               entry->packetInfo |= loadWordBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 526  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadWordBilinearXY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 178		; 000000b2H

; 527  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 524		; 0000020cH

; 528  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 529  :               break;

	jmp	$LN110@DecodeInst@2

; 530  :             case 0x08:
; 531  :               break;

	jmp	$LN110@DecodeInst@2

; 532  :             case 0x09:
; 533  :               break;

	jmp	$LN110@DecodeInst@2
$LN99@DecodeInst@2:

; 534  :             case 0x0A:
; 535  :               //ld_s (uv),Sk
; 536  :               entry->packetInfo |= loadScalarBilinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 537  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 179		; 000000b3H

; 538  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 539  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 540  :               break;

	jmp	$LN110@DecodeInst@2
$LN98@DecodeInst@2:

; 541  :             case 0x0B:
; 542  :               //ld_s (xy),Sk
; 543  :               entry->packetInfo |= loadScalarBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 544  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadScalarBilinearXY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 180		; 000000b4H

; 545  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 524		; 0000020cH

; 546  :               entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 547  :               //entry->packetInfo |= PACKETINFO_NEVERCOMPILE;
; 548  :               break;

	jmp	$LN110@DecodeInst@2
$LN97@DecodeInst@2:

; 549  :             case 0x0C:
; 550  :               //ld_sv (Si),Vk
; 551  :               entry->packetInfo |= loadShortVectorLinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 552  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadShortVectorLinear;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 181		; 000000b5H

; 553  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 554  :               entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 555  :               break;

	jmp	$LN110@DecodeInst@2

; 556  :             case 0x0D:
; 557  :               break;

	jmp	$LN110@DecodeInst@2
$LN95@DecodeInst@2:

; 558  :             case 0x0E:
; 559  :               //ld_sv (uv),Vk
; 560  :               entry->packetInfo |= loadShortVectorBilinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 561  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadShortVectorBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 182		; 000000b6H

; 562  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 563  :               entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	eax, 15					; 0000000fH
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 564  :               break;

	jmp	SHORT $LN110@DecodeInst@2
$LN94@DecodeInst@2:

; 565  :             case 0x0F:
; 566  :               //ld_sv (xy),Vk
; 567  :               entry->packetInfo |= loadShortVectorBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 568  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadShortVectorBilinearXY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 183		; 000000b7H

; 569  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 524		; 0000020cH

; 570  :               entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx
$LN110@DecodeInst@2:

; 571  :               break;
; 572  :           }
; 573  :           break;

	jmp	$LN113@DecodeInst@2
$LN93@DecodeInst@2:

; 574  :         }
; 575  :         case 0x01:
; 576  :         {
; 577  :           entry->scalarOutputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 578  :           switch(*(iPtr + 3) & 0x0F)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR tv616[ebp], edx
	cmp	DWORD PTR tv616[ebp], 11		; 0000000bH
	ja	$LN113@DecodeInst@2
	mov	eax, DWORD PTR tv616[ebp]
	jmp	DWORD PTR $LN167@DecodeInst@2[eax*4]
$LN90@DecodeInst@2:

; 579  :           {
; 580  :             case 0x00:
; 581  :               //ld_v (Si), Vk
; 582  :               entry->packetInfo |= loadVectorLinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 583  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorLinear;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 184		; 000000b8H

; 584  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 585  :               entry->miscInputDependencies[SLOT_MEM] = strictMemoryMiscInputDependencies;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1348]
	mov	DWORD PTR [ecx+224], eax

; 586  :               break;

	jmp	$LN113@DecodeInst@2
$LN89@DecodeInst@2:

; 587  :             case 0x01:
; 588  :             case 0x02:
; 589  :               //ld_v (uv), Vk
; 590  :               entry->packetInfo |= loadVectorBilinearFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 591  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 185		; 000000b9H

; 592  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 593  :               break;

	jmp	$LN113@DecodeInst@2
$LN88@DecodeInst@2:

; 594  :             case 0x03:
; 595  :               //ld_v (xy), Vk
; 596  :               entry->packetInfo |= loadVectorBilinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 597  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadVectorBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 186		; 000000baH

; 598  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH

; 599  :               break;

	jmp	$LN113@DecodeInst@2
$LN87@DecodeInst@2:

; 600  :             case 0x04:
; 601  :               //ld_p (Si), Vk
; 602  :               entry->packetInfo |= loadPixelLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 603  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelLinear;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 187		; 000000bbH

; 604  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 605  :               entry->miscInputDependencies[SLOT_MEM] = strictMemoryMiscInputDependencies;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1348]
	mov	DWORD PTR [edx+224], ecx

; 606  :               break;

	jmp	$LN113@DecodeInst@2

; 607  :             case 0x05:
; 608  :               break;

	jmp	$LN113@DecodeInst@2
$LN85@DecodeInst@2:

; 609  :             case 0x06:
; 610  :               //ld_p (uv), Vk
; 611  :               entry->packetInfo |= loadPixelBilinearUVFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 612  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelBilinearUV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 188		; 000000bcH

; 613  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+224], 1072		; 00000430H

; 614  :               break;

	jmp	$LN113@DecodeInst@2
$LN84@DecodeInst@2:

; 615  :             case 0x07:
; 616  :               //ld_p (xy), Vk
; 617  :               entry->packetInfo |= loadPixelBilinearXYFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 618  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelBilinearXY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 189		; 000000bdH

; 619  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 524		; 0000020cH

; 620  :               break;

	jmp	$LN113@DecodeInst@2
$LN83@DecodeInst@2:

; 621  :             case 0x08:
; 622  :               //ld_pz (Si), Vk
; 623  :               entry->packetInfo |= loadPixelZLinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 624  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelZLinear;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 190		; 000000beH

; 625  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 626  :               entry->miscInputDependencies[SLOT_MEM] = strictMemoryMiscInputDependencies;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1348]
	mov	DWORD PTR [ecx+224], eax

; 627  :               break;

	jmp	SHORT $LN113@DecodeInst@2

; 628  :             case 0x09:
; 629  :               break;

	jmp	SHORT $LN113@DecodeInst@2
$LN81@DecodeInst@2:

; 630  :             case 0x0A:
; 631  :               //ld_pz (uv), Vk
; 632  :               entry->packetInfo |= loadPixelZBilinearUVFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 633  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelZBilinearUV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 191		; 000000bfH

; 634  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 635  :               break;

	jmp	SHORT $LN113@DecodeInst@2
$LN80@DecodeInst@2:

; 636  :             case 0x0B:
; 637  :               //ld_pz (xy), Vk
; 638  :               entry->packetInfo |= loadPixelZBilinearXYFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 639  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_LoadPixelZBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 192		; 000000c0H

; 640  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH
$LN113@DecodeInst@2:

; 641  :               break;
; 642  :             case 0x0C:
; 643  :               break;
; 644  :             case 0x0D:
; 645  :               break;
; 646  :             case 0x0E:
; 647  :               break;
; 648  :             case 0x0F:
; 649  :               break;
; 650  :           }
; 651  :           break;
; 652  :         }
; 653  :       }
; 654  :       break;

	jmp	$LN159@DecodeInst@2
$LN75@DecodeInst@2:

; 655  :     }
; 656  :     case 0x5:
; 657  :     {
; 658  :       //mirror Sj, Sk
; 659  :       entry->packetInfo |= mirrorFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 660  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_Mirror;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 151		; 00000097H

; 661  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F0000;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 662  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E00000;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_3E00000$[ebp]
	mov	DWORD PTR [edx+176], eax

; 663  :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 664  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 665  :       break;

	jmp	$LN159@DecodeInst@2
$LN74@DecodeInst@2:

; 666  :     }
; 667  :     case 0x6:
; 668  :     {
; 669  :       //mv_s #nnn, Sk
; 670  :       entry->packetInfo |= moveImmediateFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 671  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_MV_SImmediate;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 152		; 00000098H

; 672  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = (((int32)((int8)((*(iPtr + 3) & 0x7F) << 1))) << 4) | (*(iPtr + 1) & 0x1F);

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 127				; 0000007fH
	shl	eax, 1
	movsx	ecx, al
	shl	ecx, 4
	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 31					; 0000001fH
	or	ecx, eax
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], ecx

; 673  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E00000;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 674  :       entry->scalarOutputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+244], edx

; 675  :       break;

	jmp	$LN159@DecodeInst@2
$LN73@DecodeInst@2:

; 676  :     }
; 677  :     case 0x7:
; 678  :     case 0x8:
; 679  :     case 0x9:
; 680  :     case 0xA:
; 681  :     {
; 682  :       //st_s Sj, <label B>
; 683  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = ((field_3F << 5) | field_3E00000) << 2;

	mov	ecx, DWORD PTR _field_3F$[ebp]
	shl	ecx, 5
	or	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 684  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F0000;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 685  :       entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 686  :       switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv746[ebp], edx
	je	SHORT $LN70@DecodeInst@2
	cmp	DWORD PTR tv746[ebp], 1
	je	SHORT $LN69@DecodeInst@2
	cmp	DWORD PTR tv746[ebp], 2
	je	$LN68@DecodeInst@2
	jmp	$LN71@DecodeInst@2
$LN70@DecodeInst@2:

; 687  :       {
; 688  :         case 0:
; 689  :           entry->packetInfo |= storeScalarAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 690  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 193		; 000000c1H

; 691  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	add	edx, 536870912				; 20000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 692  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 693  :           return;

	jmp	$LN159@DecodeInst@2
$LN69@DecodeInst@2:

; 694  :         case 1:
; 695  :           entry->packetInfo |= storeScalarAbsoluteFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 696  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 193		; 000000c1H

; 697  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 537919488				; 20100000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 698  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 699  :           return;

	jmp	$LN159@DecodeInst@2
$LN68@DecodeInst@2:

; 700  :         case 2:
; 701  :           entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 8388608				; 00800000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 702  :           entry->packetInfo |= storeControlRegisterFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 703  :           entry->miscOutputDependencies[SLOT_MEM] = GetControlRegisterOutputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)], bException);

	lea	ecx, DWORD PTR _bException$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterOutputDependencies
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 704  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarControlRegisterAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 194		; 000000c2H

; 705  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_CTRL_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 542113792				; 20500000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 706  :           if(bException)

	movzx	eax, BYTE PTR _bException$[ebp]
	test	eax, eax
	je	SHORT $LN67@DecodeInst@2

; 707  :           {
; 708  :             entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN67@DecodeInst@2:

; 709  :           }
; 710  :           return;

	jmp	$LN159@DecodeInst@2
$LN71@DecodeInst@2:

; 711  :       }
; 712  :       break;

	jmp	$LN159@DecodeInst@2
$LN66@DecodeInst@2:

; 713  :     }
; 714  :     case 0xB:
; 715  :     {
; 716  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = ((field_3F << 5) | field_3E00000);

	mov	ecx, DWORD PTR _field_3F$[ebp]
	shl	ecx, 5
	or	ecx, DWORD PTR _field_3E00000$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 717  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F0000 & 0x1C;

	mov	eax, DWORD PTR _field_1F0000$[ebp]
	and	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 718  : 
; 719  :       switch(*(iPtr + 1) & 0x03)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 3
	mov	DWORD PTR tv817[ebp], eax
	cmp	DWORD PTR tv817[ebp], 3
	ja	$LN42@DecodeInst@2
	mov	ecx, DWORD PTR tv817[ebp]
	jmp	DWORD PTR $LN168@DecodeInst@2[ecx*4]
$LN63@DecodeInst@2:

; 720  :       {
; 721  :         case 0:
; 722  :         {
; 723  :           //st_sv Vj, <label>
; 724  :           entry->packetInfo |= storeShortVectorAbsoluteFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 725  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreShortVectorAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 195		; 000000c3H

; 726  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] <<= 3;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	shl	ecx, 3
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 727  :           entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	eax, 15					; 0000000fH
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 728  :           switch(*(iPtr + 3) >> 6)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	sar	eax, 6
	mov	DWORD PTR tv834[ebp], eax
	je	SHORT $LN60@DecodeInst@2
	cmp	DWORD PTR tv834[ebp], 1
	je	SHORT $LN59@DecodeInst@2
	jmp	SHORT $LN61@DecodeInst@2
$LN60@DecodeInst@2:

; 729  :           {
; 730  :             case 0:
; 731  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	add	edx, 536870912				; 20000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 732  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 733  :               return;

	jmp	$LN159@DecodeInst@2
$LN59@DecodeInst@2:

; 734  :             case 1:
; 735  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	add	eax, 537919488				; 20100000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 736  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+560]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+184], eax

; 737  :               return;

	jmp	$LN159@DecodeInst@2
$LN61@DecodeInst@2:

; 738  :           }
; 739  :           break;

	jmp	$LN42@DecodeInst@2
$LN58@DecodeInst@2:

; 740  :         }
; 741  :         case 1:
; 742  :         {
; 743  :           //st_v Vj, <label>
; 744  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreVectorAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 196		; 000000c4H

; 745  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] <<= 4;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	shl	edx, 4
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 746  :           entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 747  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv872[ebp], edx
	je	SHORT $LN55@DecodeInst@2
	cmp	DWORD PTR tv872[ebp], 1
	je	SHORT $LN54@DecodeInst@2
	cmp	DWORD PTR tv872[ebp], 2
	je	$LN53@DecodeInst@2
	jmp	$LN56@DecodeInst@2
$LN55@DecodeInst@2:

; 748  :           {
; 749  :             case 0:
; 750  :               entry->packetInfo |= storeVectorAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 751  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 752  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 753  :               return;

	jmp	$LN159@DecodeInst@2
$LN54@DecodeInst@2:

; 754  :             case 1:
; 755  :               entry->packetInfo |= storeVectorAbsoluteFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 756  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 757  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 758  :               return;

	jmp	$LN159@DecodeInst@2
$LN53@DecodeInst@2:

; 759  :             case 2:
; 760  :               entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 761  :               entry->packetInfo |= storeControlRegisterFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 762  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreVectorControlRegisterAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 197		; 000000c5H

; 763  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_CTRL_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 542113792				; 20500000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 764  :               //the only vector control registers are commxmit and commrecv, both of which can cause exceptions
; 765  :               entry->packetInfo |= PACKETINFO_NEVERCOMPILE;            

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 766  :               return;

	jmp	$LN159@DecodeInst@2
$LN56@DecodeInst@2:

; 767  :           }
; 768  :           break;

	jmp	$LN42@DecodeInst@2
$LN52@DecodeInst@2:

; 769  :         }
; 770  :         case 2:
; 771  :         {
; 772  :           //st_p Vj, <label>
; 773  :           entry->packetInfo |= storePixelAbsoluteFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 774  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelAbsolute;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 198		; 000000c6H

; 775  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_INFO)] = MEM_INFO_LINEAR_ABSOLUTE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+172], 1

; 776  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] <<= 1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	shl	eax, 1
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 777  :           entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 778  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv937[ebp], edx
	je	SHORT $LN49@DecodeInst@2
	cmp	DWORD PTR tv937[ebp], 1
	je	SHORT $LN48@DecodeInst@2
	jmp	SHORT $LN50@DecodeInst@2
$LN49@DecodeInst@2:

; 779  :           {
; 780  :             case 0:
; 781  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 782  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 783  :               return;

	jmp	$LN159@DecodeInst@2
$LN48@DecodeInst@2:

; 784  :             case 1:
; 785  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 786  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 787  :               return;

	jmp	$LN159@DecodeInst@2
$LN50@DecodeInst@2:

; 788  :           }
; 789  :           break;

	jmp	$LN42@DecodeInst@2
$LN47@DecodeInst@2:

; 790  :         }
; 791  :         case 3:
; 792  :         {
; 793  :           //st_pz Vj, <label>
; 794  :           entry->packetInfo |= storePixelZAbsoluteFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 795  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelZAbsolute;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 199		; 000000c7H

; 796  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_INFO)] = MEM_INFO_LINEAR_ABSOLUTE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+172], 1

; 797  :           entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] <<= 1;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	shl	edx, 1
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 798  :           entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK((field_1F0000 & 0x1C));

	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	and	ecx, 28					; 0000001cH
	mov	edx, 15					; 0000000fH
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 799  :           //entry->packetInfo |= PACKETINFO_NEVERCOMPILE;
; 800  : 
; 801  :           switch(*(iPtr + 3) >> 6)

	mov	ecx, DWORD PTR _iPtr$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	sar	edx, 6
	mov	DWORD PTR tv980[ebp], edx
	je	SHORT $LN44@DecodeInst@2
	cmp	DWORD PTR tv980[ebp], 1
	je	SHORT $LN43@DecodeInst@2
	jmp	SHORT $LN42@DecodeInst@2
$LN44@DecodeInst@2:

; 802  :           {
; 803  :             case 0:
; 804  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 805  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 806  :               return;

	jmp	$LN159@DecodeInst@2
$LN43@DecodeInst@2:

; 807  :             case 1:
; 808  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	add	edx, 537919488				; 20100000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 809  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 810  :               return;

	jmp	$LN159@DecodeInst@2
$LN42@DecodeInst@2:

; 811  :           }
; 812  :           break;
; 813  :         }
; 814  :       }
; 815  :     }
; 816  :     case 0xC:
; 817  :       //store
; 818  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = field_1F0000;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _field_1F0000$[ebp]
	mov	DWORD PTR [edx+180], eax

; 819  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = field_3E00000;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _field_3E00000$[ebp]
	mov	DWORD PTR [ecx+176], edx

; 820  :       switch(*(iPtr + 3) >> 4)

	mov	eax, DWORD PTR _iPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	sar	ecx, 4
	mov	DWORD PTR tv1013[ebp], ecx
	je	SHORT $LN39@DecodeInst@2
	cmp	DWORD PTR tv1013[ebp], 1
	je	$LN29@DecodeInst@2
	jmp	$LN40@DecodeInst@2
$LN39@DecodeInst@2:

; 821  :       {
; 822  :         case 0x00:
; 823  :           switch(*(iPtr + 3) & 0x0F)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv1017[ebp], eax
	mov	ecx, DWORD PTR tv1017[ebp]
	sub	ecx, 10					; 0000000aH
	mov	DWORD PTR tv1017[ebp], ecx
	cmp	DWORD PTR tv1017[ebp], 5
	ja	$LN37@DecodeInst@2
	mov	edx, DWORD PTR tv1017[ebp]
	jmp	DWORD PTR $LN169@DecodeInst@2[edx*4]

; 824  :           {
; 825  :             case 0x00:
; 826  :             case 0x01:
; 827  :             case 0x02:
; 828  :             case 0x03:
; 829  :             case 0x04:
; 830  :             case 0x05:
; 831  :             case 0x06:
; 832  :             case 0x07:
; 833  :             case 0x08:
; 834  :             case 0x09:
; 835  :               break;

	jmp	$LN37@DecodeInst@2
$LN35@DecodeInst@2:

; 836  :             case 0x0A:
; 837  :               //st_s Sj, (uv)
; 838  :               entry->packetInfo |= storeScalarBilinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 839  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarBilinearUV;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 201		; 000000c9H

; 840  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 841  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 1072		; 00000430H

; 842  :               //entry->packetInfo |= PACKETINFO_NEVERCOMPILE;
; 843  :               break;

	jmp	$LN37@DecodeInst@2
$LN34@DecodeInst@2:

; 844  :             case 0x0B:
; 845  :               //st_s Sj, (xy)
; 846  :               entry->packetInfo |= storeScalarBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 847  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarBilinearXY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 202		; 000000caH

; 848  :               entry->scalarInputDependencies[SLOT_MEM] = SCALAR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 1
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 849  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 524		; 0000020cH

; 850  :               //entry->packetInfo |= PACKETINFO_NEVERCOMPILE;
; 851  :               break;

	jmp	$LN37@DecodeInst@2
$LN33@DecodeInst@2:

; 852  :             case 0x0C:
; 853  :               //st_sv Vj, (Si)
; 854  :               entry->packetInfo |= storeShortVectorLinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 855  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreShortVectorLinear;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 203		; 000000cbH

; 856  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000) | SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], edx

; 857  :               break;

	jmp	$LN37@DecodeInst@2

; 858  :             case 0x0D:
; 859  :               break;

	jmp	SHORT $LN37@DecodeInst@2
$LN31@DecodeInst@2:

; 860  :             case 0x0E:
; 861  :               //st_sv Vj, (uv)
; 862  :               entry->packetInfo |= storeShortVectorBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 863  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreShortVectorBilinearUV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 204		; 000000ccH

; 864  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 865  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 866  :               break;

	jmp	SHORT $LN37@DecodeInst@2
$LN30@DecodeInst@2:

; 867  :             case 0x0F:
; 868  :               //st_sv Vj, (xy)
; 869  :               entry->packetInfo |= storeShortVectorBilinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 870  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreShortVectorBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 205		; 000000cdH

; 871  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 872  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH
$LN37@DecodeInst@2:

; 873  :               break;
; 874  :           }
; 875  :           break;

	jmp	$LN40@DecodeInst@2
$LN29@DecodeInst@2:

; 876  :         case 0x01:
; 877  :           switch(*(iPtr + 3) & 0x0F)

	mov	edx, DWORD PTR _iPtr$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv1073[ebp], eax
	cmp	DWORD PTR tv1073[ebp], 11		; 0000000bH
	ja	$LN40@DecodeInst@2
	mov	ecx, DWORD PTR tv1073[ebp]
	jmp	DWORD PTR $LN170@DecodeInst@2[ecx*4]
$LN26@DecodeInst@2:

; 878  :           {
; 879  :             case 0x00:
; 880  :               //st_v Vj, (Sk)
; 881  :               entry->packetInfo |= storeVectorLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 882  :               entry->packetInfo |= PACKETINFO_MEMORY_INDIRECT;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 883  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreVectorLinear;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 206		; 000000ceH

; 884  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000) | SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	or	eax, edx
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 885  :               break;

	jmp	$LN40@DecodeInst@2
$LN25@DecodeInst@2:

; 886  :             case 0x01:
; 887  :             case 0x02:
; 888  :               //st_v Vj, (uv)
; 889  :               entry->packetInfo |= storeVectorBilinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 890  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreVectorBilinearUV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 207		; 000000cfH

; 891  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 892  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 893  :               entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 894  :               break;

	jmp	$LN40@DecodeInst@2
$LN24@DecodeInst@2:

; 895  :             case 0x03:
; 896  :               //st_v Vj, (xy)
; 897  :               entry->packetInfo |= storeVectorBilinearFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 898  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreVectorBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 208		; 000000d0H

; 899  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 900  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH

; 901  :               entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 902  :               break;

	jmp	$LN40@DecodeInst@2
$LN23@DecodeInst@2:

; 903  :             case 0x04:
; 904  :               //st_p Vj, (Si)
; 905  :               entry->packetInfo |= storePixelLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 906  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelLinear;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 209		; 000000d1H

; 907  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000) | SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	or	eax, edx
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 908  :               break;

	jmp	$LN40@DecodeInst@2

; 909  :             case 0x05:
; 910  :               break;

	jmp	$LN40@DecodeInst@2
$LN21@DecodeInst@2:

; 911  :             case 0x06:
; 912  :               //st_p Vj, (uv)
; 913  :               entry->packetInfo |= storePixelBilinearUVFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 914  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelBilinearUV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 210		; 000000d2H

; 915  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 916  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 917  :               break;

	jmp	$LN40@DecodeInst@2
$LN20@DecodeInst@2:

; 918  :             case 0x07:
; 919  :               //st_p Vj, (xy)
; 920  :               entry->packetInfo |= storePixelBilinearXYFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 921  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 211		; 000000d3H

; 922  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 923  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH

; 924  :               break;

	jmp	$LN40@DecodeInst@2
$LN19@DecodeInst@2:

; 925  :             case 0x08:
; 926  :               //st_pz Vj, (Si)
; 927  :               entry->packetInfo |= storePixelZLinearFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 928  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelZLinear;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 212		; 000000d4H

; 929  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000) | SCALAR_REG_DEPENDENCY_MASK(field_3E00000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	edx, 1
	mov	ecx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, cl
	or	eax, edx
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 930  :               break;

	jmp	$LN40@DecodeInst@2

; 931  :             case 0x09:
; 932  :               break;

	jmp	SHORT $LN40@DecodeInst@2
$LN17@DecodeInst@2:

; 933  :             case 0x0A:
; 934  :               //st_pz Vj, (uv)
; 935  :               entry->packetInfo |= storePixelZBilinearUVFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 936  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelZBilinearUV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 213		; 000000d5H

; 937  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 938  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_UVCTL | DEPENDENCY_MASK_RU | DEPENDENCY_MASK_RV;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+224], 1072		; 00000430H

; 939  :               break;

	jmp	SHORT $LN40@DecodeInst@2
$LN16@DecodeInst@2:

; 940  :             case 0x0B:
; 941  :               //st_pz Vj, (xy)
; 942  :               entry->packetInfo |= storePixelZBilinearXYFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 943  :               entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StorePixelZBilinearXY;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 214		; 000000d6H

; 944  :               entry->scalarInputDependencies[SLOT_MEM] = VECTOR_REG_DEPENDENCY_MASK(field_1F0000);

	mov	edx, 15					; 0000000fH
	mov	ecx, DWORD PTR _field_1F0000$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+204], edx

; 945  :               entry->miscInputDependencies[SLOT_MEM] = DEPENDENCY_MASK_XYCTL | DEPENDENCY_MASK_RX | DEPENDENCY_MASK_RY;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+224], 524		; 0000020cH
$LN40@DecodeInst@2:

; 946  :               break;
; 947  :             case 0x0C:
; 948  :               break;
; 949  :             case 0x0D:
; 950  :               break;
; 951  :             case 0x0E:
; 952  :               break;
; 953  :             case 0x0F:
; 954  :               break;
; 955  :           }
; 956  :           break;
; 957  :       }
; 958  :       break;

	jmp	$LN159@DecodeInst@2

; 959  :     case 0xD:
; 960  :       break;

	jmp	$LN159@DecodeInst@2
$LN10@DecodeInst@2:

; 961  :     case 0xE:
; 962  :       //st_s #nn, <label C> (fall through)
; 963  :     case 0xF:
; 964  :     {
; 965  :       //st_s #nn, <label C>
; 966  :       entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_FROM)] = ((*immExt & 0x7FFFFE0UL) << 5) | ((field_3F & 0x1F) << 5) | field_1F0000;

	mov	edx, DWORD PTR _immExt$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 134217696				; 07ffffe0H
	shl	eax, 5
	mov	ecx, DWORD PTR _field_3F$[ebp]
	and	ecx, 31					; 0000001fH
	shl	ecx, 5
	or	eax, ecx
	or	eax, DWORD PTR _field_1F0000$[ebp]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+180], eax

; 967  :       if(*immExt == 0)

	mov	eax, DWORD PTR _immExt$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN9@DecodeInst@2

; 968  :       {
; 969  :         entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 8388608				; 00800000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 970  :         entry->packetInfo |= storeControlRegisterFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 971  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarControlRegisterImmediate;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 215		; 000000d7H

; 972  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = (((field_1E0 << 5) | field_3E00000) << 4);

	mov	edx, DWORD PTR _field_1E0$[ebp]
	shl	edx, 5
	or	edx, DWORD PTR _field_3E00000$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+176], edx

; 973  :         entry->miscOutputDependencies[SLOT_MEM] = GetControlRegisterOutputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)], bException);

	lea	ecx, DWORD PTR _bException$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterOutputDependencies
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 974  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_CTRL_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	add	eax, 542113792				; 20500000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 975  :         if(bException)

	movzx	edx, BYTE PTR _bException$[ebp]
	test	edx, edx
	je	SHORT $LN8@DecodeInst@2

; 976  :         {
; 977  :           entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN8@DecodeInst@2:

; 978  :         }
; 979  :         return;

	jmp	$LN159@DecodeInst@2

; 980  :       }
; 981  :       else

	jmp	$LN159@DecodeInst@2
$LN9@DecodeInst@2:

; 982  :       {
; 983  :         //st_s #nnnn, <label D>
; 984  :         entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] = (((*immExt & 0x04UL) << 9) | (field_1E0 << 7) | (field_3E00000 << 2) | (*immExt & 0x03UL)) << 2;

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	shl	ecx, 9
	mov	edx, DWORD PTR _field_1E0$[ebp]
	shl	edx, 7
	or	ecx, edx
	mov	eax, DWORD PTR _field_3E00000$[ebp]
	shl	eax, 2
	or	ecx, eax
	mov	edx, DWORD PTR _immExt$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 3
	or	ecx, eax
	shl	ecx, 2
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 985  :         switch((*immExt & 0x18UL) >> 3)

	mov	eax, DWORD PTR _immExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 24					; 00000018H
	shr	ecx, 3
	mov	DWORD PTR tv1228[ebp], ecx
	je	SHORT $LN4@DecodeInst@2
	cmp	DWORD PTR tv1228[ebp], 1
	je	SHORT $LN3@DecodeInst@2
	cmp	DWORD PTR tv1228[ebp], 2
	je	$LN2@DecodeInst@2
	jmp	$LN159@DecodeInst@2
$LN4@DecodeInst@2:

; 986  :         {
; 987  :           case 0:
; 988  :             entry->packetInfo |= storeControlRegisterFlags;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+24]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 989  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarImmediate;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+168], 216		; 000000d8H

; 990  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTROM_BASE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+176], ecx

; 991  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+560]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 992  :             return;

	jmp	$LN159@DecodeInst@2
$LN3@DecodeInst@2:

; 993  :           case 1:
; 994  :             entry->packetInfo |= storeControlRegisterFlags;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+24], edx

; 995  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarImmediate;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+168], 216		; 000000d8H

; 996  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_DTRAM_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	add	eax, 537919488				; 20100000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 997  :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_POINTER)] = (uint32)&dtrom[entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] & MPE_VALID_MEMORY_MASK];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+560]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+184], eax

; 998  :             return;

	jmp	$LN159@DecodeInst@2
$LN2@DecodeInst@2:

; 999  :           case 2:
; 1000 :             entry->packetInfo |= PACKETINFO_MEMORY_IO;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 8388608				; 00800000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 1001 :             entry->packetInfo |= storeControlRegisterFlags;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 1002 :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_HANDLER)] = Handler_StoreScalarControlRegisterImmediate;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+168], 215		; 000000d7H

; 1003 :             entry->miscOutputDependencies[SLOT_MEM] = GetControlRegisterOutputDependencies(entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)], bException);

	lea	ecx, DWORD PTR _bException$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ; MPE::GetControlRegisterOutputDependencies
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 1004 :             entry->nuances[FIXED_FIELD(SLOT_MEM,FIELD_MEM_TO)] += MPE_CTRL_BASE;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+176]
	add	eax, 542113792				; 20500000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 1005 :             if(bException)

	movzx	edx, BYTE PTR _bException$[ebp]
	test	edx, edx
	je	SHORT $LN159@DecodeInst@2

; 1006 :             {
; 1007 :               entry->packetInfo |= PACKETINFO_NEVERCOMPILE;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN159@DecodeInst@2:

; 1008 :             }
; 1009 :             return;
; 1010 :         }
; 1011 :       }
; 1012 :       break;
; 1013 :     }
; 1014 :   }
; 1015 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN163@DecodeInst@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN163@DecodeInst@2:
	DD	1
	DD	$LN162@DecodeInst@2
$LN162@DecodeInst@2:
	DD	-25					; ffffffe7H
	DD	1
	DD	$LN161@DecodeInst@2
$LN161@DecodeInst@2:
	DB	98					; 00000062H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
	npad	1
$LN164@DecodeInst@2:
	DD	$LN156@DecodeInst@2
	DD	$LN151@DecodeInst@2
	DD	$LN146@DecodeInst@2
	DD	$LN139@DecodeInst@2
	DD	$LN115@DecodeInst@2
	DD	$LN75@DecodeInst@2
	DD	$LN74@DecodeInst@2
	DD	$LN73@DecodeInst@2
	DD	$LN73@DecodeInst@2
	DD	$LN73@DecodeInst@2
	DD	$LN73@DecodeInst@2
	DD	$LN66@DecodeInst@2
	DD	$LN42@DecodeInst@2
	DD	$LN159@DecodeInst@2
	DD	$LN10@DecodeInst@2
	DD	$LN10@DecodeInst@2
$LN165@DecodeInst@2:
	DD	$LN136@DecodeInst@2
	DD	$LN131@DecodeInst@2
	DD	$LN125@DecodeInst@2
	DD	$LN120@DecodeInst@2
$LN166@DecodeInst@2:
	DD	$LN109@DecodeInst@2
	DD	$LN110@DecodeInst@2
	DD	$LN107@DecodeInst@2
	DD	$LN106@DecodeInst@2
	DD	$LN105@DecodeInst@2
	DD	$LN110@DecodeInst@2
	DD	$LN103@DecodeInst@2
	DD	$LN102@DecodeInst@2
	DD	$LN110@DecodeInst@2
	DD	$LN110@DecodeInst@2
	DD	$LN99@DecodeInst@2
	DD	$LN98@DecodeInst@2
	DD	$LN97@DecodeInst@2
	DD	$LN110@DecodeInst@2
	DD	$LN95@DecodeInst@2
	DD	$LN94@DecodeInst@2
$LN167@DecodeInst@2:
	DD	$LN90@DecodeInst@2
	DD	$LN89@DecodeInst@2
	DD	$LN89@DecodeInst@2
	DD	$LN88@DecodeInst@2
	DD	$LN87@DecodeInst@2
	DD	$LN113@DecodeInst@2
	DD	$LN85@DecodeInst@2
	DD	$LN84@DecodeInst@2
	DD	$LN83@DecodeInst@2
	DD	$LN113@DecodeInst@2
	DD	$LN81@DecodeInst@2
	DD	$LN80@DecodeInst@2
$LN168@DecodeInst@2:
	DD	$LN63@DecodeInst@2
	DD	$LN58@DecodeInst@2
	DD	$LN52@DecodeInst@2
	DD	$LN47@DecodeInst@2
$LN169@DecodeInst@2:
	DD	$LN35@DecodeInst@2
	DD	$LN34@DecodeInst@2
	DD	$LN33@DecodeInst@2
	DD	$LN37@DecodeInst@2
	DD	$LN31@DecodeInst@2
	DD	$LN30@DecodeInst@2
$LN170@DecodeInst@2:
	DD	$LN26@DecodeInst@2
	DD	$LN25@DecodeInst@2
	DD	$LN25@DecodeInst@2
	DD	$LN24@DecodeInst@2
	DD	$LN23@DecodeInst@2
	DD	$LN40@DecodeInst@2
	DD	$LN21@DecodeInst@2
	DD	$LN20@DecodeInst@2
	DD	$LN19@DecodeInst@2
	DD	$LN40@DecodeInst@2
	DD	$LN17@DecodeInst@2
	DD	$LN16@DecodeInst@2
?DecodeInstruction_MEM32@MPE@@QAEXPAEPAVInstructionCacheEntry@@PAI@Z ENDP ; MPE::DecodeInstruction_MEM32
; Function compile flags: /Odtp /RTCsu
tv66 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_bException$ = 12					; size = 4
?GetControlRegisterInputDependencies@MPE@@QAEIIAA_N@Z PROC ; MPE::GetControlRegisterInputDependencies
; _this$ = ecx

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1019 :   bException = false;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 0

; 1020 : 
; 1021 :   switch((address & 0x1FF0) >> 4)

	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 8176				; 00001ff0H
	shr	ecx, 4
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 129		; 00000081H
	ja	$LN1@GetControl
	mov	edx, DWORD PTR tv66[ebp]
	movzx	eax, BYTE PTR $LN33@GetControl[edx]
	jmp	DWORD PTR $LN34@GetControl[eax*4]
$LN28@GetControl:

; 1022 :   {
; 1023 :     case (0x00 >> 4):
; 1024 :       //mpectl
; 1025 :     case (0x10 >> 4):
; 1026 :       //excepsrc
; 1027 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1028 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN27@GetControl:

; 1029 :     case (0x20 >> 4):
; 1030 :       //excepclr
; 1031 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN26@GetControl:

; 1032 :     case (0x30 >> 4):
; 1033 :       //excephalten
; 1034 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1035 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN25@GetControl:

; 1036 :     case (0x40 >> 4):
; 1037 :       //cc
; 1038 :       return DEPENDENCY_FLAG_ALLFLAGS;

	mov	eax, 67076096				; 03ff8000H
	jmp	$LN31@GetControl
$LN24@GetControl:

; 1039 :     case (0x50 >> 4):
; 1040 :       //pcfetch
; 1041 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1042 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN23@GetControl:

; 1043 :     case (0x60 >> 4):
; 1044 :       //pcroute
; 1045 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1046 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN22@GetControl:

; 1047 :     case (0x70 >> 4):
; 1048 :       //pcexec
; 1049 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1050 :       return 0;

	xor	eax, eax
	jmp	$LN31@GetControl
$LN21@GetControl:

; 1051 :     case (0x80 >> 4):
; 1052 :       //rz
; 1053 :       return DEPENDENCY_MASK_RZ;

	mov	eax, 64					; 00000040H
	jmp	$LN31@GetControl
$LN20@GetControl:

; 1054 :     case (0x90 >> 4):
; 1055 :       //rzi1
; 1056 :       return DEPENDENCY_MASK_RZI1;

	mov	eax, 128				; 00000080H
	jmp	$LN31@GetControl
$LN19@GetControl:

; 1057 :     case (0xA0 >> 4):
; 1058 :       //rzi2
; 1059 :       return DEPENDENCY_MASK_RZI2;

	mov	eax, 256				; 00000100H
	jmp	$LN31@GetControl
$LN18@GetControl:

; 1060 :     case (0xB0 >> 4):
; 1061 :       //intvec1
; 1062 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN31@GetControl
$LN17@GetControl:

; 1063 :     case (0xC0 >> 4):
; 1064 :       //intvec2
; 1065 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN31@GetControl
$LN16@GetControl:

; 1066 :     case (0xD0 >> 4):
; 1067 :       //intsrc
; 1068 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1069 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN31@GetControl
$LN15@GetControl:

; 1070 :     case (0xE0 >> 4):
; 1071 :       //intclr
; 1072 :     case (0xF0 >> 4):
; 1073 :       //intctl
; 1074 :     case (0x100 >> 4):
; 1075 :       //inten1
; 1076 :     case (0x110 >> 4):
; 1077 :       //inten1set
; 1078 :     case (0x130 >> 4):
; 1079 :       //inten2sel
; 1080 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1081 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN31@GetControl
$LN14@GetControl:

; 1082 :     case (0x1E0 >> 4):
; 1083 :       //rc0
; 1084 :       return DEPENDENCY_MASK_RC0;

	mov	eax, 1
	jmp	SHORT $LN31@GetControl
$LN13@GetControl:

; 1085 :     case (0x1F0 >> 4):
; 1086 :       //rc1
; 1087 :       return DEPENDENCY_MASK_RC1;

	mov	eax, 2
	jmp	SHORT $LN31@GetControl
$LN12@GetControl:

; 1088 :     case (0x200 >> 4):
; 1089 :       //rx
; 1090 :       return DEPENDENCY_MASK_RX;

	mov	eax, 4
	jmp	SHORT $LN31@GetControl
$LN11@GetControl:

; 1091 :     case (0x210 >> 4):
; 1092 :       //ry
; 1093 :       return DEPENDENCY_MASK_RY;

	mov	eax, 8
	jmp	SHORT $LN31@GetControl
$LN10@GetControl:

; 1094 :     case (0x220 >> 4):
; 1095 :       //xyrange
; 1096 :       return DEPENDENCY_MASK_XYRANGE;

	mov	eax, 2048				; 00000800H
	jmp	SHORT $LN31@GetControl
$LN9@GetControl:

; 1097 :     case (0x240 >> 4):
; 1098 :       //xyctl
; 1099 :       return DEPENDENCY_MASK_XYCTL;

	mov	eax, 512				; 00000200H
	jmp	SHORT $LN31@GetControl
$LN8@GetControl:

; 1100 :     case (0x250 >> 4):
; 1101 :       //ru
; 1102 :       return DEPENDENCY_MASK_RU;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN31@GetControl
$LN7@GetControl:

; 1103 :     case (0x260 >> 4):
; 1104 :       //rv
; 1105 :       return DEPENDENCY_MASK_RV;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN31@GetControl
$LN6@GetControl:

; 1106 :     case (0x270 >> 4):
; 1107 :       //uvrange
; 1108 :       return DEPENDENCY_MASK_UVRANGE;

	mov	eax, 4096				; 00001000H
	jmp	SHORT $LN31@GetControl
$LN5@GetControl:

; 1109 :     case (0x290 >> 4):
; 1110 :       //uvctl
; 1111 :       return DEPENDENCY_MASK_UVCTL;

	mov	eax, 1024				; 00000400H
	jmp	SHORT $LN31@GetControl
$LN4@GetControl:

; 1112 :     case (0x2C0 >> 4):
; 1113 :       //svshift
; 1114 :       return DEPENDENCY_MASK_SVSHIFT;  

	mov	eax, 16384				; 00004000H
	jmp	SHORT $LN31@GetControl
$LN3@GetControl:

; 1115 :     case (0x2D0 >> 4):
; 1116 :       //acshift
; 1117 :       return DEPENDENCY_MASK_ACSHIFT;

	mov	eax, 8192				; 00002000H
	jmp	SHORT $LN31@GetControl
$LN2@GetControl:

; 1118 :     case (0x500 >> 4):
; 1119 :       //odmactl
; 1120 :     case (0x510 >> 4):
; 1121 :       //odmacptr
; 1122 :     case (0x600 >> 4):
; 1123 :       //mdmactl
; 1124 :     case (0x610 >> 4):
; 1125 :       //mdmacptr
; 1126 :     case (0x7E0 >> 4):
; 1127 :       //comminfo
; 1128 :     case (0x7F0 >> 4):
; 1129 :       //commctl
; 1130 :     case (0x800 >> 4):
; 1131 :       //commxmit0 to commxmit3
; 1132 :     case (0x810 >> 4):
; 1133 :       //commrecv0 to commrecv3
; 1134 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1135 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN31@GetControl
$LN1@GetControl:

; 1136 :     default:
; 1137 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1138 :       return 0;

	xor	eax, eax
$LN31@GetControl:

; 1139 :   }
; 1140 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN34@GetControl:
	DD	$LN28@GetControl
	DD	$LN27@GetControl
	DD	$LN26@GetControl
	DD	$LN25@GetControl
	DD	$LN24@GetControl
	DD	$LN23@GetControl
	DD	$LN22@GetControl
	DD	$LN21@GetControl
	DD	$LN20@GetControl
	DD	$LN19@GetControl
	DD	$LN18@GetControl
	DD	$LN17@GetControl
	DD	$LN16@GetControl
	DD	$LN15@GetControl
	DD	$LN14@GetControl
	DD	$LN13@GetControl
	DD	$LN12@GetControl
	DD	$LN11@GetControl
	DD	$LN10@GetControl
	DD	$LN9@GetControl
	DD	$LN8@GetControl
	DD	$LN7@GetControl
	DD	$LN6@GetControl
	DD	$LN5@GetControl
	DD	$LN4@GetControl
	DD	$LN3@GetControl
	DD	$LN2@GetControl
	DD	$LN1@GetControl
$LN33@GetControl:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	27					; 0000001bH
	DB	13					; 0000000dH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	27					; 0000001bH
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	27					; 0000001bH
	DB	23					; 00000017H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
?GetControlRegisterInputDependencies@MPE@@QAEIIAA_N@Z ENDP ; MPE::GetControlRegisterInputDependencies
; Function compile flags: /Odtp /RTCsu
tv66 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_bException$ = 12					; size = 4
?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z PROC ; MPE::GetControlRegisterOutputDependencies
; _this$ = ecx

; 1143 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1144 :   bException = false;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 0

; 1145 : 
; 1146 :   switch((address & 0x1FF0) >> 4)

	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 8176				; 00001ff0H
	shr	ecx, 4
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 255		; 000000ffH
	ja	SHORT $LN35@GetControl@2
	cmp	DWORD PTR tv66[ebp], 255		; 000000ffH
	je	$LN2@GetControl@2
	cmp	DWORD PTR tv66[ebp], 129		; 00000081H
	ja	$LN1@GetControl@2
	mov	edx, DWORD PTR tv66[ebp]
	movzx	eax, BYTE PTR $LN36@GetControl@2[edx]
	jmp	DWORD PTR $LN37@GetControl@2[eax*4]
$LN35@GetControl@2:
	jmp	$LN1@GetControl@2
$LN30@GetControl@2:

; 1147 :   {
; 1148 :     case (0x00 >> 4):
; 1149 :       //mpectl
; 1150 :     case (0x10 >> 4):
; 1151 :       //excepsrc
; 1152 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1153 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN29@GetControl@2:

; 1154 :     case (0x20 >> 4):
; 1155 :       //excepclr
; 1156 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN28@GetControl@2:

; 1157 :     case (0x30 >> 4):
; 1158 :       //excephalten
; 1159 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1160 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN27@GetControl@2:

; 1161 :     case (0x40 >> 4):
; 1162 :       //cc
; 1163 :       return DEPENDENCY_FLAG_ALLFLAGS;

	mov	eax, 67076096				; 03ff8000H
	jmp	$LN33@GetControl@2
$LN26@GetControl@2:

; 1164 :     case (0x50 >> 4):
; 1165 :       //pcfetch
; 1166 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1167 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN25@GetControl@2:

; 1168 :     case (0x60 >> 4):
; 1169 :       //pcroute
; 1170 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1171 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN24@GetControl@2:

; 1172 :     case (0x70 >> 4):
; 1173 :       //pcexec
; 1174 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1175 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN23@GetControl@2:

; 1176 :     case (0x80 >> 4):
; 1177 :       //rz
; 1178 :       return DEPENDENCY_MASK_RZ;

	mov	eax, 64					; 00000040H
	jmp	$LN33@GetControl@2
$LN22@GetControl@2:

; 1179 :     case (0x90 >> 4):
; 1180 :       //rzi1
; 1181 :       return DEPENDENCY_MASK_RZI1;

	mov	eax, 128				; 00000080H
	jmp	$LN33@GetControl@2
$LN21@GetControl@2:

; 1182 :     case (0xA0 >> 4):
; 1183 :       //rzi2
; 1184 :       return DEPENDENCY_MASK_RZI2;

	mov	eax, 256				; 00000100H
	jmp	$LN33@GetControl@2
$LN20@GetControl@2:

; 1185 :     case (0xB0 >> 4):
; 1186 :       //intvec1
; 1187 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN19@GetControl@2:

; 1188 :     case (0xC0 >> 4):
; 1189 :       //intvec2
; 1190 :       return 0;

	xor	eax, eax
	jmp	$LN33@GetControl@2
$LN18@GetControl@2:

; 1191 :     case (0xD0 >> 4):
; 1192 :       //intsrc
; 1193 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1194 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN33@GetControl@2
$LN17@GetControl@2:

; 1195 :     case (0xE0 >> 4):
; 1196 :       //intclr
; 1197 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN33@GetControl@2
$LN16@GetControl@2:

; 1198 :     case (0xF0 >> 4):
; 1199 :       //intctl
; 1200 :     case (0x100 >> 4):
; 1201 :       //inten1
; 1202 :     case (0x110 >> 4):
; 1203 :       //inten1set
; 1204 :     case (0x130 >> 4):
; 1205 :       //inten2sel
; 1206 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1207 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN33@GetControl@2
$LN15@GetControl@2:

; 1208 :     case (0x1E0 >> 4):
; 1209 :       //rc0
; 1210 :       return DEPENDENCY_MASK_RC0 | DEPENDENCY_FLAG_C0Z;

	mov	eax, 1048577				; 00100001H
	jmp	SHORT $LN33@GetControl@2
$LN14@GetControl@2:

; 1211 :     case (0x1F0 >> 4):
; 1212 :       //rc1
; 1213 :       return DEPENDENCY_MASK_RC1 | DEPENDENCY_FLAG_C1Z;

	mov	eax, 2097154				; 00200002H
	jmp	SHORT $LN33@GetControl@2
$LN13@GetControl@2:

; 1214 :     case (0x200 >> 4):
; 1215 :       //rx
; 1216 :       return DEPENDENCY_MASK_RX;

	mov	eax, 4
	jmp	SHORT $LN33@GetControl@2
$LN12@GetControl@2:

; 1217 :     case (0x210 >> 4):
; 1218 :       //ry
; 1219 :       return DEPENDENCY_MASK_RY;

	mov	eax, 8
	jmp	SHORT $LN33@GetControl@2
$LN11@GetControl@2:

; 1220 :     case (0x220 >> 4):
; 1221 :       //xyrange
; 1222 :       return DEPENDENCY_MASK_XYRANGE;

	mov	eax, 2048				; 00000800H
	jmp	SHORT $LN33@GetControl@2
$LN10@GetControl@2:

; 1223 :     case (0x240 >> 4):
; 1224 :       //xyctl
; 1225 :       return DEPENDENCY_MASK_XYCTL;

	mov	eax, 512				; 00000200H
	jmp	SHORT $LN33@GetControl@2
$LN9@GetControl@2:

; 1226 :     case (0x250 >> 4):
; 1227 :       //ru
; 1228 :       return DEPENDENCY_MASK_RU;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN33@GetControl@2
$LN8@GetControl@2:

; 1229 :     case (0x260 >> 4):
; 1230 :       //rv
; 1231 :       return DEPENDENCY_MASK_RV;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN33@GetControl@2
$LN7@GetControl@2:

; 1232 :     case (0x270 >> 4):
; 1233 :       //uvrange
; 1234 :       return DEPENDENCY_MASK_UVRANGE;

	mov	eax, 4096				; 00001000H
	jmp	SHORT $LN33@GetControl@2
$LN6@GetControl@2:

; 1235 :     case (0x290 >> 4):
; 1236 :       //uvctl
; 1237 :       return DEPENDENCY_MASK_UVCTL;

	mov	eax, 1024				; 00000400H
	jmp	SHORT $LN33@GetControl@2
$LN5@GetControl@2:

; 1238 :     case (0x2C0 >> 4):
; 1239 :       //svshift
; 1240 :       return DEPENDENCY_MASK_SVSHIFT;  

	mov	eax, 16384				; 00004000H
	jmp	SHORT $LN33@GetControl@2
$LN4@GetControl@2:

; 1241 :     case (0x2D0 >> 4):
; 1242 :       //acshift
; 1243 :       return DEPENDENCY_MASK_ACSHIFT;

	mov	eax, 8192				; 00002000H
	jmp	SHORT $LN33@GetControl@2
$LN3@GetControl@2:

; 1244 :     case (0x500 >> 4):
; 1245 :       //odmactl
; 1246 :     case (0x510 >> 4):
; 1247 :       //odmacptr
; 1248 :     case (0x600 >> 4):
; 1249 :       //mdmactl
; 1250 :     case (0x610 >> 4):
; 1251 :       //mdmacptr
; 1252 :     case (0x7E0 >> 4):
; 1253 :       //comminfo
; 1254 :     case (0x7F0 >> 4):
; 1255 :       //commctl
; 1256 :     case (0x800 >> 4):
; 1257 :       //commxmit0 to commxmit3
; 1258 :     case (0x810 >> 4):
; 1259 :       //commrecv0 to commrecv3
; 1260 :       bException = true;

	mov	edx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [edx], 1

; 1261 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN33@GetControl@2
$LN2@GetControl@2:

; 1262 :     case (0xFF0 >> 4):
; 1263 :       //configa: writing to this register acts as a syscall
; 1264 :       bException = true;

	mov	eax, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [eax], 1

; 1265 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN33@GetControl@2
$LN1@GetControl@2:

; 1266 :     default:
; 1267 :       bException = true;

	mov	ecx, DWORD PTR _bException$[ebp]
	mov	BYTE PTR [ecx], 1

; 1268 :       return 0;

	xor	eax, eax
$LN33@GetControl@2:

; 1269 :   }
; 1270 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN37@GetControl@2:
	DD	$LN30@GetControl@2
	DD	$LN29@GetControl@2
	DD	$LN28@GetControl@2
	DD	$LN27@GetControl@2
	DD	$LN26@GetControl@2
	DD	$LN25@GetControl@2
	DD	$LN24@GetControl@2
	DD	$LN23@GetControl@2
	DD	$LN22@GetControl@2
	DD	$LN21@GetControl@2
	DD	$LN20@GetControl@2
	DD	$LN19@GetControl@2
	DD	$LN18@GetControl@2
	DD	$LN17@GetControl@2
	DD	$LN16@GetControl@2
	DD	$LN15@GetControl@2
	DD	$LN14@GetControl@2
	DD	$LN13@GetControl@2
	DD	$LN12@GetControl@2
	DD	$LN11@GetControl@2
	DD	$LN10@GetControl@2
	DD	$LN9@GetControl@2
	DD	$LN8@GetControl@2
	DD	$LN7@GetControl@2
	DD	$LN6@GetControl@2
	DD	$LN5@GetControl@2
	DD	$LN4@GetControl@2
	DD	$LN3@GetControl@2
	DD	$LN1@GetControl@2
$LN36@GetControl@2:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	28					; 0000001cH
	DB	14					; 0000000eH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	28					; 0000001cH
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	28					; 0000001cH
	DB	24					; 00000018H
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	28					; 0000001cH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
?GetControlRegisterOutputDependencies@MPE@@QAEIIAA_N@Z ENDP ; MPE::GetControlRegisterOutputDependencies
_TEXT	ENDS
END
