; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ExecuteMisc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?Execute_CheckECUSkipCounter@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CheckECUSkipCounter
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\executemisc.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CheckECUSkipCounter@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CheckECUSkipCounter

; 6    : {

	push	ebp
	mov	ebp, esp

; 7    :   if(mpe.ecuSkipCounter)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax+576], 0
	je	SHORT $LN3@Execute_Ch

; 8    :   {
; 9    :     mpe.ecuSkipCounter--;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+576]
	sub	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+576], edx

; 10   :     if(!mpe.ecuSkipCounter)

	mov	ecx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [ecx+576], 0
	jne	SHORT $LN3@Execute_Ch

; 11   :     {
; 12   :       mpe.bInterpretedBranchTaken = true;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	BYTE PTR [edx+642], 1
$LN3@Execute_Ch:

; 13   :     }
; 14   :   }
; 15   : }

	pop	ebp
	ret	0
?Execute_CheckECUSkipCounter@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CheckECUSkipCounter
_TEXT	ENDS
PUBLIC	?Execute_SaveFlags@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SaveFlags
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SaveFlags@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SaveFlags

; 18   : {

	push	ebp
	mov	ebp, esp

; 19   :   mpe.tempCC = mpe.cc;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+320], edx

; 20   :   mpe.pICacheEntry = &(mpe.ICacheEntry_SaveFlags);

	mov	eax, DWORD PTR _mpe$[ebp]
	add	eax, 1076				; 00000434H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+668], eax

; 21   : }

	pop	ebp
	ret	0
?Execute_SaveFlags@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SaveFlags
_TEXT	ENDS
PUBLIC	?Execute_SaveRegs@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SaveRegs
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SaveRegs@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SaveRegs

; 24   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 25   :   uint32 i;
; 26   : 
; 27   :   mpe.tempCC = mpe.cc;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+320], edx

; 28   :   for(i = 0; i < 32; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Execute_Sa
$LN2@Execute_Sa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Execute_Sa:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jae	SHORT $LN1@Execute_Sa

; 29   :   {
; 30   :     mpe.tempScalarRegs[i] = mpe.regs[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4+192], eax

; 31   :   }

	jmp	SHORT $LN2@Execute_Sa
$LN1@Execute_Sa:

; 32   : 
; 33   :   mpe.tempRx = mpe.rx;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	DWORD PTR [ecx+332], eax

; 34   :   mpe.tempRy = mpe.ry;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [ecx+336], eax

; 35   :   mpe.tempRu = mpe.ru;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR [ecx+340], eax

; 36   :   mpe.tempRv = mpe.rv;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+152]
	mov	DWORD PTR [ecx+344], eax

; 37   :   mpe.tempRc0 = mpe.rc0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+132]
	mov	DWORD PTR [ecx+324], eax

; 38   :   mpe.tempRc1 = mpe.rc1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR [ecx+328], eax

; 39   :   mpe.tempRz = mpe.rz;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR [ecx+348], eax

; 40   :   mpe.tempRzi1 = mpe.rzi1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+160]
	mov	DWORD PTR [ecx+352], eax

; 41   :   mpe.tempRzi2 = mpe.rzi2;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR [ecx+356], eax

; 42   :   mpe.tempXyctl = mpe.xyctl;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	DWORD PTR [ecx+360], eax

; 43   :   mpe.tempUvctl = mpe.uvctl;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR [ecx+364], eax

; 44   :   mpe.tempXyrange = mpe.xyrange;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+368], eax

; 45   :   mpe.tempUvrange = mpe.uvrange;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+180]
	mov	DWORD PTR [ecx+372], eax

; 46   :   mpe.tempAcshift = mpe.acshift;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+376], eax

; 47   :   mpe.tempSvshift = mpe.svshift;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+380], eax

; 48   : 
; 49   :   mpe.pICacheEntry = &(mpe.ICacheEntry_SaveRegs);

	mov	ecx, DWORD PTR _mpe$[ebp]
	add	ecx, 808				; 00000328H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+668], ecx

; 50   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SaveRegs@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SaveRegs
_TEXT	ENDS
PUBLIC	?Execute_StoreScalarRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreScalarRegisterConstant
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_flagMask$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreScalarRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreScalarRegisterConstant

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 54   :   mpe.regs[nuance.fields[FIELD_CONSTANT_ADDRESS]] = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx*4], eax

; 55   :   uint32 flagMask = nuance.fields[FIELD_CONSTANT_FLAGMASK];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _flagMask$[ebp], edx

; 56   : 
; 57   :   if(flagMask)

	cmp	DWORD PTR _flagMask$[ebp], 0
	je	SHORT $LN2@Execute_St

; 58   :   {
; 59   :     mpe.cc &= (~flagMask);

	mov	eax, DWORD PTR _flagMask$[ebp]
	not	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	and	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax

; 60   :     mpe.cc |= nuance.fields[FIELD_CONSTANT_FLAGVALUES];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+128]
	or	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_St:

; 61   :   }
; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_StoreScalarRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreScalarRegisterConstant
_TEXT	ENDS
PUBLIC	?Execute_StoreMiscRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_StoreMiscRegisterConstant
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv67 = -12						; size = 4
_flagMask$ = -8						; size = 4
_miscRegIndex$ = -4					; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_StoreMiscRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_StoreMiscRegisterConstant

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 66   :   uint32 miscRegIndex = nuance.fields[FIELD_CONSTANT_ADDRESS];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _miscRegIndex$[ebp], ecx

; 67   :   uint32 flagMask = nuance.fields[FIELD_CONSTANT_FLAGMASK];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _flagMask$[ebp], eax

; 68   : 
; 69   :   if(miscRegIndex != CONSTANT_REG_DISCARD)

	cmp	DWORD PTR _miscRegIndex$[ebp], 32	; 00000020H
	je	$LN17@Execute_St@2

; 70   :   {
; 71   :     switch(miscRegIndex)

	mov	ecx, DWORD PTR _miscRegIndex$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 14			; 0000000eH
	ja	$LN17@Execute_St@2
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN20@Execute_St@2[edx*4]
$LN14@Execute_St@2:

; 72   :     {
; 73   :       case CONSTANT_REG_RX:
; 74   :         mpe.rx = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+140], edx

; 75   :         break;

	jmp	$LN17@Execute_St@2
$LN13@Execute_St@2:

; 76   :       case CONSTANT_REG_RY:
; 77   :         mpe.ry = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+144], edx

; 78   :         break;

	jmp	$LN17@Execute_St@2
$LN12@Execute_St@2:

; 79   :       case CONSTANT_REG_RU:
; 80   :         mpe.ru = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+148], edx

; 81   :         break;

	jmp	$LN17@Execute_St@2
$LN11@Execute_St@2:

; 82   :       case CONSTANT_REG_RV:
; 83   :         mpe.rv = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+152], edx

; 84   :         break;

	jmp	$LN17@Execute_St@2
$LN10@Execute_St@2:

; 85   :       case CONSTANT_REG_RC0:
; 86   :         mpe.rc0 = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+132], edx

; 87   :         break;

	jmp	$LN17@Execute_St@2
$LN9@Execute_St@2:

; 88   :       case CONSTANT_REG_RC1:
; 89   :         mpe.rc1 = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+136], edx

; 90   :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN8@Execute_St@2:

; 91   :       case CONSTANT_REG_RZ:
; 92   :         mpe.rz = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+156], edx

; 93   :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN7@Execute_St@2:

; 94   :       case CONSTANT_REG_XYCTL:
; 95   :         mpe.xyctl = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+168], edx

; 96   :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN6@Execute_St@2:

; 97   :       case CONSTANT_REG_UVCTL:
; 98   :         mpe.uvctl = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+172], edx

; 99   :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN5@Execute_St@2:

; 100  :       case CONSTANT_REG_XYRANGE:
; 101  :         mpe.xyrange = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+176], edx

; 102  :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN4@Execute_St@2:

; 103  :       case CONSTANT_REG_UVRANGE:
; 104  :         mpe.uvrange = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+180], edx

; 105  :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN3@Execute_St@2:

; 106  :       case CONSTANT_REG_ACSHIFT:
; 107  :         mpe.acshift = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+184], edx

; 108  :         break;

	jmp	SHORT $LN17@Execute_St@2
$LN2@Execute_St@2:

; 109  :       case CONSTANT_REG_SVSHIFT:
; 110  :         mpe.svshift = nuance.fields[FIELD_CONSTANT_VALUE];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+188], edx
$LN17@Execute_St@2:

; 111  :         break;
; 112  :     }
; 113  :   }
; 114  :   
; 115  :   if(flagMask)

	cmp	DWORD PTR _flagMask$[ebp], 0
	je	SHORT $LN18@Execute_St@2

; 116  :   {
; 117  :     mpe.cc &= (~flagMask);

	mov	eax, DWORD PTR _flagMask$[ebp]
	not	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	and	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax

; 118  :     mpe.cc |= nuance.fields[FIELD_CONSTANT_FLAGVALUES];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [eax+128]
	or	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN18@Execute_St@2:

; 119  :   }
; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@Execute_St@2:
	DD	$LN10@Execute_St@2
	DD	$LN9@Execute_St@2
	DD	$LN14@Execute_St@2
	DD	$LN13@Execute_St@2
	DD	$LN12@Execute_St@2
	DD	$LN11@Execute_St@2
	DD	$LN8@Execute_St@2
	DD	$LN17@Execute_St@2
	DD	$LN17@Execute_St@2
	DD	$LN7@Execute_St@2
	DD	$LN6@Execute_St@2
	DD	$LN5@Execute_St@2
	DD	$LN4@Execute_St@2
	DD	$LN3@Execute_St@2
	DD	$LN2@Execute_St@2
?Execute_StoreMiscRegisterConstant@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_StoreMiscRegisterConstant
_TEXT	ENDS
END
