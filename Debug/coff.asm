; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\coff.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12420
_DATA	ENDS
CONST	SEGMENT
$SG12420 DB	'bad allocation', 00H
	ORG $+1
$SG41559 DB	'PATCH', 00H
	ORG $+2
$SG41567 DB	'PATCH', 00H
CONST	ENDS
PUBLIC	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z		; MPE::LoadCoffFile
EXTRN	_close:PROC
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	_strcmp:PROC
EXTRN	_lseek:PROC
EXTRN	_read:PROC
EXTRN	_tell:PROC
EXTRN	_open:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\coff.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_i$41568 = -112						; size = 4
_i$41560 = -108						; size = 4
_start_offset$ = -104					; size = 4
_sectionhdr$ = -96					; size = 44
_coffhdr$ = -44						; size = 20
_nextPos$ = -20						; size = 4
_entryPoint$ = -12					; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
_bSetEntryPoint$ = 12					; size = 1
_handle$ = 16						; size = 4
?LoadCoffFile@MPE@@QAE_NPAD_NH@Z PROC			; MPE::LoadCoffFile
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   :   uint32 entryPoint;
; 42   :   int nextPos;
; 43   :   FILHDR coffhdr;
; 44   :   SCNHDR sectionhdr;
; 45   :   int start_offset;
; 46   : 
; 47   :   if(handle == -1)

	cmp	DWORD PTR _handle$[ebp], -1
	jne	SHORT $LN22@LoadCoffFi

; 48   :   {
; 49   :     handle = open(filename,O_RDONLY|O_BINARY,0);

	push	0
	push	32768					; 00008000H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _handle$[ebp], eax
$LN22@LoadCoffFi:

; 50   :   }
; 51   : 
; 52   :   start_offset = tell(handle);

	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_tell
	add	esp, 4
	mov	DWORD PTR _start_offset$[ebp], eax

; 53   : 
; 54   :   if(handle >= 0)

	cmp	DWORD PTR _handle$[ebp], 0
	jl	$LN21@LoadCoffFi

; 55   :   {
; 56   :     read(handle, &coffhdr, sizeof(FILHDR));

	push	20					; 00000014H
	lea	edx, DWORD PTR _coffhdr$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH

; 57   :     coffhdr.f_magic = bswap16(coffhdr.f_magic);

	movzx	ecx, WORD PTR _coffhdr$[ebp]
	shl	ecx, 8
	movzx	edx, WORD PTR _coffhdr$[ebp]
	sar	edx, 8
	and	edx, 255				; 000000ffH
	or	ecx, edx
	mov	WORD PTR _coffhdr$[ebp], cx

; 58   :     coffhdr.f_nscns = bswap16(coffhdr.f_nscns);

	movzx	eax, WORD PTR _coffhdr$[ebp+2]
	shl	eax, 8
	movzx	ecx, WORD PTR _coffhdr$[ebp+2]
	sar	ecx, 8
	and	ecx, 255				; 000000ffH
	or	eax, ecx
	mov	WORD PTR _coffhdr$[ebp+2], ax

; 59   :     coffhdr.f_timdat = bswap32(coffhdr.f_timdat);

	mov	edx, DWORD PTR _coffhdr$[ebp+4]
	and	edx, 255				; 000000ffH
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _coffhdr$[ebp+4]
	and	eax, 65280				; 0000ff00H
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _coffhdr$[ebp+4]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _coffhdr$[ebp+4]
	shr	eax, 24					; 00000018H
	or	edx, eax
	mov	DWORD PTR _coffhdr$[ebp+4], edx

; 60   :     coffhdr.f_symptr = bswap32(coffhdr.f_symptr);

	mov	ecx, DWORD PTR _coffhdr$[ebp+8]
	and	ecx, 255				; 000000ffH
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _coffhdr$[ebp+8]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _coffhdr$[ebp+8]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _coffhdr$[ebp+8]
	shr	edx, 24					; 00000018H
	or	ecx, edx
	mov	DWORD PTR _coffhdr$[ebp+8], ecx

; 61   :     coffhdr.f_nsyms = bswap32(coffhdr.f_nsyms);

	mov	eax, DWORD PTR _coffhdr$[ebp+12]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _coffhdr$[ebp+12]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _coffhdr$[ebp+12]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _coffhdr$[ebp+12]
	shr	ecx, 24					; 00000018H
	or	eax, ecx
	mov	DWORD PTR _coffhdr$[ebp+12], eax

; 62   :     coffhdr.f_opthdr = bswap16(coffhdr.f_opthdr);

	movzx	edx, WORD PTR _coffhdr$[ebp+16]
	shl	edx, 8
	movzx	eax, WORD PTR _coffhdr$[ebp+16]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	or	edx, eax
	mov	WORD PTR _coffhdr$[ebp+16], dx

; 63   :     coffhdr.f_flags = bswap16(coffhdr.f_flags);

	movzx	ecx, WORD PTR _coffhdr$[ebp+18]
	shl	ecx, 8
	movzx	edx, WORD PTR _coffhdr$[ebp+18]
	sar	edx, 8
	and	edx, 255				; 000000ffH
	or	ecx, edx
	mov	WORD PTR _coffhdr$[ebp+18], cx

; 64   : 
; 65   :     //expect magic number 0x01 0x20
; 66   :     if(coffhdr.f_magic != 0x0120)

	movzx	eax, WORD PTR _coffhdr$[ebp]
	cmp	eax, 288				; 00000120H
	je	SHORT $LN20@LoadCoffFi

; 67   :       return false;

	xor	al, al
	jmp	$LN23@LoadCoffFi
$LN20@LoadCoffFi:

; 68   : 
; 69   :     //read the entry point, which is the first four bytes of the optional header
; 70   :     read(handle, &entryPoint, 4);

	push	4
	lea	ecx, DWORD PTR _entryPoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH

; 71   :     entryPoint = bswap32(entryPoint);

	mov	eax, DWORD PTR _entryPoint$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _entryPoint$[ebp]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _entryPoint$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _entryPoint$[ebp]
	shr	ecx, 24					; 00000018H
	or	eax, ecx
	mov	DWORD PTR _entryPoint$[ebp], eax

; 72   :     //skip past the remainder of the optional header
; 73   :     lseek(handle, (coffhdr.f_opthdr - 4), SEEK_CUR);

	push	1
	movzx	edx, WORD PTR _coffhdr$[ebp+16]
	sub	edx, 4
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_lseek
	add	esp, 12					; 0000000cH
$LN19@LoadCoffFi:

; 74   :     while(coffhdr.f_nscns > 0)

	movzx	ecx, WORD PTR _coffhdr$[ebp+2]
	test	ecx, ecx
	jle	$LN18@LoadCoffFi

; 75   :     {
; 76   :       read(handle, &sectionhdr, sizeof(SCNHDR));

	push	44					; 0000002cH
	lea	edx, DWORD PTR _sectionhdr$[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH

; 77   :       sectionhdr.s_paddr = bswap32(sectionhdr.s_paddr);

	mov	ecx, DWORD PTR _sectionhdr$[ebp+8]
	and	ecx, 255				; 000000ffH
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sectionhdr$[ebp+8]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _sectionhdr$[ebp+8]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _sectionhdr$[ebp+8]
	shr	edx, 24					; 00000018H
	or	ecx, edx
	mov	DWORD PTR _sectionhdr$[ebp+8], ecx

; 78   :       sectionhdr.s_vaddr = bswap32(sectionhdr.s_vaddr);

	mov	eax, DWORD PTR _sectionhdr$[ebp+12]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sectionhdr$[ebp+12]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _sectionhdr$[ebp+12]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _sectionhdr$[ebp+12]
	shr	ecx, 24					; 00000018H
	or	eax, ecx
	mov	DWORD PTR _sectionhdr$[ebp+12], eax

; 79   :       sectionhdr.s_size = bswap32(sectionhdr.s_size);

	mov	edx, DWORD PTR _sectionhdr$[ebp+16]
	and	edx, 255				; 000000ffH
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _sectionhdr$[ebp+16]
	and	eax, 65280				; 0000ff00H
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _sectionhdr$[ebp+16]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _sectionhdr$[ebp+16]
	shr	eax, 24					; 00000018H
	or	edx, eax
	mov	DWORD PTR _sectionhdr$[ebp+16], edx

; 80   :       sectionhdr.s_scnptr = bswap32(sectionhdr.s_scnptr);

	mov	ecx, DWORD PTR _sectionhdr$[ebp+20]
	and	ecx, 255				; 000000ffH
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sectionhdr$[ebp+20]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _sectionhdr$[ebp+20]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _sectionhdr$[ebp+20]
	shr	edx, 24					; 00000018H
	or	ecx, edx
	mov	DWORD PTR _sectionhdr$[ebp+20], ecx

; 81   :       sectionhdr.s_relptr = bswap32(sectionhdr.s_relptr);

	mov	eax, DWORD PTR _sectionhdr$[ebp+24]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sectionhdr$[ebp+24]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _sectionhdr$[ebp+24]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _sectionhdr$[ebp+24]
	shr	ecx, 24					; 00000018H
	or	eax, ecx
	mov	DWORD PTR _sectionhdr$[ebp+24], eax

; 82   :       sectionhdr.s_lnnoptr = bswap32(sectionhdr.s_lnnoptr);

	mov	edx, DWORD PTR _sectionhdr$[ebp+28]
	and	edx, 255				; 000000ffH
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _sectionhdr$[ebp+28]
	and	eax, 65280				; 0000ff00H
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _sectionhdr$[ebp+28]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _sectionhdr$[ebp+28]
	shr	eax, 24					; 00000018H
	or	edx, eax
	mov	DWORD PTR _sectionhdr$[ebp+28], edx

; 83   :       sectionhdr.s_nreloc = bswap32(sectionhdr.s_nreloc);

	mov	ecx, DWORD PTR _sectionhdr$[ebp+32]
	and	ecx, 255				; 000000ffH
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _sectionhdr$[ebp+32]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	ecx, edx
	mov	eax, DWORD PTR _sectionhdr$[ebp+32]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _sectionhdr$[ebp+32]
	shr	edx, 24					; 00000018H
	or	ecx, edx
	mov	DWORD PTR _sectionhdr$[ebp+32], ecx

; 84   :       sectionhdr.s_nlnno = bswap32(sectionhdr.s_nlnno);

	mov	eax, DWORD PTR _sectionhdr$[ebp+36]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _sectionhdr$[ebp+36]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _sectionhdr$[ebp+36]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _sectionhdr$[ebp+36]
	shr	ecx, 24					; 00000018H
	or	eax, ecx
	mov	DWORD PTR _sectionhdr$[ebp+36], eax

; 85   :       sectionhdr.s_flags = bswap32(sectionhdr.s_flags);

	mov	edx, DWORD PTR _sectionhdr$[ebp+40]
	and	edx, 255				; 000000ffH
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _sectionhdr$[ebp+40]
	and	eax, 65280				; 0000ff00H
	shl	eax, 8
	or	edx, eax
	mov	ecx, DWORD PTR _sectionhdr$[ebp+40]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _sectionhdr$[ebp+40]
	shr	eax, 24					; 00000018H
	or	edx, eax
	mov	DWORD PTR _sectionhdr$[ebp+40], edx

; 86   : 
; 87   :       if((sectionhdr.s_flags & 0x000000282) != 0)

	mov	ecx, DWORD PTR _sectionhdr$[ebp+40]
	and	ecx, 642				; 00000282H
	je	SHORT $LN17@LoadCoffFi

; 88   :       {
; 89   :         //Don't skip the bss or section even though
; 90   :         //it is marked as do-not-load.  VM Labs actually
; 91   :         //puts code into the BSS section and later zeroes it
; 92   :         //out after executing it.
; 93   : 
; 94   :         //if(strcmp(sectionhdr.s_name,"bss"))
; 95   :         //{
; 96   :           //Skip this section
; 97   :           coffhdr.f_nscns--;

	mov	dx, WORD PTR _coffhdr$[ebp+2]
	sub	dx, 1
	mov	WORD PTR _coffhdr$[ebp+2], dx

; 98   :           continue;

	jmp	$LN19@LoadCoffFi
$LN17@LoadCoffFi:

; 99   :         //}
; 100  :       }
; 101  : 
; 102  :       //save position so we can go to the section data
; 103  :       nextPos = tell(handle);

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_tell
	add	esp, 4
	mov	DWORD PTR _nextPos$[ebp], eax

; 104  :       //start_offset may not be 0 if loading a COFF image stored inside of
; 105  :       //a NUONROM-DISK image
; 106  :       lseek(handle,start_offset,SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _start_offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH

; 107  :       lseek(handle,sectionhdr.s_scnptr,SEEK_CUR);

	push	1
	mov	eax, DWORD PTR _sectionhdr$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 108  : 
; 109  :       if(sectionhdr.s_paddr < MAIN_BUS_BASE)

	cmp	DWORD PTR _sectionhdr$[ebp+8], 1073741824 ; 40000000H
	jae	SHORT $LN16@LoadCoffFi

; 110  :       {
; 111  :         //assume local MPE memory
; 112  :         read(handle,&dtrom[sectionhdr.s_paddr & MPE_VALID_MEMORY_MASK],sectionhdr.s_size);

	mov	edx, DWORD PTR _sectionhdr$[ebp+16]
	push	edx
	mov	eax, DWORD PTR _sectionhdr$[ebp+8]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+560]
	push	eax
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	jmp	$LN15@LoadCoffFi
$LN16@LoadCoffFi:

; 113  :       }
; 114  :       else if(sectionhdr.s_paddr < SYSTEM_BUS_BASE)

	cmp	DWORD PTR _sectionhdr$[ebp+8], -2147483648 ; 80000000H
	jae	$LN14@LoadCoffFi

; 115  :       {
; 116  :         //main bus DRAM
; 117  :         if(strcmp(sectionhdr.s_name,"PATCH") == 0)

	push	OFFSET $SG41559
	lea	eax, DWORD PTR _sectionhdr$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@LoadCoffFi

; 118  :         {
; 119  :           //zero out the first 16 bytes in the PATCH section to avoid
; 120  :           //BIOS patching in the C startup code
; 121  : 
; 122  :           for(int i = 0; i < 16; i++)

	mov	DWORD PTR _i$41560[ebp], 0
	jmp	SHORT $LN12@LoadCoffFi
$LN11@LoadCoffFi:
	mov	ecx, DWORD PTR _i$41560[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$41560[ebp], ecx
$LN12@LoadCoffFi:
	cmp	DWORD PTR _i$41560[ebp], 16		; 00000010H
	jge	SHORT $LN10@LoadCoffFi

; 123  :           {
; 124  :             nuonEnv->mainBusDRAM[(sectionhdr.s_paddr & MAIN_BUS_VALID_MEMORY_MASK) + i] = 0;

	mov	edx, DWORD PTR _sectionhdr$[ebp+8]
	and	edx, 8388607				; 007fffffH
	add	edx, DWORD PTR _i$41560[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+24]
	mov	BYTE PTR [edx+ecx], 0

; 125  :           }

	jmp	SHORT $LN11@LoadCoffFi
$LN10@LoadCoffFi:

; 126  :           lseek(handle,16,SEEK_CUR);

	push	1
	push	16					; 00000010H
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH

; 127  :           read(handle,&(nuonEnv->mainBusDRAM[(sectionhdr.s_paddr & MAIN_BUS_VALID_MEMORY_MASK) + 16]),sectionhdr.s_size - 16);

	mov	eax, DWORD PTR _sectionhdr$[ebp+16]
	sub	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _sectionhdr$[ebp+8]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+24]
	lea	ecx, DWORD PTR [ecx+eax+16]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH

; 128  :         }
; 129  :         else

	jmp	SHORT $LN9@LoadCoffFi
$LN13@LoadCoffFi:

; 130  :         {
; 131  :           read(handle,&(nuonEnv->mainBusDRAM[sectionhdr.s_paddr & MAIN_BUS_VALID_MEMORY_MASK]),sectionhdr.s_size);

	mov	eax, DWORD PTR _sectionhdr$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _sectionhdr$[ebp+8]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	add	ecx, DWORD PTR [edx+24]
	push	ecx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH
$LN9@LoadCoffFi:

; 132  :         }
; 133  :       }
; 134  :       else

	jmp	$LN15@LoadCoffFi
$LN14@LoadCoffFi:

; 135  :       {
; 136  :         //assume system bus DRAM
; 137  :         if(strcmp(sectionhdr.s_name,"PATCH") == 0)

	push	OFFSET $SG41567
	lea	ecx, DWORD PTR _sectionhdr$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@LoadCoffFi

; 138  :         {
; 139  :           //zero out the first 16 bytes in the PATCH section to avoid
; 140  :           //BIOS patching in the C startup code
; 141  : 
; 142  :           for(int i = 0; i < 16; i++)

	mov	DWORD PTR _i$41568[ebp], 0
	jmp	SHORT $LN6@LoadCoffFi
$LN5@LoadCoffFi:
	mov	edx, DWORD PTR _i$41568[ebp]
	add	edx, 1
	mov	DWORD PTR _i$41568[ebp], edx
$LN6@LoadCoffFi:
	cmp	DWORD PTR _i$41568[ebp], 16		; 00000010H
	jge	SHORT $LN4@LoadCoffFi

; 143  :           {
; 144  :             nuonEnv->systemBusDRAM[(sectionhdr.s_paddr & SYSTEM_BUS_VALID_MEMORY_MASK) + i] = 0;

	mov	eax, DWORD PTR _sectionhdr$[ebp+8]
	and	eax, 8388607				; 007fffffH
	add	eax, DWORD PTR _i$41568[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+28]
	mov	BYTE PTR [eax+edx], 0

; 145  :           }

	jmp	SHORT $LN5@LoadCoffFi
$LN4@LoadCoffFi:

; 146  :           lseek(handle,16,SEEK_CUR);

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_lseek
	add	esp, 12					; 0000000cH

; 147  :           read(handle,&(nuonEnv->systemBusDRAM[(sectionhdr.s_paddr & SYSTEM_BUS_VALID_MEMORY_MASK) + 16]),sectionhdr.s_size - 16);

	mov	ecx, DWORD PTR _sectionhdr$[ebp+16]
	sub	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _sectionhdr$[ebp+8]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+28]
	lea	edx, DWORD PTR [edx+ecx+16]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_read
	add	esp, 12					; 0000000cH

; 148  :         }
; 149  :         else

	jmp	SHORT $LN15@LoadCoffFi
$LN7@LoadCoffFi:

; 150  :         {
; 151  :           read(handle,&(nuonEnv->systemBusDRAM[(sectionhdr.s_paddr & SYSTEM_BUS_VALID_MEMORY_MASK)]),sectionhdr.s_size);

	mov	ecx, DWORD PTR _sectionhdr$[ebp+16]
	push	ecx
	mov	edx, DWORD PTR _sectionhdr$[ebp+8]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_read
	add	esp, 12					; 0000000cH
$LN15@LoadCoffFi:

; 152  :         }
; 153  :       }
; 154  : 
; 155  :       coffhdr.f_nscns--;

	mov	dx, WORD PTR _coffhdr$[ebp+2]
	sub	dx, 1
	mov	WORD PTR _coffhdr$[ebp+2], dx

; 156  :       lseek(handle,nextPos,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _nextPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_lseek
	add	esp, 12					; 0000000cH

; 157  :     }

	jmp	$LN19@LoadCoffFi
$LN18@LoadCoffFi:

; 158  : 
; 159  :     close(handle);

	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	call	_close
	add	esp, 4

; 160  : 
; 161  :     if(bSetEntryPoint)

	movzx	eax, BYTE PTR _bSetEntryPoint$[ebp]
	test	eax, eax
	je	SHORT $LN2@LoadCoffFi

; 162  :     {
; 163  :       pcexec = entryPoint;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _entryPoint$[ebp]
	mov	DWORD PTR [ecx+408], edx
$LN2@LoadCoffFi:

; 164  :     }
; 165  : 
; 166  :     return true;

	mov	al, 1
	jmp	SHORT $LN23@LoadCoffFi

; 167  :   }
; 168  :   else

	jmp	SHORT $LN23@LoadCoffFi
$LN21@LoadCoffFi:

; 169  :   {
; 170  :     return false;

	xor	al, al
$LN23@LoadCoffFi:

; 171  :   }
; 172  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@LoadCoffFi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 112				; 00000070H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN30@LoadCoffFi:
	DD	3
	DD	$LN29@LoadCoffFi
$LN29@LoadCoffFi:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN26@LoadCoffFi
	DD	-44					; ffffffd4H
	DD	20					; 00000014H
	DD	$LN27@LoadCoffFi
	DD	-96					; ffffffa0H
	DD	44					; 0000002cH
	DD	$LN28@LoadCoffFi
$LN28@LoadCoffFi:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	104					; 00000068H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	0
$LN27@LoadCoffFi:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	104					; 00000068H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	0
$LN26@LoadCoffFi:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?LoadCoffFile@MPE@@QAE_NPAD_NH@Z ENDP			; MPE::LoadCoffFile
_TEXT	ENDS
END
