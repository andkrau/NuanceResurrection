; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\file.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?fdesc@@3HA					; fdesc
PUBLIC	?fileDescriptors@@3PAHA				; fileDescriptors
_BSS	SEGMENT
?fdesc@@3HA DD	01H DUP (?)				; fdesc
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG67132
	ORG $+4
?fileDescriptors@@3PAHA DD 0ffffffffH			; fileDescriptors
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
_DATA	ENDS
CONST	SEGMENT
$SG67132 DB	'bad allocation', 00H
	ORG $+1
$SG77929 DB	'/iso9660/', 00H
	ORG $+2
$SG77932 DB	'/udf/', 00H
	ORG $+2
$SG77997 DB	'Unimplemented File Call: FileIoctl', 00H
	ORG $+1
$SG77998 DB	'This handler does nothing', 00H
	ORG $+2
$SG78056 DB	'Unimplemented File Call: FileStat', 00H
	ORG $+2
$SG78064 DB	'Unimplemented File Call: FileIsatty', 00H
$SG78087 DB	'Unimplemented File Call: FileLink', 00H
	ORG $+2
$SG78088 DB	'This handler does nothing', 00H
	ORG $+2
$SG78097 DB	'Unimplemented File Call: FileLstat', 00H
	ORG $+1
$SG78105 DB	'Unimplemented File Call: FileUnlink', 00H
CONST	ENDS
PUBLIC	?ConvertFlags@@YAII@Z				; ConvertFlags
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\file.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_result$ = -4						; size = 4
_nuonFlags$ = 8						; size = 4
?ConvertFlags@@YAII@Z PROC				; ConvertFlags

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 59   :   uint32 result = nuonFlags & (_O_RDONLY|_O_WRONLY|O_RDWR|_O_APPEND);

	mov	eax, DWORD PTR _nuonFlags$[ebp]
	and	eax, 11					; 0000000bH
	mov	DWORD PTR _result$[ebp], eax

; 60   : 
; 61   :   if(nuonFlags & _FCREAT)

	mov	ecx, DWORD PTR _nuonFlags$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN4@ConvertFla

; 62   :   {
; 63   :     result |= O_CREAT;

	mov	edx, DWORD PTR _result$[ebp]
	or	edx, 256				; 00000100H
	mov	DWORD PTR _result$[ebp], edx
$LN4@ConvertFla:

; 64   :   }
; 65   :   if(nuonFlags & _FTRUNC)

	mov	eax, DWORD PTR _nuonFlags$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN3@ConvertFla

; 66   :   {
; 67   :     result |= O_TRUNC;

	mov	ecx, DWORD PTR _result$[ebp]
	or	ecx, 512				; 00000200H
	mov	DWORD PTR _result$[ebp], ecx
$LN3@ConvertFla:

; 68   :   }
; 69   :   if(nuonFlags & _FEXCL)

	mov	edx, DWORD PTR _nuonFlags$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN2@ConvertFla

; 70   :   {
; 71   :     result |= O_EXCL;

	mov	eax, DWORD PTR _result$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _result$[ebp], eax
$LN2@ConvertFla:

; 72   :   }
; 73   :   if(nuonFlags & _FBINARY)

	mov	ecx, DWORD PTR _nuonFlags$[ebp]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN1@ConvertFla

; 74   :   {
; 75   :     result |= O_BINARY;

	mov	edx, DWORD PTR _result$[ebp]
	or	edx, 32768				; 00008000H
	mov	DWORD PTR _result$[ebp], edx
$LN1@ConvertFla:

; 76   :   }
; 77   : 
; 78   :   return (result | O_BINARY) & ~O_TEXT;

	mov	eax, DWORD PTR _result$[ebp]
	or	eax, 32768				; 00008000H
	and	eax, -16385				; ffffbfffH

; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertFlags@@YAII@Z ENDP				; ConvertFlags
_TEXT	ENDS
PUBLIC	?FindFileDescriptorIndex@@YAHH@Z		; FindFileDescriptorIndex
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
_fd$ = 8						; size = 4
?FindFileDescriptorIndex@@YAHH@Z PROC			; FindFileDescriptorIndex

; 82   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 83   :   uint32 i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 84   : 
; 85   :   for(i = 0; i < 16; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FindFileDe
$LN3@FindFileDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FindFileDe:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jae	SHORT $LN2@FindFileDe

; 86   :   {
; 87   :     if(fileDescriptors[i] == fd)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?fileDescriptors@@3PAHA[ecx*4]
	cmp	edx, DWORD PTR _fd$[ebp]
	jne	SHORT $LN1@FindFileDe

; 88   :     {
; 89   :       return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN5@FindFileDe
$LN1@FindFileDe:

; 90   :     }
; 91   :   }

	jmp	SHORT $LN3@FindFileDe
$LN2@FindFileDe:

; 92   : 
; 93   :   return -1;

	or	eax, -1
$LN5@FindFileDe:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindFileDescriptorIndex@@YAHH@Z ENDP			; FindFileDescriptorIndex
_TEXT	ENDS
PUBLIC	?ConvertIFMT@@YAII@Z				; ConvertIFMT
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -4						; size = 4
_hostIFMT$ = 8						; size = 4
?ConvertIFMT@@YAII@Z PROC				; ConvertIFMT

; 97   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 98   :   uint32 result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 99   : 
; 100  :   //Convert MSVC file type flags to newlib format (fstat)
; 101  :   if(hostIFMT & _S_IFCHR)

	mov	eax, DWORD PTR _hostIFMT$[ebp]
	and	eax, 8192				; 00002000H
	je	SHORT $LN6@ConvertIFM

; 102  :   {
; 103  :     result |= NUON_IFCHR;

	mov	ecx, DWORD PTR _result$[ebp]
	or	ecx, 131072				; 00020000H
	mov	DWORD PTR _result$[ebp], ecx
$LN6@ConvertIFM:

; 104  :   }
; 105  :   if(hostIFMT & _S_IFIFO)

	mov	edx, DWORD PTR _hostIFMT$[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN5@ConvertIFM

; 106  :   {
; 107  :     result |= NUON_IFIFO;

	mov	eax, DWORD PTR _result$[ebp]
	or	eax, 65536				; 00010000H
	mov	DWORD PTR _result$[ebp], eax
$LN5@ConvertIFM:

; 108  :   }
; 109  :   if(hostIFMT & _S_IFREG)

	mov	ecx, DWORD PTR _hostIFMT$[ebp]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN4@ConvertIFM

; 110  :   {
; 111  :     result |= NUON_IFREG;

	mov	edx, DWORD PTR _result$[ebp]
	or	edx, 1048576				; 00100000H
	mov	DWORD PTR _result$[ebp], edx
$LN4@ConvertIFM:

; 112  :   }
; 113  :   if(hostIFMT & _S_IREAD)

	mov	eax, DWORD PTR _hostIFMT$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN3@ConvertIFM

; 114  :   {
; 115  :     result |= NUON_S_IRUSR;

	mov	ecx, DWORD PTR _result$[ebp]
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _result$[ebp], ecx
$LN3@ConvertIFM:

; 116  :   }
; 117  :   if(hostIFMT & _S_IWRITE)

	mov	edx, DWORD PTR _hostIFMT$[ebp]
	and	edx, 128				; 00000080H
	je	SHORT $LN2@ConvertIFM

; 118  :   {
; 119  :     result |= NUON_S_IWUSR;

	mov	eax, DWORD PTR _result$[ebp]
	or	eax, 512				; 00000200H
	mov	DWORD PTR _result$[ebp], eax
$LN2@ConvertIFM:

; 120  :   }
; 121  :   if(hostIFMT & _S_IEXEC)

	mov	ecx, DWORD PTR _hostIFMT$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN1@ConvertIFM

; 122  :   {
; 123  :     result |= NUON_S_IXUSR;

	mov	edx, DWORD PTR _result$[ebp]
	or	edx, 256				; 00000100H
	mov	DWORD PTR _result$[ebp], edx
$LN1@ConvertIFM:

; 124  :   }
; 125  : 
; 126  :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertIFMT@@YAII@Z ENDP				; ConvertIFMT
_TEXT	ENDS
PUBLIC	?IsValidFileDescriptor@@YA_NH@Z			; IsValidFileDescriptor
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
_fd$ = 8						; size = 4
?IsValidFileDescriptor@@YA_NH@Z PROC			; IsValidFileDescriptor

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 131  :   uint32 i;
; 132  : 
; 133  :   if(fd < 3)

	cmp	DWORD PTR _fd$[ebp], 3
	jge	SHORT $LN5@IsValidFil

; 134  :   {
; 135  :     for(i = fd - 3; i < 16; i++)

	mov	eax, DWORD PTR _fd$[ebp]
	sub	eax, 3
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@IsValidFil
$LN3@IsValidFil:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@IsValidFil:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jae	SHORT $LN5@IsValidFil

; 136  :     {
; 137  :       if(fileDescriptors[i] == fd)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?fileDescriptors@@3PAHA[edx*4]
	cmp	eax, DWORD PTR _fd$[ebp]
	jne	SHORT $LN1@IsValidFil

; 138  :       {
; 139  :         return true;

	mov	al, 1
	jmp	SHORT $LN6@IsValidFil
$LN1@IsValidFil:

; 140  :       }
; 141  :     }

	jmp	SHORT $LN3@IsValidFil
$LN5@IsValidFil:

; 142  :   }
; 143  : 
; 144  :   return false;  

	xor	al, al
$LN6@IsValidFil:

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsValidFileDescriptor@@YA_NH@Z ENDP			; IsValidFileDescriptor
_TEXT	ENDS
PUBLIC	?ConvertSeparatorCharacters@@YAXPAD@Z		; ConvertSeparatorCharacters
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pathname$ = 8						; size = 4
?ConvertSeparatorCharacters@@YAXPAD@Z PROC		; ConvertSeparatorCharacters

; 148  : {

	push	ebp
	mov	ebp, esp

; 149  :   if(pathname)

	cmp	DWORD PTR _pathname$[ebp], 0
	je	SHORT $LN5@ConvertSep
$LN3@ConvertSep:

; 150  :   {
; 151  :     while(*pathname)

	mov	eax, DWORD PTR _pathname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@ConvertSep

; 152  :     {
; 153  :       if(*pathname == '/')

	mov	edx, DWORD PTR _pathname$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN1@ConvertSep

; 154  :       {
; 155  :         *pathname = '\\';

	mov	ecx, DWORD PTR _pathname$[ebp]
	mov	BYTE PTR [ecx], 92			; 0000005cH
$LN1@ConvertSep:

; 156  :       }
; 157  :       
; 158  :       pathname++;

	mov	edx, DWORD PTR _pathname$[ebp]
	add	edx, 1
	mov	DWORD PTR _pathname$[ebp], edx

; 159  :     }

	jmp	SHORT $LN3@ConvertSep
$LN5@ConvertSep:

; 160  :   }
; 161  : }

	pop	ebp
	ret	0
?ConvertSeparatorCharacters@@YAXPAD@Z ENDP		; ConvertSeparatorCharacters
_TEXT	ENDS
PUBLIC	?GetDVDBase@NuonEnvironment@@QAEPADXZ		; NuonEnvironment::GetDVDBase
PUBLIC	?FileOpen@@YAXPAVMPE@@@Z			; FileOpen
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	__errno:PROC
EXTRN	_open:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strncmp:PROC
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_fd$ = -560						; size = 4
_index$ = -556						; size = 4
_pPath$ = -552						; size = 4
_name$ = -544						; size = 513
_pErr$ = -20						; size = 4
_errnum$ = -16						; size = 4
_mode$ = -12						; size = 4
_access$ = -8						; size = 4
_path$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileOpen@@YAXPAVMPE@@@Z PROC				; FileOpen

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	push	edi
	lea	edi, DWORD PTR [ebp-560]
	mov	ecx, 140				; 0000008cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 165  :   uint32 path = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _path$[ebp], ecx

; 166  :   uint32 access = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _access$[ebp], eax

; 167  :   uint32 mode = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mode$[ebp], edx

; 168  :   uint32 errnum = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _errnum$[ebp], ecx

; 169  :   uint32 *pErr;
; 170  :   FILE *fp;
; 171  :   char name[513];
; 172  : 
; 173  :   char *pPath = (char *)nuonEnv->GetPointerToMemory(mpe,path);

	push	1
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pPath$[ebp], eax

; 174  :   int index, fd;
; 175  : 
; 176  :   if((index = FindFileDescriptorIndex(-1)) >= 0)

	push	-1
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	$Error$77934

; 177  :   {
; 178  :     access = ConvertFlags(access);

	mov	ecx, DWORD PTR _access$[ebp]
	push	ecx
	call	?ConvertFlags@@YAII@Z			; ConvertFlags
	add	esp, 4
	mov	DWORD PTR _access$[ebp], eax

; 179  :     //Windows will set the read-only flag after opening the file if _S_IWRITE is not specified within the mode bits
; 180  :     mode = ConvertFlags(mode) | _S_IWRITE;

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	call	?ConvertFlags@@YAII@Z			; ConvertFlags
	add	esp, 4
	or	eax, 128				; 00000080H
	mov	DWORD PTR _mode$[ebp], eax

; 181  : 
; 182  :     if(!strncmp("/iso9660/",pPath,9))

	push	9
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	push	OFFSET $SG77929
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FileOpen

; 183  :     {
; 184  :       pPath += 9;

	mov	ecx, DWORD PTR _pPath$[ebp]
	add	ecx, 9
	mov	DWORD PTR _pPath$[ebp], ecx
	jmp	SHORT $LN5@FileOpen
$LN6@FileOpen:

; 185  :     }
; 186  :     else if(!strncmp("/udf/",pPath,5))

	push	5
	mov	edx, DWORD PTR _pPath$[ebp]
	push	edx
	push	OFFSET $SG77932
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@FileOpen

; 187  :     {
; 188  :       pPath += 5;

	mov	eax, DWORD PTR _pPath$[ebp]
	add	eax, 5
	mov	DWORD PTR _pPath$[ebp], eax
$LN5@FileOpen:

; 189  :     }
; 190  : 
; 191  :     strcpy(name,nuonEnv->GetDVDBase());

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetDVDBase@NuonEnvironment@@QAEPADXZ	; NuonEnvironment::GetDVDBase
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 192  :     strcat(name,pPath);

	mov	edx, DWORD PTR _pPath$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 193  :     
; 194  :     ConvertSeparatorCharacters(name);

	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	?ConvertSeparatorCharacters@@YAXPAD@Z	; ConvertSeparatorCharacters
	add	esp, 4

; 195  : 
; 196  :     fd = open(name,access,mode);

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _access$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fd$[ebp], eax

; 197  :     if(fd == -1)

	cmp	DWORD PTR _fd$[ebp], -1
	jne	SHORT $LN3@FileOpen
	jmp	SHORT $Error$77934

; 198  :     {
; 199  :       goto Error;

	jmp	SHORT $Error$77934
$LN3@FileOpen:

; 200  :     }
; 201  :     fileDescriptors[index] = fd;

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _fd$[ebp]
	mov	DWORD PTR ?fileDescriptors@@3PAHA[edx*4], eax

; 202  :     mpe->regs[0] = fd;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _fd$[ebp]
	mov	DWORD PTR [ecx], edx

; 203  :   }
; 204  :   else

	jmp	SHORT $LN8@FileOpen
$Error$77934:

; 205  :   {
; 206  : Error:
; 207  :     pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,errnum);

	push	1
	mov	eax, DWORD PTR _errnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 208  :     *pErr = errno;

	call	__errno
	mov	edx, DWORD PTR _pErr$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 209  :     SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 210  :     mpe->regs[0] = -1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], -1
$LN8@FileOpen:

; 211  :   }
; 212  :   
; 213  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@FileOpen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 560				; 00000230H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@FileOpen:
	DD	1
	DD	$LN11@FileOpen
$LN11@FileOpen:
	DD	-544					; fffffde0H
	DD	513					; 00000201H
	DD	$LN10@FileOpen
$LN10@FileOpen:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?FileOpen@@YAXPAVMPE@@@Z ENDP				; FileOpen
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\nuonenvironment.h
_TEXT	ENDS
;	COMDAT ?GetDVDBase@NuonEnvironment@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDVDBase@NuonEnvironment@@QAEPADXZ PROC		; NuonEnvironment::GetDVDBase, COMDAT
; _this$ = ecx

; 58   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 59   :     return dvdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]

; 60   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDVDBase@NuonEnvironment@@QAEPADXZ ENDP		; NuonEnvironment::GetDVDBase
_TEXT	ENDS
PUBLIC	?FileClose@@YAXPAVMPE@@@Z			; FileClose
EXTRN	_close:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\file.cpp
_TEXT	SEGMENT
_index$ = -20						; size = 4
_result$ = -16						; size = 4
_pErr$ = -12						; size = 4
_errnum$ = -8						; size = 4
_fd$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileClose@@YAXPAVMPE@@@Z PROC				; FileClose

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 217  :   int32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 218  :   uint32 errnum = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _errnum$[ebp], eax

; 219  :   uint32 *pErr;
; 220  : 
; 221  :   int result, index;
; 222  : 
; 223  :   if((index = FindFileDescriptorIndex(fd)) >= 0)

	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $Error$77948

; 224  :   {
; 225  :     result = close(fileDescriptors[index]);

	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR ?fileDescriptors@@3PAHA[edx*4]
	push	eax
	call	_close
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax

; 226  :     if(result == -1)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN3@FileClose
	jmp	SHORT $Error$77948

; 227  :     {
; 228  :       goto Error;

	jmp	SHORT $Error$77948
$LN3@FileClose:

; 229  :     }
; 230  : 
; 231  :     fileDescriptors[index] = -1;

	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR ?fileDescriptors@@3PAHA[ecx*4], -1

; 232  :     mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0

; 233  :   }
; 234  :   else

	jmp	SHORT $LN5@FileClose
$Error$77948:

; 235  :   {
; 236  : Error:
; 237  :     pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe, errnum);

	push	1
	mov	eax, DWORD PTR _errnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 238  :     *pErr = EINVAL;

	mov	edx, DWORD PTR _pErr$[ebp]
	mov	DWORD PTR [edx], 22			; 00000016H

; 239  :     SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 240  :     mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1
$LN5@FileClose:

; 241  :   }
; 242  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileClose@@YAXPAVMPE@@@Z ENDP				; FileClose
_TEXT	ENDS
PUBLIC	?FileRead@@YAXPAVMPE@@@Z			; FileRead
EXTRN	_read:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pBuf$ = -32						; size = 4
_result$ = -28						; size = 4
_index$ = -24						; size = 4
_pErr$ = -20						; size = 4
_errnum$ = -16						; size = 4
_len$ = -12						; size = 4
_buf$ = -8						; size = 4
_fd$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileRead@@YAXPAVMPE@@@Z PROC				; FileRead

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 246  :   uint32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 247  :   uint32 buf = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _buf$[ebp], eax

; 248  :   uint32 len = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _len$[ebp], edx

; 249  :   uint32 errnum = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _errnum$[ebp], ecx

; 250  :   uint32 *pErr;
; 251  :   int32 index, result;
; 252  :   void *pBuf;
; 253  : 
; 254  :   if((index = FindFileDescriptorIndex(fd)) >= 0)

	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $Error$77965

; 255  :   {
; 256  :     pBuf = nuonEnv->GetPointerToMemory(mpe, buf);

	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBuf$[ebp], eax

; 257  :     result = read(fileDescriptors[index], pBuf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR ?fileDescriptors@@3PAHA[ecx*4]
	push	edx
	call	_read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 258  :     if(result == -1)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN3@FileRead
	jmp	SHORT $Error$77965

; 259  :     {
; 260  :       goto Error;

	jmp	SHORT $Error$77965
$LN3@FileRead:

; 261  :     }
; 262  :       mpe->regs[0] = result;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], ecx

; 263  :   }
; 264  :   else

	jmp	SHORT $LN5@FileRead
$Error$77965:

; 265  :   {
; 266  : Error:
; 267  :     pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe, errnum);

	push	1
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 268  :     *pErr = EBADF;

	mov	ecx, DWORD PTR _pErr$[ebp]
	mov	DWORD PTR [ecx], 9

; 269  :     SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 270  :     mpe->regs[0] = -1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1
$LN5@FileRead:

; 271  :   }
; 272  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileRead@@YAXPAVMPE@@@Z ENDP				; FileRead
_TEXT	ENDS
PUBLIC	?FileWrite@@YAXPAVMPE@@@Z			; FileWrite
EXTRN	_write:PROC
EXTRN	?WriteFile@NuonEnvironment@@QAEXPAVMPE@@III@Z:PROC ; NuonEnvironment::WriteFile
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pBuf$ = -32						; size = 4
_result$ = -28						; size = 4
_index$ = -24						; size = 4
_pErr$ = -20						; size = 4
_errnum$ = -16						; size = 4
_len$ = -12						; size = 4
_buf$ = -8						; size = 4
_fd$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileWrite@@YAXPAVMPE@@@Z PROC				; FileWrite

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 276  :   uint32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 277  :   uint32 buf = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _buf$[ebp], eax

; 278  :   uint32 len = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _len$[ebp], edx

; 279  :   uint32 errnum = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _errnum$[ebp], ecx

; 280  :   uint32 *pErr;
; 281  :   int32 index, result;
; 282  : 
; 283  :   char *pBuf = (char *)nuonEnv->GetPointerToMemory(mpe,buf);

	push	1
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBuf$[ebp], eax

; 284  : 
; 285  :   if((fd == NUON_FD_STDOUT) || (fd == NUON_FD_STDERR))

	cmp	DWORD PTR _fd$[ebp], 1
	je	SHORT $LN6@FileWrite
	cmp	DWORD PTR _fd$[ebp], 2
	jne	SHORT $LN7@FileWrite
$LN6@FileWrite:

; 286  :   {
; 287  :     nuonEnv->WriteFile(mpe,fd,buf,len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?WriteFile@NuonEnvironment@@QAEXPAVMPE@@III@Z ; NuonEnvironment::WriteFile

; 288  :     mpe->regs[0] = len;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], eax

; 289  :   }
; 290  :   else

	jmp	SHORT $LN8@FileWrite
$LN7@FileWrite:

; 291  :   {
; 292  :     if((index = FindFileDescriptorIndex(fd)) >= 0)

	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $Error$77986

; 293  :     {
; 294  :       result = write(fileDescriptors[index], pBuf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR ?fileDescriptors@@3PAHA[ecx*4]
	push	edx
	call	_write
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 295  :       if(result == -1)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN3@FileWrite
	jmp	SHORT $Error$77986

; 296  :       {
; 297  :         goto Error;

	jmp	SHORT $Error$77986
$LN3@FileWrite:

; 298  :       }
; 299  :       mpe->regs[0] = result;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], ecx

; 300  :     }
; 301  :     else

	jmp	SHORT $LN8@FileWrite
$Error$77986:

; 302  :     {
; 303  :   Error:
; 304  :       pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe, errnum);

	push	1
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 305  :       *pErr = errno;

	call	__errno
	mov	ecx, DWORD PTR _pErr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 306  :       SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 307  :       mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1
$LN8@FileWrite:

; 308  :     }
; 309  :   }
; 310  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileWrite@@YAXPAVMPE@@@Z ENDP				; FileWrite
_TEXT	ENDS
PUBLIC	?FileIoctl@@YAXPAVMPE@@@Z			; FileIoctl
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_errnum$ = -16						; size = 4
_argp$ = -12						; size = 4
_request$ = -8						; size = 4
_fd$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileIoctl@@YAXPAVMPE@@@Z PROC				; FileIoctl

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 314  :   uint32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 315  :   uint32 request = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _request$[ebp], eax

; 316  :   uint32 argp = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _argp$[ebp], edx

; 317  :   uint32 errnum = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _errnum$[ebp], ecx

; 318  : 
; 319  :   MessageBox(NULL,"This handler does nothing","Unimplemented File Call: FileIoctl",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG77997
	push	OFFSET $SG77998
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 320  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileIoctl@@YAXPAVMPE@@@Z ENDP				; FileIoctl
_TEXT	ENDS
PUBLIC	?FileFstat@@YAXPAVMPE@@@Z			; FileFstat
EXTRN	__fstat32:PROC
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv72 = -76						; size = 4
_pBuf$ = -72						; size = 4
_errnum$ = -68						; size = 4
_buf$ = -64						; size = 4
_fd$ = -60						; size = 4
_st$ = -52						; size = 36
_pErr$ = -12						; size = 4
_result$ = -8						; size = 4
_index$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileFstat@@YAXPAVMPE@@@Z PROC				; FileFstat

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 324  :   int32 index, result;
; 325  :   uint32 *pErr;
; 326  :   struct _stat32 st;
; 327  :   uint32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 328  :   uint32 buf = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _buf$[ebp], eax

; 329  :   uint32 errnum = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _errnum$[ebp], edx

; 330  : 
; 331  :   nuon_stat *pBuf = (nuon_stat *)nuonEnv->GetPointerToMemory(mpe,buf);

	push	1
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBuf$[ebp], eax

; 332  : 
; 333  :   if(fd <= NUON_FD_STDERR)

	cmp	DWORD PTR _fd$[ebp], 2
	ja	$LN11@FileFstat

; 334  :   {
; 335  :     mpe->regs[0] = -1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1

; 336  : 
; 337  :     switch(fd)

	mov	eax, DWORD PTR _fd$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN8@FileFstat
	cmp	DWORD PTR tv72[ebp], 1
	je	SHORT $LN7@FileFstat
	cmp	DWORD PTR tv72[ebp], 2
	je	$LN6@FileFstat
	jmp	$LN9@FileFstat
$LN8@FileFstat:

; 338  :     {
; 339  :       case NUON_FD_STDIN:
; 340  :         pBuf->st_mode = NUON_IFCHR | NUON_S_IRUSR | NUON_S_IRGRP | NUON_S_IROTH;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [ecx+8], 132164		; 00020444H

; 341  :         pBuf->st_dev = pBuf->st_rdev = NUON_FD_STDIN;

	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [edx+18], 0
	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [eax], 0

; 342  :         SwapWordBytes((uint16 *)&pBuf->st_dev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 343  :         SwapWordBytes((uint16 *)&pBuf->st_rdev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 18					; 00000012H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 344  :         SwapScalarBytes((uint32 *)&pBuf->st_mode);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 8
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 345  :         mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0

; 346  :         break;

	jmp	$LN9@FileFstat
$LN7@FileFstat:

; 347  :       case NUON_FD_STDOUT:
; 348  :         pBuf->st_mode = NUON_IFCHR | NUON_S_IWUSR | NUON_S_IWGRP | NUON_S_IWOTH;

	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [edx+8], 131618		; 00020222H

; 349  :         pBuf->st_dev = pBuf->st_rdev = NUON_FD_STDOUT;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [eax+18], 1
	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [ecx], 1

; 350  :         SwapWordBytes((uint16 *)&pBuf->st_dev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 351  :         SwapWordBytes((uint16 *)&pBuf->st_rdev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 18					; 00000012H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 352  :         SwapScalarBytes((uint32 *)&pBuf->st_mode);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 8
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 353  :         mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0

; 354  :         break;

	jmp	SHORT $LN9@FileFstat
$LN6@FileFstat:

; 355  :       case NUON_FD_STDERR:
; 356  :         pBuf->st_mode = NUON_IFCHR | NUON_S_IWUSR | NUON_S_IWGRP | NUON_S_IWOTH;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [eax+8], 131618		; 00020222H

; 357  :         pBuf->st_dev = pBuf->st_rdev = NUON_FD_STDERR;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [ecx+18], 2
	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	WORD PTR [edx], 2

; 358  :         SwapWordBytes((uint16 *)&pBuf->st_dev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 359  :         SwapWordBytes((uint16 *)&pBuf->st_rdev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 18					; 00000012H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 360  :         SwapScalarBytes((uint32 *)&pBuf->st_mode);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 8
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 361  :         mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@FileFstat:

; 362  :         break;
; 363  :     }
; 364  :   }
; 365  :   else

	jmp	$LN12@FileFstat
$LN11@FileFstat:

; 366  :   {
; 367  :     if((index = FindFileDescriptorIndex(fd)) >= 0)

	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	$Error$78031

; 368  :     {
; 369  :       result = _fstat32(fd, &st);

	lea	edx, DWORD PTR _st$[ebp]
	push	edx
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	__fstat32
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 370  :       if(result == -1)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN3@FileFstat
	jmp	$Error$78031

; 371  :       {
; 372  :         goto Error;

	jmp	$Error$78031
$LN3@FileFstat:

; 373  :       }
; 374  :       
; 375  :       pBuf->st_atime = st.st_atime;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	edx, DWORD PTR _st$[ebp+24]
	mov	DWORD PTR [ecx+24], edx

; 376  :       pBuf->st_blksize = 1;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [eax+48], 1

; 377  :       pBuf->st_blocks = st.st_size;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	edx, DWORD PTR _st$[ebp+20]
	mov	DWORD PTR [ecx+52], edx

; 378  :       pBuf->st_ctime = st.st_ctime;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	ecx, DWORD PTR _st$[ebp+32]
	mov	DWORD PTR [eax+40], ecx

; 379  :       pBuf->st_dev = st.st_dev;

	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	ax, WORD PTR _st$[ebp]
	mov	WORD PTR [edx], ax

; 380  :       pBuf->st_gid = st.st_gid;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	dx, WORD PTR _st$[ebp+12]
	mov	WORD PTR [ecx+16], dx

; 381  :       pBuf->st_ino = st.st_ino;

	movzx	eax, WORD PTR _st$[ebp+4]
	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 382  :       pBuf->st_mode = ConvertIFMT(st.st_mode);

	movzx	edx, WORD PTR _st$[ebp+6]
	push	edx
	call	?ConvertIFMT@@YAII@Z			; ConvertIFMT
	add	esp, 4
	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 383  :       pBuf->st_mtime = st.st_mtime;

	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	eax, DWORD PTR _st$[ebp+28]
	mov	DWORD PTR [edx+32], eax

; 384  :       pBuf->st_nlink = st.st_nlink;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	dx, WORD PTR _st$[ebp+8]
	mov	WORD PTR [ecx+12], dx

; 385  :       pBuf->st_rdev = st.st_rdev;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	cx, WORD PTR _st$[ebp+16]
	mov	WORD PTR [eax+18], cx

; 386  :       pBuf->st_size = st.st_size;

	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	eax, DWORD PTR _st$[ebp+20]
	mov	DWORD PTR [edx+20], eax

; 387  :       pBuf->st_uid = st.st_uid;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	dx, WORD PTR _st$[ebp+10]
	mov	WORD PTR [ecx+14], dx

; 388  : 
; 389  :       SwapWordBytes((uint16 *)&pBuf->st_dev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 390  :       SwapWordBytes((uint16 *)&pBuf->st_nlink);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 12					; 0000000cH
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 391  :       SwapWordBytes((uint16 *)&pBuf->st_gid);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 16					; 00000010H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 392  :       SwapWordBytes((uint16 *)&pBuf->st_uid);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 14					; 0000000eH
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 393  :       SwapWordBytes((uint16 *)&pBuf->st_rdev);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 18					; 00000012H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 394  :       SwapScalarBytes((uint32 *)&pBuf->st_atime);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 24					; 00000018H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 395  :       SwapScalarBytes((uint32 *)&pBuf->st_ctime);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 40					; 00000028H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 396  :       SwapScalarBytes((uint32 *)&pBuf->st_mtime);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 32					; 00000020H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 397  :       SwapScalarBytes((uint32 *)&pBuf->st_ino);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 4
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 398  :       SwapScalarBytes((uint32 *)&pBuf->st_mode);      

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 8
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 399  :       SwapScalarBytes((uint32 *)&pBuf->st_size);

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 20					; 00000014H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 400  :       SwapScalarBytes((uint32 *)&pBuf->st_blocks);      

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 52					; 00000034H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 401  :       SwapScalarBytes((uint32 *)&pBuf->st_blksize);      

	mov	ecx, DWORD PTR _pBuf$[ebp]
	add	ecx, 48					; 00000030H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 402  :       mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0

; 403  :     }
; 404  :     else

	jmp	SHORT $LN12@FileFstat
$Error$78031:

; 405  :     {
; 406  :   Error:
; 407  :       pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe, errnum);

	push	1
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 408  :       *pErr = errno;

	call	__errno
	mov	ecx, DWORD PTR _pErr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 409  :       SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 410  :       mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1
$LN12@FileFstat:

; 411  :     }
; 412  :   }
; 413  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@FileFstat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@FileFstat:
	DD	1
	DD	$LN15@FileFstat
$LN15@FileFstat:
	DD	-52					; ffffffccH
	DD	36					; 00000024H
	DD	$LN14@FileFstat
$LN14@FileFstat:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
?FileFstat@@YAXPAVMPE@@@Z ENDP				; FileFstat
_TEXT	ENDS
PUBLIC	?FileStat@@YAXPAVMPE@@@Z			; FileStat
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pPath$ = -16						; size = 4
_errnum$ = -12						; size = 4
_buf$ = -8						; size = 4
_path$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileStat@@YAXPAVMPE@@@Z PROC				; FileStat

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 417  :   uint32 path = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _path$[ebp], ecx

; 418  :   uint32 buf = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _buf$[ebp], eax

; 419  :   uint32 errnum = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _errnum$[ebp], edx

; 420  : 
; 421  :   char *pPath = (char *)nuonEnv->GetPointerToMemory(mpe,path);

	push	1
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pPath$[ebp], eax

; 422  : 
; 423  :   MessageBox(NULL,pPath,"Unimplemented File Call: FileStat",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78056
	mov	edx, DWORD PTR _pPath$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 424  : 
; 425  :   mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0

; 426  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileStat@@YAXPAVMPE@@@Z ENDP				; FileStat
_TEXT	ENDS
PUBLIC	?FileIsatty@@YAXPAVMPE@@@Z			; FileIsatty
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pPath$ = -12						; size = 4
_errnum$ = -8						; size = 4
_path$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileIsatty@@YAXPAVMPE@@@Z PROC				; FileIsatty

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 430  :   uint32 path = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _path$[ebp], ecx

; 431  :   uint32 errnum = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _errnum$[ebp], eax

; 432  : 
; 433  :   char *pPath = (char *)nuonEnv->GetPointerToMemory(mpe,path);

	push	1
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pPath$[ebp], eax

; 434  : 
; 435  :   MessageBox(NULL,pPath,"Unimplemented File Call: FileIsatty",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78064
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 436  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileIsatty@@YAXPAVMPE@@@Z ENDP				; FileIsatty
_TEXT	ENDS
PUBLIC	?FileLseek@@YAXPAVMPE@@@Z			; FileLseek
EXTRN	_lseek:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pErr$ = -28						; size = 4
_result$ = -24						; size = 4
_index$ = -20						; size = 4
_errnum$ = -16						; size = 4
_whence$ = -12						; size = 4
_offset$ = -8						; size = 4
_fd$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileLseek@@YAXPAVMPE@@@Z PROC				; FileLseek

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 440  :   uint32 fd = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _fd$[ebp], ecx

; 441  :   uint32 offset = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _offset$[ebp], eax

; 442  :   uint32 whence = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _whence$[ebp], edx

; 443  :   uint32 errnum = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _errnum$[ebp], ecx

; 444  :   int32 index, result;
; 445  :   uint32 *pErr;
; 446  : 
; 447  :   if((index = FindFileDescriptorIndex(fd)) >= 0)

	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	?FindFileDescriptorIndex@@YAHH@Z	; FindFileDescriptorIndex
	add	esp, 4
	mov	DWORD PTR _index$[ebp], eax
	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $Error$78077

; 448  :   {
; 449  :     result = lseek(fd, offset, whence);

	mov	eax, DWORD PTR _whence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	call	_lseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 450  :     if(result == -1)

	cmp	DWORD PTR _result$[ebp], -1
	jne	SHORT $LN3@FileLseek
	jmp	SHORT $Error$78077

; 451  :     {
; 452  :       goto Error;

	jmp	SHORT $Error$78077
$LN3@FileLseek:

; 453  :     }
; 454  :     mpe->regs[0] = result;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], ecx

; 455  :   }
; 456  :   else

	jmp	SHORT $LN5@FileLseek
$Error$78077:

; 457  :   {
; 458  : Error:
; 459  :     pErr = (uint32 *)nuonEnv->GetPointerToMemory(mpe, errnum);

	push	1
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pErr$[ebp], eax

; 460  :     *pErr = EBADF;

	mov	ecx, DWORD PTR _pErr$[ebp]
	mov	DWORD PTR [ecx], 9

; 461  :     SwapScalarBytes(pErr);

	mov	ecx, DWORD PTR _pErr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 462  :     mpe->regs[0] = -1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1
$LN5@FileLseek:

; 463  :   }
; 464  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileLseek@@YAXPAVMPE@@@Z ENDP				; FileLseek
_TEXT	ENDS
PUBLIC	?FileLink@@YAXPAVMPE@@@Z			; FileLink
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_errnum$ = -12						; size = 4
_newpath$ = -8						; size = 4
_oldpath$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileLink@@YAXPAVMPE@@@Z PROC				; FileLink

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 468  :   uint32 oldpath = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldpath$[ebp], ecx

; 469  :   uint32 newpath = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _newpath$[ebp], eax

; 470  :   uint32 errnum = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _errnum$[ebp], edx

; 471  : 
; 472  :   MessageBox(NULL,"This handler does nothing","Unimplemented File Call: FileLink",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78087
	push	OFFSET $SG78088
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileLink@@YAXPAVMPE@@@Z ENDP				; FileLink
_TEXT	ENDS
PUBLIC	?FileLstat@@YAXPAVMPE@@@Z			; FileLstat
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pFilename$ = -16					; size = 4
_errnum$ = -12						; size = 4
_buf$ = -8						; size = 4
_file_name$ = -4					; size = 4
_mpe$ = 8						; size = 4
?FileLstat@@YAXPAVMPE@@@Z PROC				; FileLstat

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 477  :   uint32 file_name = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _file_name$[ebp], ecx

; 478  :   uint32 buf = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _buf$[ebp], eax

; 479  :   uint32 errnum = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _errnum$[ebp], edx

; 480  : 
; 481  :   char *pFilename = (char *)nuonEnv->GetPointerToMemory(mpe,file_name);

	push	1
	mov	eax, DWORD PTR _file_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pFilename$[ebp], eax

; 482  : 
; 483  :   MessageBox(NULL,pFilename,"Unimplemented File Call: FileLstat",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78097
	mov	edx, DWORD PTR _pFilename$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 484  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileLstat@@YAXPAVMPE@@@Z ENDP				; FileLstat
_TEXT	ENDS
PUBLIC	?FileUnlink@@YAXPAVMPE@@@Z			; FileUnlink
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pPathname$ = -12					; size = 4
_errnum$ = -8						; size = 4
_pathname$ = -4						; size = 4
_mpe$ = 8						; size = 4
?FileUnlink@@YAXPAVMPE@@@Z PROC				; FileUnlink

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 488  :   uint32 pathname = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pathname$[ebp], ecx

; 489  :   uint32 errnum = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _errnum$[ebp], eax

; 490  : 
; 491  :   char *pPathname = (char *)nuonEnv->GetPointerToMemory(mpe,pathname);

	push	1
	mov	ecx, DWORD PTR _pathname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pPathname$[ebp], eax

; 492  : 
; 493  :   MessageBox(NULL,pPathname,"Unimplemented File Call: FileUnlink",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78105
	mov	eax, DWORD PTR _pPathname$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 494  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileUnlink@@YAXPAVMPE@@@Z ENDP				; FileUnlink
_TEXT	ENDS
END
