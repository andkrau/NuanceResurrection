; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\ExecuteALU.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?Execute_ABS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ABS
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\executealu.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ABS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ABS

; 6    : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 7    :   int32 src1;
; 8    :   
; 9    :   mpe.cc &= ~(CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_ZERO | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 10   :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 11   :   if((src1) < 0)

	cmp	DWORD PTR _src1$[ebp], 0
	jge	SHORT $LN4@Execute_AB

; 12   :   {  
; 13   :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 14   :     if(src1 == 0x80000000UL)

	cmp	DWORD PTR _src1$[ebp], -2147483648	; 80000000H
	jne	SHORT $LN3@Execute_AB

; 15   :     {
; 16   :       //source was negative, result is negative (non-zero)
; 17   :       mpe.cc |= (CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 18   :       return;

	jmp	SHORT $LN5@Execute_AB
$LN3@Execute_AB:

; 19   :     }
; 20   :     mpe.regs[nuance.fields[FIELD_ALU_DEST]] = -src1;

	mov	edx, DWORD PTR _src1$[ebp]
	neg	edx
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 21   :     return;

	jmp	SHORT $LN5@Execute_AB

; 22   :   }
; 23   :   else

	jmp	SHORT $LN5@Execute_AB
$LN4@Execute_AB:

; 24   :   {
; 25   :     if(!src1)

	cmp	DWORD PTR _src1$[ebp], 0
	jne	SHORT $LN5@Execute_AB

; 26   :     {
; 27   :       //source wasnt negative, result is zero (non-negative)
; 28   :       mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_AB:

; 29   :     }
; 30   :     return;
; 31   :   }
; 32   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ABS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ABS
_TEXT	ENDS
PUBLIC	?Execute_BITSScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_BITSScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_BITSScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_BITSScalar

; 35   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 36   :   uint32 result;
; 37   : 
; 38   :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -10				; fffffff6H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 39   :   result = nuance.fields[FIELD_ALU_SRC1] & 
; 40   :     (entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]] >> (entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] & 0x1F));

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _entry$[ebp]
	mov	esi, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+edx*4]
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _nuance$[ebp]
	and	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _result$[ebp], eax

; 41   :   
; 42   :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 43   :   
; 44   :   if(!result)

	jne	SHORT $LN2@Execute_BI

; 45   :   {
; 46   :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 47   :     return;

	jmp	SHORT $LN3@Execute_BI

; 48   :   }
; 49   :   else

	jmp	SHORT $LN3@Execute_BI
$LN2@Execute_BI:

; 50   :   {
; 51   :     // negative = bit 31 of result
; 52   :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_BI:

; 53   :   }
; 54   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_BITSScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_BITSScalar
_TEXT	ENDS
PUBLIC	?Execute_BITSImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_BITSImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_BITSImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_BITSImmediate

; 56   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 57   :   uint32 result;
; 58   : 
; 59   :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -10				; fffffff6H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 60   :   result = nuance.fields[FIELD_ALU_SRC1] & 
; 61   :     (entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]] >> nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shr	eax, cl
	mov	ecx, DWORD PTR _nuance$[ebp]
	and	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _result$[ebp], eax

; 62   :   
; 63   :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 64   :   
; 65   :   if(!result)

	jne	SHORT $LN2@Execute_BI@2

; 66   :   {
; 67   :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 68   :     return;

	jmp	SHORT $LN3@Execute_BI@2

; 69   :   }
; 70   :   else

	jmp	SHORT $LN3@Execute_BI@2
$LN2@Execute_BI@2:

; 71   :   {
; 72   :     // negative = bit 31 of result
; 73   :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_BI@2:

; 74   :   }
; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_BITSImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_BITSImmediate
_TEXT	ENDS
PUBLIC	?Execute_BTST@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_BTST
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_BTST@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_BTST

; 77   : {

	push	ebp
	mov	ebp, esp

; 78   :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 79   :   if(!(nuance.fields[FIELD_ALU_SRC1] & entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]]))

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [edx+8]
	and	edx, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN2@Execute_BT

; 80   :   {
; 81   :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_BT:

; 82   :   }
; 83   : }

	pop	ebp
	ret	0
?Execute_BTST@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_BTST
_TEXT	ENDS
PUBLIC	?Execute_BUTT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_BUTT
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv216 = -52						; size = 8
tv203 = -44						; size = 8
tv177 = -36						; size = 8
_dest$ = -28						; size = 4
_src2$ = -24						; size = 8
_src1$ = -16						; size = 8
_sum$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_BUTT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_BUTT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   :   uint64 sum;
; 87   :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 88   :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 89   :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _dest$[ebp], ecx

; 90   : 
; 91   :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 92   : 
; 93   :   sum = src1 + src2;

	mov	edx, DWORD PTR _src1$[ebp]
	add	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	adc	eax, DWORD PTR _src2$[ebp+4]
	mov	DWORD PTR _sum$[ebp], edx
	mov	DWORD PTR _sum$[ebp+4], eax

; 94   :   mpe.regs[dest + 1] = (uint32)(src2 - src1);

	mov	ecx, DWORD PTR _src2$[ebp]
	sub	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	sbb	edx, DWORD PTR _src1$[ebp+4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4+4], ecx

; 95   : 
; 96   :   if(sum & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _sum$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _sum$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv177[ebp], eax
	mov	DWORD PTR tv177[ebp+4], ecx
	mov	edx, DWORD PTR tv177[ebp]
	or	edx, DWORD PTR tv177[ebp+4]
	je	SHORT $LN6@Execute_BU

; 97   :   {
; 98   :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_BU:

; 99   :   }
; 100  : 
; 101  :   if(((int32)(src1 ^ src2)) >= 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jl	SHORT $LN5@Execute_BU

; 102  :   {
; 103  :     if(((int32)(src1 ^ (sum & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _sum$[ebp]
	mov	eax, DWORD PTR _sum$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src1$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_BU

; 104  :     {
; 105  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_BU:

; 106  :     }
; 107  :   }
; 108  : 
; 109  :   if(sum & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _sum$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _sum$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv203[ebp], ecx
	mov	DWORD PTR tv203[ebp+4], edx
	mov	eax, DWORD PTR tv203[ebp]
	or	eax, DWORD PTR tv203[ebp+4]
	je	SHORT $LN3@Execute_BU

; 110  :   {
; 111  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_BU
$LN3@Execute_BU:

; 112  :   }
; 113  :   else if(!(sum & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _sum$[ebp]
	mov	edx, DWORD PTR _sum$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv216[ebp], ecx
	mov	DWORD PTR tv216[ebp+4], edx
	mov	eax, DWORD PTR tv216[ebp]
	or	eax, DWORD PTR tv216[ebp+4]
	jne	SHORT $LN2@Execute_BU

; 114  :   {
; 115  :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_BU:

; 116  :   }
; 117  : 
; 118  :   mpe.regs[dest] = (uint32)sum;

	mov	ecx, DWORD PTR _sum$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 119  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_BUTT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_BUTT
_TEXT	ENDS
PUBLIC	?Execute_COPY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_COPY
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_src$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_COPY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_COPY

; 121  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 122  :   uint32 src; 
; 123  : 
; 124  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 125  : 
; 126  :   src = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src$[ebp], ecx

; 127  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = src;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 128  : 
; 129  :   if(!src)

	cmp	DWORD PTR _src$[ebp], 0
	jne	SHORT $LN2@Execute_CO

; 130  :   {
; 131  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 132  :     return;

	jmp	SHORT $LN3@Execute_CO

; 133  :   }
; 134  :   else

	jmp	SHORT $LN3@Execute_CO
$LN2@Execute_CO:

; 135  :   {
; 136  :     // negative = bit 31 of result
; 137  :     mpe.cc |= ((src >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _src$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_CO:

; 138  :   }
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_COPY@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_COPY
_TEXT	ENDS
PUBLIC	?Execute_MSB@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_MSB
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_n$ = -8						; size = 4
_sigbits$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_MSB@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_MSB

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 142  :   uint32 sigbits;
; 143  :   int32 n;
; 144  : 
; 145  :   mpe.cc &= ~CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 146  :   n = mpe.regs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _n$[ebp], eax

; 147  : 
; 148  :   if((n == 0) || (n == -1))

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN3@Execute_MS
	cmp	DWORD PTR _n$[ebp], -1
	jne	SHORT $LN4@Execute_MS
$LN3@Execute_MS:

; 149  :   {
; 150  :     sigbits = 0;

	mov	DWORD PTR _sigbits$[ebp], 0

; 151  :   }
; 152  :   else

	jmp	$LN2@Execute_MS
$LN4@Execute_MS:

; 153  :   {
; 154  :     //n = n if positive, n = ~n if negative
; 155  :     n = (n ^ (n >> 31));

	mov	ecx, DWORD PTR _n$[ebp]
	sar	ecx, 31					; 0000001fH
	xor	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 156  : 
; 157  :     //fold n into itself to get a new value where all bits below the
; 158  :     //most significant one bit have also been set to one.
; 159  : 
; 160  :     n |= (n >> 1);

	mov	edx, DWORD PTR _n$[ebp]
	sar	edx, 1
	or	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 161  :     n |= (n >> 2);

	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 2
	or	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 162  :     n |= (n >> 4);

	mov	ecx, DWORD PTR _n$[ebp]
	sar	ecx, 4
	or	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 163  :     n |= (n >> 8);

	mov	edx, DWORD PTR _n$[ebp]
	sar	edx, 8
	or	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], edx

; 164  :     n |= (n >> 16);

	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 16					; 00000010H
	or	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 165  : 
; 166  :     //get the ones count
; 167  : 
; 168  :     n -= ((n >> 1) & 0x55555555);

	mov	ecx, DWORD PTR _n$[ebp]
	sar	ecx, 1
	and	ecx, 1431655765				; 55555555H
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _n$[ebp], edx

; 169  :     n = (((n >> 2) & 0x33333333) + (n & 0x33333333));

	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 2
	and	eax, 858993459				; 33333333H
	mov	ecx, DWORD PTR _n$[ebp]
	and	ecx, 858993459				; 33333333H
	add	eax, ecx
	mov	DWORD PTR _n$[ebp], eax

; 170  :     n = (((n >> 4) + n) & 0x0f0f0f0f);

	mov	edx, DWORD PTR _n$[ebp]
	sar	edx, 4
	add	edx, DWORD PTR _n$[ebp]
	and	edx, 252645135				; 0f0f0f0fH
	mov	DWORD PTR _n$[ebp], edx

; 171  :     n += (n >> 8);

	mov	eax, DWORD PTR _n$[ebp]
	sar	eax, 8
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 172  :     n += (n >> 16);

	mov	ecx, DWORD PTR _n$[ebp]
	sar	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 173  : 
; 174  :     //return the ones count... if n was orignally 0 or -1 then the ones count
; 175  :     //will be zero which is exactly what we want
; 176  :     sigbits = ((uint32)n) & 0x1FUL;

	mov	edx, DWORD PTR _n$[ebp]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _sigbits$[ebp], edx
$LN2@Execute_MS:

; 177  :   }
; 178  : 
; 179  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = sigbits;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _sigbits$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 180  : 
; 181  :   if(!sigbits)

	cmp	DWORD PTR _sigbits$[ebp], 0
	jne	SHORT $LN5@Execute_MS

; 182  :   {
; 183  :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_MS:

; 184  :   }
; 185  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_MSB@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_MSB
_TEXT	ENDS
PUBLIC	?Execute_SAT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SAT
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_n$ = -8						; size = 4
_mask$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SAT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 188  :   int32 mask = (0x01UL << nuance.fields[FIELD_ALU_SRC2]) - 1;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+12]
	shl	edx, cl
	sub	edx, 1
	mov	DWORD PTR _mask$[ebp], edx

; 189  :   int32 n = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _n$[ebp], ecx

; 190  :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _dest$[ebp], eax

; 191  : 
; 192  :   //initial mask is largest negative number using 'bits' bits, minus one to get
; 193  :   //largest positive signed number using 'bits' bits
; 194  : 
; 195  :   //NOTE: the bits parameter will be one less than the number of bits desired
; 196  :   //so you do not have to subtract 1 from the shift amount to get the correct
; 197  :   //mask
; 198  : 
; 199  :   if(n > mask)

	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR _mask$[ebp]
	jle	SHORT $LN5@Execute_SA

; 200  :   {
; 201  :     mpe.regs[dest] = mask;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _mask$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 202  :   }
; 203  :   else

	jmp	SHORT $LN4@Execute_SA
$LN5@Execute_SA:

; 204  :   {
; 205  :     //inverting mask gives smallest negative number possible using 'bits' bits
; 206  :     mask = ~mask;

	mov	edx, DWORD PTR _mask$[ebp]
	not	edx
	mov	DWORD PTR _mask$[ebp], edx

; 207  : 
; 208  :     if(n < mask)

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _mask$[ebp]
	jge	SHORT $LN3@Execute_SA

; 209  :     {
; 210  :       mpe.regs[dest] = mask;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _mask$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 211  :     }
; 212  :     else

	jmp	SHORT $LN4@Execute_SA
$LN3@Execute_SA:

; 213  :     {
; 214  :       mpe.regs[dest] = n;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN4@Execute_SA:

; 215  :     }
; 216  :   }
; 217  : 
; 218  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -10				; fffffff6H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 219  : 
; 220  :   if(mpe.regs[dest] == 0)

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN1@Execute_SA

; 221  :   {
; 222  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 223  :     return;

	jmp	SHORT $LN6@Execute_SA
$LN1@Execute_SA:

; 224  :   }
; 225  : 
; 226  :   // negative = bit 31 of result
; 227  :   mpe.cc |= ((mpe.regs[dest] >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN6@Execute_SA:

; 228  :   return;
; 229  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SAT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SAT
_TEXT	ENDS
PUBLIC	?Execute_AS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_AS
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_AS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_AS

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 232  :   uint32 src1, src2, result;
; 233  : 
; 234  :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] & 0x3FUL;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _src1$[ebp], ecx

; 235  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 236  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE | CC_ALU_CARRY);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -16				; fffffff0H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 237  : 
; 238  :   if(src1 & 0x20)

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, 32					; 00000020H
	je	$LN7@Execute_AS

; 239  :   {
; 240  :     //shift left
; 241  :     src1 = 64UL - src1;

	mov	edx, 64					; 00000040H
	sub	edx, DWORD PTR _src1$[ebp]
	mov	DWORD PTR _src1$[ebp], edx

; 242  :     //carry = bit 31 of source
; 243  :     mpe.cc |= ((src2 >> 30) & CC_ALU_CARRY);

	mov	eax, DWORD PTR _src2$[ebp]
	shr	eax, 30					; 0000001eH
	and	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax

; 244  :     result = src2 << src1;

	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	shl	eax, cl
	mov	DWORD PTR _result$[ebp], eax

; 245  :     //The Nuon allows left shifts by 32, effectively clearing out the
; 246  :     //source register.  The x86 shift instructions performs shifts with
; 247  :     //counts adjusted to the range [0,31] so the result of a shift by 32
; 248  :     //is treated as a shift by zero.  The result of the shift needs to be
; 249  :     //monitored for this special case, and when it happens, the destination
; 250  :     //register should be forced to zero.
; 251  : 
; 252  :     if((result == 0) || (src1 == 32))

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@Execute_AS
	cmp	DWORD PTR _src1$[ebp], 32		; 00000020H
	jne	SHORT $LN6@Execute_AS
$LN5@Execute_AS:

; 253  :     {
; 254  :       mpe.regs[nuance.fields[FIELD_ALU_DEST]] = 0;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 255  :       mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 256  :       return;

	jmp	$LN8@Execute_AS

; 257  :     }
; 258  :     else

	jmp	SHORT $LN4@Execute_AS
$LN6@Execute_AS:

; 259  :     {
; 260  :       // negative = bit 31 of result
; 261  :       mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 262  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 263  :       return;

	jmp	SHORT $LN8@Execute_AS
$LN4@Execute_AS:

; 264  :     }
; 265  :   }
; 266  :   else

	jmp	SHORT $LN8@Execute_AS
$LN7@Execute_AS:

; 267  :   {
; 268  :     //shift right
; 269  :     result = ((int32)src2) >> src1;

	mov	edx, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	sar	edx, cl
	mov	DWORD PTR _result$[ebp], edx

; 270  :     mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 271  :     // carry = bit 0 of source
; 272  :     mpe.cc |= ((src2 << 1) & CC_ALU_CARRY);    

	mov	ecx, DWORD PTR _src2$[ebp]
	shl	ecx, 1
	and	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 273  :     if(result == 0)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_AS

; 274  :     {
; 275  :       mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 276  :       return;

	jmp	SHORT $LN8@Execute_AS

; 277  :     }
; 278  :     else

	jmp	SHORT $LN8@Execute_AS
$LN2@Execute_AS:

; 279  :     {
; 280  :       // negative = bit 31 of result
; 281  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _result$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN8@Execute_AS:

; 282  :     }
; 283  :   }
; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_AS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_AS
_TEXT	ENDS
PUBLIC	?Execute_ASL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ASL
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_src2$ = -8						; size = 4
_result$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ASL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ASL

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 287  :   uint32 result, src2;
; 288  : 
; 289  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 290  : 
; 291  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src2$[ebp], ecx

; 292  :   
; 293  :   // carry = bit 31 of source
; 294  :   mpe.cc |= ((src2 >> 30) & CC_ALU_CARRY);

	mov	edx, DWORD PTR _src2$[ebp]
	shr	edx, 30					; 0000001eH
	and	edx, 2
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 295  :   result = src2 << nuance.fields[FIELD_ALU_SRC1];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	shl	eax, cl
	mov	DWORD PTR _result$[ebp], eax

; 296  : 
; 297  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 298  :   
; 299  :   //The Nuon allows left shifts by 32, effectively clearing out the
; 300  :   //source register.  The x86 shift instructions performs shifts with
; 301  :   //counts adjusted to the range [0,31] so the result of a shift by 32
; 302  :   //is treated as a shift by zero.  The result of the shift needs to be
; 303  :   //monitored for this special case, and when it happens, the destination
; 304  :   //register should be forced to zero.
; 305  : 
; 306  :   if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_AS@2

; 307  :   {
; 308  :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 309  :     return;

	jmp	SHORT $LN3@Execute_AS@2

; 310  :   }
; 311  :   else

	jmp	SHORT $LN3@Execute_AS@2
$LN2@Execute_AS@2:

; 312  :   {
; 313  :     // negative = bit 31 of result
; 314  :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_AS@2:

; 315  :   }
; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ASL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ASL
_TEXT	ENDS
PUBLIC	?Execute_ASR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ASR
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -8						; size = 4
_src2$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ASR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ASR

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 319  :   uint32 src2, result;
; 320  : 
; 321  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 322  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src2$[ebp], ecx

; 323  : 
; 324  :   result = ((int32)src2) >> nuance.fields[FIELD_ALU_SRC1];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sar	eax, cl
	mov	DWORD PTR _result$[ebp], eax

; 325  :   // carry = bit 0 of source
; 326  :   mpe.cc |= ((src2 << 1) & CC_ALU_CARRY);

	mov	ecx, DWORD PTR _src2$[ebp]
	shl	ecx, 1
	and	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 327  :   
; 328  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 329  : 
; 330  :   if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_AS@3

; 331  :   {
; 332  :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 333  :     return;

	jmp	SHORT $LN3@Execute_AS@3

; 334  :   }
; 335  :   else

	jmp	SHORT $LN3@Execute_AS@3
$LN2@Execute_AS@3:

; 336  :   {
; 337  :     // negative = bit 31 of result
; 338  :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_AS@3:

; 339  :   }
; 340  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ASR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ASR
_TEXT	ENDS
PUBLIC	?Execute_LS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LS
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LS

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 343  :   uint32 src1, src2, result;
; 344  : 
; 345  :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] & 0x3FUL;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _src1$[ebp], ecx

; 346  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 347  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE | CC_ALU_CARRY);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -16				; fffffff0H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 348  : 
; 349  :   if(src1 & 0x20)

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, 32					; 00000020H
	je	$LN7@Execute_LS

; 350  :   {
; 351  :     //shift left
; 352  :     src1 = 64UL - src1;

	mov	edx, 64					; 00000040H
	sub	edx, DWORD PTR _src1$[ebp]
	mov	DWORD PTR _src1$[ebp], edx

; 353  :     //carry = bit 31 of source
; 354  :     mpe.cc |= ((src2 >> 30) & CC_ALU_CARRY);

	mov	eax, DWORD PTR _src2$[ebp]
	shr	eax, 30					; 0000001eH
	and	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax

; 355  :     result = src2 << src1;

	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	shl	eax, cl
	mov	DWORD PTR _result$[ebp], eax

; 356  :     //The Nuon allows left shifts by 32, effectively clearing out the
; 357  :     //source register.  The x86 shift instructions performs shifts with
; 358  :     //counts adjusted to the range [0,31] so the result of a shift by 32
; 359  :     //is treated as a shift by zero.  The result of the shift needs to be
; 360  :     //monitored for this special case, and when it happens, the destination
; 361  :     //register should be forced to zero.
; 362  : 
; 363  :     if(!result || (src1 == 32))

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@Execute_LS
	cmp	DWORD PTR _src1$[ebp], 32		; 00000020H
	jne	SHORT $LN6@Execute_LS
$LN5@Execute_LS:

; 364  :     {
; 365  :       mpe.regs[nuance.fields[FIELD_ALU_DEST]] = 0;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 366  :       mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 367  :       return;

	jmp	$LN8@Execute_LS

; 368  :     }
; 369  :     else

	jmp	SHORT $LN4@Execute_LS
$LN6@Execute_LS:

; 370  :     {
; 371  :       // negative = bit 31 of result
; 372  :       mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 373  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 374  :       return;

	jmp	SHORT $LN8@Execute_LS
$LN4@Execute_LS:

; 375  :     }
; 376  :   }
; 377  :   else

	jmp	SHORT $LN8@Execute_LS
$LN7@Execute_LS:

; 378  :   {
; 379  :     //shift right
; 380  :     result = src2 >> src1;

	mov	edx, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	shr	edx, cl
	mov	DWORD PTR _result$[ebp], edx

; 381  :     mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 382  :     // carry = bit 0 of source
; 383  :     mpe.cc |= ((src2 << 1) & CC_ALU_CARRY);    

	mov	ecx, DWORD PTR _src2$[ebp]
	shl	ecx, 1
	and	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 384  :     if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_LS

; 385  :     {
; 386  :       mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 387  :       return;

	jmp	SHORT $LN8@Execute_LS

; 388  :     }
; 389  :     else

	jmp	SHORT $LN8@Execute_LS
$LN2@Execute_LS:

; 390  :     {
; 391  :       // negative = bit 31 of result
; 392  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _result$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN8@Execute_LS:

; 393  :     }
; 394  :   }
; 395  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LS@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LS
_TEXT	ENDS
PUBLIC	?Execute_LSR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_LSR
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -8						; size = 4
_src2$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_LSR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_LSR

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 398  :   uint32 src2, result;
; 399  : 
; 400  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src2$[ebp], ecx

; 401  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 402  :   result = src2 >> nuance.fields[FIELD_ALU_SRC1];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	shr	eax, cl
	mov	DWORD PTR _result$[ebp], eax

; 403  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 404  :   // carry = bit 0 of source
; 405  :   mpe.cc |= ((src2 << 1) & CC_ALU_CARRY);

	mov	edx, DWORD PTR _src2$[ebp]
	shl	edx, 1
	and	edx, 2
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 406  : 
; 407  :   if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_LS@2

; 408  :   {
; 409  :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 410  :     return;

	jmp	SHORT $LN3@Execute_LS@2

; 411  :   }
; 412  :   else

	jmp	SHORT $LN3@Execute_LS@2
$LN2@Execute_LS@2:

; 413  :   {
; 414  :     // negative = bit 31 of result
; 415  :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_LS@2:

; 416  :   }
; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_LSR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_LSR
_TEXT	ENDS
PUBLIC	?Execute_ROT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ROT
EXTRN	__lrotr:PROC
EXTRN	__lrotl:PROC
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ROT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ROT

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 420  :   uint32 src1, src2, result;
; 421  : 
; 422  :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] & 0x3FUL;

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _src1$[ebp], ecx

; 423  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 424  : 
; 425  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -14				; fffffff2H
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 426  : 
; 427  :   if(src1 & 0x20)

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN6@Execute_RO

; 428  :   {
; 429  :     //shift left
; 430  :     src1 = 64UL - src1;

	mov	edx, 64					; 00000040H
	sub	edx, DWORD PTR _src1$[ebp]
	mov	DWORD PTR _src1$[ebp], edx

; 431  :     result = _lrotl(src2,src1);

	mov	eax, DWORD PTR _src1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 432  :     mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 433  : 
; 434  :     if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN5@Execute_RO

; 435  :     {
; 436  :       mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 437  :       return;

	jmp	SHORT $LN7@Execute_RO

; 438  :     }
; 439  :     else

	jmp	SHORT $LN4@Execute_RO
$LN5@Execute_RO:

; 440  :     {
; 441  :       // negative = bit 31 of result
; 442  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax

; 443  :       return;

	jmp	SHORT $LN7@Execute_RO
$LN4@Execute_RO:

; 444  :     }
; 445  :   }
; 446  :   else

	jmp	SHORT $LN7@Execute_RO
$LN6@Execute_RO:

; 447  :   {
; 448  :     result = _lrotr(src2,src1);

	mov	eax, DWORD PTR _src1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 449  :     mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 450  : 
; 451  :     if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_RO

; 452  :     {
; 453  :       mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 454  :       return;

	jmp	SHORT $LN7@Execute_RO

; 455  :     }
; 456  :     else

	jmp	SHORT $LN7@Execute_RO
$LN2@Execute_RO:

; 457  :     {
; 458  :       // negative = bit 31 of result
; 459  :       mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN7@Execute_RO:

; 460  :       return;
; 461  :     }
; 462  :   }
; 463  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ROT@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ROT
_TEXT	ENDS
PUBLIC	?Execute_ROL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ROL
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -8						; size = 4
_src2$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ROL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ROL

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 466  :   uint32 src2, result;
; 467  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src2$[ebp], ecx

; 468  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -14				; fffffff2H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 469  : 
; 470  :   result = _lrotl(src2, nuance.fields[FIELD_ALU_SRC1]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	call	__lrotl
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 471  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 472  : 
; 473  :   if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_RO@2

; 474  :   {
; 475  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 476  :     return;

	jmp	SHORT $LN3@Execute_RO@2

; 477  :   }
; 478  :   else

	jmp	SHORT $LN3@Execute_RO@2
$LN2@Execute_RO@2:

; 479  :   {
; 480  :     // negative = bit 31 of result
; 481  :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_RO@2:

; 482  :     return;
; 483  :   }
; 484  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ROL@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ROL
_TEXT	ENDS
PUBLIC	?Execute_ROR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ROR
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -8						; size = 4
_src2$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ROR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ROR

; 486  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 487  :   uint32 src2, result;
; 488  : 
; 489  :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src2$[ebp], ecx

; 490  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_OVERFLOW | CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -14				; fffffff2H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 491  : 
; 492  :   result = _lrotr(src2, nuance.fields[FIELD_ALU_SRC1]);

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 493  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 494  : 
; 495  :   if(!result)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN2@Execute_RO@3

; 496  :   {
; 497  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 498  :     return;

	jmp	SHORT $LN3@Execute_RO@3

; 499  :   }
; 500  :   else

	jmp	SHORT $LN3@Execute_RO@3
$LN2@Execute_RO@3:

; 501  :   {
; 502  :     // negative = bit 31 of result
; 503  :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_RO@3:

; 504  :     return;
; 505  :   }
; 506  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ROR@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ROR
_TEXT	ENDS
PUBLIC	?Execute_ADD_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADD_P
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADD_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADD_P

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 509  :   uint32 src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 510  :   uint32 src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 511  :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 512  : 
; 513  :   mpe.regs[dest + 0] =
; 514  :     (entry.pScalarRegs[src2 + 0] & 0xFFFF0000) +
; 515  :     (entry.pScalarRegs[src1 + 0] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 516  : 
; 517  :   mpe.regs[dest + 1] =
; 518  :     (entry.pScalarRegs[src2 + 1] & 0xFFFF0000) +
; 519  :     (entry.pScalarRegs[src1 + 1] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 520  : 
; 521  :   mpe.regs[dest + 2] =
; 522  :     (entry.pScalarRegs[src2 + 2] & 0xFFFF0000) +
; 523  :     (entry.pScalarRegs[src1 + 2] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+8]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADD_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADD_P
_TEXT	ENDS
PUBLIC	?Execute_SUB_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUB_P
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUB_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUB_P

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 527  :   uint32 src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 528  :   uint32 src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 529  :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 530  : 
; 531  :   mpe.regs[dest + 0] =
; 532  :     (entry.pScalarRegs[src2 + 0] & 0xFFFF0000) -
; 533  :     (entry.pScalarRegs[src1 + 0] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 534  : 
; 535  :   mpe.regs[dest + 1] =
; 536  :     (entry.pScalarRegs[src2 + 1] & 0xFFFF0000) -
; 537  :     (entry.pScalarRegs[src1 + 1] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 538  : 
; 539  :   mpe.regs[dest + 2] =
; 540  :     (entry.pScalarRegs[src2 + 2] & 0xFFFF0000) -
; 541  :     (entry.pScalarRegs[src1 + 2] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+8]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 542  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUB_P@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUB_P
_TEXT	ENDS
PUBLIC	?Execute_ADD_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADD_SV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADD_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADD_SV

; 544  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 545  :   uint32 src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 546  :   uint32 src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 547  :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 548  : 
; 549  :   mpe.regs[dest + 0] =
; 550  :     (entry.pScalarRegs[src2 + 0] & 0xFFFF0000) +
; 551  :     (entry.pScalarRegs[src1 + 0] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 552  : 
; 553  :   mpe.regs[dest + 1] =
; 554  :     (entry.pScalarRegs[src2 + 1] & 0xFFFF0000) +
; 555  :     (entry.pScalarRegs[src1 + 1] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 556  : 
; 557  :   mpe.regs[dest + 2] =
; 558  :     (entry.pScalarRegs[src2 + 2] & 0xFFFF0000) +
; 559  :     (entry.pScalarRegs[src1 + 2] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+8]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 560  : 
; 561  :   mpe.regs[dest + 3] =
; 562  :     (entry.pScalarRegs[src2 + 3] & 0xFFFF0000) +
; 563  :     (entry.pScalarRegs[src1 + 3] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+12]
	and	edx, -65536				; ffff0000H
	add	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 564  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADD_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADD_SV
_TEXT	ENDS
PUBLIC	?Execute_SUB_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUB_SV
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUB_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUB_SV

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 567  :   uint32 src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 568  :   uint32 src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 569  :   uint32 dest = nuance.fields[FIELD_ALU_DEST];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _dest$[ebp], edx

; 570  : 
; 571  :   mpe.regs[dest + 0] =
; 572  :     (entry.pScalarRegs[src2 + 0] & 0xFFFF0000) -
; 573  :     (entry.pScalarRegs[src1 + 0] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 574  : 
; 575  :   mpe.regs[dest + 1] =
; 576  :     (entry.pScalarRegs[src2 + 1] & 0xFFFF0000) -
; 577  :     (entry.pScalarRegs[src1 + 1] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 578  : 
; 579  :   mpe.regs[dest + 2] =
; 580  :     (entry.pScalarRegs[src2 + 2] & 0xFFFF0000) -
; 581  :     (entry.pScalarRegs[src1 + 2] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+8]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+8]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 582  : 
; 583  :   mpe.regs[dest + 3] =
; 584  :     (entry.pScalarRegs[src2 + 3] & 0xFFFF0000) -
; 585  :     (entry.pScalarRegs[src1 + 3] & 0xFFFF0000);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+12]
	and	eax, -65536				; ffff0000H
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+12]
	and	edx, -65536				; ffff0000H
	sub	eax, edx
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 586  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUB_SV@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUB_SV
_TEXT	ENDS
PUBLIC	?Execute_ADDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv197 = -48						; size = 8
tv184 = -40						; size = 8
tv158 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDImmediate

; 588  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 589  :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 590  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 591  :   uint64 result;
; 592  : 
; 593  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 594  : 
; 595  :   result = src1 + src2;

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 596  : 
; 597  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv158[ebp], edx
	mov	DWORD PTR tv158[ebp+4], eax
	mov	ecx, DWORD PTR tv158[ebp]
	or	ecx, DWORD PTR tv158[ebp+4]
	je	SHORT $LN6@Execute_AD

; 598  :   {
; 599  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_AD:

; 600  :   }
; 601  : 
; 602  :   if(((int32)(src1 ^ src2)) >= 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jl	SHORT $LN5@Execute_AD

; 603  :   {
; 604  :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	xor	ecx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src1$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_AD

; 605  :     {
; 606  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_AD:

; 607  :     }
; 608  :   }
; 609  : 
; 610  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv184[ebp], eax
	mov	DWORD PTR tv184[ebp+4], ecx
	mov	edx, DWORD PTR tv184[ebp]
	or	edx, DWORD PTR tv184[ebp+4]
	je	SHORT $LN3@Execute_AD

; 611  :   {
; 612  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_AD
$LN3@Execute_AD:

; 613  :   }
; 614  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv197[ebp], eax
	mov	DWORD PTR tv197[ebp+4], ecx
	mov	edx, DWORD PTR tv197[ebp]
	or	edx, DWORD PTR tv197[ebp+4]
	jne	SHORT $LN2@Execute_AD

; 615  :   {
; 616  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_AD:

; 617  :   }
; 618  : 
; 619  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 620  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDImmediate
_TEXT	ENDS
PUBLIC	?Execute_ADDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv200 = -48						; size = 8
tv187 = -40						; size = 8
tv163 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDScalar

; 622  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 623  :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 624  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 625  :   uint64 result;
; 626  : 
; 627  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 628  : 
; 629  :   result = src1 + src2;

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 630  : 
; 631  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv163[ebp], edx
	mov	DWORD PTR tv163[ebp+4], eax
	mov	ecx, DWORD PTR tv163[ebp]
	or	ecx, DWORD PTR tv163[ebp+4]
	je	SHORT $LN6@Execute_AD@2

; 632  :   {
; 633  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_AD@2:

; 634  :   }
; 635  : 
; 636  :   if(((int32)(src1 ^ src2)) >= 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jl	SHORT $LN5@Execute_AD@2

; 637  :   {
; 638  :     if(((int32)(src1 ^ result)) < 0)

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src1$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_AD@2

; 639  :     {
; 640  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_AD@2:

; 641  :     }
; 642  :   }
; 643  : 
; 644  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv187[ebp], eax
	mov	DWORD PTR tv187[ebp+4], ecx
	mov	edx, DWORD PTR tv187[ebp]
	or	edx, DWORD PTR tv187[ebp+4]
	je	SHORT $LN3@Execute_AD@2

; 645  :   {
; 646  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_AD@2
$LN3@Execute_AD@2:

; 647  :   }
; 648  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv200[ebp], eax
	mov	DWORD PTR tv200[ebp+4], ecx
	mov	edx, DWORD PTR tv200[ebp]
	or	edx, DWORD PTR tv200[ebp+4]
	jne	SHORT $LN2@Execute_AD@2

; 649  :   {
; 650  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_AD@2:

; 651  :   }
; 652  : 
; 653  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 654  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDScalar
_TEXT	ENDS
PUBLIC	?Execute_ADDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv210 = -48						; size = 8
tv197 = -40						; size = 8
tv173 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDScalarShiftRightImmediate

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 657  :   uint64 src1 = (((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 658  :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 659  :   uint64 src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 660  :   uint64 result;
; 661  : 
; 662  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 663  : 
; 664  :   result = src1 + src2;

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 665  : 
; 666  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv173[ebp], edx
	mov	DWORD PTR tv173[ebp+4], eax
	mov	ecx, DWORD PTR tv173[ebp]
	or	ecx, DWORD PTR tv173[ebp+4]
	je	SHORT $LN6@Execute_AD@3

; 667  :   {
; 668  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_AD@3:

; 669  :   }
; 670  : 
; 671  :   if(((int32)(src1 ^ src2)) >= 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jl	SHORT $LN5@Execute_AD@3

; 672  :   {
; 673  :     if(((int32)(src1 ^ result)) < 0)

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src1$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_AD@3

; 674  :     {
; 675  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_AD@3:

; 676  :     }
; 677  :   }
; 678  : 
; 679  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv197[ebp], eax
	mov	DWORD PTR tv197[ebp+4], ecx
	mov	edx, DWORD PTR tv197[ebp]
	or	edx, DWORD PTR tv197[ebp+4]
	je	SHORT $LN3@Execute_AD@3

; 680  :   {
; 681  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_AD@3
$LN3@Execute_AD@3:

; 682  :   }
; 683  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv210[ebp], eax
	mov	DWORD PTR tv210[ebp+4], ecx
	mov	edx, DWORD PTR tv210[ebp]
	or	edx, DWORD PTR tv210[ebp+4]
	jne	SHORT $LN2@Execute_AD@3

; 684  :   {
; 685  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_AD@3:

; 686  :   }
; 687  : 
; 688  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 689  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_ADDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv209 = -48						; size = 8
tv196 = -40						; size = 8
tv170 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDScalarShiftLeftImmediate

; 691  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 692  :   uint64 src1 = (uint64)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] <<
; 693  :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 694  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 695  :   uint64 result;
; 696  : 
; 697  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 698  : 
; 699  :   result = src1 + src2;

	mov	edx, DWORD PTR _src1$[ebp]
	add	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	adc	eax, DWORD PTR _src2$[ebp+4]
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 700  : 
; 701  :   if(result & (uint64)0x0000000100000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 1
	mov	DWORD PTR tv170[ebp], ecx
	mov	DWORD PTR tv170[ebp+4], edx
	mov	eax, DWORD PTR tv170[ebp]
	or	eax, DWORD PTR tv170[ebp+4]
	je	SHORT $LN6@Execute_AD@4

; 702  :   {
; 703  :     mpe.cc |= CC_ALU_CARRY;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 2
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN6@Execute_AD@4:

; 704  :   }
; 705  : 
; 706  :   if(((int32)(src1 ^ src2)) >= 0)

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp+4]
	xor	edx, DWORD PTR _src2$[ebp+4]
	test	ecx, ecx
	jl	SHORT $LN5@Execute_AD@4

; 707  :   {
; 708  :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	xor	eax, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src1$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_AD@4

; 709  :     {
; 710  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 4
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN5@Execute_AD@4:

; 711  :     }
; 712  :   }
; 713  : 
; 714  :   if(result & (uint64)0x0000000080000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv196[ebp], edx
	mov	DWORD PTR tv196[ebp+4], eax
	mov	ecx, DWORD PTR tv196[ebp]
	or	ecx, DWORD PTR tv196[ebp+4]
	je	SHORT $LN3@Execute_AD@4

; 715  :   {
; 716  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	SHORT $LN2@Execute_AD@4
$LN3@Execute_AD@4:

; 717  :   }
; 718  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv209[ebp], edx
	mov	DWORD PTR tv209[ebp+4], eax
	mov	ecx, DWORD PTR tv209[ebp]
	or	ecx, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN2@Execute_AD@4

; 719  :   {
; 720  :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN2@Execute_AD@4:

; 721  :   }
; 722  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 723  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv194 = -48						; size = 8
tv181 = -40						; size = 8
tv157 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBImmediate

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 726  :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 727  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 728  :   uint64 result;
; 729  : 
; 730  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 731  : 
; 732  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 733  : 
; 734  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv157[ebp], edx
	mov	DWORD PTR tv157[ebp+4], eax
	mov	ecx, DWORD PTR tv157[ebp]
	or	ecx, DWORD PTR tv157[ebp+4]
	je	SHORT $LN6@Execute_SU

; 735  :   {
; 736  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_SU:

; 737  :   }
; 738  : 
; 739  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU

; 740  :   {
; 741  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU

; 742  :     {
; 743  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_SU:

; 744  :     }
; 745  :   }
; 746  : 
; 747  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv181[ebp], eax
	mov	DWORD PTR tv181[ebp+4], ecx
	mov	edx, DWORD PTR tv181[ebp]
	or	edx, DWORD PTR tv181[ebp+4]
	je	SHORT $LN3@Execute_SU

; 748  :   {
; 749  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_SU
$LN3@Execute_SU:

; 750  :   }
; 751  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv194[ebp], eax
	mov	DWORD PTR tv194[ebp+4], ecx
	mov	edx, DWORD PTR tv194[ebp]
	or	edx, DWORD PTR tv194[ebp+4]
	jne	SHORT $LN2@Execute_SU

; 752  :   {
; 753  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_SU:

; 754  :   }
; 755  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 756  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBImmediateReverse
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv194 = -48						; size = 8
tv181 = -40						; size = 8
tv157 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBImmediateReverse

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 759  :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 760  :   uint64 src2 = (uint64)nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 761  :   uint64 result;
; 762  : 
; 763  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 764  : 
; 765  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 766  : 
; 767  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv157[ebp], edx
	mov	DWORD PTR tv157[ebp+4], eax
	mov	ecx, DWORD PTR tv157[ebp]
	or	ecx, DWORD PTR tv157[ebp+4]
	je	SHORT $LN6@Execute_SU@2

; 768  :   {
; 769  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_SU@2:

; 770  :   }
; 771  : 
; 772  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@2

; 773  :   {
; 774  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU@2

; 775  :     {
; 776  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_SU@2:

; 777  :     }
; 778  :   }
; 779  : 
; 780  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv181[ebp], eax
	mov	DWORD PTR tv181[ebp+4], ecx
	mov	edx, DWORD PTR tv181[ebp]
	or	edx, DWORD PTR tv181[ebp+4]
	je	SHORT $LN3@Execute_SU@2

; 781  :   {
; 782  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_SU@2
$LN3@Execute_SU@2:

; 783  :   }
; 784  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv194[ebp], eax
	mov	DWORD PTR tv194[ebp+4], ecx
	mov	edx, DWORD PTR tv194[ebp]
	or	edx, DWORD PTR tv194[ebp+4]
	jne	SHORT $LN2@Execute_SU@2

; 785  :   {
; 786  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_SU@2:

; 787  :   }
; 788  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 789  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBImmediateReverse
_TEXT	ENDS
PUBLIC	?Execute_SUBScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv200 = -48						; size = 8
tv187 = -40						; size = 8
tv163 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBScalar

; 791  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 792  :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 793  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 794  :   uint64 result;
; 795  : 
; 796  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 797  : 
; 798  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 799  : 
; 800  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv163[ebp], edx
	mov	DWORD PTR tv163[ebp+4], eax
	mov	ecx, DWORD PTR tv163[ebp]
	or	ecx, DWORD PTR tv163[ebp+4]
	je	SHORT $LN6@Execute_SU@3

; 801  :   {
; 802  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_SU@3:

; 803  :   }
; 804  : 
; 805  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@3

; 806  :   {
; 807  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU@3

; 808  :     {
; 809  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_SU@3:

; 810  :     }
; 811  :   }
; 812  : 
; 813  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv187[ebp], eax
	mov	DWORD PTR tv187[ebp+4], ecx
	mov	edx, DWORD PTR tv187[ebp]
	or	edx, DWORD PTR tv187[ebp+4]
	je	SHORT $LN3@Execute_SU@3

; 814  :   {
; 815  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_SU@3
$LN3@Execute_SU@3:

; 816  :   }
; 817  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv200[ebp], eax
	mov	DWORD PTR tv200[ebp+4], ecx
	mov	edx, DWORD PTR tv200[ebp]
	or	edx, DWORD PTR tv200[ebp+4]
	jne	SHORT $LN2@Execute_SU@3

; 818  :   {
; 819  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_SU@3:

; 820  :   }
; 821  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 822  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBScalar
_TEXT	ENDS
PUBLIC	?Execute_SUBScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv210 = -48						; size = 8
tv197 = -40						; size = 8
tv173 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBScalarShiftRightImmediate

; 825  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 826  :   uint64 src1 = (uint64)(((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 827  :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 828  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 829  :   uint64 result;
; 830  : 
; 831  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 832  : 
; 833  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 834  : 
; 835  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv173[ebp], edx
	mov	DWORD PTR tv173[ebp+4], eax
	mov	ecx, DWORD PTR tv173[ebp]
	or	ecx, DWORD PTR tv173[ebp+4]
	je	SHORT $LN6@Execute_SU@4

; 836  :   {
; 837  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_SU@4:

; 838  :   }
; 839  : 
; 840  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@4

; 841  :   {
; 842  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU@4

; 843  :     {
; 844  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_SU@4:

; 845  :     }
; 846  :   }
; 847  : 
; 848  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv197[ebp], eax
	mov	DWORD PTR tv197[ebp+4], ecx
	mov	edx, DWORD PTR tv197[ebp]
	or	edx, DWORD PTR tv197[ebp+4]
	je	SHORT $LN3@Execute_SU@4

; 849  :   {
; 850  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_SU@4
$LN3@Execute_SU@4:

; 851  :   }
; 852  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv210[ebp], eax
	mov	DWORD PTR tv210[ebp+4], ecx
	mov	edx, DWORD PTR tv210[ebp]
	or	edx, DWORD PTR tv210[ebp+4]
	jne	SHORT $LN2@Execute_SU@4

; 853  :   {
; 854  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_SU@4:

; 855  :   }
; 856  : 
; 857  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 858  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv206 = -48						; size = 8
tv193 = -40						; size = 8
tv169 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBScalarShiftLeftImmediate

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 861  :   uint64 src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] << nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 862  :   uint64 src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 863  :   uint64 result;
; 864  : 
; 865  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 866  : 
; 867  :   result = src2 - src1;

	mov	edx, DWORD PTR _src2$[ebp]
	sub	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR _src2$[ebp+4]
	sbb	eax, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 868  : 
; 869  :   if(result & (uint64)0x0000000100000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 1
	mov	DWORD PTR tv169[ebp], ecx
	mov	DWORD PTR tv169[ebp+4], edx
	mov	eax, DWORD PTR tv169[ebp]
	or	eax, DWORD PTR tv169[ebp+4]
	je	SHORT $LN6@Execute_SU@5

; 870  :   {
; 871  :     mpe.cc |= CC_ALU_CARRY;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 2
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN6@Execute_SU@5:

; 872  :   }
; 873  : 
; 874  :   if(((int32)(src1 ^ src2)) < 0)

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp+4]
	xor	edx, DWORD PTR _src2$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU@5

; 875  :   {
; 876  :     if(((int32)(src2 ^ result)) < 0)

	mov	eax, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	xor	ecx, DWORD PTR _result$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_SU@5

; 877  :     {
; 878  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 4
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN5@Execute_SU@5:

; 879  :     }
; 880  :   }
; 881  : 
; 882  :   if(result & (uint64)0x0000000080000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv193[ebp], edx
	mov	DWORD PTR tv193[ebp+4], eax
	mov	ecx, DWORD PTR tv193[ebp]
	or	ecx, DWORD PTR tv193[ebp+4]
	je	SHORT $LN3@Execute_SU@5

; 883  :   {
; 884  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	SHORT $LN2@Execute_SU@5
$LN3@Execute_SU@5:

; 885  :   }
; 886  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv206[ebp], edx
	mov	DWORD PTR tv206[ebp+4], eax
	mov	ecx, DWORD PTR tv206[ebp]
	or	ecx, DWORD PTR tv206[ebp+4]
	jne	SHORT $LN2@Execute_SU@5

; 887  :   {
; 888  :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN2@Execute_SU@5:

; 889  :   }
; 890  :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 891  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv189 = -48						; size = 8
tv176 = -40						; size = 8
tv152 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPImmediate

; 893  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 894  :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 895  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 896  :   uint64 result;
; 897  : 
; 898  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 899  : 
; 900  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 901  : 
; 902  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv152[ebp], edx
	mov	DWORD PTR tv152[ebp+4], eax
	mov	ecx, DWORD PTR tv152[ebp]
	or	ecx, DWORD PTR tv152[ebp+4]
	je	SHORT $LN6@Execute_CM

; 903  :   {
; 904  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_CM:

; 905  :   }
; 906  : 
; 907  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM

; 908  :   {
; 909  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM

; 910  :     {
; 911  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_CM:

; 912  :     }
; 913  :   }
; 914  : 
; 915  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv176[ebp], eax
	mov	DWORD PTR tv176[ebp+4], ecx
	mov	edx, DWORD PTR tv176[ebp]
	or	edx, DWORD PTR tv176[ebp+4]
	je	SHORT $LN3@Execute_CM

; 916  :   {
; 917  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN7@Execute_CM
$LN3@Execute_CM:

; 918  :   }
; 919  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv189[ebp], eax
	mov	DWORD PTR tv189[ebp+4], ecx
	mov	edx, DWORD PTR tv189[ebp]
	or	edx, DWORD PTR tv189[ebp+4]
	jne	SHORT $LN7@Execute_CM

; 920  :   {
; 921  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_CM:

; 922  :   }
; 923  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPImmediateReverse
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv189 = -48						; size = 8
tv176 = -40						; size = 8
tv152 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPImmediateReverse

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 926  :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 927  :   uint64 src2 = (uint64)nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 928  :   uint64 result;
; 929  : 
; 930  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 931  : 
; 932  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 933  : 
; 934  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv152[ebp], edx
	mov	DWORD PTR tv152[ebp+4], eax
	mov	ecx, DWORD PTR tv152[ebp]
	or	ecx, DWORD PTR tv152[ebp+4]
	je	SHORT $LN6@Execute_CM@2

; 935  :   {
; 936  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_CM@2:

; 937  :   }
; 938  : 
; 939  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@2

; 940  :   {
; 941  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM@2

; 942  :     {
; 943  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_CM@2:

; 944  :     }
; 945  :   }
; 946  : 
; 947  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv176[ebp], eax
	mov	DWORD PTR tv176[ebp+4], ecx
	mov	edx, DWORD PTR tv176[ebp]
	or	edx, DWORD PTR tv176[ebp+4]
	je	SHORT $LN3@Execute_CM@2

; 948  :   {
; 949  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN7@Execute_CM@2
$LN3@Execute_CM@2:

; 950  :   }
; 951  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv189[ebp], eax
	mov	DWORD PTR tv189[ebp+4], ecx
	mov	edx, DWORD PTR tv189[ebp]
	or	edx, DWORD PTR tv189[ebp+4]
	jne	SHORT $LN7@Execute_CM@2

; 952  :   {
; 953  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_CM@2:

; 954  :   }
; 955  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPImmediateReverse
_TEXT	ENDS
PUBLIC	?Execute_CMPScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv195 = -48						; size = 8
tv182 = -40						; size = 8
tv158 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPScalar

; 957  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 958  :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 959  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 960  :   uint64 result;
; 961  : 
; 962  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 963  : 
; 964  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 965  : 
; 966  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv158[ebp], edx
	mov	DWORD PTR tv158[ebp+4], eax
	mov	ecx, DWORD PTR tv158[ebp]
	or	ecx, DWORD PTR tv158[ebp+4]
	je	SHORT $LN6@Execute_CM@3

; 967  :   {
; 968  :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_CM@3:

; 969  :   }
; 970  : 
; 971  :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@3

; 972  :   {
; 973  :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM@3

; 974  :     {
; 975  :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_CM@3:

; 976  :     }
; 977  :   }
; 978  : 
; 979  :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv182[ebp], eax
	mov	DWORD PTR tv182[ebp+4], ecx
	mov	edx, DWORD PTR tv182[ebp]
	or	edx, DWORD PTR tv182[ebp+4]
	je	SHORT $LN3@Execute_CM@3

; 980  :   {
; 981  :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN7@Execute_CM@3
$LN3@Execute_CM@3:

; 982  :   }
; 983  :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv195[ebp], eax
	mov	DWORD PTR tv195[ebp+4], ecx
	mov	edx, DWORD PTR tv195[ebp]
	or	edx, DWORD PTR tv195[ebp+4]
	jne	SHORT $LN7@Execute_CM@3

; 984  :   {
; 985  :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_CM@3:

; 986  :   }
; 987  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPScalar
_TEXT	ENDS
PUBLIC	?Execute_CMPScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv205 = -48						; size = 8
tv192 = -40						; size = 8
tv168 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPScalarShiftRightImmediate

; 989  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 990  :   uint64 src1 = (uint64)(((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 991  :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 992  :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 993  :   uint64 result;
; 994  : 
; 995  :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 996  : 
; 997  :   result = src2 - src1;

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 998  : 
; 999  :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv168[ebp], edx
	mov	DWORD PTR tv168[ebp+4], eax
	mov	ecx, DWORD PTR tv168[ebp]
	or	ecx, DWORD PTR tv168[ebp+4]
	je	SHORT $LN6@Execute_CM@4

; 1000 :   {
; 1001 :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_CM@4:

; 1002 :   }
; 1003 : 
; 1004 :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@4

; 1005 :   {
; 1006 :     if(((int32)(src2 ^ result)) < 0)

	mov	ecx, DWORD PTR _src2$[ebp]
	xor	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _src2$[ebp+4]
	xor	edx, DWORD PTR _result$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM@4

; 1007 :     {
; 1008 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_CM@4:

; 1009 :     }
; 1010 :   }
; 1011 : 
; 1012 :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv192[ebp], eax
	mov	DWORD PTR tv192[ebp+4], ecx
	mov	edx, DWORD PTR tv192[ebp]
	or	edx, DWORD PTR tv192[ebp+4]
	je	SHORT $LN3@Execute_CM@4

; 1013 :   {
; 1014 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN7@Execute_CM@4
$LN3@Execute_CM@4:

; 1015 :   }
; 1016 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv205[ebp], eax
	mov	DWORD PTR tv205[ebp+4], ecx
	mov	edx, DWORD PTR tv205[ebp]
	or	edx, DWORD PTR tv205[ebp+4]
	jne	SHORT $LN7@Execute_CM@4

; 1017 :   {
; 1018 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_CM@4:

; 1019 :   }
; 1020 : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv201 = -48						; size = 8
tv188 = -40						; size = 8
tv164 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPScalarShiftLeftImmediate

; 1022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1023 :   uint64 src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] << nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 1024 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 1025 :   uint64 result;
; 1026 : 
; 1027 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1028 : 
; 1029 :   result = src2 - src1;

	mov	edx, DWORD PTR _src2$[ebp]
	sub	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR _src2$[ebp+4]
	sbb	eax, DWORD PTR _src1$[ebp+4]
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 1030 : 
; 1031 :   if(result & (uint64)0x0000000100000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, 0
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 1
	mov	DWORD PTR tv164[ebp], ecx
	mov	DWORD PTR tv164[ebp+4], edx
	mov	eax, DWORD PTR tv164[ebp]
	or	eax, DWORD PTR tv164[ebp+4]
	je	SHORT $LN6@Execute_CM@5

; 1032 :   {
; 1033 :     mpe.cc |= CC_ALU_CARRY;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 2
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN6@Execute_CM@5:

; 1034 :   }
; 1035 : 
; 1036 :   if(((int32)(src1 ^ src2)) < 0)

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp+4]
	xor	edx, DWORD PTR _src2$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM@5

; 1037 :   {
; 1038 :     if(((int32)(src2 ^ result)) < 0)

	mov	eax, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	xor	ecx, DWORD PTR _result$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_CM@5

; 1039 :     {
; 1040 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 4
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN5@Execute_CM@5:

; 1041 :     }
; 1042 :   }
; 1043 : 
; 1044 :   if(result & (uint64)0x0000000080000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv188[ebp], edx
	mov	DWORD PTR tv188[ebp+4], eax
	mov	ecx, DWORD PTR tv188[ebp]
	or	ecx, DWORD PTR tv188[ebp+4]
	je	SHORT $LN3@Execute_CM@5

; 1045 :   {
; 1046 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	SHORT $LN7@Execute_CM@5
$LN3@Execute_CM@5:

; 1047 :   }
; 1048 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	mov	DWORD PTR tv201[ebp], edx
	mov	DWORD PTR tv201[ebp+4], eax
	mov	ecx, DWORD PTR tv201[ebp]
	or	ecx, DWORD PTR tv201[ebp+4]
	jne	SHORT $LN7@Execute_CM@5

; 1049 :   {
; 1050 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN7@Execute_CM@5:

; 1051 :   }
; 1052 : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_ANDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDImmediate

; 1054 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1055 :   uint32 src1, src2, result;
; 1056 : 
; 1057 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1058 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1059 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1060 : 
; 1061 :   result = src1 & src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1062 : 
; 1063 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1064 : 
; 1065 :   if(result == 0)

	jne	SHORT $LN2@Execute_AN

; 1066 :   {
; 1067 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1068 :   }
; 1069 :   else

	jmp	SHORT $LN3@Execute_AN
$LN2@Execute_AN:

; 1070 :   {
; 1071 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_AN:

; 1072 :   }
; 1073 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDImmediate
_TEXT	ENDS
PUBLIC	?Execute_ANDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDScalar

; 1075 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1076 :   uint32 src1, src2, result;
; 1077 : 
; 1078 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1079 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1080 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1081 : 
; 1082 :   result = src1 & src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1083 : 
; 1084 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1085 : 
; 1086 :   if(result == 0)

	jne	SHORT $LN2@Execute_AN@2

; 1087 :   {
; 1088 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1089 :   }
; 1090 :   else

	jmp	SHORT $LN3@Execute_AN@2
$LN2@Execute_AN@2:

; 1091 :   {
; 1092 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_AN@2:

; 1093 :   }
; 1094 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDScalar
_TEXT	ENDS
PUBLIC	?Execute_ANDImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDImmediateShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDImmediateShiftScalar

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1097 :   uint32 src1, src2, dest;
; 1098 : 
; 1099 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1100 : 
; 1101 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1102 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1103 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1104 : 
; 1105 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_AN@3

; 1106 :   {
; 1107 :     dest &= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1108 :   }
; 1109 :   else

	jmp	SHORT $LN3@Execute_AN@3
$LN4@Execute_AN@3:

; 1110 :   {
; 1111 :     dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_AN@3:

; 1112 :   }
; 1113 : 
; 1114 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1115 : 
; 1116 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_AN@3

; 1117 :   {
; 1118 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1119 :   }
; 1120 :   else

	jmp	SHORT $LN5@Execute_AN@3
$LN2@Execute_AN@3:

; 1121 :   {
; 1122 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_AN@3:

; 1123 :   }
; 1124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDImmediateShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_ANDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDScalarShiftRightImmediate

; 1126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1127 :   uint32 src1, src2, dest;
; 1128 : 
; 1129 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1130 : 
; 1131 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1132 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1133 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1134 : 
; 1135 :   dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1136 : 
; 1137 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1138 : 
; 1139 :   if(!dest)

	jne	SHORT $LN2@Execute_AN@4

; 1140 :   {
; 1141 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1142 :   }
; 1143 :   else

	jmp	SHORT $LN3@Execute_AN@4
$LN2@Execute_AN@4:

; 1144 :   {
; 1145 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_AN@4:

; 1146 :   }
; 1147 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_ANDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDScalarShiftLeftImmediate

; 1149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1150 :   uint32 src1, src2, dest;
; 1151 : 
; 1152 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1153 : 
; 1154 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1155 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1156 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1157 : 
; 1158 :   dest &= (src1 << src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1159 : 
; 1160 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1161 : 
; 1162 :   if(!dest)

	jne	SHORT $LN2@Execute_AN@5

; 1163 :   {
; 1164 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1165 :   }
; 1166 :   else

	jmp	SHORT $LN3@Execute_AN@5
$LN2@Execute_AN@5:

; 1167 :   {
; 1168 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_AN@5:

; 1169 :   }
; 1170 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_ANDScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDScalarShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDScalarShiftScalar

; 1172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1173 :   uint32 src1, src2, dest;
; 1174 : 
; 1175 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1176 : 
; 1177 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1178 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1179 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1180 : 
; 1181 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_AN@6

; 1182 :   {
; 1183 :     dest &= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1184 :   }
; 1185 :   else

	jmp	SHORT $LN3@Execute_AN@6
$LN4@Execute_AN@6:

; 1186 :   {
; 1187 :     dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_AN@6:

; 1188 :   }
; 1189 : 
; 1190 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1191 : 
; 1192 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_AN@6

; 1193 :   {
; 1194 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1195 :   }
; 1196 :   else

	jmp	SHORT $LN5@Execute_AN@6
$LN2@Execute_AN@6:

; 1197 :   {
; 1198 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_AN@6:

; 1199 :   }
; 1200 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDScalarShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_ANDScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ANDScalarRotateScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ANDScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ANDScalarRotateScalar

; 1202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1203 :   uint32 src1, src2, dest;
; 1204 : 
; 1205 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1206 : 
; 1207 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1208 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1209 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1210 : 
; 1211 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_AN@7

; 1212 :   {
; 1213 :     dest &= _lrotl(src1, 64UL - src2);

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src1$[ebp]
	push	edx
	call	__lrotl
	add	esp, 8
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1214 :   }
; 1215 :   else

	jmp	SHORT $LN3@Execute_AN@7
$LN4@Execute_AN@7:

; 1216 :   {
; 1217 :     dest &= _lrotr(src1, src2);

	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_AN@7:

; 1218 :   }
; 1219 : 
; 1220 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1221 : 
; 1222 :   if(dest == 0)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_AN@7

; 1223 :   {
; 1224 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1225 :   }
; 1226 :   else

	jmp	SHORT $LN5@Execute_AN@7
$LN2@Execute_AN@7:

; 1227 :   {
; 1228 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _dest$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN5@Execute_AN@7:

; 1229 :   }
; 1230 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ANDScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ANDScalarRotateScalar
_TEXT	ENDS
PUBLIC	?Execute_FTSTImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTImmediate

; 1232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1233 :   uint32 src1, src2, result;
; 1234 : 
; 1235 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1236 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1237 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1238 : 
; 1239 :   result = src1 & src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1240 : 
; 1241 :   if(result == 0)

	jne	SHORT $LN2@Execute_FT

; 1242 :   {
; 1243 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1244 :   }
; 1245 :   else

	jmp	SHORT $LN3@Execute_FT
$LN2@Execute_FT:

; 1246 :   {
; 1247 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_FT:

; 1248 :   }
; 1249 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTImmediate
_TEXT	ENDS
PUBLIC	?Execute_FTSTScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTScalar

; 1251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1252 :   uint32 src1, src2, result;
; 1253 : 
; 1254 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1255 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1256 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1257 : 
; 1258 :   result = src1 & src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	and	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1259 : 
; 1260 :   if(result == 0)

	jne	SHORT $LN2@Execute_FT@2

; 1261 :   {
; 1262 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1263 :   }
; 1264 :   else

	jmp	SHORT $LN3@Execute_FT@2
$LN2@Execute_FT@2:

; 1265 :   {
; 1266 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _result$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_FT@2:

; 1267 :   }
; 1268 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTScalar
_TEXT	ENDS
PUBLIC	?Execute_FTSTImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTImmediateShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTImmediateShiftScalar

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1271 :   uint32 src1, src2, dest;
; 1272 : 
; 1273 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1274 : 
; 1275 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1276 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1277 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1278 : 
; 1279 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_FT@3

; 1280 :   {
; 1281 :     dest &= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1282 :   }
; 1283 :   else

	jmp	SHORT $LN3@Execute_FT@3
$LN4@Execute_FT@3:

; 1284 :   {
; 1285 :     dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_FT@3:

; 1286 :   }
; 1287 : 
; 1288 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_FT@3

; 1289 :   {
; 1290 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 1291 :   }
; 1292 :   else

	jmp	SHORT $LN5@Execute_FT@3
$LN2@Execute_FT@3:

; 1293 :   {
; 1294 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _dest$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN5@Execute_FT@3:

; 1295 :   }
; 1296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTImmediateShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_FTSTScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTScalarShiftRightImmediate

; 1298 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1299 :   uint32 src1, src2, dest;
; 1300 : 
; 1301 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1302 : 
; 1303 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1304 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1305 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1306 : 
; 1307 :   dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1308 : 
; 1309 :   if(!dest)

	jne	SHORT $LN2@Execute_FT@4

; 1310 :   {
; 1311 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 1312 :   }
; 1313 :   else

	jmp	SHORT $LN3@Execute_FT@4
$LN2@Execute_FT@4:

; 1314 :   {
; 1315 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _dest$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN3@Execute_FT@4:

; 1316 :   }
; 1317 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_FTSTScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTScalarShiftLeftImmediate

; 1320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1321 :   uint32 src1, src2, dest;
; 1322 : 
; 1323 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1324 : 
; 1325 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1326 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1327 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1328 : 
; 1329 :   dest &= (src1 << src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1330 : 
; 1331 :   if(!dest)

	jne	SHORT $LN2@Execute_FT@5

; 1332 :   {
; 1333 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 1334 :   }
; 1335 :   else

	jmp	SHORT $LN3@Execute_FT@5
$LN2@Execute_FT@5:

; 1336 :   {
; 1337 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _dest$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN3@Execute_FT@5:

; 1338 :   }
; 1339 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_FTSTScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTScalarShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTScalarShiftScalar

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1342 :   uint32 src1, src2, dest;
; 1343 : 
; 1344 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1345 : 
; 1346 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1347 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1348 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1349 : 
; 1350 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_FT@6

; 1351 :   {
; 1352 :     dest &= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	and	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1353 :   }
; 1354 :   else

	jmp	SHORT $LN3@Execute_FT@6
$LN4@Execute_FT@6:

; 1355 :   {
; 1356 :     dest &= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_FT@6:

; 1357 :   }
; 1358 : 
; 1359 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_FT@6

; 1360 :   {
; 1361 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx

; 1362 :   }
; 1363 :   else

	jmp	SHORT $LN5@Execute_FT@6
$LN2@Execute_FT@6:

; 1364 :   {
; 1365 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	ecx, DWORD PTR _dest$[ebp]
	shr	ecx, 28					; 0000001cH
	and	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	or	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN5@Execute_FT@6:

; 1366 :   }
; 1367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTScalarShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_FTSTScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_FTSTScalarRotateScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_FTSTScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_FTSTScalarRotateScalar

; 1369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1370 :   uint32 src1, src2, dest;
; 1371 : 
; 1372 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1373 : 
; 1374 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1375 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1376 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1377 : 
; 1378 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_FT@7

; 1379 :   {
; 1380 :     dest &= _lrotl(src1, 64UL - src2);

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src1$[ebp]
	push	edx
	call	__lrotl
	add	esp, 8
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1381 :   }
; 1382 :   else

	jmp	SHORT $LN3@Execute_FT@7
$LN4@Execute_FT@7:

; 1383 :   {
; 1384 :     dest &= _lrotr(src1, src2);

	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	and	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_FT@7:

; 1385 :   }
; 1386 : 
; 1387 :   if(dest == 0)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_FT@7

; 1388 :   {
; 1389 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1390 :   }
; 1391 :   else

	jmp	SHORT $LN5@Execute_FT@7
$LN2@Execute_FT@7:

; 1392 :   {
; 1393 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_FT@7:

; 1394 :   }
; 1395 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_FTSTScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_FTSTScalarRotateScalar
_TEXT	ENDS
PUBLIC	?Execute_ORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORImmediate

; 1397 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1398 :   uint32 src1, src2, result;
; 1399 : 
; 1400 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1401 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1402 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1403 : 
; 1404 :   result = src1 | src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	or	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1405 : 
; 1406 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1407 : 
; 1408 :   if(result == 0)

	jne	SHORT $LN2@Execute_OR

; 1409 :   {
; 1410 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1411 :   }
; 1412 :   else

	jmp	SHORT $LN3@Execute_OR
$LN2@Execute_OR:

; 1413 :   {
; 1414 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_OR:

; 1415 :   }
; 1416 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORImmediate
_TEXT	ENDS
PUBLIC	?Execute_ORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORScalar

; 1418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1419 :   uint32 src1, src2, result;
; 1420 : 
; 1421 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1422 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1423 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1424 : 
; 1425 :   result = src1 | src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	or	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1426 : 
; 1427 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1428 : 
; 1429 :   if(result == 0)

	jne	SHORT $LN2@Execute_OR@2

; 1430 :   {
; 1431 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1432 :   }
; 1433 :   else

	jmp	SHORT $LN3@Execute_OR@2
$LN2@Execute_OR@2:

; 1434 :   {
; 1435 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_OR@2:

; 1436 :   }
; 1437 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORScalar
_TEXT	ENDS
PUBLIC	?Execute_ORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORImmediateShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORImmediateShiftScalar

; 1439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1440 :   uint32 src1, src2, dest;
; 1441 : 
; 1442 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1443 : 
; 1444 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1445 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1446 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1447 : 
; 1448 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_OR@3

; 1449 :   {
; 1450 :     dest |= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1451 :   }
; 1452 :   else

	jmp	SHORT $LN3@Execute_OR@3
$LN4@Execute_OR@3:

; 1453 :   {
; 1454 :     dest |= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_OR@3:

; 1455 :   }
; 1456 : 
; 1457 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1458 : 
; 1459 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_OR@3

; 1460 :   {
; 1461 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1462 :   }
; 1463 :   else

	jmp	SHORT $LN5@Execute_OR@3
$LN2@Execute_OR@3:

; 1464 :   {
; 1465 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_OR@3:

; 1466 :   }
; 1467 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORImmediateShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_ORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORScalarShiftRightImmediate

; 1469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1470 :   uint32 src1, src2, dest;
; 1471 : 
; 1472 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1473 : 
; 1474 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1475 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1476 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1477 : 
; 1478 :   dest |= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1479 : 
; 1480 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1481 : 
; 1482 :   if(!dest)

	jne	SHORT $LN2@Execute_OR@4

; 1483 :   {
; 1484 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1485 :   }
; 1486 :   else

	jmp	SHORT $LN3@Execute_OR@4
$LN2@Execute_OR@4:

; 1487 :   {
; 1488 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_OR@4:

; 1489 :   }
; 1490 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_ORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORScalarShiftLeftImmediate

; 1492 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1493 :   uint32 src1, src2, dest;
; 1494 : 
; 1495 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1496 : 
; 1497 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1498 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1499 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1500 : 
; 1501 :   dest |= (src1 << src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1502 : 
; 1503 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1504 : 
; 1505 :   if(!dest)

	jne	SHORT $LN2@Execute_OR@5

; 1506 :   {
; 1507 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1508 :   }
; 1509 :   else

	jmp	SHORT $LN3@Execute_OR@5
$LN2@Execute_OR@5:

; 1510 :   {
; 1511 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_OR@5:

; 1512 :   }
; 1513 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_ORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORScalarShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORScalarShiftScalar

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1516 :   uint32 src1, src2, dest;
; 1517 : 
; 1518 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1519 : 
; 1520 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1521 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1522 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1523 : 
; 1524 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_OR@6

; 1525 :   {
; 1526 :     dest |= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1527 :   }
; 1528 :   else

	jmp	SHORT $LN3@Execute_OR@6
$LN4@Execute_OR@6:

; 1529 :   {
; 1530 :     dest |= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_OR@6:

; 1531 :   }
; 1532 : 
; 1533 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1534 : 
; 1535 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_OR@6

; 1536 :   {
; 1537 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1538 :   }
; 1539 :   else

	jmp	SHORT $LN5@Execute_OR@6
$LN2@Execute_OR@6:

; 1540 :   {
; 1541 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_OR@6:

; 1542 :   }
; 1543 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORScalarShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_ORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ORScalarRotateScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ORScalarRotateScalar

; 1545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1546 :   uint32 src1, src2, dest;
; 1547 : 
; 1548 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1549 : 
; 1550 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1551 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1552 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1553 : 
; 1554 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_OR@7

; 1555 :   {
; 1556 :     dest |= _lrotl(src1, 64UL - src2);

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src1$[ebp]
	push	edx
	call	__lrotl
	add	esp, 8
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1557 :   }
; 1558 :   else

	jmp	SHORT $LN3@Execute_OR@7
$LN4@Execute_OR@7:

; 1559 :   {
; 1560 :     dest |= _lrotr(src1, src2);

	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	or	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_OR@7:

; 1561 :   }
; 1562 : 
; 1563 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1564 : 
; 1565 :   if(dest == 0)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_OR@7

; 1566 :   {
; 1567 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1568 :   }
; 1569 :   else

	jmp	SHORT $LN5@Execute_OR@7
$LN2@Execute_OR@7:

; 1570 :   {
; 1571 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _dest$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN5@Execute_OR@7:

; 1572 :   }
; 1573 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ORScalarRotateScalar
_TEXT	ENDS
PUBLIC	?Execute_EORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORImmediate

; 1575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1576 :   uint32 src1, src2, result;
; 1577 : 
; 1578 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1579 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1580 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1581 : 
; 1582 :   result = src1 ^ src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1583 : 
; 1584 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1585 : 
; 1586 :   if(result == 0)

	jne	SHORT $LN2@Execute_EO

; 1587 :   {
; 1588 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1589 :   }
; 1590 :   else

	jmp	SHORT $LN3@Execute_EO
$LN2@Execute_EO:

; 1591 :   {
; 1592 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_EO:

; 1593 :   }
; 1594 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORImmediate
_TEXT	ENDS
PUBLIC	?Execute_EORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_result$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORScalar

; 1596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1597 :   uint32 src1, src2, result;
; 1598 : 
; 1599 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1600 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1601 :   src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _src2$[ebp], eax

; 1602 : 
; 1603 :   result = src1 ^ src2;

	mov	ecx, DWORD PTR _src1$[ebp]
	xor	ecx, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _result$[ebp], ecx

; 1604 : 
; 1605 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = result;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1606 : 
; 1607 :   if(result == 0)

	jne	SHORT $LN2@Execute_EO@2

; 1608 :   {
; 1609 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1610 :   }
; 1611 :   else

	jmp	SHORT $LN3@Execute_EO@2
$LN2@Execute_EO@2:

; 1612 :   {
; 1613 :     mpe.cc |= ((result >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _result$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN3@Execute_EO@2:

; 1614 :   }
; 1615 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORScalar
_TEXT	ENDS
PUBLIC	?Execute_EORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORImmediateShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORImmediateShiftScalar

; 1617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1618 :   uint32 src1, src2, dest;
; 1619 : 
; 1620 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1621 : 
; 1622 :   src1 = nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _src1$[ebp], ecx

; 1623 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1624 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1625 : 
; 1626 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_EO@3

; 1627 :   {
; 1628 :     dest ^= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	xor	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1629 :   }
; 1630 :   else

	jmp	SHORT $LN3@Execute_EO@3
$LN4@Execute_EO@3:

; 1631 :   {
; 1632 :     dest ^= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_EO@3:

; 1633 :   }
; 1634 : 
; 1635 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1636 : 
; 1637 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_EO@3

; 1638 :   {
; 1639 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1640 :   }
; 1641 :   else

	jmp	SHORT $LN5@Execute_EO@3
$LN2@Execute_EO@3:

; 1642 :   {
; 1643 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_EO@3:

; 1644 :   }
; 1645 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORImmediateShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORImmediateShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_EORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORScalarShiftRightImmediate

; 1647 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1648 :   uint32 src1, src2, dest;
; 1649 : 
; 1650 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1651 : 
; 1652 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1653 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1654 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1655 : 
; 1656 :   dest ^= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1657 : 
; 1658 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1659 : 
; 1660 :   if(!dest)

	jne	SHORT $LN2@Execute_EO@4

; 1661 :   {
; 1662 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1663 :   }
; 1664 :   else

	jmp	SHORT $LN3@Execute_EO@4
$LN2@Execute_EO@4:

; 1665 :   {
; 1666 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_EO@4:

; 1667 :   }
; 1668 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_EORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORScalarShiftLeftImmediate

; 1670 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1671 :   uint32 src1, src2, dest;
; 1672 : 
; 1673 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1674 : 
; 1675 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1676 :   src2 = nuance.fields[FIELD_ALU_SRC2];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _src2$[ebp], eax

; 1677 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1678 : 
; 1679 :   dest ^= (src1 << src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shl	eax, cl
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1680 : 
; 1681 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1682 : 
; 1683 :   if(!dest)

	jne	SHORT $LN2@Execute_EO@5

; 1684 :   {
; 1685 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1686 :   }
; 1687 :   else

	jmp	SHORT $LN3@Execute_EO@5
$LN2@Execute_EO@5:

; 1688 :   {
; 1689 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN3@Execute_EO@5:

; 1690 :   }
; 1691 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_EORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORScalarShiftScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORScalarShiftScalar

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1694 :   uint32 src1, src2, dest;
; 1695 : 
; 1696 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1697 : 
; 1698 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1699 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1700 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1701 : 
; 1702 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_EO@6

; 1703 :   {
; 1704 :     dest ^= (src1 << (64UL - src2));

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	shl	edx, cl
	xor	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], edx

; 1705 :   }
; 1706 :   else

	jmp	SHORT $LN3@Execute_EO@6
$LN4@Execute_EO@6:

; 1707 :   {
; 1708 :     dest ^= (src1 >> src2);

	mov	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp]
	shr	eax, cl
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_EO@6:

; 1709 :   }
; 1710 : 
; 1711 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1712 : 
; 1713 :   if(!dest)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_EO@6

; 1714 :   {
; 1715 :     mpe.cc |= CC_ALU_ZERO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1716 :   }
; 1717 :   else

	jmp	SHORT $LN5@Execute_EO@6
$LN2@Execute_EO@6:

; 1718 :   {
; 1719 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	edx, DWORD PTR _dest$[ebp]
	shr	edx, 28					; 0000001cH
	and	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], edx
$LN5@Execute_EO@6:

; 1720 :   }
; 1721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORScalarShiftScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORScalarShiftScalar
_TEXT	ENDS
PUBLIC	?Execute_EORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_EORScalarRotateScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dest$ = -12						; size = 4
_src2$ = -8						; size = 4
_src1$ = -4						; size = 4
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_EORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_EORScalarRotateScalar

; 1723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1724 :   uint32 src1, src2, dest;
; 1725 : 
; 1726 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -14				; fffffff2H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1727 : 
; 1728 :   src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src1$[ebp], ecx

; 1729 :   src2 = (((int32)(entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]] << 26)) >> 26) & 0x3FUL;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	shl	eax, 26					; 0000001aH
	sar	eax, 26					; 0000001aH
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _src2$[ebp], eax

; 1730 :   dest = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dest$[ebp], edx

; 1731 : 
; 1732 :   if(src2 & 0x20)

	mov	eax, DWORD PTR _src2$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN4@Execute_EO@7

; 1733 :   {
; 1734 :     dest ^= _lrotl(src1, 64UL - src2);

	mov	ecx, 64					; 00000040H
	sub	ecx, DWORD PTR _src2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src1$[ebp]
	push	edx
	call	__lrotl
	add	esp, 8
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax

; 1735 :   }
; 1736 :   else

	jmp	SHORT $LN3@Execute_EO@7
$LN4@Execute_EO@7:

; 1737 :   {
; 1738 :     dest ^= _lrotr(src1, src2);

	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	call	__lrotr
	add	esp, 8
	xor	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dest$[ebp], eax
$LN3@Execute_EO@7:

; 1739 :   }
; 1740 : 
; 1741 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = dest;

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 1742 : 
; 1743 :   if(dest == 0)

	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $LN2@Execute_EO@7

; 1744 :   {
; 1745 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1746 :   }
; 1747 :   else

	jmp	SHORT $LN5@Execute_EO@7
$LN2@Execute_EO@7:

; 1748 :   {
; 1749 :     mpe.cc |= ((dest >> 28) & CC_ALU_NEGATIVE);

	mov	eax, DWORD PTR _dest$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 8
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], eax
$LN5@Execute_EO@7:

; 1750 :   }
; 1751 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_EORScalarRotateScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_EORScalarRotateScalar
_TEXT	ENDS
PUBLIC	?Execute_ADDWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDWCImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv209 = -48						; size = 8
tv196 = -40						; size = 8
tv170 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDWCImmediate

; 1753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1754 :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 1755 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1756 :   uint64 result;
; 1757 : 
; 1758 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1759 : 
; 1760 :   result = src1 + src2 + ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	add	eax, edx
	adc	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1761 : 
; 1762 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv170[ebp], eax
	mov	DWORD PTR tv170[ebp+4], ecx
	mov	edx, DWORD PTR tv170[ebp]
	or	edx, DWORD PTR tv170[ebp+4]
	je	SHORT $LN6@Execute_AD@5

; 1763 :   {
; 1764 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_AD@5:

; 1765 :   }
; 1766 : 
; 1767 :   if(((int32)(src1 ^ src2)) >= 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jl	SHORT $LN5@Execute_AD@5

; 1768 :   {
; 1769 :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src1$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_AD@5

; 1770 :     {
; 1771 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_AD@5:

; 1772 :     }
; 1773 :   }
; 1774 : 
; 1775 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv196[ebp], ecx
	mov	DWORD PTR tv196[ebp+4], edx
	mov	eax, DWORD PTR tv196[ebp]
	or	eax, DWORD PTR tv196[ebp+4]
	je	SHORT $LN3@Execute_AD@5

; 1776 :   {
; 1777 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_AD@5
$LN3@Execute_AD@5:

; 1778 :   }
; 1779 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv209[ebp], ecx
	mov	DWORD PTR tv209[ebp+4], edx
	mov	eax, DWORD PTR tv209[ebp]
	or	eax, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN2@Execute_AD@5

; 1780 :   {
; 1781 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_AD@5:

; 1782 :   }
; 1783 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1784 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDWCImmediate
_TEXT	ENDS
PUBLIC	?Execute_ADDWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDWCScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv215 = -48						; size = 8
tv202 = -40						; size = 8
tv176 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDWCScalar

; 1786 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1787 :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 1788 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1789 :   uint64 result;
; 1790 : 
; 1791 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1792 : 
; 1793 :   result = src1 + src2 + ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	add	eax, edx
	adc	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1794 : 
; 1795 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv176[ebp], eax
	mov	DWORD PTR tv176[ebp+4], ecx
	mov	edx, DWORD PTR tv176[ebp]
	or	edx, DWORD PTR tv176[ebp+4]
	je	SHORT $LN6@Execute_AD@6

; 1796 :   {
; 1797 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_AD@6:

; 1798 :   }
; 1799 : 
; 1800 :   if(((int32)(src1 ^ src2)) >= 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jl	SHORT $LN5@Execute_AD@6

; 1801 :   {
; 1802 :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src1$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_AD@6

; 1803 :     {
; 1804 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_AD@6:

; 1805 :     }
; 1806 :   }
; 1807 : 
; 1808 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv202[ebp], ecx
	mov	DWORD PTR tv202[ebp+4], edx
	mov	eax, DWORD PTR tv202[ebp]
	or	eax, DWORD PTR tv202[ebp+4]
	je	SHORT $LN3@Execute_AD@6

; 1809 :   {
; 1810 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_AD@6
$LN3@Execute_AD@6:

; 1811 :   }
; 1812 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv215[ebp], ecx
	mov	DWORD PTR tv215[ebp+4], edx
	mov	eax, DWORD PTR tv215[ebp]
	or	eax, DWORD PTR tv215[ebp+4]
	jne	SHORT $LN2@Execute_AD@6

; 1813 :   {
; 1814 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_AD@6:

; 1815 :   }
; 1816 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1817 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDWCScalar
_TEXT	ENDS
PUBLIC	?Execute_ADDWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDWCScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv225 = -48						; size = 8
tv212 = -40						; size = 8
tv186 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDWCScalarShiftRightImmediate

; 1819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1820 :   uint64 src1 = (uint64)(((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 1821 :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 1822 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1823 :   uint64 result;
; 1824 : 
; 1825 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1826 : 
; 1827 :   result = src1 + src2 + ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src1$[ebp]
	add	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	adc	ecx, DWORD PTR _src2$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	add	eax, edx
	adc	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1828 : 
; 1829 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv186[ebp], eax
	mov	DWORD PTR tv186[ebp+4], ecx
	mov	edx, DWORD PTR tv186[ebp]
	or	edx, DWORD PTR tv186[ebp+4]
	je	SHORT $LN6@Execute_AD@7

; 1830 :   {
; 1831 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_AD@7:

; 1832 :   }
; 1833 : 
; 1834 :   if(((int32)(src1 ^ src2)) >= 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jl	SHORT $LN5@Execute_AD@7

; 1835 :   {
; 1836 :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src1$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_AD@7

; 1837 :     {
; 1838 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_AD@7:

; 1839 :     }
; 1840 :   }
; 1841 : 
; 1842 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv212[ebp], ecx
	mov	DWORD PTR tv212[ebp+4], edx
	mov	eax, DWORD PTR tv212[ebp]
	or	eax, DWORD PTR tv212[ebp+4]
	je	SHORT $LN3@Execute_AD@7

; 1843 :   {
; 1844 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_AD@7
$LN3@Execute_AD@7:

; 1845 :   }
; 1846 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv225[ebp], ecx
	mov	DWORD PTR tv225[ebp+4], edx
	mov	eax, DWORD PTR tv225[ebp]
	or	eax, DWORD PTR tv225[ebp+4]
	jne	SHORT $LN2@Execute_AD@7

; 1847 :   {
; 1848 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_AD@7:

; 1849 :   }
; 1850 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1851 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDWCScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_ADDWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_ADDWCScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv221 = -48						; size = 8
tv208 = -40						; size = 8
tv182 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_ADDWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_ADDWCScalarShiftLeftImmediate

; 1853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1854 :   uint64 src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] << nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 1855 :   uint64 src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 1856 :   uint64 result;
; 1857 : 
; 1858 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 1859 : 
; 1860 :   result = src1 + src2 + ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	edx, DWORD PTR _src1$[ebp]
	add	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	adc	eax, DWORD PTR _src2$[ebp+4]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [ecx+320]
	and	ecx, 2
	shr	ecx, 1
	xor	esi, esi
	add	edx, ecx
	adc	eax, esi
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 1861 : 
; 1862 :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv182[ebp], edx
	mov	DWORD PTR tv182[ebp+4], eax
	mov	ecx, DWORD PTR tv182[ebp]
	or	ecx, DWORD PTR tv182[ebp+4]
	je	SHORT $LN6@Execute_AD@8

; 1863 :   {
; 1864 :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_AD@8:

; 1865 :   }
; 1866 : 
; 1867 :   if(((int32)(src1 ^ src2)) >= 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jl	SHORT $LN5@Execute_AD@8

; 1868 :   {
; 1869 :     if(((int32)(src1 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	xor	ecx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src1$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_AD@8

; 1870 :     {
; 1871 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_AD@8:

; 1872 :     }
; 1873 :   }
; 1874 : 
; 1875 :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv208[ebp], eax
	mov	DWORD PTR tv208[ebp+4], ecx
	mov	edx, DWORD PTR tv208[ebp]
	or	edx, DWORD PTR tv208[ebp+4]
	je	SHORT $LN3@Execute_AD@8

; 1876 :   {
; 1877 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_AD@8
$LN3@Execute_AD@8:

; 1878 :   }
; 1879 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv221[ebp], eax
	mov	DWORD PTR tv221[ebp+4], ecx
	mov	edx, DWORD PTR tv221[ebp]
	or	edx, DWORD PTR tv221[ebp+4]
	jne	SHORT $LN2@Execute_AD@8

; 1880 :   {
; 1881 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_AD@8:

; 1882 :   }
; 1883 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1884 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_ADDWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_ADDWCScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBWCImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv209 = -48						; size = 8
tv196 = -40						; size = 8
tv170 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBWCImmediate

; 1886 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1887 :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 1888 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1889 :   uint64 result;
; 1890 : 
; 1891 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1892 : 
; 1893 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1894 : 
; 1895 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv170[ebp], eax
	mov	DWORD PTR tv170[ebp+4], ecx
	mov	edx, DWORD PTR tv170[ebp]
	or	edx, DWORD PTR tv170[ebp+4]
	je	SHORT $LN6@Execute_SU@6

; 1896 :   {
; 1897 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_SU@6:

; 1898 :   }
; 1899 : 
; 1900 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_SU@6

; 1901 :   {
; 1902 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@6

; 1903 :     {
; 1904 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_SU@6:

; 1905 :     }
; 1906 :   }
; 1907 : 
; 1908 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv196[ebp], ecx
	mov	DWORD PTR tv196[ebp+4], edx
	mov	eax, DWORD PTR tv196[ebp]
	or	eax, DWORD PTR tv196[ebp+4]
	je	SHORT $LN3@Execute_SU@6

; 1909 :   {
; 1910 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_SU@6
$LN3@Execute_SU@6:

; 1911 :   }
; 1912 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv209[ebp], ecx
	mov	DWORD PTR tv209[ebp+4], edx
	mov	eax, DWORD PTR tv209[ebp]
	or	eax, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN2@Execute_SU@6

; 1913 :   {
; 1914 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_SU@6:

; 1915 :   }
; 1916 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1917 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBWCImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBWCImmediateReverse
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv209 = -48						; size = 8
tv196 = -40						; size = 8
tv170 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBWCImmediateReverse

; 1919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1920 :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 1921 :   uint64 src2 = (uint64)nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1922 :   uint64 result;
; 1923 : 
; 1924 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1925 : 
; 1926 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1927 : 
; 1928 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv170[ebp], eax
	mov	DWORD PTR tv170[ebp+4], ecx
	mov	edx, DWORD PTR tv170[ebp]
	or	edx, DWORD PTR tv170[ebp+4]
	je	SHORT $LN6@Execute_SU@7

; 1929 :   {
; 1930 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_SU@7:

; 1931 :   }
; 1932 : 
; 1933 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_SU@7

; 1934 :   {
; 1935 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@7

; 1936 :     {
; 1937 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_SU@7:

; 1938 :     }
; 1939 :   }
; 1940 : 
; 1941 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv196[ebp], ecx
	mov	DWORD PTR tv196[ebp+4], edx
	mov	eax, DWORD PTR tv196[ebp]
	or	eax, DWORD PTR tv196[ebp+4]
	je	SHORT $LN3@Execute_SU@7

; 1942 :   {
; 1943 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_SU@7
$LN3@Execute_SU@7:

; 1944 :   }
; 1945 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv209[ebp], ecx
	mov	DWORD PTR tv209[ebp+4], edx
	mov	eax, DWORD PTR tv209[ebp]
	or	eax, DWORD PTR tv209[ebp+4]
	jne	SHORT $LN2@Execute_SU@7

; 1946 :   {
; 1947 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_SU@7:

; 1948 :   }
; 1949 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1950 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBWCImmediateReverse
_TEXT	ENDS
PUBLIC	?Execute_SUBWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBWCScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv215 = -48						; size = 8
tv202 = -40						; size = 8
tv176 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBWCScalar

; 1952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1953 :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 1954 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1955 :   uint64 result;
; 1956 : 
; 1957 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1958 : 
; 1959 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1960 : 
; 1961 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv176[ebp], eax
	mov	DWORD PTR tv176[ebp+4], ecx
	mov	edx, DWORD PTR tv176[ebp]
	or	edx, DWORD PTR tv176[ebp+4]
	je	SHORT $LN6@Execute_SU@8

; 1962 :   {
; 1963 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_SU@8:

; 1964 :   }
; 1965 : 
; 1966 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_SU@8

; 1967 :   {
; 1968 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@8

; 1969 :     {
; 1970 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_SU@8:

; 1971 :     }
; 1972 :   }
; 1973 : 
; 1974 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv202[ebp], ecx
	mov	DWORD PTR tv202[ebp+4], edx
	mov	eax, DWORD PTR tv202[ebp]
	or	eax, DWORD PTR tv202[ebp+4]
	je	SHORT $LN3@Execute_SU@8

; 1975 :   {
; 1976 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_SU@8
$LN3@Execute_SU@8:

; 1977 :   }
; 1978 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv215[ebp], ecx
	mov	DWORD PTR tv215[ebp+4], edx
	mov	eax, DWORD PTR tv215[ebp]
	or	eax, DWORD PTR tv215[ebp+4]
	jne	SHORT $LN2@Execute_SU@8

; 1979 :   {
; 1980 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_SU@8:

; 1981 :   }
; 1982 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1983 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBWCScalar
_TEXT	ENDS
PUBLIC	?Execute_SUBWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBWCScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv225 = -48						; size = 8
tv212 = -40						; size = 8
tv186 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBWCScalarShiftRightImmediate

; 1985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1986 :   uint64 src1 = (uint64)(((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 1987 :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 1988 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 1989 :   uint64 result;
; 1990 : 
; 1991 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 1992 : 
; 1993 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 1994 : 
; 1995 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv186[ebp], eax
	mov	DWORD PTR tv186[ebp+4], ecx
	mov	edx, DWORD PTR tv186[ebp]
	or	edx, DWORD PTR tv186[ebp+4]
	je	SHORT $LN6@Execute_SU@9

; 1996 :   {
; 1997 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_SU@9:

; 1998 :   }
; 1999 : 
; 2000 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_SU@9

; 2001 :   {
; 2002 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@9

; 2003 :     {
; 2004 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_SU@9:

; 2005 :     }
; 2006 :   }
; 2007 : 
; 2008 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv212[ebp], ecx
	mov	DWORD PTR tv212[ebp+4], edx
	mov	eax, DWORD PTR tv212[ebp]
	or	eax, DWORD PTR tv212[ebp+4]
	je	SHORT $LN3@Execute_SU@9

; 2009 :   {
; 2010 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN2@Execute_SU@9
$LN3@Execute_SU@9:

; 2011 :   }
; 2012 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv225[ebp], ecx
	mov	DWORD PTR tv225[ebp+4], edx
	mov	eax, DWORD PTR tv225[ebp]
	or	eax, DWORD PTR tv225[ebp+4]
	jne	SHORT $LN2@Execute_SU@9

; 2013 :   {
; 2014 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN2@Execute_SU@9:

; 2015 :   }
; 2016 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2017 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBWCScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_SUBWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_SUBWCScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv221 = -48						; size = 8
tv208 = -40						; size = 8
tv182 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_SUBWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_SUBWCScalarShiftLeftImmediate

; 2019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2020 :   uint64 src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] << nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 2021 :   uint64 src2 = entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 2022 :   uint64 result;
; 2023 : 
; 2024 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 2025 : 
; 2026 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	edx, DWORD PTR _src2$[ebp]
	sub	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR _src2$[ebp+4]
	sbb	eax, DWORD PTR _src1$[ebp+4]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [ecx+320]
	and	ecx, 2
	shr	ecx, 1
	xor	esi, esi
	sub	edx, ecx
	sbb	eax, esi
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 2027 : 
; 2028 :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv182[ebp], edx
	mov	DWORD PTR tv182[ebp+4], eax
	mov	ecx, DWORD PTR tv182[ebp]
	or	ecx, DWORD PTR tv182[ebp+4]
	je	SHORT $LN6@Execute_SU@10

; 2029 :   {
; 2030 :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_SU@10:

; 2031 :   }
; 2032 : 
; 2033 :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_SU@10

; 2034 :   {
; 2035 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	xor	ecx, DWORD PTR _src2$[ebp]
	xor	edx, DWORD PTR _src2$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_SU@10

; 2036 :     {
; 2037 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_SU@10:

; 2038 :     }
; 2039 :   }
; 2040 : 
; 2041 :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv208[ebp], eax
	mov	DWORD PTR tv208[ebp+4], ecx
	mov	edx, DWORD PTR tv208[ebp]
	or	edx, DWORD PTR tv208[ebp+4]
	je	SHORT $LN3@Execute_SU@10

; 2042 :   {
; 2043 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN2@Execute_SU@10
$LN3@Execute_SU@10:

; 2044 :   }
; 2045 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv221[ebp], eax
	mov	DWORD PTR tv221[ebp+4], ecx
	mov	edx, DWORD PTR tv221[ebp]
	or	edx, DWORD PTR tv221[ebp+4]
	jne	SHORT $LN2@Execute_SU@10

; 2046 :   {
; 2047 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN2@Execute_SU@10:

; 2048 :   }
; 2049 :   mpe.regs[nuance.fields[FIELD_ALU_DEST]] = (uint32)result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _nuance$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2050 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_SUBWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_SUBWCScalarShiftLeftImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPWCImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv204 = -48						; size = 8
tv191 = -40						; size = 8
tv165 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPWCImmediate

; 2052 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2053 :   uint64 src1 = (uint64)nuance.fields[FIELD_ALU_SRC1];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 2054 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 2055 :   uint64 result;
; 2056 : 
; 2057 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 2058 : 
; 2059 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 2060 : 
; 2061 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv165[ebp], eax
	mov	DWORD PTR tv165[ebp+4], ecx
	mov	edx, DWORD PTR tv165[ebp]
	or	edx, DWORD PTR tv165[ebp+4]
	je	SHORT $LN6@Execute_CM@6

; 2062 :   {
; 2063 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_CM@6:

; 2064 :   }
; 2065 : 
; 2066 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_CM@6

; 2067 :   {
; 2068 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@6

; 2069 :     {
; 2070 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_CM@6:

; 2071 :     }
; 2072 :   }
; 2073 : 
; 2074 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv191[ebp], ecx
	mov	DWORD PTR tv191[ebp+4], edx
	mov	eax, DWORD PTR tv191[ebp]
	or	eax, DWORD PTR tv191[ebp+4]
	je	SHORT $LN3@Execute_CM@6

; 2075 :   {
; 2076 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN7@Execute_CM@6
$LN3@Execute_CM@6:

; 2077 :   }
; 2078 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv204[ebp], ecx
	mov	DWORD PTR tv204[ebp+4], edx
	mov	eax, DWORD PTR tv204[ebp]
	or	eax, DWORD PTR tv204[ebp+4]
	jne	SHORT $LN7@Execute_CM@6

; 2079 :   {
; 2080 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN7@Execute_CM@6:

; 2081 :   }
; 2082 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPWCImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPWCImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPWCImmediateReverse
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv204 = -48						; size = 8
tv191 = -40						; size = 8
tv165 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPWCImmediateReverse

; 2085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2086 :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 2087 :   uint64 src2 = (uint64)nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 2088 :   uint64 result;
; 2089 : 
; 2090 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 2091 : 
; 2092 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 2093 : 
; 2094 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv165[ebp], eax
	mov	DWORD PTR tv165[ebp+4], ecx
	mov	edx, DWORD PTR tv165[ebp]
	or	edx, DWORD PTR tv165[ebp+4]
	je	SHORT $LN6@Execute_CM@7

; 2095 :   {
; 2096 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_CM@7:

; 2097 :   }
; 2098 : 
; 2099 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_CM@7

; 2100 :   {
; 2101 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@7

; 2102 :     {
; 2103 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_CM@7:

; 2104 :     }
; 2105 :   }
; 2106 : 
; 2107 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv191[ebp], ecx
	mov	DWORD PTR tv191[ebp+4], edx
	mov	eax, DWORD PTR tv191[ebp]
	or	eax, DWORD PTR tv191[ebp+4]
	je	SHORT $LN3@Execute_CM@7

; 2108 :   {
; 2109 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN7@Execute_CM@7
$LN3@Execute_CM@7:

; 2110 :   }
; 2111 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv204[ebp], ecx
	mov	DWORD PTR tv204[ebp+4], edx
	mov	eax, DWORD PTR tv204[ebp]
	or	eax, DWORD PTR tv204[ebp+4]
	jne	SHORT $LN7@Execute_CM@7

; 2112 :   {
; 2113 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN7@Execute_CM@7:

; 2114 :   }
; 2115 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPWCImmediateReverse@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPWCImmediateReverse
_TEXT	ENDS
PUBLIC	?Execute_CMPWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPWCScalar
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv210 = -48						; size = 8
tv197 = -40						; size = 8
tv171 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPWCScalar

; 2118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2119 :   uint64 src1 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src1$[ebp], ecx
	mov	DWORD PTR _src1$[ebp+4], edx

; 2120 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC2]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 2121 :   uint64 result;
; 2122 : 
; 2123 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 2124 : 
; 2125 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 2126 : 
; 2127 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv171[ebp], eax
	mov	DWORD PTR tv171[ebp+4], ecx
	mov	edx, DWORD PTR tv171[ebp]
	or	edx, DWORD PTR tv171[ebp+4]
	je	SHORT $LN6@Execute_CM@8

; 2128 :   {
; 2129 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_CM@8:

; 2130 :   }
; 2131 : 
; 2132 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_CM@8

; 2133 :   {
; 2134 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@8

; 2135 :     {
; 2136 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_CM@8:

; 2137 :     }
; 2138 :   }
; 2139 : 
; 2140 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv197[ebp], ecx
	mov	DWORD PTR tv197[ebp+4], edx
	mov	eax, DWORD PTR tv197[ebp]
	or	eax, DWORD PTR tv197[ebp+4]
	je	SHORT $LN3@Execute_CM@8

; 2141 :   {
; 2142 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN7@Execute_CM@8
$LN3@Execute_CM@8:

; 2143 :   }
; 2144 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv210[ebp], ecx
	mov	DWORD PTR tv210[ebp+4], edx
	mov	eax, DWORD PTR tv210[ebp]
	or	eax, DWORD PTR tv210[ebp+4]
	jne	SHORT $LN7@Execute_CM@8

; 2145 :   {
; 2146 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN7@Execute_CM@8:

; 2147 :   }
; 2148 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPWCScalar@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPWCScalar
_TEXT	ENDS
PUBLIC	?Execute_CMPWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPWCScalarShiftRightImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv220 = -48						; size = 8
tv207 = -40						; size = 8
tv181 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPWCScalarShiftRightImmediate

; 2150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2151 :   uint64 src1 = (uint64)(((int32)entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]]) >>
; 2152 :     nuance.fields[FIELD_ALU_SRC2]);

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	sar	eax, cl
	cdq
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], edx

; 2153 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+ecx*4]
	xor	edx, edx
	mov	DWORD PTR _src2$[ebp], ecx
	mov	DWORD PTR _src2$[ebp+4], edx

; 2154 :   uint64 result;
; 2155 : 
; 2156 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	and	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 2157 : 
; 2158 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	eax, DWORD PTR _src2$[ebp]
	sub	eax, DWORD PTR _src1$[ebp]
	mov	ecx, DWORD PTR _src2$[ebp+4]
	sbb	ecx, DWORD PTR _src1$[ebp+4]
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [edx+320]
	and	edx, 2
	shr	edx, 1
	xor	esi, esi
	sub	eax, edx
	sbb	ecx, esi
	mov	DWORD PTR _result$[ebp], eax
	mov	DWORD PTR _result$[ebp+4], ecx

; 2159 : 
; 2160 :   if(result & (uint64)0x0000000100000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, 0
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 1
	mov	DWORD PTR tv181[ebp], eax
	mov	DWORD PTR tv181[ebp+4], ecx
	mov	edx, DWORD PTR tv181[ebp]
	or	edx, DWORD PTR tv181[ebp+4]
	je	SHORT $LN6@Execute_CM@9

; 2161 :   {
; 2162 :     mpe.cc |= CC_ALU_CARRY;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 2
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN6@Execute_CM@9:

; 2163 :   }
; 2164 : 
; 2165 :   if(((int32)(src1 ^ src2)) < 0)

	mov	eax, DWORD PTR _src1$[ebp]
	xor	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp+4]
	xor	ecx, DWORD PTR _src2$[ebp+4]
	test	eax, eax
	jge	SHORT $LN5@Execute_CM@9

; 2166 :   {
; 2167 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 0
	xor	edx, DWORD PTR _src2$[ebp]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@9

; 2168 :     {
; 2169 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 4
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN5@Execute_CM@9:

; 2170 :     }
; 2171 :   }
; 2172 : 
; 2173 :   if(result & (uint64)0x0000000080000000)

	mov	ecx, DWORD PTR _result$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv207[ebp], ecx
	mov	DWORD PTR tv207[ebp+4], edx
	mov	eax, DWORD PTR tv207[ebp]
	or	eax, DWORD PTR tv207[ebp+4]
	je	SHORT $LN3@Execute_CM@9

; 2174 :   {
; 2175 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 8
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
	jmp	SHORT $LN7@Execute_CM@9
$LN3@Execute_CM@9:

; 2176 :   }
; 2177 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	mov	DWORD PTR tv220[ebp], ecx
	mov	DWORD PTR tv220[ebp+4], edx
	mov	eax, DWORD PTR tv220[ebp]
	or	eax, DWORD PTR tv220[ebp+4]
	jne	SHORT $LN7@Execute_CM@9

; 2178 :   {
; 2179 :     mpe.cc |= CC_ALU_ZERO;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	or	edx, 1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN7@Execute_CM@9:

; 2180 :   }
; 2181 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPWCScalarShiftRightImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPWCScalarShiftRightImmediate
_TEXT	ENDS
PUBLIC	?Execute_CMPWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ; Execute_CMPWCScalarShiftLeftImmediate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv216 = -48						; size = 8
tv203 = -40						; size = 8
tv177 = -32						; size = 8
_result$ = -24						; size = 8
_src2$ = -16						; size = 8
_src1$ = -8						; size = 8
_mpe$ = 8						; size = 4
_entry$ = 12						; size = 4
_nuance$ = 16						; size = 4
?Execute_CMPWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z PROC ; Execute_CMPWCScalarShiftLeftImmediate

; 2183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2184 :   uint64 src1 = entry.pScalarRegs[nuance.fields[FIELD_ALU_SRC1]] << nuance.fields[FIELD_ALU_SRC2];

	mov	eax, DWORD PTR _nuance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+12]
	shl	eax, cl
	xor	ecx, ecx
	mov	DWORD PTR _src1$[ebp], eax
	mov	DWORD PTR _src1$[ebp+4], ecx

; 2185 :   uint64 src2 = (uint64)entry.pScalarRegs[nuance.fields[FIELD_ALU_DEST]];

	mov	edx, DWORD PTR _nuance$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, ecx
	mov	DWORD PTR _src2$[ebp], eax
	mov	DWORD PTR _src2$[ebp+4], ecx

; 2186 :   uint64 result;
; 2187 : 
; 2188 :   mpe.cc &= ~(CC_ALU_ZERO | CC_ALU_NEGATIVE | CC_ALU_OVERFLOW | CC_ALU_CARRY);

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 2189 : 
; 2190 :   result = src2 - src1 - ((uint64)((mpe.tempCC & CC_ALU_CARRY) >> 1));

	mov	edx, DWORD PTR _src2$[ebp]
	sub	edx, DWORD PTR _src1$[ebp]
	mov	eax, DWORD PTR _src2$[ebp+4]
	sbb	eax, DWORD PTR _src1$[ebp+4]
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [ecx+320]
	and	ecx, 2
	shr	ecx, 1
	xor	esi, esi
	sub	edx, ecx
	sbb	eax, esi
	mov	DWORD PTR _result$[ebp], edx
	mov	DWORD PTR _result$[ebp+4], eax

; 2191 : 
; 2192 :   if(result & (uint64)0x0000000100000000)

	mov	edx, DWORD PTR _result$[ebp]
	and	edx, 0
	mov	eax, DWORD PTR _result$[ebp+4]
	and	eax, 1
	mov	DWORD PTR tv177[ebp], edx
	mov	DWORD PTR tv177[ebp+4], eax
	mov	ecx, DWORD PTR tv177[ebp]
	or	ecx, DWORD PTR tv177[ebp+4]
	je	SHORT $LN6@Execute_CM@10

; 2193 :   {
; 2194 :     mpe.cc |= CC_ALU_CARRY;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+128]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+128], eax
$LN6@Execute_CM@10:

; 2195 :   }
; 2196 : 
; 2197 :   if(((int32)(src1 ^ src2)) < 0)

	mov	edx, DWORD PTR _src1$[ebp]
	xor	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp+4]
	xor	eax, DWORD PTR _src2$[ebp+4]
	test	edx, edx
	jge	SHORT $LN5@Execute_CM@10

; 2198 :   {
; 2199 :     if(((int32)(src2 ^ (result & 0xFFFFFFFFUL))) < 0)

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _result$[ebp+4]
	and	edx, 0
	xor	ecx, DWORD PTR _src2$[ebp]
	xor	edx, DWORD PTR _src2$[ebp+4]
	test	ecx, ecx
	jge	SHORT $LN5@Execute_CM@10

; 2200 :     {
; 2201 :       mpe.cc |= CC_ALU_OVERFLOW;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 4
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN5@Execute_CM@10:

; 2202 :     }
; 2203 :   }
; 2204 : 
; 2205 :   if(result & (uint64)0x0000000080000000)

	mov	eax, DWORD PTR _result$[ebp]
	and	eax, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv203[ebp], eax
	mov	DWORD PTR tv203[ebp+4], ecx
	mov	edx, DWORD PTR tv203[ebp]
	or	edx, DWORD PTR tv203[ebp+4]
	je	SHORT $LN3@Execute_CM@10

; 2206 :   {
; 2207 :     mpe.cc |= CC_ALU_NEGATIVE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 8
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
	jmp	SHORT $LN7@Execute_CM@10
$LN3@Execute_CM@10:

; 2208 :   }
; 2209 :   else if(!(result & (uint64)0x00000000FFFFFFFF))

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR _result$[ebp+4]
	and	ecx, 0
	mov	DWORD PTR tv216[ebp], eax
	mov	DWORD PTR tv216[ebp+4], ecx
	mov	edx, DWORD PTR tv216[ebp]
	or	edx, DWORD PTR tv216[ebp+4]
	jne	SHORT $LN7@Execute_CM@10

; 2210 :   {
; 2211 :     mpe.cc |= CC_ALU_ZERO;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+128], ecx
$LN7@Execute_CM@10:

; 2212 :   }
; 2213 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Execute_CMPWCScalarShiftLeftImmediate@@YAXAAVMPE@@AAVInstructionCacheEntry@@AAVNuance@@@Z ENDP ; Execute_CMPWCScalarShiftLeftImmediate
_TEXT	ENDS
END
