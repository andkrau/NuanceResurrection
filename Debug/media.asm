; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\media.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?bCableFileOpen@@3_NA				; bCableFileOpen
PUBLIC	?bNvramFileOpen@@3_NA				; bNvramFileOpen
PUBLIC	?bEmulatorFileOpen@@3_NA			; bEmulatorFileOpen
PUBLIC	?media_mpe_allocated@@3IA			; media_mpe_allocated
PUBLIC	?media_mpe@@3IA					; media_mpe
PUBLIC	?DeviceInfo@@3PAUMediaDevInfo@@A		; DeviceInfo
PUBLIC	?fileNameArray@@3PAPADA				; fileNameArray
PUBLIC	?fileModeArray@@3PAIA				; fileModeArray
PUBLIC	?bCallingMediaCallback@@3_NA			; bCallingMediaCallback
_BSS	SEGMENT
?bCableFileOpen@@3_NA DB 01H DUP (?)			; bCableFileOpen
	ALIGN	4

?bNvramFileOpen@@3_NA DB 01H DUP (?)			; bNvramFileOpen
	ALIGN	4

?bEmulatorFileOpen@@3_NA DB 01H DUP (?)			; bEmulatorFileOpen
	ALIGN	4

?media_mpe_allocated@@3IA DD 01H DUP (?)		; media_mpe_allocated
?media_mpe@@3IA DD 01H DUP (?)				; media_mpe
?fileModeArray@@3PAIA DD 013H DUP (?)			; fileModeArray
?bCallingMediaCallback@@3_NA DB 01H DUP (?)		; bCallingMediaCallback
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG66926
	ORG $+4
?DeviceInfo@@3PAUMediaDevInfo@@A DD 00H			; DeviceInfo
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	0800H
	DD	00H
	DD	00H
	DD	0180000H
	DD	01H
	DD	00H
	DD	0800H
	DD	00H
	DD	00H
	DD	0180000H
?fileNameArray@@3PAPADA DD FLAT:$SG77698		; fileNameArray
	DD	FLAT:$SG77699
	DD	FLAT:$SG77700
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
$SG66926 DB	'bad allocation', 00H
	ORG $+1
$SG77675 DB	'minibios.cof', 00H
	ORG $+3
$SG77677 DB	'Could not load minibios.cof', 00H
$SG77678 DB	'Missing File!', 00H
	ORG $+2
$SG77680 DB	'minibiosX.cof', 00H
	ORG $+2
$SG77682 DB	'Could not load minibiosX.cof', 00H
	ORG $+3
$SG77683 DB	'Missing File!', 00H
	ORG $+2
$SG77698 DB	'stdin', 00H
	ORG $+2
$SG77699 DB	'stdout', 00H
	ORG $+1
$SG77700 DB	'stderr', 00H
	ORG $+1
$SG77729 DB	'/iso9660/', 00H
	ORG $+2
$SG77732 DB	'/udf/', 00H
	ORG $+2
$SG77781 DB	'rb', 00H
	ORG $+1
$SG77799 DB	'r+b', 00H
$SG77801 DB	'w+b', 00H
CONST	ENDS
PUBLIC	?Halt@MPE@@QAEXXZ				; MPE::Halt
PUBLIC	?MediaShutdownMPE@@YAXPAVMPE@@@Z		; MediaShutdownMPE
EXTRN	?mpeFlags@@3PAIA:BYTE				; mpeFlags
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\media.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
?MediaShutdownMPE@@YAXPAVMPE@@@Z PROC			; MediaShutdownMPE

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :   if(media_mpe_allocated)

	cmp	DWORD PTR ?media_mpe_allocated@@3IA, 0	; media_mpe_allocated
	je	SHORT $LN1@MediaShutd

; 27   :   {
; 28   :     //Halt the media processor
; 29   :     nuonEnv->mpe[media_mpe]->Halt();

	mov	eax, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?Halt@MPE@@QAEXXZ			; MPE::Halt

; 30   :     //Disable commrecv interrupts
; 31   :     nuonEnv->mpe[media_mpe]->inten1 &= ~(INT_COMMRECV);

	mov	edx, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+432]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+432], edx

; 32   :     //Mark as free and clear Mini BIOS flag
; 33   :     mpeFlags[media_mpe] &= ~(MPE_ALLOC_USER | MPE_ALLOC_BIOS | MPE_HAS_MINI_BIOS);

	mov	ecx, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	edx, DWORD PTR ?mpeFlags@@3PAIA[ecx*4]
	and	edx, -50331665				; fcffffefH
	mov	eax, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	DWORD PTR ?mpeFlags@@3PAIA[eax*4], edx

; 34   :     nuonEnv->bProcessorStartStopChange = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+85], 1
$LN1@MediaShutd:

; 35   :   }
; 36   : 
; 37   :   media_mpe_allocated = 0;

	mov	DWORD PTR ?media_mpe_allocated@@3IA, 0	; media_mpe_allocated

; 38   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?MediaShutdownMPE@@YAXPAVMPE@@@Z ENDP			; MediaShutdownMPE
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
_TEXT	ENDS
;	COMDAT ?Halt@MPE@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Halt@MPE@@QAEXXZ PROC					; MPE::Halt, COMDAT
; _this$ = ecx

; 471  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 472  :     mpectl &= ~MPECTRL_MPEGO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], ecx

; 473  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?Halt@MPE@@QAEXXZ ENDP					; MPE::Halt
_TEXT	ENDS
PUBLIC	?MediaInitMPE@@YAXI@Z				; MediaInitMPE
EXTRN	?UpdateInvalidateRegion@MPE@@QAEXII@Z:PROC	; MPE::UpdateInvalidateRegion
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z:PROC		; MPE::LoadCoffFile
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\media.cpp
_TEXT	SEGMENT
_loadStatus$ = -1					; size = 1
_i$ = 8							; size = 4
?MediaInitMPE@@YAXI@Z PROC				; MediaInitMPE

; 41   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 42   :   bool loadStatus = false;

	mov	BYTE PTR _loadStatus$[ebp], 0

; 43   : 
; 44   :   mpeFlags[i] |= (MPE_ALLOC_BIOS | MPE_HAS_MINI_BIOS);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	or	ecx, 33554448				; 02000010H
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?mpeFlags@@3PAIA[edx*4], ecx

; 45   : 
; 46   :   //nuonEnv->mpe[i]->inten1 = INT_COMMRECV;
; 47   : 
; 48   :   //Load the minibios code
; 49   :   if(i == 0)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN7@MediaInitM

; 50   :   {
; 51   :     loadStatus = nuonEnv->mpe[i]->LoadCoffFile("minibios.cof",false);

	push	-1
	push	0
	push	OFFSET $SG77675
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z	; MPE::LoadCoffFile
	mov	BYTE PTR _loadStatus$[ebp], al

; 52   : 
; 53   :     if(!loadStatus)

	movzx	edx, BYTE PTR _loadStatus$[ebp]
	test	edx, edx
	jne	SHORT $LN6@MediaInitM

; 54   :     {
; 55   :       MessageBox(NULL,"Missing File!","Could not load minibios.cof",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG77677
	push	OFFSET $SG77678
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@MediaInitM:

; 56   :     }
; 57   : 
; 58   :     nuonEnv->mpe[i]->intvec1 = MINIBIOS_INTVEC1_HANDLER_ADDRESS;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+412], 540024820		; 20301ff4H

; 59   :     nuonEnv->mpe[i]->intvec2 = MINIBIOS_INTVEC2_HANDLER_ADDRESS;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+416], 540023834		; 20301c1aH

; 60   :   }
; 61   :   else

	jmp	SHORT $LN5@MediaInitM
$LN7@MediaInitM:

; 62   :   {
; 63   :    loadStatus = nuonEnv->mpe[i]->LoadCoffFile("minibiosX.cof",false);

	push	-1
	push	0
	push	OFFSET $SG77680
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?LoadCoffFile@MPE@@QAE_NPAD_NH@Z	; MPE::LoadCoffFile
	mov	BYTE PTR _loadStatus$[ebp], al

; 64   : 
; 65   :     if(!loadStatus)

	movzx	edx, BYTE PTR _loadStatus$[ebp]
	test	edx, edx
	jne	SHORT $LN4@MediaInitM

; 66   :     {
; 67   :       MessageBox(NULL,"Missing File!","Could not load minibiosX.cof",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG77682
	push	OFFSET $SG77683
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@MediaInitM:

; 68   :     }
; 69   : 
; 70   :     nuonEnv->mpe[i]->intvec1 = MINIBIOSX_INTVEC1_HANDLER_ADDRESS;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+412], 540020724		; 20300ff4H

; 71   :     nuonEnv->mpe[i]->intvec2 = MINIBIOSX_INTVEC2_HANDLER_ADDRESS;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+416], 540019730		; 20300c12H
$LN5@MediaInitM:

; 72   :   }
; 73   : 
; 74   :   //Mask interrupts
; 75   :   nuonEnv->mpe[i]->intctl = 0xAA;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+428], 170		; 000000aaH

; 76   :   nuonEnv->mpe[i]->UpdateInvalidateRegion(MPE_IRAM_BASE, OVERLAY_SIZE);

	push	8192					; 00002000H
	push	540016640				; 20300000H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion

; 77   : 
; 78   :   //Set pcexec to the minibios spinwait routine.
; 79   :   if(i == 0)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@MediaInitM

; 80   :   {
; 81   :     nuonEnv->mpe[i]->sp = 0x20101BE0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+464], 537926624		; 20101be0H

; 82   :     nuonEnv->mpe[i]->pcexec = MINIBIOS_ENTRY_POINT;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+408], 540023424		; 20301a80H

; 83   :   }
; 84   :   else

	jmp	SHORT $LN2@MediaInitM
$LN3@MediaInitM:

; 85   :   {
; 86   :     nuonEnv->mpe[i]->pcexec = MINIBIOSX_SPINWAIT_ADDRESS;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+408], 540019402		; 20300acaH
$LN2@MediaInitM:

; 87   :   }
; 88   : 
; 89   :   media_mpe = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?media_mpe@@3IA, edx		; media_mpe

; 90   :   media_mpe_allocated = 1;

	mov	DWORD PTR ?media_mpe_allocated@@3IA, 1	; media_mpe_allocated

; 91   : 
; 92   :   if(!(nuonEnv->mpe[i]->mpectl & MPECTRL_MPEGO))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 2
	jne	SHORT $LN8@MediaInitM

; 93   :   {
; 94   :     nuonEnv->mpe[i]->mpectl |= MPECTRL_MPEGO;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+384]
	or	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edx+384], ecx

; 95   :     nuonEnv->bProcessorStartStopChange = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+85], 1
$LN8@MediaInitM:

; 96   :   }
; 97   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaInitMPE@@YAXI@Z ENDP				; MediaInitMPE
_TEXT	ENDS
PUBLIC	?MediaInitMPE@@YAXPAVMPE@@@Z			; MediaInitMPE
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$77692 = -8						; size = 4
_which$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?MediaInitMPE@@YAXPAVMPE@@@Z PROC			; MediaInitMPE

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 101  :   int32 which;
; 102  :   //Check to see if the media code is already running on an MPE
; 103  :   //in which case don't reallocate it and simply return the index
; 104  :   //of the MPE that it is running on
; 105  : 
; 106  :   if(media_mpe_allocated)

	cmp	DWORD PTR ?media_mpe_allocated@@3IA, 0	; media_mpe_allocated
	je	SHORT $LN5@MediaInitM@2

; 107  :   {
; 108  :     the_mpe->regs[0] = media_mpe;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR ?media_mpe@@3IA		; media_mpe
	mov	DWORD PTR [eax], ecx

; 109  :     return;

	jmp	SHORT $LN6@MediaInitM@2
$LN5@MediaInitM@2:

; 110  :   }
; 111  : 
; 112  :   which = -1;

	mov	DWORD PTR _which$[ebp], -1

; 113  : 
; 114  :   for(uint32 i = 0; i < 4; i++)

	mov	DWORD PTR _i$77692[ebp], 0
	jmp	SHORT $LN4@MediaInitM@2
$LN3@MediaInitM@2:
	mov	edx, DWORD PTR _i$77692[ebp]
	add	edx, 1
	mov	DWORD PTR _i$77692[ebp], edx
$LN4@MediaInitM@2:
	cmp	DWORD PTR _i$77692[ebp], 4
	jae	SHORT $LN2@MediaInitM@2

; 115  :   {
; 116  :     if((mpeFlags[i] & (MPE_ALLOC_BIOS|MPE_ALLOC_USER)) == 0)

	mov	eax, DWORD PTR _i$77692[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	and	ecx, 50331648				; 03000000H
	jne	SHORT $LN1@MediaInitM@2

; 117  :     {
; 118  :         which = i;

	mov	edx, DWORD PTR _i$77692[ebp]
	mov	DWORD PTR _which$[ebp], edx

; 119  :         MediaInitMPE(i);

	mov	eax, DWORD PTR _i$77692[ebp]
	push	eax
	call	?MediaInitMPE@@YAXI@Z			; MediaInitMPE
	add	esp, 4

; 120  :         break;

	jmp	SHORT $LN2@MediaInitM@2
$LN1@MediaInitM@2:

; 121  :     }
; 122  :   }

	jmp	SHORT $LN3@MediaInitM@2
$LN2@MediaInitM@2:

; 123  : 
; 124  :   the_mpe->regs[0] = which;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR _which$[ebp]
	mov	DWORD PTR [ecx], edx
$LN6@MediaInitM@2:

; 125  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaInitMPE@@YAXPAVMPE@@@Z ENDP			; MediaInitMPE
_TEXT	ENDS
PUBLIC	?FindFirstFreeHandle@@YAHXZ			; FindFirstFreeHandle
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
?FindFirstFreeHandle@@YAHXZ PROC			; FindFirstFreeHandle

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 144  :   int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 145  : 
; 146  :   for(i = FIRST_DVD_FD; i <= LAST_DVD_FD; i++)

	mov	DWORD PTR _i$[ebp], 3
	jmp	SHORT $LN4@FindFirstF
$LN3@FindFirstF:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FindFirstF:
	cmp	DWORD PTR _i$[ebp], 19			; 00000013H
	jg	SHORT $LN2@FindFirstF

; 147  :   {
; 148  :     if(!fileNameArray[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?fileNameArray@@3PAPADA[ecx*4], 0
	jne	SHORT $LN1@FindFirstF

; 149  :     {
; 150  :       return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN5@FindFirstF
$LN1@FindFirstF:

; 151  :     }
; 152  :   }

	jmp	SHORT $LN3@FindFirstF
$LN2@FindFirstF:

; 153  : 
; 154  :   return 0;

	xor	eax, eax
$LN5@FindFirstF:

; 155  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindFirstFreeHandle@@YAHXZ ENDP			; FindFirstFreeHandle
_TEXT	ENDS
PUBLIC	?GetDVDBase@NuonEnvironment@@QAEPADXZ		; NuonEnvironment::GetDVDBase
PUBLIC	?MediaOpen@@YAXPAVMPE@@@Z			; MediaOpen
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T79938 = -32						; size = 4
_baseString$ = -28					; size = 4
_bufLength$ = -24					; size = 4
_handle$ = -20						; size = 4
_pBlockSize$ = -16					; size = 4
_mode$ = -12						; size = 4
_name$ = -8						; size = 4
_device$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaOpen@@YAXPAVMPE@@@Z PROC				; MediaOpen

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 159  :   uint32 device = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _device$[ebp], ecx

; 160  :   char *name = (char *)nuonEnv->GetPointerToMemory(mpe,mpe->regs[1]);

	push	1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _name$[ebp], eax

; 161  :   uint32 mode = mpe->regs[2];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _mode$[ebp], eax

; 162  :   uint32 *pBlockSize = (uint32 *)nuonEnv->GetPointerToMemory(mpe,mpe->regs[3]);

	push	1
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBlockSize$[ebp], eax

; 163  :   int32 handle = 0;

	mov	DWORD PTR _handle$[ebp], 0

; 164  :   uint32 bufLength;
; 165  :   char *baseString;
; 166  : 
; 167  :   if((device == MEDIA_BOOT_DEVICE) || (device == MEDIA_DVD))

	cmp	DWORD PTR _device$[ebp], 1
	je	SHORT $LN6@MediaOpen
	cmp	DWORD PTR _device$[ebp], 2
	jne	$LN7@MediaOpen
$LN6@MediaOpen:

; 168  :   {
; 169  :     handle = FindFirstFreeHandle();

	call	?FindFirstFreeHandle@@YAHXZ		; FindFirstFreeHandle
	mov	DWORD PTR _handle$[ebp], eax

; 170  : 
; 171  :     if(handle)

	cmp	DWORD PTR _handle$[ebp], 0
	je	$LN7@MediaOpen

; 172  :     {    
; 173  :       if(pBlockSize)

	cmp	DWORD PTR _pBlockSize$[ebp], 0
	je	SHORT $LN4@MediaOpen

; 174  :       {
; 175  :         *pBlockSize = BLOCK_SIZE_DVD; 

	mov	ecx, DWORD PTR _pBlockSize$[ebp]
	mov	DWORD PTR [ecx], 2048			; 00000800H

; 176  :         SwapScalarBytes(pBlockSize);

	mov	ecx, DWORD PTR _pBlockSize$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes
$LN4@MediaOpen:

; 177  :       }
; 178  : 
; 179  :       baseString = nuonEnv->GetDVDBase();

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetDVDBase@NuonEnvironment@@QAEPADXZ	; NuonEnvironment::GetDVDBase
	mov	DWORD PTR _baseString$[ebp], eax

; 180  : 
; 181  :       //Treat iso9660 device reads as DVD device reads
; 182  :       if(!strncmp("/iso9660/",name,9))

	push	9
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET $SG77729
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@MediaOpen

; 183  :       {
; 184  :         name = &name[9];

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 9
	mov	DWORD PTR _name$[ebp], eax
	jmp	SHORT $LN2@MediaOpen
$LN3@MediaOpen:

; 185  :       }
; 186  :       else if(!strncmp("/udf/",name,5))

	push	5
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET $SG77732
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@MediaOpen

; 187  :       {
; 188  :         name = &name[5];

	mov	edx, DWORD PTR _name$[ebp]
	add	edx, 5
	mov	DWORD PTR _name$[ebp], edx
$LN2@MediaOpen:

; 189  :       }
; 190  : 
; 191  :       bufLength = strlen(name)+strlen(baseString)+1;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _baseString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	lea	edx, DWORD PTR [esi+eax+1]
	mov	DWORD PTR _bufLength$[ebp], edx

; 192  :       fileNameArray[handle] = new char[bufLength];

	mov	eax, DWORD PTR _bufLength$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T79938[ebp], eax
	mov	ecx, DWORD PTR _handle$[ebp]
	mov	edx, DWORD PTR $T79938[ebp]
	mov	DWORD PTR ?fileNameArray@@3PAPADA[ecx*4], edx

; 193  :       strcpy(fileNameArray[handle],baseString);

	mov	eax, DWORD PTR _baseString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	mov	edx, DWORD PTR ?fileNameArray@@3PAPADA[ecx*4]
	push	edx
	call	_strcpy
	add	esp, 8

; 194  :       strcat(fileNameArray[handle],name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	mov	edx, DWORD PTR ?fileNameArray@@3PAPADA[ecx*4]
	push	edx
	call	_strcat
	add	esp, 8

; 195  :       fileModeArray[handle] = mode;

	mov	eax, DWORD PTR _handle$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR ?fileModeArray@@3PAIA[eax*4], ecx
$LN7@MediaOpen:

; 196  :     }
; 197  :   }
; 198  : 
; 199  :   mpe->regs[0] = handle;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _handle$[ebp]
	mov	DWORD PTR [edx], eax

; 200  : }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaOpen@@YAXPAVMPE@@@Z ENDP				; MediaOpen
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\nuonenvironment.h
_TEXT	ENDS
;	COMDAT ?GetDVDBase@NuonEnvironment@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDVDBase@NuonEnvironment@@QAEPADXZ PROC		; NuonEnvironment::GetDVDBase, COMDAT
; _this$ = ecx

; 58   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 59   :     return dvdBase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+124]

; 60   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDVDBase@NuonEnvironment@@QAEPADXZ ENDP		; NuonEnvironment::GetDVDBase
_TEXT	ENDS
PUBLIC	?MediaClose@@YAXPAVMPE@@@Z			; MediaClose
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\media.cpp
_TEXT	SEGMENT
$T79942 = -8						; size = 4
_handle$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaClose@@YAXPAVMPE@@@Z PROC				; MediaClose

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 204  :   int32 handle = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _handle$[ebp], ecx

; 205  : 
; 206  :   if((handle >= FIRST_DVD_FD) && (handle <= LAST_DVD_FD))

	cmp	DWORD PTR _handle$[ebp], 3
	jl	SHORT $LN3@MediaClose
	cmp	DWORD PTR _handle$[ebp], 19		; 00000013H
	jg	SHORT $LN3@MediaClose

; 207  :   {
; 208  :     if(fileNameArray[handle])

	mov	edx, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileNameArray@@3PAPADA[edx*4], 0
	je	SHORT $LN3@MediaClose

; 209  :     {
; 210  :       delete [] fileNameArray[handle];

	mov	eax, DWORD PTR _handle$[ebp]
	mov	ecx, DWORD PTR ?fileNameArray@@3PAPADA[eax*4]
	mov	DWORD PTR $T79942[ebp], ecx
	mov	edx, DWORD PTR $T79942[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 211  :       fileNameArray[handle] = 0;

	mov	eax, DWORD PTR _handle$[ebp]
	mov	DWORD PTR ?fileNameArray@@3PAPADA[eax*4], 0
$LN3@MediaClose:

; 212  :     }
; 213  :   }
; 214  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaClose@@YAXPAVMPE@@@Z ENDP				; MediaClose
_TEXT	ENDS
PUBLIC	?MediaGetDevicesAvailable@@YAXPAVMPE@@@Z	; MediaGetDevicesAvailable
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?MediaGetDevicesAvailable@@YAXPAVMPE@@@Z PROC		; MediaGetDevicesAvailable

; 217  : {

	push	ebp
	mov	ebp, esp

; 218  :   mpe->regs[0] = MEDIA_DEVICES_AVAILABLE;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 3

; 219  : }

	pop	ebp
	ret	0
?MediaGetDevicesAvailable@@YAXPAVMPE@@@Z ENDP		; MediaGetDevicesAvailable
_TEXT	ENDS
PUBLIC	?MediaGetInfo@@YAXPAVMPE@@@Z			; MediaGetInfo
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_id$ = -44						; size = 4
_datarate$ = -32					; size = 4
_sectorsize$ = -20					; size = 4
_result$ = -12						; size = 4
_pDevInfo$ = -8						; size = 4
_handle$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaGetInfo@@YAXPAVMPE@@@Z PROC			; MediaGetInfo

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 223  :   int32 handle = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _handle$[ebp], ecx

; 224  :   void *pDevInfo = (void *)mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _pDevInfo$[ebp], eax

; 225  :   int32 result = -1;

	mov	DWORD PTR _result$[ebp], -1

; 226  :   uint32 sectorsize, datarate, id;
; 227  : 
; 228  :   if(pDevInfo)

	cmp	DWORD PTR _pDevInfo$[ebp], 0
	je	$LN3@MediaGetIn

; 229  :   {
; 230  :     if((handle >= FIRST_DVD_FD) && (handle <= LAST_DVD_FD))

	cmp	DWORD PTR _handle$[ebp], 3
	jl	$LN3@MediaGetIn
	cmp	DWORD PTR _handle$[ebp], 19		; 00000013H
	jg	$LN3@MediaGetIn

; 231  :     {
; 232  :       pDevInfo = nuonEnv->GetPointerToMemory(mpe,(uint32)pDevInfo);

	push	1
	mov	ecx, DWORD PTR _pDevInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pDevInfo$[ebp], eax

; 233  : 
; 234  :       id = handle;

	mov	eax, DWORD PTR _handle$[ebp]
	mov	DWORD PTR _id$[ebp], eax

; 235  :       datarate = DATA_RATE_DVD;

	mov	DWORD PTR _datarate$[ebp], 1572864	; 00180000H

; 236  :       sectorsize = BLOCK_SIZE_DVD;

	mov	DWORD PTR _sectorsize$[ebp], 2048	; 00000800H

; 237  : 
; 238  :       SwapScalarBytes(&sectorsize);

	lea	ecx, DWORD PTR _sectorsize$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 239  :       SwapScalarBytes(&datarate);

	lea	ecx, DWORD PTR _datarate$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 240  :       SwapScalarBytes(&id);          

	lea	ecx, DWORD PTR _id$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 241  : 
; 242  :       ((MediaDevInfo *)pDevInfo)->sectorsize = BLOCK_SIZE_DVD;

	mov	ecx, DWORD PTR _pDevInfo$[ebp]
	mov	DWORD PTR [ecx+8], 2048			; 00000800H

; 243  :       ((MediaDevInfo *)pDevInfo)->datarate = DATA_RATE_DVD;

	mov	edx, DWORD PTR _pDevInfo$[ebp]
	mov	DWORD PTR [edx+20], 1572864		; 00180000H

; 244  :       ((MediaDevInfo *)pDevInfo)->id = handle;

	mov	eax, DWORD PTR _pDevInfo$[ebp]
	mov	ecx, DWORD PTR _handle$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 245  :       ((MediaDevInfo *)pDevInfo)->type = 0;

	mov	edx, DWORD PTR _pDevInfo$[ebp]
	mov	DWORD PTR [edx], 0

; 246  :       ((MediaDevInfo *)pDevInfo)->bus = 0;

	mov	eax, DWORD PTR _pDevInfo$[ebp]
	mov	DWORD PTR [eax+12], 0

; 247  :       ((MediaDevInfo *)pDevInfo)->state = 0;

	mov	ecx, DWORD PTR _pDevInfo$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 248  :       result = 0;

	mov	DWORD PTR _result$[ebp], 0
$LN3@MediaGetIn:

; 249  :     }
; 250  :   }
; 251  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@MediaGetIn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@MediaGetIn:
	DD	3
	DD	$LN8@MediaGetIn
$LN8@MediaGetIn:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@MediaGetIn
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN6@MediaGetIn
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN7@MediaGetIn
$LN7@MediaGetIn:
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$LN6@MediaGetIn:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN5@MediaGetIn:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
?MediaGetInfo@@YAXPAVMPE@@@Z ENDP			; MediaGetInfo
_TEXT	ENDS
PUBLIC	?MediaRead@@YAXPAVMPE@@@Z			; MediaRead
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_fopen:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pBuf$ = -36						; size = 4
_readCount$ = -32					; size = 4
_callback$ = -28					; size = 4
_buffer$ = -24						; size = 4
_blockcount$ = -20					; size = 4
_startblock$ = -16					; size = 4
_mode$ = -12						; size = 4
_handle$ = -8						; size = 4
_inFile$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaRead@@YAXPAVMPE@@@Z PROC				; MediaRead

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 257  :   FILE *inFile;
; 258  :   int32 handle = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _handle$[ebp], ecx

; 259  :   int32 mode = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mode$[ebp], eax

; 260  :   uint32 startblock = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _startblock$[ebp], edx

; 261  :   uint32 blockcount = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _blockcount$[ebp], ecx

; 262  :   uint32 buffer = mpe->regs[4];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _buffer$[ebp], eax

; 263  :   uint32 callback = mpe->regs[5];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _callback$[ebp], edx

; 264  :   uint32 readCount;
; 265  :   void *pBuf;
; 266  : 
; 267  :   mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1

; 268  : 
; 269  :   if((handle >= FIRST_DVD_FD) && (handle <= LAST_DVD_FD))

	cmp	DWORD PTR _handle$[ebp], 3
	jl	$LN6@MediaRead
	cmp	DWORD PTR _handle$[ebp], 19		; 00000013H
	jg	$LN6@MediaRead

; 270  :   {
; 271  :     if(fileNameArray[handle] && buffer && (fileModeArray[handle] != MEDIA_WRITE))

	mov	ecx, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileNameArray@@3PAPADA[ecx*4], 0
	je	$LN6@MediaRead
	cmp	DWORD PTR _buffer$[ebp], 0
	je	$LN6@MediaRead
	mov	edx, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileModeArray@@3PAIA[edx*4], 1
	je	$LN6@MediaRead

; 272  :     {
; 273  :       inFile = fopen(fileNameArray[handle],"rb");

	push	OFFSET $SG77781
	mov	eax, DWORD PTR _handle$[ebp]
	mov	ecx, DWORD PTR ?fileNameArray@@3PAPADA[eax*4]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _inFile$[ebp], eax

; 274  :       if(inFile)

	cmp	DWORD PTR _inFile$[ebp], 0
	je	$LN6@MediaRead

; 275  :       {
; 276  :         pBuf = nuonEnv->GetPointerToMemory(mpe,buffer);

	push	1
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBuf$[ebp], eax

; 277  :         fseek(inFile,startblock*BLOCK_SIZE_DVD,SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _startblock$[ebp]
	shl	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _inFile$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 278  :         readCount = fread(pBuf,BLOCK_SIZE_DVD,blockcount,inFile);

	mov	eax, DWORD PTR _inFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockcount$[ebp]
	push	ecx
	push	2048					; 00000800H
	mov	edx, DWORD PTR _pBuf$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _readCount$[ebp], eax

; 279  :         if(readCount >= (blockcount - 1))

	mov	eax, DWORD PTR _blockcount$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _readCount$[ebp], eax
	jb	SHORT $LN6@MediaRead

; 280  :         {
; 281  :           fclose(inFile);

	mov	ecx, DWORD PTR _inFile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 282  :           mpe->regs[0] = mode;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [edx], eax

; 283  :           mpe->regs[1] = blockcount;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _blockcount$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 284  :           if(callback)

	cmp	DWORD PTR _callback$[ebp], 0
	je	SHORT $LN6@MediaRead

; 285  :           {
; 286  :             mpe->pcexec = callback;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [eax+408], ecx

; 287  :             bCallingMediaCallback = true;

	mov	BYTE PTR ?bCallingMediaCallback@@3_NA, 1 ; bCallingMediaCallback
$LN6@MediaRead:

; 288  :           }
; 289  :         }
; 290  :       }
; 291  :     }
; 292  :   }
; 293  : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaRead@@YAXPAVMPE@@@Z ENDP				; MediaRead
_TEXT	ENDS
PUBLIC	?MediaWrite@@YAXPAVMPE@@@Z			; MediaWrite
EXTRN	_fwrite:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pBuf$ = -36						; size = 4
_writeCount$ = -32					; size = 4
_callback$ = -28					; size = 4
_buffer$ = -24						; size = 4
_blockcount$ = -20					; size = 4
_startblock$ = -16					; size = 4
_mode$ = -12						; size = 4
_handle$ = -8						; size = 4
_outFile$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaWrite@@YAXPAVMPE@@@Z PROC				; MediaWrite

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 297  :   FILE *outFile;
; 298  :   int32 handle = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _handle$[ebp], ecx

; 299  :   int32 mode = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mode$[ebp], eax

; 300  :   uint32 startblock = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _startblock$[ebp], edx

; 301  :   uint32 blockcount = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _blockcount$[ebp], ecx

; 302  :   uint32 buffer = mpe->regs[4];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _buffer$[ebp], eax

; 303  :   uint32 callback = mpe->regs[5];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _callback$[ebp], edx

; 304  :   uint32 writeCount;
; 305  :   void *pBuf;
; 306  : 
; 307  :   mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1

; 308  : 
; 309  :   if((handle >= FIRST_DVD_FD) && (handle <= LAST_DVD_FD))

	cmp	DWORD PTR _handle$[ebp], 3
	jl	$LN7@MediaWrite
	cmp	DWORD PTR _handle$[ebp], 19		; 00000013H
	jg	$LN7@MediaWrite

; 310  :   {
; 311  :     if(fileNameArray[handle] && buffer && (fileModeArray[handle] != MEDIA_READ))

	mov	ecx, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileNameArray@@3PAPADA[ecx*4], 0
	je	$LN7@MediaWrite
	cmp	DWORD PTR _buffer$[ebp], 0
	je	$LN7@MediaWrite
	mov	edx, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileModeArray@@3PAIA[edx*4], 0
	je	$LN7@MediaWrite

; 312  :     {
; 313  :       //try to open the existing file for read/write without erasing the contents
; 314  :       outFile = fopen(fileNameArray[handle],"r+b");

	push	OFFSET $SG77799
	mov	eax, DWORD PTR _handle$[ebp]
	mov	ecx, DWORD PTR ?fileNameArray@@3PAPADA[eax*4]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outFile$[ebp], eax

; 315  :       
; 316  :       if(!outFile)

	cmp	DWORD PTR _outFile$[ebp], 0
	jne	SHORT $LN4@MediaWrite

; 317  :       {
; 318  :         //try to create the file
; 319  :         outFile = fopen(fileNameArray[handle],"w+b");

	push	OFFSET $SG77801
	mov	edx, DWORD PTR _handle$[ebp]
	mov	eax, DWORD PTR ?fileNameArray@@3PAPADA[edx*4]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outFile$[ebp], eax
$LN4@MediaWrite:

; 320  :       }
; 321  : 
; 322  :       if(outFile)

	cmp	DWORD PTR _outFile$[ebp], 0
	je	$LN7@MediaWrite

; 323  :       {
; 324  :         pBuf = nuonEnv->GetPointerToMemory(mpe,buffer);

	push	1
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pBuf$[ebp], eax

; 325  :         fseek(outFile,startblock*BLOCK_SIZE_DVD,SEEK_SET);

	push	0
	mov	eax, DWORD PTR _startblock$[ebp]
	shl	eax, 11					; 0000000bH
	push	eax
	mov	ecx, DWORD PTR _outFile$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 326  :         writeCount = fwrite(pBuf,BLOCK_SIZE_DVD,blockcount,outFile);

	mov	edx, DWORD PTR _outFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _blockcount$[ebp]
	push	eax
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _writeCount$[ebp], eax

; 327  :         if(writeCount >= (blockcount - 1))

	mov	edx, DWORD PTR _blockcount$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _writeCount$[ebp], edx
	jb	SHORT $LN7@MediaWrite

; 328  :         {
; 329  :           fclose(outFile);

	mov	eax, DWORD PTR _outFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 330  :           mpe->regs[0] = mode;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [ecx], edx

; 331  :           mpe->regs[1] = blockcount;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR _blockcount$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 332  :           if(callback)

	cmp	DWORD PTR _callback$[ebp], 0
	je	SHORT $LN7@MediaWrite

; 333  :           {
; 334  :             mpe->pcexec = callback;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [edx+408], eax

; 335  :             bCallingMediaCallback = true;

	mov	BYTE PTR ?bCallingMediaCallback@@3_NA, 1 ; bCallingMediaCallback
$LN7@MediaWrite:

; 336  :           }
; 337  :         }
; 338  :       }
; 339  :     }
; 340  :   }
; 341  : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MediaWrite@@YAXPAVMPE@@@Z ENDP				; MediaWrite
_TEXT	ENDS
PUBLIC	?MediaIoctl@@YAXPAVMPE@@@Z			; MediaIoctl
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv74 = -32						; size = 4
_ctlStr$ = -24						; size = 2
_ptr$ = -16						; size = 4
_value$ = -12						; size = 4
_ctl$ = -8						; size = 4
_handle$ = -4						; size = 4
_mpe$ = 8						; size = 4
?MediaIoctl@@YAXPAVMPE@@@Z PROC				; MediaIoctl

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 345  :   int32 handle = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _handle$[ebp], ecx

; 346  :   int32 ctl = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ctl$[ebp], eax

; 347  :   uint32 value = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _value$[ebp], edx

; 348  :   uint32 *ptr;
; 349  :   char ctlStr[2];
; 350  : 
; 351  :   mpe->regs[0] = -1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -1

; 352  :   ctlStr[0] = '0'+ctl;

	mov	ecx, DWORD PTR _ctl$[ebp]
	add	ecx, 48					; 00000030H
	mov	BYTE PTR _ctlStr$[ebp], cl

; 353  :   ctlStr[1] = 0;

	mov	BYTE PTR _ctlStr$[ebp+1], 0

; 354  : 
; 355  :   if((handle >= FIRST_DVD_FD) && (handle <= LAST_DVD_FD))

	cmp	DWORD PTR _handle$[ebp], 3
	jl	$LN22@MediaIoctl
	cmp	DWORD PTR _handle$[ebp], 19		; 00000013H
	jg	$LN22@MediaIoctl

; 356  :   {
; 357  :     mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0

; 358  : 
; 359  :     if(fileNameArray[handle])

	mov	eax, DWORD PTR _handle$[ebp]
	cmp	DWORD PTR ?fileNameArray@@3PAPADA[eax*4], 0
	je	SHORT $LN22@MediaIoctl

; 360  :     {
; 361  :       switch(ctl)

	mov	ecx, DWORD PTR _ctl$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 14			; 0000000eH
	ja	SHORT $LN1@MediaIoctl
	mov	edx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN27@MediaIoctl[edx*4]
$LN17@MediaIoctl:

; 362  :       {
; 363  :         case MEDIA_IOCTL_SET_MODE:
; 364  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN16@MediaIoctl:

; 365  :         case MEDIA_IOCTL_GET_MODE:
; 366  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN15@MediaIoctl:

; 367  :         case MEDIA_IOCTL_EJECT:
; 368  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN14@MediaIoctl:

; 369  :         case MEDIA_IOCTL_RETRACT:
; 370  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN13@MediaIoctl:

; 371  :         case MEDIA_IOCTL_FLUSH:
; 372  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN12@MediaIoctl:

; 373  :         case MEDIA_IOCTL_GET_DRIVETYPE:
; 374  :           //return kTypeDvdSingle for now, but should really allow the user to declare the disk type
; 375  :           mpe->regs[0] = kTypeDVDSingle;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 2

; 376  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN11@MediaIoctl:

; 377  :         case MEDIA_IOCTL_READ_BCA:
; 378  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN10@MediaIoctl:

; 379  :         case MEDIA_IOCTL_GET_START:
; 380  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN9@MediaIoctl:

; 381  :         case MEDIA_IOCTL_SET_START:
; 382  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN8@MediaIoctl:

; 383  :         case MEDIA_IOCTL_SET_END:
; 384  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN7@MediaIoctl:

; 385  :         case MEDIA_IOCTL_GET_PHYSICAL:
; 386  :           if(value)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN6@MediaIoctl

; 387  :           {
; 388  :             ptr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,value);

	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _ptr$[ebp], eax

; 389  :             //For now, return physical sector zero, but in the future there needs to be some sort
; 390  :             //of TOC to allow for loading from image files in which case the base file sector will
; 391  :             //be non-zero
; 392  :             *ptr = 0;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], 0

; 393  :             SwapScalarBytes(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes
$LN6@MediaIoctl:

; 394  :           }
; 395  :           //return DVD layer 0 (should this be zero-based or one-based?)
; 396  :           mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0

; 397  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN5@MediaIoctl:

; 398  :         case MEDIA_IOCTL_OVERWRITE:
; 399  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN4@MediaIoctl:

; 400  :         case MEDIA_IOCTL_ERASE:
; 401  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN3@MediaIoctl:

; 402  :         case MEDIA_IOCTL_SIZE:
; 403  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN2@MediaIoctl:

; 404  :         case MEDIA_IOCTL_CDDATA_OFFSET:
; 405  :           break;

	jmp	SHORT $LN22@MediaIoctl
$LN1@MediaIoctl:

; 406  :         default:
; 407  :           mpe->regs[0] = -1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1
$LN22@MediaIoctl:

; 408  :           break;
; 409  :       }
; 410  :     }
; 411  :   }
; 412  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@MediaIoctl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN26@MediaIoctl:
	DD	1
	DD	$LN25@MediaIoctl
$LN25@MediaIoctl:
	DD	-24					; ffffffe8H
	DD	2
	DD	$LN24@MediaIoctl
$LN24@MediaIoctl:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
	npad	1
$LN27@MediaIoctl:
	DD	$LN17@MediaIoctl
	DD	$LN16@MediaIoctl
	DD	$LN15@MediaIoctl
	DD	$LN14@MediaIoctl
	DD	$LN13@MediaIoctl
	DD	$LN12@MediaIoctl
	DD	$LN11@MediaIoctl
	DD	$LN10@MediaIoctl
	DD	$LN9@MediaIoctl
	DD	$LN8@MediaIoctl
	DD	$LN7@MediaIoctl
	DD	$LN5@MediaIoctl
	DD	$LN4@MediaIoctl
	DD	$LN3@MediaIoctl
	DD	$LN2@MediaIoctl
?MediaIoctl@@YAXPAVMPE@@@Z ENDP				; MediaIoctl
_TEXT	ENDS
PUBLIC	?SpinWait@@YAXPAVMPE@@@Z			; SpinWait
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pMediaWaiting$ = -20					; size = 4
_status$ = -16						; size = 4
_result$ = -8						; size = 4
_mpe$ = 8						; size = 4
?SpinWait@@YAXPAVMPE@@@Z PROC				; SpinWait

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 416  :   uint32 result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 417  :   uint32 status = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _status$[ebp], ecx

; 418  :   uint32 *pMediaWaiting = (uint32 *)nuonEnv->GetPointerToMemory(mpe,MEDIAWAITING_ADDRESS,false);

	push	0
	push	-2147481596				; 80000804H
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pMediaWaiting$[ebp], eax

; 419  : 
; 420  : 
; 421  :   if((status >> 30) == 0x03)

	mov	eax, DWORD PTR _status$[ebp]
	shr	eax, 30					; 0000001eH
	cmp	eax, 3
	jne	SHORT $LN1@SpinWait

; 422  :   {
; 423  :     result = status;

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR _result$[ebp], ecx
$LN1@SpinWait:

; 424  :   }
; 425  : 
; 426  :   SwapScalarBytes(&result);

	lea	ecx, DWORD PTR _result$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 427  :   *pMediaWaiting = result;

	mov	edx, DWORD PTR _pMediaWaiting$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx], eax

; 428  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SpinWait
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@SpinWait:
	DD	1
	DD	$LN5@SpinWait
$LN5@SpinWait:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@SpinWait
$LN4@SpinWait:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?SpinWait@@YAXPAVMPE@@@Z ENDP				; SpinWait
_TEXT	ENDS
END
