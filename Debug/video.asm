; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\video.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?vdgCLUT@@3PAIA					; vdgCLUT
PUBLIC	?main_write_pixel_type@@3IA			; main_write_pixel_type
PUBLIC	?structMainDisplay@@3UVidDisplay@@A		; structMainDisplay
PUBLIC	?structMainChannelPrev@@3UVidChannel@@A		; structMainChannelPrev
PUBLIC	?render_time@@3MA				; render_time
PUBLIC	?main_fetch_pixel_type@@3IA			; main_fetch_pixel_type
PUBLIC	?structOverlayChannelPrev@@3UVidChannel@@A	; structOverlayChannelPrev
PUBLIC	?structMainDisplayPrev@@3UVidDisplay@@A		; structMainDisplayPrev
PUBLIC	?videoTexInfo@@3UvidTexInfo@@A			; videoTexInfo
PUBLIC	?counter_start@@3T_LARGE_INTEGER@@A		; counter_start
PUBLIC	?shaderProgram@@3PAVShaderProgram@@A		; shaderProgram
PUBLIC	?msg@@3PADA					; msg
PUBLIC	?LuminanceTable@@3PACA				; LuminanceTable
PUBLIC	?structMainChannel@@3UVidChannel@@A		; structMainChannel
PUBLIC	?ChromianceTable@@3PACA				; ChromianceTable
PUBLIC	?counter_end@@3T_LARGE_INTEGER@@A		; counter_end
PUBLIC	?structOverlayChannel@@3UVidChannel@@A		; structOverlayChannel
PUBLIC	?overlay_pixel_type_width@@3IA			; overlay_pixel_type_width
PUBLIC	?overlay_fetch_pixel_type@@3IA			; overlay_fetch_pixel_type
PUBLIC	?overlay_write_pixel_type@@3IA			; overlay_write_pixel_type
PUBLIC	?mainInternalTextureFormat@@3HA			; mainInternalTextureFormat
PUBLIC	?mainExternalTextureFormat@@3HA			; mainExternalTextureFormat
PUBLIC	?mainPixelType@@3HA				; mainPixelType
PUBLIC	?mainTextureUnit@@3HA				; mainTextureUnit
PUBLIC	?osdInternalTextureFormat@@3HA			; osdInternalTextureFormat
PUBLIC	?osdExternalTextureFormat@@3HA			; osdExternalTextureFormat
PUBLIC	?osdTextureUnit@@3HA				; osdTextureUnit
PUBLIC	?bUseBilinearFiltering@@3_NA			; bUseBilinearFiltering
PUBLIC	?mainDisplayBuffer@@3PAEA			; mainDisplayBuffer
PUBLIC	?mainChannelBuffer@@3PAEA			; mainChannelBuffer
PUBLIC	?overlayChannelBuffer@@3PAEA			; overlayChannelBuffer
PUBLIC	?clutPtr@@3PAEA					; clutPtr
PUBLIC	?bMainChannelActive@@3_NA			; bMainChannelActive
PUBLIC	?bOverlayChannelActive@@3_NA			; bOverlayChannelActive
PUBLIC	?bMainTextureCreated@@3_NA			; bMainTextureCreated
PUBLIC	?bOverlayTextureCreated@@3_NA			; bOverlayTextureCreated
PUBLIC	?bCanDisplayVideo@@3_NA				; bCanDisplayVideo
PUBLIC	?channelState@@3IA				; channelState
PUBLIC	?channelStatePrev@@3IA				; channelStatePrev
PUBLIC	?mainChannelScaleX@@3MA				; mainChannelScaleX
PUBLIC	?mainChannelScaleY@@3MA				; mainChannelScaleY
PUBLIC	?overlayChannelScaleX@@3MA			; overlayChannelScaleX
PUBLIC	?overlayChannelScaleY@@3MA			; overlayChannelScaleY
PUBLIC	?ycrcb2rgbColorMatrix@@3PAMA			; ycrcb2rgbColorMatrix
PUBLIC	?ycrcb2rgbGreyscaleColorMatrix@@3PAMA		; ycrcb2rgbGreyscaleColorMatrix
PUBLIC	?transparencyTexture@@3PAEA			; transparencyTexture
PUBLIC	?borderTexture@@3PAEA				; borderTexture
PUBLIC	?lineIncrement@@3IA				; lineIncrement
PUBLIC	?fieldIncrement@@3IA				; fieldIncrement
PUBLIC	?fieldMask@@3IA					; fieldMask
PUBLIC	?clearColorR@@3MA				; clearColorR
PUBLIC	?clearColorG@@3MA				; clearColorG
PUBLIC	?clearColorB@@3MA				; clearColorB
PUBLIC	?bTexturesInitialized@@3_NA			; bTexturesInitialized
PUBLIC	?bMainChannelMemoryAGP@@3_NA			; bMainChannelMemoryAGP
PUBLIC	?bOverlayChannelMemoryAGP@@3_NA			; bOverlayChannelMemoryAGP
PUBLIC	?audioCounter@@3IA				; audioCounter
PUBLIC	?pixTypeToPixWidth@@3PAIA			; pixTypeToPixWidth
_BSS	SEGMENT
?vdgCLUT@@3PAIA DD 0100H DUP (?)			; vdgCLUT
?main_write_pixel_type@@3IA DD 01H DUP (?)		; main_write_pixel_type
?structMainDisplay@@3UVidDisplay@@A DB 028H DUP (?)	; structMainDisplay
?structMainChannelPrev@@3UVidChannel@@A DB 040H DUP (?)	; structMainChannelPrev
?render_time@@3MA DD 01H DUP (?)			; render_time
?main_fetch_pixel_type@@3IA DD 01H DUP (?)		; main_fetch_pixel_type
?structOverlayChannelPrev@@3UVidChannel@@A DB 040H DUP (?) ; structOverlayChannelPrev
?structMainDisplayPrev@@3UVidDisplay@@A DB 028H DUP (?)	; structMainDisplayPrev
?videoTexInfo@@3UvidTexInfo@@A DB 084H DUP (?)		; videoTexInfo
?counter_start@@3T_LARGE_INTEGER@@A DQ 01H DUP (?)	; counter_start
?shaderProgram@@3PAVShaderProgram@@A DD 01H DUP (?)	; shaderProgram
?msg@@3PADA DB	0200H DUP (?)				; msg
?LuminanceTable@@3PACA DB 0100H DUP (?)			; LuminanceTable
?structMainChannel@@3UVidChannel@@A DB 040H DUP (?)	; structMainChannel
?ChromianceTable@@3PACA DB 0100H DUP (?)		; ChromianceTable
	ALIGN	8

?counter_end@@3T_LARGE_INTEGER@@A DQ 01H DUP (?)	; counter_end
?structOverlayChannel@@3UVidChannel@@A DB 040H DUP (?)	; structOverlayChannel
?overlay_pixel_type_width@@3IA DD 01H DUP (?)		; overlay_pixel_type_width
?overlay_fetch_pixel_type@@3IA DD 01H DUP (?)		; overlay_fetch_pixel_type
?overlay_write_pixel_type@@3IA DD 01H DUP (?)		; overlay_write_pixel_type
?bUseBilinearFiltering@@3_NA DB 01H DUP (?)		; bUseBilinearFiltering
	ALIGN	4

?mainDisplayBuffer@@3PAEA DD 01H DUP (?)		; mainDisplayBuffer
?mainChannelBuffer@@3PAEA DD 01H DUP (?)		; mainChannelBuffer
?overlayChannelBuffer@@3PAEA DD 01H DUP (?)		; overlayChannelBuffer
?bMainChannelActive@@3_NA DB 01H DUP (?)		; bMainChannelActive
	ALIGN	4

?bOverlayChannelActive@@3_NA DB 01H DUP (?)		; bOverlayChannelActive
	ALIGN	4

?bMainTextureCreated@@3_NA DB 01H DUP (?)		; bMainTextureCreated
	ALIGN	4

?bOverlayTextureCreated@@3_NA DB 01H DUP (?)		; bOverlayTextureCreated
	ALIGN	4

?bCanDisplayVideo@@3_NA DB 01H DUP (?)			; bCanDisplayVideo
	ALIGN	4

?channelState@@3IA DD 01H DUP (?)			; channelState
?channelStatePrev@@3IA DD 01H DUP (?)			; channelStatePrev
_videoPerfCounter DQ 01H DUP (?)
_videoPerfStart DQ 01H DUP (?)
_videoPerfEnd DQ 01H DUP (?)
_videoPerfFreq DQ 01H DUP (?)
_videoPerfCycleCount DQ 01H DUP (?)
_videoPerfOverhead DQ 01H DUP (?)
?fieldMask@@3IA DD 01H DUP (?)				; fieldMask
?clearColorR@@3MA DD 01H DUP (?)			; clearColorR
?clearColorG@@3MA DD 01H DUP (?)			; clearColorG
?clearColorB@@3MA DD 01H DUP (?)			; clearColorB
?bTexturesInitialized@@3_NA DB 01H DUP (?)		; bTexturesInitialized
	ALIGN	4

?bMainChannelMemoryAGP@@3_NA DB 01H DUP (?)		; bMainChannelMemoryAGP
	ALIGN	4

?bOverlayChannelMemoryAGP@@3_NA DB 01H DUP (?)		; bOverlayChannelMemoryAGP
	ALIGN	4

_lastWidth DD	01H DUP (?)
_lastHeight DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG73725
?mainInternalTextureFormat@@3HA DD 08058H		; mainInternalTextureFormat
?mainExternalTextureFormat@@3HA DD 080e1H		; mainExternalTextureFormat
?mainPixelType@@3HA DD 01401H				; mainPixelType
?mainTextureUnit@@3HA DD 084c0H				; mainTextureUnit
?osdInternalTextureFormat@@3HA DD 08058H		; osdInternalTextureFormat
?osdExternalTextureFormat@@3HA DD 080e1H		; osdExternalTextureFormat
?osdTextureUnit@@3HA DD 084c1H				; osdTextureUnit
?clutPtr@@3PAEA DD FLAT:?vdgCLUT@@3PAIA			; clutPtr
?mainChannelScaleX@@3MA DD 03f800000r		; 1	; mainChannelScaleX
?mainChannelScaleY@@3MA DD 03f800000r		; 1	; mainChannelScaleY
?overlayChannelScaleX@@3MA DD 03f800000r	; 1	; overlayChannelScaleX
?overlayChannelScaleY@@3MA DD 03f800000r	; 1	; overlayChannelScaleY
?lineIncrement@@3IA DD 01H				; lineIncrement
?ycrcb2rgbColorMatrix@@3PAMA DD 03f800000r	; 1	; ycrcb2rgbColorMatrix
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03fb374bcr			; 1.402
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0beae147br			; -0.34
	DD	03fe2d0e5r			; 1.772
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?ycrcb2rgbGreyscaleColorMatrix@@3PAMA DD 03f800000r ; 1	; ycrcb2rgbGreyscaleColorMatrix
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
?transparencyTexture@@3PAEA DB 00H			; transparencyTexture
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
?borderTexture@@3PAEA DB 010H				; borderTexture
	DB	080H
	DB	080H
	DB	00H
	DB	010H
	DB	080H
	DB	080H
	DB	00H
	DB	010H
	DB	080H
	DB	080H
	DB	00H
	DB	010H
	DB	080H
	DB	080H
	DB	00H
?fieldIncrement@@3IA DD 02H				; fieldIncrement
?audioCounter@@3IA DD 03H				; audioCounter
?pixTypeToPixWidth@@3PAIA DD 010H			; pixTypeToPixWidth
	DD	02H
	DD	02H
	DD	02H
	DD	04H
	DD	04H
	DD	08H
_DATA	ENDS
CONST	SEGMENT
$SG73725 DB	'bad allocation', 00H
	ORG $+1
$SG77855 DB	'video_generic.vs', 00H
	ORG $+3
$SG77856 DB	'video_m32_o32.fs', 00H
	ORG $+3
$SG77859 DB	'mainChannelSampler', 00H
	ORG $+1
$SG77860 DB	'overlayChannelSampler', 00H
	ORG $+2
$SG78245 DB	'Invalid Video Pointer', 00H
	ORG $+2
$SG78246 DB	'VidChangeBase was called with a base parameter of 0', 00H
CONST	ENDS
PUBLIC	__real@406fe00000000000
PUBLIC	?CalculateTableEntries@@YAXPAEEE@Z		; CalculateTableEntries
EXTRN	__fltused:DWORD
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT __real@406fe00000000000
; File c:\nuanceexperimental\video.cpp
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv133 = -28						; size = 4
tv131 = -24						; size = 4
tv128 = -18						; size = 2
tv93 = -16						; size = 4
tv91 = -12						; size = 4
_i$77756 = -8						; size = 4
_clampedVal$ = -1					; size = 1
_table$ = 8						; size = 4
_min$ = 12						; size = 1
_max$ = 16						; size = 1
?CalculateTableEntries@@YAXPAEEE@Z PROC			; CalculateTableEntries

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 85   :   uint8 clampedVal;
; 86   : 
; 87   :   for(uint32 i = 0; i < 256; i++)

	mov	DWORD PTR _i$77756[ebp], 0
	jmp	SHORT $LN6@CalculateT
$LN5@CalculateT:
	mov	eax, DWORD PTR _i$77756[ebp]
	add	eax, 1
	mov	DWORD PTR _i$77756[ebp], eax
$LN6@CalculateT:
	cmp	DWORD PTR _i$77756[ebp], 256		; 00000100H
	jae	SHORT $LN4@CalculateT

; 88   :   {
; 89   :     clampedVal = i;

	mov	cl, BYTE PTR _i$77756[ebp]
	mov	BYTE PTR _clampedVal$[ebp], cl

; 90   : 
; 91   :     if(clampedVal < min)

	movzx	edx, BYTE PTR _clampedVal$[ebp]
	movzx	eax, BYTE PTR _min$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@CalculateT

; 92   :     {
; 93   :       clampedVal = min;

	mov	cl, BYTE PTR _min$[ebp]
	mov	BYTE PTR _clampedVal$[ebp], cl
	jmp	SHORT $LN1@CalculateT
$LN3@CalculateT:

; 94   :     }
; 95   :     else if(clampedVal > max)

	movzx	edx, BYTE PTR _clampedVal$[ebp]
	movzx	eax, BYTE PTR _max$[ebp]
	cmp	edx, eax
	jle	SHORT $LN1@CalculateT

; 96   :     {
; 97   :       clampedVal = max;

	mov	cl, BYTE PTR _max$[ebp]
	mov	BYTE PTR _clampedVal$[ebp], cl
$LN1@CalculateT:

; 98   :     }
; 99   : 
; 100  :     table[i] = (uint8)(((double)(clampedVal - min)) * (255.0/(max-min)));

	movzx	edx, BYTE PTR _clampedVal$[ebp]
	movzx	eax, BYTE PTR _min$[ebp]
	sub	edx, eax
	mov	DWORD PTR tv91[ebp], edx
	fild	DWORD PTR tv91[ebp]
	movzx	ecx, BYTE PTR _max$[ebp]
	movzx	edx, BYTE PTR _min$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv93[ebp], ecx
	fild	DWORD PTR tv93[ebp]
	fdivr	QWORD PTR __real@406fe00000000000
	fmulp	ST(1), ST(0)
	fnstcw	WORD PTR tv128[ebp]
	movzx	eax, WORD PTR tv128[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv131[ebp], eax
	fldcw	WORD PTR tv131[ebp]
	fistp	DWORD PTR tv133[ebp]
	fldcw	WORD PTR tv128[ebp]
	mov	al, BYTE PTR tv133[ebp]
	mov	ecx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR _i$77756[ebp]
	mov	BYTE PTR [ecx], al
	jmp	$LN5@CalculateT
$LN4@CalculateT:

; 101  :   }
; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateTableEntries@@YAXPAEEE@Z ENDP			; CalculateTableEntries
_TEXT	ENDS
PUBLIC	__real@bf62d0e5
PUBLIC	__real@3f051eb8
PUBLIC	__real@bf3374bc
PUBLIC	?InitializeYCrCbColorSpace@@YAXXZ		; InitializeYCrCbColorSpace
EXTRN	__imp__glPixelTransferf@8:PROC
EXTRN	__imp__glLoadMatrixf@4:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
;	COMDAT __real@bf62d0e5
CONST	SEGMENT
__real@bf62d0e5 DD 0bf62d0e5r			; -0.886
CONST	ENDS
;	COMDAT __real@3f051eb8
CONST	SEGMENT
__real@3f051eb8 DD 03f051eb8r			; 0.52
CONST	ENDS
;	COMDAT __real@bf3374bc
CONST	SEGMENT
__real@bf3374bc DD 0bf3374bcr			; -0.701
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
_TEXT	SEGMENT
?InitializeYCrCbColorSpace@@YAXXZ PROC			; InitializeYCrCbColorSpace

; 129  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 130  :   if(!nuonEnv->videoOptions.bUseShaders)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	ecx, BYTE PTR [eax+121]
	test	ecx, ecx
	jne	$LN2@Initialize

; 131  :   {
; 132  :     glMatrixMode(GL_COLOR);

	mov	esi, esp
	push	6144					; 00001800H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 133  :     glLoadMatrixf(ycrcb2rgbColorMatrix);

	mov	esi, esp
	push	OFFSET ?ycrcb2rgbColorMatrix@@3PAMA	; ycrcb2rgbColorMatrix
	call	DWORD PTR __imp__glLoadMatrixf@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 134  : 
; 135  :     glPixelTransferf(GL_POST_COLOR_MATRIX_RED_BIAS,-1.402/2.0);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@bf3374bc
	fstp	DWORD PTR [esp]
	push	32952					; 000080b8H
	call	DWORD PTR __imp__glPixelTransferf@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 136  :     glPixelTransferf(GL_POST_COLOR_MATRIX_GREEN_BIAS,(0.70 + 0.34)/2.0);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@3f051eb8
	fstp	DWORD PTR [esp]
	push	32953					; 000080b9H
	call	DWORD PTR __imp__glPixelTransferf@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 137  :     glPixelTransferf(GL_POST_COLOR_MATRIX_BLUE_BIAS,-1.772/2.0);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@bf62d0e5
	fstp	DWORD PTR [esp]
	push	32954					; 000080baH
	call	DWORD PTR __imp__glPixelTransferf@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 138  : 
; 139  :     mainExternalTextureFormat = GL_RGBA;

	mov	DWORD PTR ?mainExternalTextureFormat@@3HA, 6408 ; mainExternalTextureFormat, 00001908H

; 140  :     osdExternalTextureFormat = GL_RGBA;

	mov	DWORD PTR ?osdExternalTextureFormat@@3HA, 6408 ; osdExternalTextureFormat, 00001908H

; 141  :   }
; 142  :   else

	jmp	SHORT $LN1@Initialize
$LN2@Initialize:

; 143  :   {
; 144  :     mainExternalTextureFormat = GL_BGRA;

	mov	DWORD PTR ?mainExternalTextureFormat@@3HA, 32993 ; mainExternalTextureFormat, 000080e1H

; 145  :     osdExternalTextureFormat = GL_BGRA;

	mov	DWORD PTR ?osdExternalTextureFormat@@3HA, 32993 ; osdExternalTextureFormat, 000080e1H
$LN1@Initialize:

; 146  :   }
; 147  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?InitializeYCrCbColorSpace@@YAXXZ ENDP			; InitializeYCrCbColorSpace
_TEXT	ENDS
PUBLIC	?InitializeColorSpaceTables@@YAXXZ		; InitializeColorSpaceTables
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	?tickFrequency@@3T_LARGE_INTEGER@@A:QWORD	; tickFrequency
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$77786 = -4						; size = 4
?InitializeColorSpaceTables@@YAXXZ PROC			; InitializeColorSpaceTables

; 150  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 151  :   CalculateTableEntries((uint8 *)LuminanceTable,16,235);

	push	235					; 000000ebH
	push	16					; 00000010H
	push	OFFSET ?LuminanceTable@@3PACA		; LuminanceTable
	call	?CalculateTableEntries@@YAXPAEEE@Z	; CalculateTableEntries
	add	esp, 12					; 0000000cH

; 152  :   CalculateTableEntries((uint8 *)ChromianceTable,16,240);

	push	240					; 000000f0H
	push	16					; 00000010H
	push	OFFSET ?ChromianceTable@@3PACA		; ChromianceTable
	call	?CalculateTableEntries@@YAXPAEEE@Z	; CalculateTableEntries
	add	esp, 12					; 0000000cH

; 153  : 
; 154  :   for(uint32 i = 0; i < 256; i++)

	mov	DWORD PTR _i$77786[ebp], 0
	jmp	SHORT $LN3@Initialize@2
$LN2@Initialize@2:
	mov	eax, DWORD PTR _i$77786[ebp]
	add	eax, 1
	mov	DWORD PTR _i$77786[ebp], eax
$LN3@Initialize@2:
	cmp	DWORD PTR _i$77786[ebp], 256		; 00000100H
	jae	SHORT $LN1@Initialize@2

; 155  :   {
; 156  :     ((uint32 *)vdgCLUT)[i] = 0x00000000UL;

	mov	ecx, DWORD PTR _i$77786[ebp]
	mov	DWORD PTR ?vdgCLUT@@3PAIA[ecx*4], 0

; 157  :   }

	jmp	SHORT $LN2@Initialize@2
$LN1@Initialize@2:

; 158  : 
; 159  :   QueryPerformanceFrequency(&tickFrequency);

	mov	esi, esp
	push	OFFSET ?tickFrequency@@3T_LARGE_INTEGER@@A ; tickFrequency
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 160  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeColorSpaceTables@@YAXXZ ENDP			; InitializeColorSpaceTables
_TEXT	ENDS
PUBLIC	?AllocateTextureMemory@@YAPAEI_N@Z		; AllocateTextureMemory
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T80457 = -12						; size = 4
$T80456 = -8						; size = 4
_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
_bOverlay$ = 12						; size = 1
?AllocateTextureMemory@@YAPAEI_N@Z PROC			; AllocateTextureMemory

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 178  :   uint8 *ptr = 0;

	mov	DWORD PTR _ptr$[ebp], 0

; 179  : 
; 180  :   if(bOverlay)

	movzx	eax, BYTE PTR _bOverlay$[ebp]
	test	eax, eax
	je	SHORT $LN6@AllocateTe

; 181  :   {
; 182  :     ptr = overlayChannelBuffer;

	mov	ecx, DWORD PTR ?overlayChannelBuffer@@3PAEA ; overlayChannelBuffer
	mov	DWORD PTR _ptr$[ebp], ecx

; 183  : 
; 184  :     if(!overlayChannelBuffer)

	cmp	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer
	jne	SHORT $LN5@AllocateTe

; 185  :     {
; 186  :       bOverlayChannelMemoryAGP = true;

	mov	BYTE PTR ?bOverlayChannelMemoryAGP@@3_NA, 1 ; bOverlayChannelMemoryAGP

; 187  :       //ptr = (uint8 *)wglAllocateMemoryNV(size,0.0,0.5,0.5);
; 188  :       if(!ptr)

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN5@AllocateTe

; 189  :       {
; 190  :         bOverlayChannelMemoryAGP = false;

	mov	BYTE PTR ?bOverlayChannelMemoryAGP@@3_NA, 0 ; bOverlayChannelMemoryAGP

; 191  :         ptr = new uint8[size];

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T80456[ebp], eax
	mov	eax, DWORD PTR $T80456[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 192  :         overlayChannelBuffer = ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR ?overlayChannelBuffer@@3PAEA, ecx ; overlayChannelBuffer
$LN5@AllocateTe:

; 193  :       }
; 194  :     }
; 195  :   }
; 196  :   else

	jmp	SHORT $LN3@AllocateTe
$LN6@AllocateTe:

; 197  :   {
; 198  :     ptr = mainChannelBuffer;

	mov	edx, DWORD PTR ?mainChannelBuffer@@3PAEA ; mainChannelBuffer
	mov	DWORD PTR _ptr$[ebp], edx

; 199  : 
; 200  :     if(!mainChannelBuffer)

	cmp	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer
	jne	SHORT $LN3@AllocateTe

; 201  :     {
; 202  :       bMainChannelMemoryAGP = true;

	mov	BYTE PTR ?bMainChannelMemoryAGP@@3_NA, 1 ; bMainChannelMemoryAGP

; 203  :       //ptr = (uint8 *)wglAllocateMemoryNV(size,0.0,1.0,1.0);
; 204  :       if(!ptr)

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN3@AllocateTe

; 205  :       {
; 206  :         bMainChannelMemoryAGP = false;

	mov	BYTE PTR ?bMainChannelMemoryAGP@@3_NA, 0 ; bMainChannelMemoryAGP

; 207  :         ptr = new uint8[size];

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T80457[ebp], eax
	mov	ecx, DWORD PTR $T80457[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 208  :         mainChannelBuffer = ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR ?mainChannelBuffer@@3PAEA, edx ; mainChannelBuffer
$LN3@AllocateTe:

; 209  :       }
; 210  :     }
; 211  :   }
; 212  : 
; 213  :   return ptr;

	mov	eax, DWORD PTR _ptr$[ebp]

; 214  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocateTextureMemory@@YAPAEI_N@Z ENDP			; AllocateTextureMemory
_TEXT	ENDS
PUBLIC	?FreeTextureMemory@@YAXPAE_N@Z			; FreeTextureMemory
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp____wglewFreeMemoryNV:DWORD
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T80460 = -8						; size = 4
$T80459 = -4						; size = 4
_ptr$ = 8						; size = 4
_bOverlay$ = 12						; size = 1
?FreeTextureMemory@@YAXPAE_N@Z PROC			; FreeTextureMemory

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 218  :   if(bOverlay)

	movzx	eax, BYTE PTR _bOverlay$[ebp]
	test	eax, eax
	je	SHORT $LN8@FreeTextur

; 219  :   {
; 220  :     if(overlayChannelBuffer)

	cmp	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer
	je	SHORT $LN7@FreeTextur

; 221  :     {
; 222  :       if(bOverlayChannelMemoryAGP)

	movzx	ecx, BYTE PTR ?bOverlayChannelMemoryAGP@@3_NA ; bOverlayChannelMemoryAGP
	test	ecx, ecx
	je	SHORT $LN6@FreeTextur

; 223  :       {
; 224  :         wglFreeMemoryNV(ptr);

	mov	esi, esp
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp____wglewFreeMemoryNV
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 225  :         overlayChannelBuffer = 0;

	mov	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer

; 226  :       }
; 227  :       else

	jmp	SHORT $LN7@FreeTextur
$LN6@FreeTextur:

; 228  :       {
; 229  :         delete [] overlayChannelBuffer;

	mov	edx, DWORD PTR ?overlayChannelBuffer@@3PAEA ; overlayChannelBuffer
	mov	DWORD PTR $T80459[ebp], edx
	mov	eax, DWORD PTR $T80459[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 230  :         overlayChannelBuffer = 0;

	mov	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer
$LN7@FreeTextur:

; 231  :       }
; 232  :     }
; 233  :   }
; 234  :   else

	jmp	SHORT $LN9@FreeTextur
$LN8@FreeTextur:

; 235  :   {
; 236  :     if(mainChannelBuffer)

	cmp	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer
	je	SHORT $LN9@FreeTextur

; 237  :     {
; 238  :       if(bMainChannelMemoryAGP)

	movzx	ecx, BYTE PTR ?bMainChannelMemoryAGP@@3_NA ; bMainChannelMemoryAGP
	test	ecx, ecx
	je	SHORT $LN2@FreeTextur

; 239  :       {
; 240  :         wglFreeMemoryNV(ptr);

	mov	esi, esp
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp____wglewFreeMemoryNV
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  :         mainChannelBuffer = 0;

	mov	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer

; 242  :       }
; 243  :       else

	jmp	SHORT $LN9@FreeTextur
$LN2@FreeTextur:

; 244  :       {
; 245  :         delete [] mainChannelBuffer;

	mov	edx, DWORD PTR ?mainChannelBuffer@@3PAEA ; mainChannelBuffer
	mov	DWORD PTR $T80460[ebp], edx
	mov	eax, DWORD PTR $T80460[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 246  :         mainChannelBuffer = 0;

	mov	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer
$LN9@FreeTextur:

; 247  :       }
; 248  :     }
; 249  :   }
; 250  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeTextureMemory@@YAXPAE_N@Z ENDP			; FreeTextureMemory
_TEXT	ENDS
PUBLIC	?UpdateTexCoords@@YAXMMPAM@Z			; UpdateTexCoords
PUBLIC	__real@3f60000000000000
PUBLIC	__real@3f50000000000000
PUBLIC	?GetProgramObject@ShaderProgram@@QAEHXZ		; ShaderProgram::GetProgramObject
PUBLIC	?UpdateTextureStates@@YAXXZ			; UpdateTextureStates
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp__glTexEnvi@12:PROC
EXTRN	__imp__glTexParameteri@12:PROC
EXTRN	__imp__glTexParameterfv@12:PROC
EXTRN	__imp__glDisable@4:PROC
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp____glewActiveTextureARB:DWORD
EXTRN	__imp____glewUniform1iARB:DWORD
EXTRN	__imp____glewGetUniformLocationARB:DWORD
EXTRN	?StartShaderProgram@ShaderProgram@@QAE_NXZ:PROC	; ShaderProgram::StartShaderProgram
EXTRN	?CompileAndLinkShaders@ShaderProgram@@QAE_NXZ:PROC ; ShaderProgram::CompileAndLinkShaders
EXTRN	?AttachShader@ShaderProgram@@QAE_NI@Z:PROC	; ShaderProgram::AttachShader
EXTRN	?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z:PROC ; ShaderProgram::InstallShaderSourceFromFile
EXTRN	?Initialize@ShaderProgram@@QAE_NXZ:PROC		; ShaderProgram::Initialize
EXTRN	??0ShaderProgram@@QAE@XZ:PROC			; ShaderProgram::ShaderProgram
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ?bShadersInstalled@?1??UpdateTextureStates@@YAXXZ@4_NA
_BSS	SEGMENT
?bShadersInstalled@?1??UpdateTextureStates@@YAXXZ@4_NA DB 01H DUP (?) ; `UpdateTextureStates'::`2'::bShadersInstalled
_BSS	ENDS
;	COMDAT __real@3f60000000000000
CONST	SEGMENT
__real@3f60000000000000 DQ 03f60000000000000r	; 0.00195313
CONST	ENDS
;	COMDAT __real@3f50000000000000
CONST	SEGMENT
__real@3f50000000000000 DQ 03f50000000000000r	; 0.000976563
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?UpdateTextureStates@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateTextureStates@@YAXXZ$0
__ehfuncinfo$?UpdateTextureStates@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateTextureStates@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv558 = -72						; size = 4
tv551 = -68						; size = 4
tv479 = -64						; size = 4
tv472 = -60						; size = 4
tv79 = -56						; size = 4
$T80463 = -52						; size = 4
$T80462 = -48						; size = 4
_status$ = -37						; size = 1
_filterType$ = -36					; size = 4
_uniformLoc$ = -32					; size = 4
_yf$ = -28						; size = 4
_y0$ = -24						; size = 4
_xf$ = -20						; size = 4
_x0$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?UpdateTextureStates@@YAXXZ PROC			; UpdateTextureStates

; 259  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateTextureStates@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 260  :   GLfloat x0, xf, y0, yf;
; 261  :   GLint uniformLoc, filterType;
; 262  :   bool status;
; 263  :   static bool bShadersInstalled = false;
; 264  :   uint8 *pBuffer;
; 265  : 
; 266  :   if(bUseBilinearFiltering)

	movzx	eax, BYTE PTR ?bUseBilinearFiltering@@3_NA ; bUseBilinearFiltering
	test	eax, eax
	je	SHORT $LN9@UpdateText

; 267  :   {
; 268  :     filterType = GL_LINEAR;

	mov	DWORD PTR _filterType$[ebp], 9729	; 00002601H

; 269  :   }
; 270  :   else

	jmp	SHORT $LN8@UpdateText
$LN9@UpdateText:

; 271  :   {
; 272  :     filterType = GL_NEAREST;

	mov	DWORD PTR _filterType$[ebp], 9728	; 00002600H
$LN8@UpdateText:

; 273  :   }
; 274  : 
; 275  :   if(!bShadersInstalled && nuonEnv->videoOptions.bUseShaders)

	movzx	ecx, BYTE PTR ?bShadersInstalled@?1??UpdateTextureStates@@YAXXZ@4_NA
	test	ecx, ecx
	jne	$LN5@UpdateText
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+121]
	test	eax, eax
	je	$LN5@UpdateText

; 276  :   {
; 277  :     shaderProgram = new ShaderProgram;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T80463[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T80463[ebp], 0
	je	SHORT $LN12@UpdateText
	mov	ecx, DWORD PTR $T80463[ebp]
	call	??0ShaderProgram@@QAE@XZ		; ShaderProgram::ShaderProgram
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN13@UpdateText
$LN12@UpdateText:
	mov	DWORD PTR tv79[ebp], 0
$LN13@UpdateText:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T80462[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T80462[ebp]
	mov	DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A, edx ; shaderProgram

; 278  : 
; 279  :     shaderProgram->Initialize();

	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?Initialize@ShaderProgram@@QAE_NXZ	; ShaderProgram::Initialize

; 280  :     shaderProgram->InstallShaderSourceFromFile("video_generic.vs",GL_VERTEX_SHADER_ARB);

	push	35633					; 00008b31H
	push	OFFSET $SG77855
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z ; ShaderProgram::InstallShaderSourceFromFile

; 281  :     shaderProgram->InstallShaderSourceFromFile("video_m32_o32.fs",GL_FRAGMENT_SHADER_ARB);

	push	35632					; 00008b30H
	push	OFFSET $SG77856
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?InstallShaderSourceFromFile@ShaderProgram@@QAE_NPADI@Z ; ShaderProgram::InstallShaderSourceFromFile

; 282  :     shaderProgram->AttachShader(GL_VERTEX_SHADER_ARB);

	push	35633					; 00008b31H
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?AttachShader@ShaderProgram@@QAE_NI@Z	; ShaderProgram::AttachShader

; 283  :     shaderProgram->AttachShader(GL_FRAGMENT_SHADER_ARB);

	push	35632					; 00008b30H
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?AttachShader@ShaderProgram@@QAE_NI@Z	; ShaderProgram::AttachShader

; 284  :     status = shaderProgram->CompileAndLinkShaders();

	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?CompileAndLinkShaders@ShaderProgram@@QAE_NXZ ; ShaderProgram::CompileAndLinkShaders
	mov	BYTE PTR _status$[ebp], al

; 285  :     bShadersInstalled = status;

	mov	al, BYTE PTR _status$[ebp]
	mov	BYTE PTR ?bShadersInstalled@?1??UpdateTextureStates@@YAXXZ@4_NA, al

; 286  :     if(status)

	movzx	ecx, BYTE PTR _status$[ebp]
	test	ecx, ecx
	je	$LN5@UpdateText

; 287  :     {
; 288  :       status = shaderProgram->StartShaderProgram();

	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?StartShaderProgram@ShaderProgram@@QAE_NXZ ; ShaderProgram::StartShaderProgram
	mov	BYTE PTR _status$[ebp], al

; 289  :       if(status)

	movzx	edx, BYTE PTR _status$[ebp]
	test	edx, edx
	je	SHORT $LN5@UpdateText

; 290  :       {
; 291  :         uniformLoc = glGetUniformLocationARB(shaderProgram->GetProgramObject(),"mainChannelSampler");

	mov	esi, esp
	push	OFFSET $SG77859
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?GetProgramObject@ShaderProgram@@QAEHXZ	; ShaderProgram::GetProgramObject
	push	eax
	mov	eax, DWORD PTR __imp____glewGetUniformLocationARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _uniformLoc$[ebp], eax

; 292  :         glUniform1iARB(uniformLoc,0);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _uniformLoc$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp____glewUniform1iARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 293  :         uniformLoc = glGetUniformLocationARB(shaderProgram->GetProgramObject(),"overlayChannelSampler");

	mov	esi, esp
	push	OFFSET $SG77860
	mov	ecx, DWORD PTR ?shaderProgram@@3PAVShaderProgram@@A ; shaderProgram
	call	?GetProgramObject@ShaderProgram@@QAEHXZ	; ShaderProgram::GetProgramObject
	push	eax
	mov	edx, DWORD PTR __imp____glewGetUniformLocationARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _uniformLoc$[ebp], eax

; 294  :         glUniform1iARB(uniformLoc,1);

	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR _uniformLoc$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp____glewUniform1iARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@UpdateText:

; 295  :       }
; 296  :     }
; 297  :   }
; 298  : 
; 299  :   bMainTextureCreated = false;

	mov	BYTE PTR ?bMainTextureCreated@@3_NA, 0	; bMainTextureCreated

; 300  :   bOverlayTextureCreated = false;

	mov	BYTE PTR ?bOverlayTextureCreated@@3_NA, 0 ; bOverlayTextureCreated

; 301  : 
; 302  :   glActiveTextureARB(mainTextureUnit);

	mov	esi, esp
	mov	ecx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewActiveTextureARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 303  : 
; 304  :   if(bMainChannelActive)

	movzx	ecx, BYTE PTR ?bMainChannelActive@@3_NA	; bMainChannelActive
	test	ecx, ecx
	je	$LN4@UpdateText

; 305  :   {
; 306  :     x0 = -((float)structMainChannel.dest_xoff * (float)structMainChannel.src_width)/((float)structMainChannel.dest_width);

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+8
	fimul	DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	fchs
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	fstp	DWORD PTR _x0$[ebp]

; 307  :     xf = ((float)(structMainDisplay.dispwidth - structMainChannel.dest_xoff) * (float)structMainChannel.src_width/(float)structMainChannel.dest_width);

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	sub	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+8
	mov	DWORD PTR tv472[ebp], edx
	fild	DWORD PTR tv472[ebp]
	fimul	DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	fstp	DWORD PTR _xf$[ebp]

; 308  :     y0 = ((float)(structMainDisplay.dispheight - structMainChannel.dest_yoff) * (float)structMainChannel.src_height)/((float)structMainChannel.dest_height);

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	sub	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+12
	mov	DWORD PTR tv479[ebp], eax
	fild	DWORD PTR tv479[ebp]
	fimul	DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	fstp	DWORD PTR _y0$[ebp]

; 309  :     yf = -((float)structMainChannel.dest_yoff * (float)structMainChannel.src_height)/((float)structMainChannel.dest_height);

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+12
	fimul	DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	fchs
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	fstp	DWORD PTR _yf$[ebp]

; 310  : 
; 311  : #if (TEXTURE_TARGET == GL_TEXTURE_2D)
; 312  :     x0 = x0 * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));

	fld	DWORD PTR _x0$[ebp]
	fmul	QWORD PTR __real@3f50000000000000
	fstp	DWORD PTR _x0$[ebp]

; 313  :     xf = xf * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));

	fld	DWORD PTR _xf$[ebp]
	fmul	QWORD PTR __real@3f50000000000000
	fstp	DWORD PTR _xf$[ebp]

; 314  :     y0 = y0 * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));

	fld	DWORD PTR _y0$[ebp]
	fmul	QWORD PTR __real@3f60000000000000
	fstp	DWORD PTR _y0$[ebp]

; 315  :     yf = yf * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));   

	fld	DWORD PTR _yf$[ebp]
	fmul	QWORD PTR __real@3f60000000000000
	fstp	DWORD PTR _yf$[ebp]

; 316  : #endif
; 317  :     
; 318  :     //pBuffer = (uint8 *)mainChannelBuffer;
; 319  :     //for(uint32 i = 0; i < (ALLOCATED_TEXTURE_WIDTH * ALLOCATED_TEXTURE_HEIGHT); i++)
; 320  :     //{
; 321  :     //  pBuffer[0] = videoTexInfo.borderColor[0];
; 322  :     //  pBuffer[1] = videoTexInfo.borderColor[1];
; 323  :     //  pBuffer[2] = videoTexInfo.borderColor[2];
; 324  :     //  pBuffer[3] = videoTexInfo.borderColor[3];
; 325  :     //  pBuffer += 4;
; 326  :     //}
; 327  : 
; 328  :     UpdateTexCoords(x0,y0,&videoTexInfo.mainTexCoords[0]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+68
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 329  :     UpdateTexCoords(x0,yf,&videoTexInfo.mainTexCoords[2]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+76
	push	ecx
	fld	DWORD PTR _yf$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 330  :     UpdateTexCoords(xf,yf,&videoTexInfo.mainTexCoords[4]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+84
	push	ecx
	fld	DWORD PTR _yf$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xf$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 331  :     UpdateTexCoords(xf,y0,&videoTexInfo.mainTexCoords[6]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+92
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xf$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 332  : 
; 333  :     glEnable(TEXTURE_TARGET);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 334  :     glBindTexture(TEXTURE_TARGET, videoTexInfo.mainTexName);

	mov	esi, esp
	mov	ecx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+20
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 335  :     //glTexImage2D(TEXTURE_TARGET,0,mainInternalTextureFormat,ALLOCATED_TEXTURE_WIDTH,ALLOCATED_TEXTURE_HEIGHT,0,mainExternalTextureFormat,GL_UNSIGNED_BYTE,mainChannelBuffer);
; 336  :   }
; 337  :   else

	jmp	SHORT $LN3@UpdateText
$LN4@UpdateText:

; 338  :   {
; 339  :     //x0 = 0.0;
; 340  :     //xf = 1.0;
; 341  :     //y0 = 1.0;
; 342  :     //yf = 0.0;
; 343  : 
; 344  : #if (TEXTURE_TARGET == GL_TEXTURE_2D)
; 345  :     //x0 = x0 * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));
; 346  :     //xf = xf * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));
; 347  :     //y0 = y0 * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));
; 348  :     //yf = yf * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));   
; 349  : #endif
; 350  : 
; 351  :     //UpdateTexCoords(x0,y0,&videoTexInfo.mainTexCoords[0]);
; 352  :     //UpdateTexCoords(x0,yf,&videoTexInfo.mainTexCoords[2]);
; 353  :     //UpdateTexCoords(xf,yf,&videoTexInfo.mainTexCoords[4]);
; 354  :     //UpdateTexCoords(xf,y0,&videoTexInfo.mainTexCoords[6]);
; 355  : 
; 356  :     glBindTexture(TEXTURE_TARGET, videoTexInfo.borderTexName);

	mov	esi, esp
	mov	edx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+28
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 357  :     glTexImage2D(TEXTURE_TARGET,0,mainInternalTextureFormat,2,2,0,mainExternalTextureFormat,GL_UNSIGNED_BYTE,borderTexture);

	mov	esi, esp
	push	OFFSET ?borderTexture@@3PAEA		; borderTexture
	push	5121					; 00001401H
	mov	eax, DWORD PTR ?mainExternalTextureFormat@@3HA ; mainExternalTextureFormat
	push	eax
	push	0
	push	2
	push	2
	mov	ecx, DWORD PTR ?mainInternalTextureFormat@@3HA ; mainInternalTextureFormat
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 358  :     glDisable(TEXTURE_TARGET);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glDisable@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@UpdateText:

; 359  :   }
; 360  : 
; 361  :   glTexParameterfv(TEXTURE_TARGET, GL_TEXTURE_BORDER_COLOR, videoTexInfo.borderColor);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+36
	push	4100					; 00001004H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterfv@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 362  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER_ARB);

	mov	esi, esp
	push	33069					; 0000812dH
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 363  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER_ARB);

	mov	esi, esp
	push	33069					; 0000812dH
	push	10243					; 00002803H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 364  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_MIN_FILTER, filterType);

	mov	esi, esp
	mov	edx, DWORD PTR _filterType$[ebp]
	push	edx
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 365  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_MAG_FILTER, filterType);

	mov	esi, esp
	mov	eax, DWORD PTR _filterType$[ebp]
	push	eax
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 366  :   glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	mov	esi, esp
	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR __imp__glTexEnvi@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 367  : 
; 368  :   glActiveTextureARB(GL_TEXTURE1_ARB);

	mov	esi, esp
	push	33985					; 000084c1H
	mov	ecx, DWORD PTR __imp____glewActiveTextureARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 369  : 
; 370  :   if(bOverlayChannelActive)

	movzx	eax, BYTE PTR ?bOverlayChannelActive@@3_NA ; bOverlayChannelActive
	test	eax, eax
	je	$LN2@UpdateText

; 371  :   {
; 372  :     x0 = -((float)structOverlayChannel.dest_xoff * (float)structOverlayChannel.src_width)/((float)structOverlayChannel.dest_width);

	fild	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+8
	fimul	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	fchs
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16
	fstp	DWORD PTR _x0$[ebp]

; 373  :     xf = ((float)(structMainDisplay.dispwidth - structOverlayChannel.dest_xoff) * (float)structOverlayChannel.src_width/(float)structOverlayChannel.dest_width);

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	sub	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+8
	mov	DWORD PTR tv551[ebp], ecx
	fild	DWORD PTR tv551[ebp]
	fimul	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16
	fstp	DWORD PTR _xf$[ebp]

; 374  :     y0 = ((float)(structMainDisplay.dispheight - structOverlayChannel.dest_yoff) * (float)structOverlayChannel.src_height)/((float)structOverlayChannel.dest_height);

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	sub	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+12
	mov	DWORD PTR tv558[ebp], edx
	fild	DWORD PTR tv558[ebp]
	fimul	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20
	fstp	DWORD PTR _y0$[ebp]

; 375  :     yf = -((float)structOverlayChannel.dest_yoff * (float)structOverlayChannel.src_height)/((float)structOverlayChannel.dest_height);

	fild	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+12
	fimul	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	fchs
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20
	fstp	DWORD PTR _yf$[ebp]

; 376  : 
; 377  : #if (TEXTURE_TARGET == GL_TEXTURE_2D)
; 378  :     x0 = x0 * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));

	fld	DWORD PTR _x0$[ebp]
	fmul	QWORD PTR __real@3f50000000000000
	fstp	DWORD PTR _x0$[ebp]

; 379  :     xf = xf * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));

	fld	DWORD PTR _xf$[ebp]
	fmul	QWORD PTR __real@3f50000000000000
	fstp	DWORD PTR _xf$[ebp]

; 380  :     y0 = y0 * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));

	fld	DWORD PTR _y0$[ebp]
	fmul	QWORD PTR __real@3f60000000000000
	fstp	DWORD PTR _y0$[ebp]

; 381  :     yf = yf * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));

	fld	DWORD PTR _yf$[ebp]
	fmul	QWORD PTR __real@3f60000000000000
	fstp	DWORD PTR _yf$[ebp]

; 382  : #endif
; 383  : 
; 384  :     UpdateTexCoords(x0,y0,&videoTexInfo.osdTexCoords[0]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+100
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 385  :     UpdateTexCoords(x0,yf,&videoTexInfo.osdTexCoords[2]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+108
	push	ecx
	fld	DWORD PTR _yf$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 386  :     UpdateTexCoords(xf,yf,&videoTexInfo.osdTexCoords[4]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+116
	push	ecx
	fld	DWORD PTR _yf$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xf$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 387  :     UpdateTexCoords(xf,y0,&videoTexInfo.osdTexCoords[6]);

	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+124
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xf$[ebp]
	fstp	DWORD PTR [esp]
	call	?UpdateTexCoords@@YAXMMPAM@Z		; UpdateTexCoords
	add	esp, 12					; 0000000cH

; 388  : 
; 389  :     //pBuffer = (uint8 *)overlayChannelBuffer;
; 390  :     //for(uint32 i = 0; i < (ALLOCATED_TEXTURE_WIDTH * ALLOCATED_TEXTURE_HEIGHT); i++)
; 391  :     //{
; 392  :     //  pBuffer[0] = videoTexInfo.transColor[0];
; 393  :     //  pBuffer[1] = videoTexInfo.transColor[1];
; 394  :     //  pBuffer[2] = videoTexInfo.transColor[2];
; 395  :     //  pBuffer[3] = videoTexInfo.transColor[3];
; 396  :     //  pBuffer += 4;
; 397  :     //}
; 398  : 
; 399  :     glEnable(TEXTURE_TARGET);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 400  :     glBindTexture(TEXTURE_TARGET, videoTexInfo.osdTexName);

	mov	esi, esp
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+24
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 401  :     //glTexImage2D(TEXTURE_TARGET,0,osdInternalTextureFormat,ALLOCATED_TEXTURE_WIDTH,ALLOCATED_TEXTURE_HEIGHT,0,osdExternalTextureFormat,GL_UNSIGNED_BYTE,overlayChannelBuffer);
; 402  :   }
; 403  :   else

	jmp	SHORT $LN1@UpdateText
$LN2@UpdateText:

; 404  :   {
; 405  :     //x0 = 0.0;
; 406  :     //y0 = 1.0;
; 407  :     //xf = 1.0;
; 408  :     //yf = 0.0;
; 409  : 
; 410  : #if (TEXTURE_TARGET == GL_TEXTURE_2D)
; 411  :     //x0 = x0 * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));
; 412  :     //xf = xf * (1.0/((float)ALLOCATED_TEXTURE_WIDTH));
; 413  :     //y0 = y0 * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));
; 414  :     //yf = yf * (1.0/((float)ALLOCATED_TEXTURE_HEIGHT));
; 415  : #endif
; 416  : 
; 417  :     //UpdateTexCoords(x0,y0,&videoTexInfo.osdTexCoords[0]);
; 418  :     //UpdateTexCoords(x0,yf,&videoTexInfo.osdTexCoords[2]);
; 419  :     //UpdateTexCoords(xf,yf,&videoTexInfo.osdTexCoords[4]);
; 420  :     //UpdateTexCoords(xf,y0,&videoTexInfo.osdTexCoords[6]);
; 421  : 
; 422  :     glBindTexture(TEXTURE_TARGET, videoTexInfo.transparencyTexName);

	mov	esi, esp
	mov	ecx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+32
	push	ecx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 423  :     glTexImage2D(TEXTURE_TARGET,0,osdInternalTextureFormat,2,2,0,osdExternalTextureFormat,GL_UNSIGNED_BYTE,transparencyTexture);

	mov	esi, esp
	push	OFFSET ?transparencyTexture@@3PAEA	; transparencyTexture
	push	5121					; 00001401H
	mov	edx, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	edx
	push	0
	push	2
	push	2
	mov	eax, DWORD PTR ?osdInternalTextureFormat@@3HA ; osdInternalTextureFormat
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 424  :     glDisable(TEXTURE_TARGET);

	mov	esi, esp
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glDisable@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@UpdateText:

; 425  :   }
; 426  : 
; 427  :   glTexParameterfv(TEXTURE_TARGET, GL_TEXTURE_BORDER_COLOR, videoTexInfo.transColor);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+52
	push	4100					; 00001004H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameterfv@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 428  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER_ARB);

	mov	esi, esp
	push	33069					; 0000812dH
	push	10242					; 00002802H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 429  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER_ARB);

	mov	esi, esp
	push	33069					; 0000812dH
	push	10243					; 00002803H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 430  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_MIN_FILTER, filterType);

	mov	esi, esp
	mov	ecx, DWORD PTR _filterType$[ebp]
	push	ecx
	push	10241					; 00002801H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 431  :   glTexParameteri(TEXTURE_TARGET, GL_TEXTURE_MAG_FILTER, filterType);

	mov	esi, esp
	mov	edx, DWORD PTR _filterType$[ebp]
	push	edx
	push	10240					; 00002800H
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexParameteri@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 432  :   glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);

	mov	esi, esp
	push	8449					; 00002101H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR __imp__glTexEnvi@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 433  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdateTextureStates@@YAXXZ$0:
	mov	eax, DWORD PTR $T80463[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?UpdateTextureStates@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateTextureStates@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateTextureStates@@YAXXZ ENDP			; UpdateTextureStates
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\shaderprogram.h
;	COMDAT ?GetProgramObject@ShaderProgram@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProgramObject@ShaderProgram@@QAEHXZ PROC		; ShaderProgram::GetProgramObject, COMDAT
; _this$ = ecx

; 27   :   GLhandleARB GetProgramObject() { return hProgramObject; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetProgramObject@ShaderProgram@@QAEHXZ ENDP		; ShaderProgram::GetProgramObject
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\video.cpp
_TEXT	ENDS
;	COMDAT ?UpdateTexCoords@@YAXMMPAM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_buffer$ = 16						; size = 4
?UpdateTexCoords@@YAXMMPAM@Z PROC			; UpdateTexCoords, COMDAT

; 253  : {

	push	ebp
	mov	ebp, esp

; 254  :   buffer[0] = x;

	mov	eax, DWORD PTR _buffer$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax]

; 255  :   buffer[1] = y;

	mov	ecx, DWORD PTR _buffer$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [ecx+4]

; 256  : }

	pop	ebp
	ret	0
?UpdateTexCoords@@YAXMMPAM@Z ENDP			; UpdateTexCoords
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@00000000
PUBLIC	?UpdateDisplayList@@YAXXZ			; UpdateDisplayList
EXTRN	__imp__glEndList@0:PROC
EXTRN	__imp__glEnd@0:PROC
EXTRN	__imp__glVertex2f@8:PROC
EXTRN	__imp____glewMultiTexCoord2fvARB:DWORD
EXTRN	__imp__glBegin@4:PROC
EXTRN	__imp__glNewList@8:PROC
EXTRN	__imp__glGenLists@4:PROC
EXTRN	__imp__glIsList@4:PROC
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
_TEXT	SEGMENT
?UpdateDisplayList@@YAXXZ PROC				; UpdateDisplayList

; 436  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 437  :   if(!glIsList(videoTexInfo.displayListName[0]))

	mov	esi, esp
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+4
	push	eax
	call	DWORD PTR __imp__glIsList@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@UpdateDisp

; 438  :   {
; 439  :     videoTexInfo.displayListName[0] = glGenLists(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__glGenLists@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+4, eax

; 440  :     videoTexInfo.displayListName[1] = glGenLists(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__glGenLists@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+8, eax

; 441  :     videoTexInfo.displayListName[2] = glGenLists(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__glGenLists@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+12, eax

; 442  :     videoTexInfo.displayListName[3] = glGenLists(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__glGenLists@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+16, eax
$LN8@UpdateDisp:

; 443  :   }
; 444  : 
; 445  :   if(channelState == (CHANNELSTATE_MAIN_ACTIVE|CHANNELSTATE_OVERLAY_ACTIVE))

	cmp	DWORD PTR ?channelState@@3IA, 3		; channelState
	jne	$LN7@UpdateDisp

; 446  :   {
; 447  :     glNewList(videoTexInfo.displayListName[CHANNELSTATE_MAIN_ACTIVE|CHANNELSTATE_OVERLAY_ACTIVE],GL_COMPILE);

	mov	esi, esp
	push	4864					; 00001300H
	mov	edx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+16
	push	edx
	call	DWORD PTR __imp__glNewList@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 448  :     glBegin(GL_QUADS);

	mov	esi, esp
	push	7
	call	DWORD PTR __imp__glBegin@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 449  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[0]);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+68
	mov	eax, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 450  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[0]);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+100
	mov	eax, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 451  :     glVertex2f(0.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 452  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[2]);

	mov	eax, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+76
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 453  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[2]);

	mov	ecx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+108
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 454  :     glVertex2f(0.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 455  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[4]);

	mov	edx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+84
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 456  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[4]);

	mov	eax, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+116
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 457  :     glVertex2f(1.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 458  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[6]);

	mov	ecx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+92
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 459  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[6]);

	mov	edx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+124
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 460  :     glVertex2f(1.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 461  :     glEnd();

	mov	esi, esp
	call	DWORD PTR __imp__glEnd@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :     glEndList();

	mov	esi, esp
	call	DWORD PTR __imp__glEndList@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN1@UpdateDisp
$LN7@UpdateDisp:

; 463  :   }
; 464  :   else if(channelState == CHANNELSTATE_OVERLAY_ACTIVE)

	cmp	DWORD PTR ?channelState@@3IA, 2		; channelState
	jne	$LN5@UpdateDisp

; 465  :   {
; 466  :     glNewList(videoTexInfo.displayListName[CHANNELSTATE_OVERLAY_ACTIVE],GL_COMPILE);

	mov	esi, esp
	push	4864					; 00001300H
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+12
	push	eax
	call	DWORD PTR __imp__glNewList@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 467  :     glBegin(GL_QUADS);

	mov	esi, esp
	push	7
	call	DWORD PTR __imp__glBegin@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 468  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[0]);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+100
	mov	ecx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 469  :     glVertex2f(0.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 470  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[2]);

	mov	ecx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+108
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 471  :     glVertex2f(0.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 472  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[4]);

	mov	edx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+116
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  :     glVertex2f(1.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 474  :     glMultiTexCoord2fvARB(osdTextureUnit, &videoTexInfo.osdTexCoords[6]);

	mov	eax, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+124
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 475  :     glVertex2f(1.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 476  :     glEnd();

	mov	esi, esp
	call	DWORD PTR __imp__glEnd@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 477  :     glEndList();

	mov	esi, esp
	call	DWORD PTR __imp__glEndList@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN1@UpdateDisp
$LN5@UpdateDisp:

; 478  :   }
; 479  :   else if(channelState == CHANNELSTATE_MAIN_ACTIVE)

	cmp	DWORD PTR ?channelState@@3IA, 1		; channelState
	jne	$LN3@UpdateDisp

; 480  :   {
; 481  :     glNewList(videoTexInfo.displayListName[CHANNELSTATE_MAIN_ACTIVE],GL_COMPILE);

	mov	esi, esp
	push	4864					; 00001300H
	mov	ecx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+8
	push	ecx
	call	DWORD PTR __imp__glNewList@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 482  :     glBegin(GL_QUADS);

	mov	esi, esp
	push	7
	call	DWORD PTR __imp__glBegin@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 483  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[0]);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+68
	mov	edx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 484  :     glVertex2f(0.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 485  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[2]);

	mov	edx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+76
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 486  :     glVertex2f(0.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 487  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[4]);

	mov	eax, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+84
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	ecx
	mov	edx, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 488  :     glVertex2f(1.0,1.0);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 489  :     glMultiTexCoord2fvARB(mainTextureUnit, &videoTexInfo.mainTexCoords[6]);

	mov	ecx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+92
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewMultiTexCoord2fvARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 490  :     glVertex2f(1.0,0.0);

	mov	esi, esp
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex2f@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 491  :     glEnd();

	mov	esi, esp
	call	DWORD PTR __imp__glEnd@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 492  :     glEndList();

	mov	esi, esp
	call	DWORD PTR __imp__glEndList@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN1@UpdateDisp
$LN3@UpdateDisp:

; 493  :   }
; 494  :   else if(channelState == 0)

	cmp	DWORD PTR ?channelState@@3IA, 0		; channelState
	jne	SHORT $LN1@UpdateDisp

; 495  :   {
; 496  :     glNewList(videoTexInfo.displayListName[0],GL_COMPILE);

	mov	esi, esp
	push	4864					; 00001300H
	mov	edx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+4
	push	edx
	call	DWORD PTR __imp__glNewList@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 497  :     glBegin(GL_QUADS);

	mov	esi, esp
	push	7
	call	DWORD PTR __imp__glBegin@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 498  :     glEnd();

	mov	esi, esp
	call	DWORD PTR __imp__glEnd@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 499  :     glEndList();

	mov	esi, esp
	call	DWORD PTR __imp__glEndList@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@UpdateDisp:

; 500  :   }
; 501  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?UpdateDisplayList@@YAXXZ ENDP				; UpdateDisplayList
_TEXT	ENDS
PUBLIC	?InitTextures@@YAXXZ				; InitTextures
EXTRN	__imp____glewActiveTexture:DWORD
EXTRN	__imp__glGenTextures@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv248 = -32						; size = 4
tv244 = -28						; size = 4
tv240 = -24						; size = 4
tv236 = -20						; size = 4
tv232 = -16						; size = 4
tv228 = -12						; size = 4
tv224 = -8						; size = 4
tv188 = -4						; size = 4
?InitTextures@@YAXXZ PROC				; InitTextures

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 505  :   videoTexInfo.borderColor[0] = ((GLfloat)borderTexture[0]) / 255.0;

	movzx	eax, BYTE PTR ?borderTexture@@3PAEA
	mov	DWORD PTR tv188[ebp], eax
	fild	DWORD PTR tv188[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+36

; 506  :   videoTexInfo.borderColor[1] = ((GLfloat)borderTexture[1]) / 255.0;

	movzx	ecx, BYTE PTR ?borderTexture@@3PAEA+1
	mov	DWORD PTR tv224[ebp], ecx
	fild	DWORD PTR tv224[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+40

; 507  :   videoTexInfo.borderColor[2] = ((GLfloat)borderTexture[2]) / 255.0;

	movzx	edx, BYTE PTR ?borderTexture@@3PAEA+2
	mov	DWORD PTR tv228[ebp], edx
	fild	DWORD PTR tv228[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+44

; 508  :   videoTexInfo.borderColor[3] = ((GLfloat)borderTexture[3]) / 255.0;

	movzx	eax, BYTE PTR ?borderTexture@@3PAEA+3
	mov	DWORD PTR tv232[ebp], eax
	fild	DWORD PTR tv232[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+48

; 509  :   videoTexInfo.transColor[0] = ((GLfloat)transparencyTexture[0]) / 255.0;

	movzx	ecx, BYTE PTR ?transparencyTexture@@3PAEA
	mov	DWORD PTR tv236[ebp], ecx
	fild	DWORD PTR tv236[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+52

; 510  :   videoTexInfo.transColor[1] = ((GLfloat)transparencyTexture[1]) / 255.0;

	movzx	edx, BYTE PTR ?transparencyTexture@@3PAEA+1
	mov	DWORD PTR tv240[ebp], edx
	fild	DWORD PTR tv240[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+56

; 511  :   videoTexInfo.transColor[2] = ((GLfloat)transparencyTexture[2]) / 255.0;

	movzx	eax, BYTE PTR ?transparencyTexture@@3PAEA+2
	mov	DWORD PTR tv244[ebp], eax
	fild	DWORD PTR tv244[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+60

; 512  :   videoTexInfo.transColor[3] = ((GLfloat)transparencyTexture[3]) / 255.0;

	movzx	ecx, BYTE PTR ?transparencyTexture@@3PAEA+3
	mov	DWORD PTR tv248[ebp], ecx
	fild	DWORD PTR tv248[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+64

; 513  :   glGenTextures(1,&videoTexInfo.mainTexName);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+20
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 514  :   glGenTextures(1,&videoTexInfo.osdTexName);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+24
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 515  :   glGenTextures(1,&videoTexInfo.borderTexName);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+28
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 516  :   glGenTextures(1,&videoTexInfo.transparencyTexName);

	mov	esi, esp
	push	OFFSET ?videoTexInfo@@3UvidTexInfo@@A+32
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 517  :   
; 518  :   glActiveTexture(mainTextureUnit);

	mov	esi, esp
	mov	edx, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewActiveTexture
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 519  :   glBindTexture(TEXTURE_TARGET, videoTexInfo.borderTexName);

	mov	esi, esp
	mov	edx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+28
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 520  :   glTexImage2D(TEXTURE_TARGET, 0, mainInternalTextureFormat, 2, 2, 0, mainExternalTextureFormat, GL_UNSIGNED_BYTE, borderTexture);

	mov	esi, esp
	push	OFFSET ?borderTexture@@3PAEA		; borderTexture
	push	5121					; 00001401H
	mov	eax, DWORD PTR ?mainExternalTextureFormat@@3HA ; mainExternalTextureFormat
	push	eax
	push	0
	push	2
	push	2
	mov	ecx, DWORD PTR ?mainInternalTextureFormat@@3HA ; mainInternalTextureFormat
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 521  :   glActiveTextureARB(osdTextureUnit);

	mov	esi, esp
	mov	edx, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	edx
	mov	eax, DWORD PTR __imp____glewActiveTextureARB
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 522  :   glBindTexture(TEXTURE_TARGET, videoTexInfo.transparencyTexName);

	mov	esi, esp
	mov	edx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+32
	push	edx
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 523  :   glTexImage2D(TEXTURE_TARGET, 0, osdExternalTextureFormat, 2, 2, 0, osdExternalTextureFormat, GL_UNSIGNED_BYTE, transparencyTexture);

	mov	esi, esp
	push	OFFSET ?transparencyTexture@@3PAEA	; transparencyTexture
	push	5121					; 00001401H
	mov	eax, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	eax
	push	0
	push	2
	push	2
	mov	ecx, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 524  : 
; 525  :   UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates

; 526  :   UpdateDisplayList();

	call	?UpdateDisplayList@@YAXXZ		; UpdateDisplayList

; 527  : 
; 528  :   videoTexInfo.bUpdateDisplayList = false;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 0

; 529  : }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitTextures@@YAXXZ ENDP				; InitTextures
_TEXT	ENDS
PUBLIC	?RenderVideo_Type4@@YAXPAE0II_N@Z		; RenderVideo_Type4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_A$ = -16						; size = 1
_CB$ = -15						; size = 1
_CR$ = -14						; size = 1
_Y$ = -13						; size = 1
_colCount$ = -12					; size = 4
_rowCount$ = -8						; size = 4
_pixel$ = -4						; size = 4
_pDestBuffer$ = 8					; size = 4
_pSrcBuffer$ = 12					; size = 4
_maxRow$ = 16						; size = 4
_maxCol$ = 20						; size = 4
_bOverlay$ = 24						; size = 1
?RenderVideo_Type4@@YAXPAE0II_N@Z PROC			; RenderVideo_Type4

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 535  :   uint32 pixel, rowCount, colCount;
; 536  :   uint8 Y, CR, CB, A;
; 537  : 
; 538  :   if(!nuonEnv->videoOptions.bUseShaders)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	ecx, BYTE PTR [eax+121]
	test	ecx, ecx
	jne	$LN12@RenderVide

; 539  :   {
; 540  :     for(rowCount = 0; rowCount < maxRow; rowCount++)

	mov	DWORD PTR _rowCount$[ebp], 0
	jmp	SHORT $LN10@RenderVide
$LN9@RenderVide:
	mov	edx, DWORD PTR _rowCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _rowCount$[ebp], edx
$LN10@RenderVide:
	mov	eax, DWORD PTR _rowCount$[ebp]
	cmp	eax, DWORD PTR _maxRow$[ebp]
	jae	$LN12@RenderVide

; 541  :     {
; 542  :       for(colCount = 0; colCount < maxCol; colCount++)

	mov	DWORD PTR _colCount$[ebp], 0
	jmp	SHORT $LN7@RenderVide
$LN6@RenderVide:
	mov	ecx, DWORD PTR _colCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _colCount$[ebp], ecx
$LN7@RenderVide:
	mov	edx, DWORD PTR _colCount$[ebp]
	cmp	edx, DWORD PTR _maxCol$[ebp]
	jae	$LN5@RenderVide

; 543  :       {
; 544  :         //32 or 32+32Z
; 545  :         Y = LuminanceTable[pSrcBuffer[0]];

	mov	eax, DWORD PTR _pSrcBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	dl, BYTE PTR ?LuminanceTable@@3PACA[ecx]
	mov	BYTE PTR _Y$[ebp], dl

; 546  :         CR = ChromianceTable[pSrcBuffer[1]];

	mov	eax, DWORD PTR _pSrcBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	dl, BYTE PTR ?ChromianceTable@@3PACA[ecx]
	mov	BYTE PTR _CR$[ebp], dl

; 547  :         CB = ChromianceTable[pSrcBuffer[2]];

	mov	eax, DWORD PTR _pSrcBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	dl, BYTE PTR ?ChromianceTable@@3PACA[ecx]
	mov	BYTE PTR _CB$[ebp], dl

; 548  : 
; 549  :         if(bOverlay)

	movzx	eax, BYTE PTR _bOverlay$[ebp]
	test	eax, eax
	je	SHORT $LN4@RenderVide

; 550  :         {
; 551  :           A = 255 - pSrcBuffer[3];

	mov	ecx, DWORD PTR _pSrcBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$[ebp], al

; 552  :           if(!(Y||CR||CB))

	movzx	ecx, BYTE PTR _Y$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@RenderVide
	movzx	edx, BYTE PTR _CR$[ebp]
	test	edx, edx
	jne	SHORT $LN3@RenderVide
	movzx	eax, BYTE PTR _CB$[ebp]
	test	eax, eax
	jne	SHORT $LN3@RenderVide

; 553  :           {
; 554  :             pixel = 0;

	mov	DWORD PTR _pixel$[ebp], 0

; 555  :           }
; 556  :           else

	jmp	SHORT $LN2@RenderVide
$LN3@RenderVide:

; 557  :           {
; 558  :             pixel = (A << 24) | (CB << 16) | (CR << 8) | Y;

	movzx	ecx, BYTE PTR _A$[ebp]
	shl	ecx, 24					; 00000018H
	movzx	edx, BYTE PTR _CB$[ebp]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	movzx	eax, BYTE PTR _CR$[ebp]
	shl	eax, 8
	or	ecx, eax
	movzx	edx, BYTE PTR _Y$[ebp]
	or	ecx, edx
	mov	DWORD PTR _pixel$[ebp], ecx
$LN2@RenderVide:

; 559  :           } 
; 560  :         }
; 561  :         else

	jmp	SHORT $LN1@RenderVide
$LN4@RenderVide:

; 562  :         {
; 563  :           A = 0xFF;

	mov	BYTE PTR _A$[ebp], 255			; 000000ffH

; 564  :           pixel = (A << 24) | (CB << 16) | (CR << 8) | Y;

	movzx	eax, BYTE PTR _A$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _CB$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _CR$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _Y$[ebp]
	or	eax, ecx
	mov	DWORD PTR _pixel$[ebp], eax
$LN1@RenderVide:

; 565  :         }
; 566  : 
; 567  :         ((uint32 *)pDestBuffer)[0] = pixel;

	mov	edx, DWORD PTR _pDestBuffer$[ebp]
	mov	eax, DWORD PTR _pixel$[ebp]
	mov	DWORD PTR [edx], eax

; 568  : 
; 569  :         pSrcBuffer += 4;

	mov	ecx, DWORD PTR _pSrcBuffer$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pSrcBuffer$[ebp], ecx

; 570  :         pDestBuffer += 4; //Always RGBA 32 bit

	mov	edx, DWORD PTR _pDestBuffer$[ebp]
	add	edx, 4
	mov	DWORD PTR _pDestBuffer$[ebp], edx

; 571  :       }

	jmp	$LN6@RenderVide
$LN5@RenderVide:

; 572  :     }

	jmp	$LN9@RenderVide
$LN12@RenderVide:

; 573  :   }  
; 574  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderVideo_Type4@@YAXPAE0II_N@Z ENDP			; RenderVideo_Type4
_TEXT	ENDS
PUBLIC	?IncrementVideoFieldCounter@@YAXXZ		; IncrementVideoFieldCounter
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_fieldCounter$ = -8					; size = 4
?IncrementVideoFieldCounter@@YAXXZ PROC			; IncrementVideoFieldCounter

; 577  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 578  :   uint32 fieldCounter;
; 579  : 
; 580  :   if(nuonEnv->systemBusDRAM)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@IncrementV

; 581  :   {
; 582  :     fieldCounter = *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+8388032]
	mov	DWORD PTR _fieldCounter$[ebp], eax

; 583  :     SwapScalarBytes(&fieldCounter);

	lea	ecx, DWORD PTR _fieldCounter$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 584  :     fieldCounter++;

	mov	ecx, DWORD PTR _fieldCounter$[ebp]
	add	ecx, 1
	mov	DWORD PTR _fieldCounter$[ebp], ecx

; 585  :     SwapScalarBytes(&fieldCounter);

	lea	ecx, DWORD PTR _fieldCounter$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 586  :     *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK])
; 587  :       = fieldCounter;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _fieldCounter$[ebp]
	mov	DWORD PTR [eax+8388032], ecx
$LN2@IncrementV:

; 588  :   }
; 589  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@IncrementV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@IncrementV:
	DD	1
	DD	$LN5@IncrementV
$LN5@IncrementV:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN4@IncrementV
$LN4@IncrementV:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?IncrementVideoFieldCounter@@YAXXZ ENDP			; IncrementVideoFieldCounter
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?RenderVideo@@YAXHH@Z				; RenderVideo
EXTRN	__imp__glFlush@0:PROC
EXTRN	__imp__glCallList@4:PROC
EXTRN	__imp__glTexSubImage2D@36:PROC
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	__imp__glOrtho@48:PROC
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__imp__glViewport@16:PROC
EXTRN	__RTC_UninitUse:PROC
;	COMDAT ?bSetupViewport@?P@??RenderVideo@@YAXHH@Z@4_NA
_BSS	SEGMENT
?bSetupViewport@?P@??RenderVideo@@YAXHH@Z@4_NA DB 01H DUP (?) ; `RenderVideo'::`15'::bSetupViewport
_BSS	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv293 = -104						; size = 4
tv216 = -100						; size = 4
tv159 = -96						; size = 4
tv130 = -92						; size = 4
$T80507 = -88						; size = 1
$T80506 = -87						; size = 1
$T80505 = -86						; size = 1
$T80504 = -85						; size = 1
$T80503 = -84						; size = 1
$T80502 = -83						; size = 1
$T80501 = -82						; size = 1
$T80500 = -81						; size = 1
$T80499 = -80						; size = 1
$T80498 = -79						; size = 1
$T80497 = -78						; size = 1
$T80496 = -77						; size = 1
_pOverlayChannelBuffer$ = -76				; size = 4
_pMainChannelBuffer$ = -72				; size = 4
_useCannedAlpha$ = -65					; size = 1
_pixel$ = -64						; size = 4
_A2$ = -60						; size = 1
_CB2$ = -59						; size = 1
_CR2$ = -58						; size = 1
_Y2$ = -57						; size = 1
_A$ = -56						; size = 1
_CB$ = -55						; size = 1
_CR$ = -54						; size = 1
_Y$ = -53						; size = 1
_rowWidth$ = -52					; size = 4
_pixType$ = -48						; size = 4
_pixWidth$ = -44					; size = 4
_pixWidthShift$ = -40					; size = 4
_activeChannels$ = -32					; size = 4
_maxRow$ = -28						; size = 4
_maxCol$ = -24						; size = 4
_ptrNuonFrameBuffer$ = -16				; size = 4
_ptrMainDisplayBuffer$ = -12				; size = 4
_colCount$ = -8						; size = 4
_rowCount$ = -4						; size = 4
_winwidth$ = 8						; size = 4
_winheight$ = 12					; size = 4
?RenderVideo@@YAXHH@Z PROC				; RenderVideo

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T80504[ebp], 0
	mov	BYTE PTR $T80497[ebp], 0
	mov	BYTE PTR $T80505[ebp], 0
	mov	BYTE PTR $T80501[ebp], 0
	mov	BYTE PTR $T80498[ebp], 0
	mov	BYTE PTR $T80496[ebp], 0
	mov	BYTE PTR $T80502[ebp], 0
	mov	BYTE PTR $T80499[ebp], 0
	mov	BYTE PTR $T80503[ebp], 0
	mov	BYTE PTR $T80506[ebp], 0
	mov	BYTE PTR $T80500[ebp], 0
	mov	BYTE PTR $T80507[ebp], 0

; 593  :   uint32 rowCount = 0, colCount = 0;

	mov	DWORD PTR _rowCount$[ebp], 0
	mov	DWORD PTR _colCount$[ebp], 0

; 594  :   uint8 *ptrMainDisplayBuffer;
; 595  :   uint8 *ptrNuonFrameBuffer;
; 596  :   uint8 *ptrNextRow;
; 597  :   uint32 maxCol;
; 598  :   uint32 maxRow;
; 599  :   uint32 activeChannels;
; 600  :   uint32 fieldCounter;
; 601  :   uint32 pixWidthShift;
; 602  :   uint32 pixWidth;
; 603  :   uint32 pixType;
; 604  :   uint32 rowWidth;
; 605  :   uint8 Y,CR,CB,A,Y2,CR2,CB2,A2;
; 606  :   uint32 pixel;
; 607  :   bool useCannedAlpha;
; 608  :   uint8 *pMainChannelBuffer;
; 609  :   uint8 *pOverlayChannelBuffer;
; 610  : 
; 611  :   if(!bCanDisplayVideo)

	movzx	eax, BYTE PTR ?bCanDisplayVideo@@3_NA	; bCanDisplayVideo
	test	eax, eax
	jne	SHORT $LN82@RenderVide@2

; 612  :   {
; 613  :     return;

	jmp	$LN83@RenderVide@2
$LN82@RenderVide@2:

; 614  :   }
; 615  : 
; 616  :   if(nuonEnv->videoOptions.bAlwaysUpdateVideo)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+122]
	test	edx, edx
	je	SHORT $LN81@RenderVide@2

; 617  :   {
; 618  :     nuonEnv->bMainBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+86], 1

; 619  :     nuonEnv->bOverlayBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+87], 1
	jmp	SHORT $LN79@RenderVide@2
$LN81@RenderVide@2:

; 620  :   }
; 621  :   else if(!(nuonEnv->bMainBufferModified || nuonEnv->bOverlayBufferModified))

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+86]
	test	eax, eax
	jne	SHORT $LN79@RenderVide@2
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+87]
	test	edx, edx
	jne	SHORT $LN79@RenderVide@2

; 622  :   {
; 623  :     return;

	jmp	$LN83@RenderVide@2
$LN79@RenderVide@2:

; 624  :   }
; 625  :    
; 626  :   if(!bTexturesInitialized)

	movzx	eax, BYTE PTR ?bTexturesInitialized@@3_NA ; bTexturesInitialized
	test	eax, eax
	jne	SHORT $LN78@RenderVide@2

; 627  :   {
; 628  :     InitTextures();

	call	?InitTextures@@YAXXZ			; InitTextures

; 629  :     bTexturesInitialized = true;

	mov	BYTE PTR ?bTexturesInitialized@@3_NA, 1	; bTexturesInitialized
$LN78@RenderVide@2:

; 630  :   }
; 631  : 
; 632  :   static bool bSetupViewport = false;
; 633  : 
; 634  :   if(!bSetupViewport)

	movzx	ecx, BYTE PTR ?bSetupViewport@?P@??RenderVideo@@YAXHH@Z@4_NA
	test	ecx, ecx
	jne	$LN77@RenderVide@2

; 635  :   {
; 636  :     glViewport(0,0,winwidth,winheight);

	mov	esi, esp
	mov	edx, DWORD PTR _winheight$[ebp]
	push	edx
	mov	eax, DWORD PTR _winwidth$[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 637  :     glMatrixMode(GL_PROJECTION);

	mov	esi, esp
	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 638  :     glLoadIdentity();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  :     glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0);

	mov	esi, esp
	sub	esp, 8
	fld1
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld	QWORD PTR __real@bff0000000000000
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld1
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fldz
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld1
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fldz
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glOrtho@48
	cmp	esi, esp
	call	__RTC_CheckEsp

; 640  :     glMatrixMode(GL_MODELVIEW);

	mov	esi, esp
	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 641  :     glLoadIdentity();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 642  :     bSetupViewport = true;

	mov	BYTE PTR ?bSetupViewport@?P@??RenderVideo@@YAXHH@Z@4_NA, 1
$LN77@RenderVide@2:

; 643  :   }
; 644  : 
; 645  : 
; 646  :   if(bMainChannelActive)

	movzx	ecx, BYTE PTR ?bMainChannelActive@@3_NA	; bMainChannelActive
	test	ecx, ecx
	je	$LN58@RenderVide@2
$setup_main_buffer$77991:

; 647  :   {
; 648  : setup_main_buffer:
; 649  :     pixType = (structMainChannel.dmaflags >> 4) & 0x0F;

	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	sar	edx, 4
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], edx

; 650  :     maxCol = structMainChannel.src_width;

	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	mov	DWORD PTR _maxCol$[ebp], eax

; 651  :     maxRow = structMainChannel.src_height;

	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	DWORD PTR _maxRow$[ebp], ecx

; 652  :     useCannedAlpha = false;

	mov	BYTE PTR _useCannedAlpha$[ebp], 0

; 653  : 
; 654  :     switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv130[ebp], edx
	cmp	DWORD PTR tv130[ebp], 6
	ja	$LN66@RenderVide@2
	mov	eax, DWORD PTR tv130[ebp]
	jmp	DWORD PTR $LN142@RenderVide@2[eax*4]
$LN73@RenderVide@2:

; 655  :     {
; 656  :       case 0:
; 657  :         //mpeg
; 658  :         break;

	jmp	$LN74@RenderVide@2
$LN72@RenderVide@2:

; 659  :       case 1:
; 660  :         //4 bit
; 661  :         break;

	jmp	$LN74@RenderVide@2
$LN71@RenderVide@2:

; 662  :       case 2:
; 663  :         //16 bit
; 664  :         pixWidthShift = 1;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 1

; 665  :         pixWidth = 2;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 2

; 666  :         useCannedAlpha = true;

	mov	BYTE PTR _useCannedAlpha$[ebp], 1

; 667  :         break;

	jmp	SHORT $LN74@RenderVide@2
$LN70@RenderVide@2:

; 668  :       case 3:
; 669  :         //8 bit
; 670  :         pixWidth = 1;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 1

; 671  :         pixWidthShift = 0;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 0

; 672  :         break;

	jmp	SHORT $LN74@RenderVide@2
$LN69@RenderVide@2:

; 673  :       case 4:
; 674  :         //32 bit
; 675  :         pixWidthShift = 2;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 2

; 676  :         pixWidth = 4;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 4

; 677  :         break;

	jmp	SHORT $LN74@RenderVide@2
$LN68@RenderVide@2:

; 678  :       case 5:
; 679  :         //16 bit+16z
; 680  :         pixWidthShift = 1;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 1

; 681  :         pixWidth = 2;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 2

; 682  :         useCannedAlpha = true;

	mov	BYTE PTR _useCannedAlpha$[ebp], 1

; 683  :         break;

	jmp	SHORT $LN74@RenderVide@2
$LN67@RenderVide@2:

; 684  :       case 6:
; 685  :         //32 bit+32z
; 686  :         pixWidthShift = 3;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 3

; 687  :         pixWidth = 8;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 8

; 688  :         break;

	jmp	SHORT $LN74@RenderVide@2
$LN66@RenderVide@2:

; 689  :       default:
; 690  :         pixWidthShift = 2;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 2

; 691  :         pixWidth = 4;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 4
$LN74@RenderVide@2:

; 692  :         break;
; 693  :     }
; 694  : 
; 695  :     ptrMainDisplayBuffer = mainChannelBuffer;

	mov	ecx, DWORD PTR ?mainChannelBuffer@@3PAEA ; mainChannelBuffer
	mov	DWORD PTR _ptrMainDisplayBuffer$[ebp], ecx

; 696  :     ptrNuonFrameBuffer =
; 697  :       (uint8 *)(nuonEnv->GetPointerToMemory(NULL,
; 698  :       (uint32)structMainChannel.base + (((structMainChannel.src_yoff * structMainChannel.src_width) + structMainChannel.src_xoff) << pixWidthShift)));

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN85@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN85@RenderVide@2:
	push	1
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+28
	imul	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	add	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+24
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	push	edx
	push	0
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _ptrNuonFrameBuffer$[ebp], eax

; 699  :     pMainChannelBuffer = ptrNuonFrameBuffer;

	mov	BYTE PTR $T80498[ebp], 1
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	DWORD PTR _pMainChannelBuffer$[ebp], eax

; 700  : 
; 701  :     rowWidth = (structMainChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN87@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN87@RenderVide@2:
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	mov	DWORD PTR _rowWidth$[ebp], edx

; 702  : 
; 703  :     if(!nuonEnv->bMainBufferModified)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	ecx, BYTE PTR [eax+86]
	test	ecx, ecx
	jne	SHORT $LN65@RenderVide@2
	jmp	$LN64@RenderVide@2

; 704  :     {
; 705  :       goto process_overlay_buffer;

	jmp	$process_overlay_buffer$78007
$LN65@RenderVide@2:

; 706  :     }
; 707  : 
; 708  :     //!ptrNextRow = ptrNuonFrameBuffer;
; 709  : 
; 710  :     if(pixType == 4)

	cmp	DWORD PTR _pixType$[ebp], 4
	jne	SHORT $LN63@RenderVide@2

; 711  :     {
; 712  :       if(!nuonEnv->videoOptions.bUseShaders)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+121]
	test	eax, eax
	jne	SHORT $LN62@RenderVide@2

; 713  :       {
; 714  :         RenderVideo_Type4(mainChannelBuffer,ptrNuonFrameBuffer,maxRow,maxCol,false);

	push	0
	mov	ecx, DWORD PTR _maxCol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxRow$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?mainChannelBuffer@@3PAEA ; mainChannelBuffer
	push	ecx
	call	?RenderVideo_Type4@@YAXPAE0II_N@Z	; RenderVideo_Type4
	add	esp, 20					; 00000014H
$LN62@RenderVide@2:

; 715  :       }

	jmp	$LN61@RenderVide@2

; 716  :       goto process_overlay_buffer;

	jmp	$process_overlay_buffer$78007
$LN63@RenderVide@2:

; 717  :     }
; 718  : 
; 719  :     for(rowCount = 0; rowCount < maxRow; rowCount++)

	mov	DWORD PTR _rowCount$[ebp], 0
	jmp	SHORT $LN60@RenderVide@2
$LN59@RenderVide@2:
	mov	edx, DWORD PTR _rowCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _rowCount$[ebp], edx
$LN60@RenderVide@2:
	mov	eax, DWORD PTR _rowCount$[ebp]
	cmp	eax, DWORD PTR _maxRow$[ebp]
	jae	$LN58@RenderVide@2

; 720  :     {
; 721  :       for(colCount = 0; colCount < maxCol; colCount++)

	mov	DWORD PTR _colCount$[ebp], 0
	jmp	SHORT $LN57@RenderVide@2
$LN56@RenderVide@2:
	mov	ecx, DWORD PTR _colCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _colCount$[ebp], ecx
$LN57@RenderVide@2:
	mov	edx, DWORD PTR _colCount$[ebp]
	cmp	edx, DWORD PTR _maxCol$[ebp]
	jae	$LN55@RenderVide@2

; 722  :       {
; 723  :         switch(pixType)

	mov	eax, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv159[ebp], eax
	cmp	DWORD PTR tv159[ebp], 2
	je	SHORT $LN52@RenderVide@2
	cmp	DWORD PTR tv159[ebp], 5
	je	SHORT $LN51@RenderVide@2
	jmp	$LN50@RenderVide@2
$LN52@RenderVide@2:

; 724  :         {
; 725  :           case 2:
; 726  :             Y = ptrNuonFrameBuffer[0] & 0xFC; 

	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 252				; 000000fcH
	mov	BYTE PTR $T80499[ebp], 1
	mov	BYTE PTR _Y$[ebp], dl

; 727  :             CR = (ptrNuonFrameBuffer[0] << 6) | ((ptrNuonFrameBuffer[1] >> 2) & 0x38);

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 6
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	sar	eax, 2
	and	eax, 56					; 00000038H
	or	ecx, eax
	mov	BYTE PTR $T80500[ebp], 1
	mov	BYTE PTR _CR$[ebp], cl

; 728  :             CB = ptrNuonFrameBuffer[1] << 3;

	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 3
	mov	BYTE PTR $T80501[ebp], 1
	mov	BYTE PTR _CB$[ebp], dl

; 729  :             break;

	jmp	SHORT $LN53@RenderVide@2
$LN51@RenderVide@2:

; 730  :           case 5:
; 731  :             //16 or 16+16Z
; 732  :             Y = ptrNuonFrameBuffer[0] & 0xFC; 

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 252				; 000000fcH
	mov	BYTE PTR $T80499[ebp], 1
	mov	BYTE PTR _Y$[ebp], cl

; 733  :             CR = (ptrNuonFrameBuffer[0] << 6) | ((ptrNuonFrameBuffer[1] >> 2) & 0x38);

	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	eax, BYTE PTR [edx]
	shl	eax, 6
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	sar	edx, 2
	and	edx, 56					; 00000038H
	or	eax, edx
	mov	BYTE PTR $T80500[ebp], 1
	mov	BYTE PTR _CR$[ebp], al

; 734  :             CB = ptrNuonFrameBuffer[1] << 3;

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 3
	mov	BYTE PTR $T80501[ebp], 1
	mov	BYTE PTR _CB$[ebp], cl

; 735  :             break;

	jmp	SHORT $LN53@RenderVide@2
$LN50@RenderVide@2:

; 736  :           case 4:
; 737  :           case 6:
; 738  :           default:
; 739  :             //32 or 32+32Z
; 740  :             Y = ptrNuonFrameBuffer[0];

	mov	BYTE PTR $T80499[ebp], 1
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _Y$[ebp], al

; 741  :             CR = ptrNuonFrameBuffer[1];

	mov	BYTE PTR $T80500[ebp], 1
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _CR$[ebp], dl

; 742  :             CB = ptrNuonFrameBuffer[2];

	mov	BYTE PTR $T80501[ebp], 1
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _CB$[ebp], cl
$LN53@RenderVide@2:

; 743  :             break;
; 744  :         }
; 745  : 
; 746  :         Y = LuminanceTable[Y];

	cmp	BYTE PTR $T80499[ebp], 0
	jne	SHORT $LN88@RenderVide@2
	push	OFFSET $LN89@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN88@RenderVide@2:
	movzx	edx, BYTE PTR _Y$[ebp]
	mov	BYTE PTR $T80499[ebp], 1
	mov	al, BYTE PTR ?LuminanceTable@@3PACA[edx]
	mov	BYTE PTR _Y$[ebp], al

; 747  :         CR = ChromianceTable[CR];

	cmp	BYTE PTR $T80500[ebp], 0
	jne	SHORT $LN90@RenderVide@2
	push	OFFSET $LN91@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN90@RenderVide@2:
	movzx	ecx, BYTE PTR _CR$[ebp]
	mov	BYTE PTR $T80500[ebp], 1
	mov	dl, BYTE PTR ?ChromianceTable@@3PACA[ecx]
	mov	BYTE PTR _CR$[ebp], dl

; 748  :         CB = ChromianceTable[CB];

	cmp	BYTE PTR $T80501[ebp], 0
	jne	SHORT $LN92@RenderVide@2
	push	OFFSET $LN93@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN92@RenderVide@2:
	movzx	eax, BYTE PTR _CB$[ebp]
	mov	BYTE PTR $T80501[ebp], 1
	mov	cl, BYTE PTR ?ChromianceTable@@3PACA[eax]
	mov	BYTE PTR _CB$[ebp], cl

; 749  : 
; 750  :         A = 255 - 0; //Alpha for main channel is opaque

	mov	BYTE PTR $T80502[ebp], 1
	mov	BYTE PTR _A$[ebp], 255			; 000000ffH

; 751  : 
; 752  :         pixel = (A << 24) | (CB << 16) | (CR << 8) | Y;

	cmp	BYTE PTR $T80502[ebp], 0
	jne	SHORT $LN94@RenderVide@2
	push	OFFSET $LN95@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN94@RenderVide@2:
	cmp	BYTE PTR $T80501[ebp], 0
	jne	SHORT $LN96@RenderVide@2
	push	OFFSET $LN93@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN96@RenderVide@2:
	cmp	BYTE PTR $T80500[ebp], 0
	jne	SHORT $LN97@RenderVide@2
	push	OFFSET $LN91@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN97@RenderVide@2:
	cmp	BYTE PTR $T80499[ebp], 0
	jne	SHORT $LN98@RenderVide@2
	push	OFFSET $LN89@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN98@RenderVide@2:
	movzx	edx, BYTE PTR _A$[ebp]
	shl	edx, 24					; 00000018H
	movzx	eax, BYTE PTR _CB$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	movzx	ecx, BYTE PTR _CR$[ebp]
	shl	ecx, 8
	or	edx, ecx
	movzx	eax, BYTE PTR _Y$[ebp]
	or	edx, eax
	mov	DWORD PTR _pixel$[ebp], edx

; 753  :         ((uint32 *)ptrMainDisplayBuffer)[0] = pixel;

	mov	ecx, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	mov	edx, DWORD PTR _pixel$[ebp]
	mov	DWORD PTR [ecx], edx

; 754  : 
; 755  :         ptrNuonFrameBuffer += pixWidth;

	cmp	BYTE PTR $T80497[ebp], 0
	jne	SHORT $LN99@RenderVide@2
	push	OFFSET $LN100@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN99@RenderVide@2:
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	add	eax, DWORD PTR _pixWidth$[ebp]
	mov	DWORD PTR _ptrNuonFrameBuffer$[ebp], eax

; 756  :         ptrMainDisplayBuffer += 4; //Always RGBA 32 bit

	mov	ecx, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptrMainDisplayBuffer$[ebp], ecx

; 757  :       }

	jmp	$LN56@RenderVide@2
$LN55@RenderVide@2:

; 758  :     }

	jmp	$LN59@RenderVide@2
$LN58@RenderVide@2:
$LN61@RenderVide@2:
$LN64@RenderVide@2:
$process_overlay_buffer$78007:

; 759  :   }
; 760  : 
; 761  : process_overlay_buffer:
; 762  :   if(bOverlayChannelActive)

	movzx	edx, BYTE PTR ?bOverlayChannelActive@@3_NA ; bOverlayChannelActive
	test	edx, edx
	je	$LN29@RenderVide@2

; 763  :   {
; 764  :     maxCol = structOverlayChannel.src_width;

	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	DWORD PTR _maxCol$[ebp], eax

; 765  :     maxRow = structOverlayChannel.src_height;

	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	mov	DWORD PTR _maxRow$[ebp], ecx

; 766  :     ptrMainDisplayBuffer = overlayChannelBuffer;

	mov	edx, DWORD PTR ?overlayChannelBuffer@@3PAEA ; overlayChannelBuffer
	mov	DWORD PTR _ptrMainDisplayBuffer$[ebp], edx

; 767  :     pixType = (structOverlayChannel.dmaflags >> 4) & 0x0F;

	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	sar	eax, 4
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _pixType$[ebp], eax

; 768  :     useCannedAlpha = false;

	mov	BYTE PTR _useCannedAlpha$[ebp], 0

; 769  : 
; 770  :     switch(pixType)

	mov	ecx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv216[ebp], ecx
	cmp	DWORD PTR tv216[ebp], 6
	ja	$LN39@RenderVide@2
	mov	edx, DWORD PTR tv216[ebp]
	jmp	DWORD PTR $LN143@RenderVide@2[edx*4]
$LN46@RenderVide@2:

; 771  :     {
; 772  :       case 0:
; 773  :         //mpeg
; 774  :         break;

	jmp	$LN47@RenderVide@2
$LN45@RenderVide@2:

; 775  :       case 1:
; 776  :         //4 bit
; 777  :         pixWidthShift = 1;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 1

; 778  :         pixWidth = 1;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 1

; 779  :         rowWidth = (structOverlayChannel.src_width >> 1);

	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	sar	eax, 1
	mov	DWORD PTR _rowWidth$[ebp], eax

; 780  :         maxRow >>= 1;

	mov	ecx, DWORD PTR _maxRow$[ebp]
	shr	ecx, 1
	mov	DWORD PTR _maxRow$[ebp], ecx

; 781  :         break;

	jmp	$LN47@RenderVide@2
$LN44@RenderVide@2:

; 782  :       case 2:
; 783  :         //16 bit
; 784  :         pixWidthShift = 1;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 1

; 785  :         pixWidth = 2;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 2

; 786  :         rowWidth = (structOverlayChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN101@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN101@RenderVide@2:
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	mov	DWORD PTR _rowWidth$[ebp], edx

; 787  :         break;

	jmp	$LN47@RenderVide@2
$LN43@RenderVide@2:

; 788  :       case 3:
; 789  :         //8 bit
; 790  :         pixWidthShift = 0;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 0

; 791  :         pixWidth = 1;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 1

; 792  :         rowWidth = structOverlayChannel.src_width;

	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	DWORD PTR _rowWidth$[ebp], eax

; 793  :         break;

	jmp	$LN47@RenderVide@2
$LN42@RenderVide@2:

; 794  :       case 4:
; 795  :         //32 bit
; 796  :         pixWidthShift = 2;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 2

; 797  :         pixWidth = 4;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 4

; 798  :         rowWidth = (structOverlayChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN102@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN102@RenderVide@2:
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	mov	DWORD PTR _rowWidth$[ebp], edx

; 799  :         break;

	jmp	$LN47@RenderVide@2
$LN41@RenderVide@2:

; 800  :       case 5:
; 801  :         //16 bit+16z
; 802  :         pixWidthShift = 1;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 1

; 803  :         pixWidth = 2;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 2

; 804  :         rowWidth = (structOverlayChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN103@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN103@RenderVide@2:
	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	eax, cl
	mov	DWORD PTR _rowWidth$[ebp], eax

; 805  :         break;

	jmp	SHORT $LN47@RenderVide@2
$LN40@RenderVide@2:

; 806  :       case 6:
; 807  :         //32 bit+32z
; 808  :         pixWidthShift = 3;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 3

; 809  :         pixWidth = 8;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 8

; 810  :         rowWidth = (structOverlayChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN104@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN104@RenderVide@2:
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	mov	DWORD PTR _rowWidth$[ebp], edx

; 811  :         break;

	jmp	SHORT $LN47@RenderVide@2
$LN39@RenderVide@2:

; 812  :       default:
; 813  :         pixWidthShift = 2;

	mov	BYTE PTR $T80496[ebp], 1
	mov	DWORD PTR _pixWidthShift$[ebp], 2

; 814  :         pixWidth = 4;

	mov	BYTE PTR $T80497[ebp], 1
	mov	DWORD PTR _pixWidth$[ebp], 4

; 815  :         rowWidth = (structOverlayChannel.src_width << pixWidthShift);

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN105@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN105@RenderVide@2:
	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	eax, cl
	mov	DWORD PTR _rowWidth$[ebp], eax
$LN47@RenderVide@2:

; 816  :         break;
; 817  :     }
; 818  : 
; 819  :     if(pixType != 1)

	cmp	DWORD PTR _pixType$[ebp], 1
	je	SHORT $LN38@RenderVide@2

; 820  :     {
; 821  :       ptrNuonFrameBuffer =
; 822  :         (uint8 *)(nuonEnv->GetPointerToMemory(NULL,
; 823  :         (uint32)structOverlayChannel.base + (((structOverlayChannel.src_yoff * structOverlayChannel.src_width) + structOverlayChannel.src_xoff) << pixWidthShift)));

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN106@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN106@RenderVide@2:
	push	1
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+28
	imul	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	add	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+24
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	shl	edx, cl
	add	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	push	edx
	push	0
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _ptrNuonFrameBuffer$[ebp], eax

; 824  :     }
; 825  :     else

	jmp	SHORT $LN37@RenderVide@2
$LN38@RenderVide@2:

; 826  :     {
; 827  :       ptrNuonFrameBuffer =
; 828  :         (uint8 *)(nuonEnv->GetPointerToMemory(NULL,
; 829  :         (uint32)structOverlayChannel.base + (((structOverlayChannel.src_yoff * structOverlayChannel.src_width) + structOverlayChannel.src_xoff) >> pixWidthShift)));

	cmp	BYTE PTR $T80496[ebp], 0
	jne	SHORT $LN107@RenderVide@2
	push	OFFSET $LN86@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN107@RenderVide@2:
	push	1
	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+28
	imul	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	add	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+24
	mov	ecx, DWORD PTR _pixWidthShift$[ebp]
	sar	eax, cl
	add	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	push	eax
	push	0
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _ptrNuonFrameBuffer$[ebp], eax
$LN37@RenderVide@2:

; 830  :     } 
; 831  :     pOverlayChannelBuffer = ptrNuonFrameBuffer;

	mov	BYTE PTR $T80503[ebp], 1
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	DWORD PTR _pOverlayChannelBuffer$[ebp], ecx

; 832  : 
; 833  :     if(!nuonEnv->bOverlayBufferModified)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+87]
	test	eax, eax
	jne	SHORT $LN36@RenderVide@2
	jmp	$LN35@RenderVide@2

; 834  :     {
; 835  :       goto render_main_buffer;

	jmp	$render_main_buffer$78046
$LN36@RenderVide@2:

; 836  :     }
; 837  : 
; 838  :     if(pixType == 4)

	cmp	DWORD PTR _pixType$[ebp], 4
	jne	SHORT $LN34@RenderVide@2

; 839  :     {
; 840  :       if(!nuonEnv->videoOptions.bUseShaders)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+121]
	test	edx, edx
	jne	SHORT $LN33@RenderVide@2

; 841  :       {
; 842  :         RenderVideo_Type4(overlayChannelBuffer,ptrNuonFrameBuffer,maxRow,maxCol,true);

	push	1
	mov	eax, DWORD PTR _maxCol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxRow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR ?overlayChannelBuffer@@3PAEA ; overlayChannelBuffer
	push	eax
	call	?RenderVideo_Type4@@YAXPAE0II_N@Z	; RenderVideo_Type4
	add	esp, 20					; 00000014H
$LN33@RenderVide@2:

; 843  :       }

	jmp	$LN32@RenderVide@2

; 844  :       goto render_main_buffer;

	jmp	$render_main_buffer$78046
$LN34@RenderVide@2:

; 845  :     }
; 846  : 
; 847  :     for(rowCount = 0; rowCount < maxRow; rowCount++)

	mov	DWORD PTR _rowCount$[ebp], 0
	jmp	SHORT $LN31@RenderVide@2
$LN30@RenderVide@2:
	mov	ecx, DWORD PTR _rowCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rowCount$[ebp], ecx
$LN31@RenderVide@2:
	mov	edx, DWORD PTR _rowCount$[ebp]
	cmp	edx, DWORD PTR _maxRow$[ebp]
	jae	$LN29@RenderVide@2

; 848  :     {
; 849  :       for(colCount = 0; colCount < maxCol; colCount++)

	mov	DWORD PTR _colCount$[ebp], 0
	jmp	SHORT $LN28@RenderVide@2
$LN27@RenderVide@2:
	mov	eax, DWORD PTR _colCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _colCount$[ebp], eax
$LN28@RenderVide@2:
	mov	ecx, DWORD PTR _colCount$[ebp]
	cmp	ecx, DWORD PTR _maxCol$[ebp]
	jae	$LN26@RenderVide@2

; 850  :       {
; 851  :         switch(pixType)

	mov	edx, DWORD PTR _pixType$[ebp]
	mov	DWORD PTR tv293[ebp], edx
	mov	eax, DWORD PTR tv293[ebp]
	sub	eax, 1
	mov	DWORD PTR tv293[ebp], eax
	cmp	DWORD PTR tv293[ebp], 5
	ja	$LN17@RenderVide@2
	mov	ecx, DWORD PTR tv293[ebp]
	jmp	DWORD PTR $LN144@RenderVide@2[ecx*4]
$LN23@RenderVide@2:

; 852  :         {
; 853  :           case 1:
; 854  :             //4-bit
; 855  :             clutPtr = (uint8 *)&vdgCLUT[ptrNuonFrameBuffer[0] >> 4];

	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	eax, BYTE PTR [edx]
	sar	eax, 4
	lea	ecx, DWORD PTR ?vdgCLUT@@3PAIA[eax*4]
	mov	DWORD PTR ?clutPtr@@3PAEA, ecx		; clutPtr

; 856  :             Y = clutPtr[0];

	mov	BYTE PTR $T80499[ebp], 1
	mov	edx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _Y$[ebp], al

; 857  :             CR = clutPtr[1];

	mov	BYTE PTR $T80500[ebp], 1
	mov	ecx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _CR$[ebp], dl

; 858  :             CB = clutPtr[2];

	mov	BYTE PTR $T80501[ebp], 1
	mov	eax, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _CB$[ebp], cl

; 859  :             A = clutPtr[3];

	mov	BYTE PTR $T80502[ebp], 1
	mov	edx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$[ebp], al

; 860  :             clutPtr = (uint8 *)&vdgCLUT[ptrNuonFrameBuffer[0] & 0xF];

	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 15					; 0000000fH
	lea	eax, DWORD PTR ?vdgCLUT@@3PAIA[edx*4]
	mov	DWORD PTR ?clutPtr@@3PAEA, eax		; clutPtr

; 861  :             Y2 = clutPtr[0];

	mov	BYTE PTR $T80504[ebp], 1
	mov	ecx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _Y2$[ebp], dl

; 862  :             CR2 = clutPtr[1];

	mov	BYTE PTR $T80505[ebp], 1
	mov	eax, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _CR2$[ebp], cl

; 863  :             CB2 = clutPtr[2];

	mov	BYTE PTR $T80506[ebp], 1
	mov	edx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _CB2$[ebp], al

; 864  :             A2 = clutPtr[3];

	mov	BYTE PTR $T80507[ebp], 1
	mov	ecx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A2$[ebp], dl

; 865  :             break;

	jmp	$LN24@RenderVide@2
$LN22@RenderVide@2:

; 866  :           case 2:
; 867  :             //16-bit
; 868  :             Y = ptrNuonFrameBuffer[0] & 0xFC;

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 252				; 000000fcH
	mov	BYTE PTR $T80499[ebp], 1
	mov	BYTE PTR _Y$[ebp], cl

; 869  :             CR = (ptrNuonFrameBuffer[0] << 6) | ((ptrNuonFrameBuffer[1] >> 2) & 0x38);

	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	eax, BYTE PTR [edx]
	shl	eax, 6
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	sar	edx, 2
	and	edx, 56					; 00000038H
	or	eax, edx
	mov	BYTE PTR $T80500[ebp], 1
	mov	BYTE PTR _CR$[ebp], al

; 870  :             CB = ptrNuonFrameBuffer[1] << 3;

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 3
	mov	BYTE PTR $T80501[ebp], 1
	mov	BYTE PTR _CB$[ebp], cl

; 871  :             A = structOverlayChannel.alpha;

	mov	BYTE PTR $T80502[ebp], 1
	mov	dl, BYTE PTR ?structOverlayChannel@@3UVidChannel@@A+41
	mov	BYTE PTR _A$[ebp], dl

; 872  :             break;

	jmp	$LN24@RenderVide@2
$LN21@RenderVide@2:

; 873  :           case 3:
; 874  :             //8-bit
; 875  :             clutPtr = (uint8 *)&vdgCLUT[ptrNuonFrameBuffer[0]];

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	lea	edx, DWORD PTR ?vdgCLUT@@3PAIA[ecx*4]
	mov	DWORD PTR ?clutPtr@@3PAEA, edx		; clutPtr

; 876  :             Y = clutPtr[0];

	mov	BYTE PTR $T80499[ebp], 1
	mov	eax, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _Y$[ebp], cl

; 877  :             CR = clutPtr[1];

	mov	BYTE PTR $T80500[ebp], 1
	mov	edx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _CR$[ebp], al

; 878  :             CB = clutPtr[2];

	mov	BYTE PTR $T80501[ebp], 1
	mov	ecx, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _CB$[ebp], dl

; 879  :             A = clutPtr[3];

	mov	BYTE PTR $T80502[ebp], 1
	mov	eax, DWORD PTR ?clutPtr@@3PAEA		; clutPtr
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _A$[ebp], cl

; 880  :             break;

	jmp	$LN24@RenderVide@2
$LN20@RenderVide@2:

; 881  :           case 4:
; 882  :             //32-bit
; 883  :             Y = ptrNuonFrameBuffer[0];

	mov	BYTE PTR $T80499[ebp], 1
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _Y$[ebp], al

; 884  :             CR = ptrNuonFrameBuffer[1];

	mov	BYTE PTR $T80500[ebp], 1
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _CR$[ebp], dl

; 885  :             CB = ptrNuonFrameBuffer[2];

	mov	BYTE PTR $T80501[ebp], 1
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _CB$[ebp], cl

; 886  :             A = ptrNuonFrameBuffer[3];

	mov	BYTE PTR $T80502[ebp], 1
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$[ebp], al

; 887  :             break;

	jmp	SHORT $LN24@RenderVide@2
$LN19@RenderVide@2:

; 888  :           case 5:
; 889  :             //16+16Z
; 890  :             Y = ptrNuonFrameBuffer[0] & 0xFC;

	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 252				; 000000fcH
	mov	BYTE PTR $T80499[ebp], 1
	mov	BYTE PTR _Y$[ebp], dl

; 891  :             CR = (ptrNuonFrameBuffer[0] << 6) | ((ptrNuonFrameBuffer[1] >> 2) & 0x38);

	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 6
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	sar	eax, 2
	and	eax, 56					; 00000038H
	or	ecx, eax
	mov	BYTE PTR $T80500[ebp], 1
	mov	BYTE PTR _CR$[ebp], cl

; 892  :             CB = ptrNuonFrameBuffer[1] << 3;

	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 3
	mov	BYTE PTR $T80501[ebp], 1
	mov	BYTE PTR _CB$[ebp], dl

; 893  :             A = 0; //Z buffered pixels are always opaque

	mov	BYTE PTR $T80502[ebp], 1
	mov	BYTE PTR _A$[ebp], 0

; 894  :             break;

	jmp	SHORT $LN24@RenderVide@2
$LN18@RenderVide@2:

; 895  :           case 6:
; 896  :             //32+32Z
; 897  :             Y = ptrNuonFrameBuffer[0];

	mov	BYTE PTR $T80499[ebp], 1
	mov	eax, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _Y$[ebp], cl

; 898  :             CR = ptrNuonFrameBuffer[1];

	mov	BYTE PTR $T80500[ebp], 1
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _CR$[ebp], al

; 899  :             CB = ptrNuonFrameBuffer[2];

	mov	BYTE PTR $T80501[ebp], 1
	mov	ecx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _CB$[ebp], dl

; 900  :             A = 0; //Z buffered pixels are always opaque

	mov	BYTE PTR $T80502[ebp], 1
	mov	BYTE PTR _A$[ebp], 0
$LN17@RenderVide@2:
$LN24@RenderVide@2:

; 901  :           default:
; 902  :             break;
; 903  :         }
; 904  : 
; 905  :         if((Y||CR||CB))

	cmp	BYTE PTR $T80499[ebp], 0
	jne	SHORT $LN108@RenderVide@2
	push	OFFSET $LN89@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN108@RenderVide@2:
	movzx	eax, BYTE PTR _Y$[ebp]
	test	eax, eax
	jne	SHORT $LN15@RenderVide@2
	cmp	BYTE PTR $T80500[ebp], 0
	jne	SHORT $LN109@RenderVide@2
	push	OFFSET $LN91@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN109@RenderVide@2:
	movzx	ecx, BYTE PTR _CR$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@RenderVide@2
	cmp	BYTE PTR $T80501[ebp], 0
	jne	SHORT $LN110@RenderVide@2
	push	OFFSET $LN93@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN110@RenderVide@2:
	movzx	edx, BYTE PTR _CB$[ebp]
	test	edx, edx
	je	$LN16@RenderVide@2
$LN15@RenderVide@2:

; 906  :         {
; 907  :           Y = LuminanceTable[Y];

	cmp	BYTE PTR $T80499[ebp], 0
	jne	SHORT $LN111@RenderVide@2
	push	OFFSET $LN89@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN111@RenderVide@2:
	movzx	eax, BYTE PTR _Y$[ebp]
	mov	BYTE PTR $T80499[ebp], 1
	mov	cl, BYTE PTR ?LuminanceTable@@3PACA[eax]
	mov	BYTE PTR _Y$[ebp], cl

; 908  :           CR = ChromianceTable[CR];

	cmp	BYTE PTR $T80500[ebp], 0
	jne	SHORT $LN112@RenderVide@2
	push	OFFSET $LN91@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN112@RenderVide@2:
	movzx	edx, BYTE PTR _CR$[ebp]
	mov	BYTE PTR $T80500[ebp], 1
	mov	al, BYTE PTR ?ChromianceTable@@3PACA[edx]
	mov	BYTE PTR _CR$[ebp], al

; 909  :           CB = ChromianceTable[CB];

	cmp	BYTE PTR $T80501[ebp], 0
	jne	SHORT $LN113@RenderVide@2
	push	OFFSET $LN93@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN113@RenderVide@2:
	movzx	ecx, BYTE PTR _CB$[ebp]
	mov	BYTE PTR $T80501[ebp], 1
	mov	dl, BYTE PTR ?ChromianceTable@@3PACA[ecx]
	mov	BYTE PTR _CB$[ebp], dl

; 910  :           A = 255 - A;

	cmp	BYTE PTR $T80502[ebp], 0
	jne	SHORT $LN114@RenderVide@2
	push	OFFSET $LN95@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN114@RenderVide@2:
	movzx	eax, BYTE PTR _A$[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR $T80502[ebp], 1
	mov	BYTE PTR _A$[ebp], cl

; 911  :           pixel = (A << 24) | (CB << 16) | (CR << 8) | Y;

	cmp	BYTE PTR $T80502[ebp], 0
	jne	SHORT $LN115@RenderVide@2
	push	OFFSET $LN95@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN115@RenderVide@2:
	cmp	BYTE PTR $T80501[ebp], 0
	jne	SHORT $LN116@RenderVide@2
	push	OFFSET $LN93@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN116@RenderVide@2:
	cmp	BYTE PTR $T80500[ebp], 0
	jne	SHORT $LN117@RenderVide@2
	push	OFFSET $LN91@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN117@RenderVide@2:
	cmp	BYTE PTR $T80499[ebp], 0
	jne	SHORT $LN118@RenderVide@2
	push	OFFSET $LN89@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN118@RenderVide@2:
	movzx	edx, BYTE PTR _A$[ebp]
	shl	edx, 24					; 00000018H
	movzx	eax, BYTE PTR _CB$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	movzx	ecx, BYTE PTR _CR$[ebp]
	shl	ecx, 8
	or	edx, ecx
	movzx	eax, BYTE PTR _Y$[ebp]
	or	edx, eax
	mov	DWORD PTR _pixel$[ebp], edx

; 912  :         }
; 913  :         else

	jmp	SHORT $LN14@RenderVide@2
$LN16@RenderVide@2:

; 914  :         {
; 915  :           //Color (0,0,0) is always transparent per Nuon architecture document
; 916  :           pixel = 0;

	mov	DWORD PTR _pixel$[ebp], 0
$LN14@RenderVide@2:

; 917  :         }
; 918  : 
; 919  :         ((uint32 *)ptrMainDisplayBuffer)[0] = pixel;

	mov	ecx, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	mov	edx, DWORD PTR _pixel$[ebp]
	mov	DWORD PTR [ecx], edx

; 920  :         ptrMainDisplayBuffer += 4; //Always RGBA 32 bit

	mov	eax, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	add	eax, 4
	mov	DWORD PTR _ptrMainDisplayBuffer$[ebp], eax

; 921  : 
; 922  :         if(pixType == 1)

	cmp	DWORD PTR _pixType$[ebp], 1
	jne	$LN13@RenderVide@2

; 923  :         {
; 924  :           if((Y2||CR2||CB2))

	cmp	BYTE PTR $T80504[ebp], 0
	jne	SHORT $LN119@RenderVide@2
	push	OFFSET $LN120@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN119@RenderVide@2:
	movzx	ecx, BYTE PTR _Y2$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@RenderVide@2
	cmp	BYTE PTR $T80505[ebp], 0
	jne	SHORT $LN121@RenderVide@2
	push	OFFSET $LN122@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN121@RenderVide@2:
	movzx	edx, BYTE PTR _CR2$[ebp]
	test	edx, edx
	jne	SHORT $LN11@RenderVide@2
	cmp	BYTE PTR $T80506[ebp], 0
	jne	SHORT $LN123@RenderVide@2
	push	OFFSET $LN124@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN123@RenderVide@2:
	movzx	eax, BYTE PTR _CB2$[ebp]
	test	eax, eax
	je	$LN12@RenderVide@2
$LN11@RenderVide@2:

; 925  :           {
; 926  :             Y2 = LuminanceTable[Y2];

	cmp	BYTE PTR $T80504[ebp], 0
	jne	SHORT $LN125@RenderVide@2
	push	OFFSET $LN120@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN125@RenderVide@2:
	movzx	ecx, BYTE PTR _Y2$[ebp]
	mov	BYTE PTR $T80504[ebp], 1
	mov	dl, BYTE PTR ?LuminanceTable@@3PACA[ecx]
	mov	BYTE PTR _Y2$[ebp], dl

; 927  :             CR2 = ChromianceTable[CR2];

	cmp	BYTE PTR $T80505[ebp], 0
	jne	SHORT $LN126@RenderVide@2
	push	OFFSET $LN122@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN126@RenderVide@2:
	movzx	eax, BYTE PTR _CR2$[ebp]
	mov	BYTE PTR $T80505[ebp], 1
	mov	cl, BYTE PTR ?ChromianceTable@@3PACA[eax]
	mov	BYTE PTR _CR2$[ebp], cl

; 928  :             CB2 = ChromianceTable[CB2];

	cmp	BYTE PTR $T80506[ebp], 0
	jne	SHORT $LN127@RenderVide@2
	push	OFFSET $LN124@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN127@RenderVide@2:
	movzx	edx, BYTE PTR _CB2$[ebp]
	mov	BYTE PTR $T80506[ebp], 1
	mov	al, BYTE PTR ?ChromianceTable@@3PACA[edx]
	mov	BYTE PTR _CB2$[ebp], al

; 929  :             A2 = 255 - A2;

	cmp	BYTE PTR $T80507[ebp], 0
	jne	SHORT $LN128@RenderVide@2
	push	OFFSET $LN129@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN128@RenderVide@2:
	movzx	ecx, BYTE PTR _A2$[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR $T80507[ebp], 1
	mov	BYTE PTR _A2$[ebp], dl

; 930  :             pixel = (A2 << 24) | (CB2 << 16) | (CR2 << 8) | Y2;

	cmp	BYTE PTR $T80507[ebp], 0
	jne	SHORT $LN130@RenderVide@2
	push	OFFSET $LN129@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN130@RenderVide@2:
	cmp	BYTE PTR $T80506[ebp], 0
	jne	SHORT $LN131@RenderVide@2
	push	OFFSET $LN124@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN131@RenderVide@2:
	cmp	BYTE PTR $T80505[ebp], 0
	jne	SHORT $LN132@RenderVide@2
	push	OFFSET $LN122@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN132@RenderVide@2:
	cmp	BYTE PTR $T80504[ebp], 0
	jne	SHORT $LN133@RenderVide@2
	push	OFFSET $LN120@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN133@RenderVide@2:
	movzx	eax, BYTE PTR _A2$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _CB2$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _CR2$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _Y2$[ebp]
	or	eax, ecx
	mov	DWORD PTR _pixel$[ebp], eax

; 931  :           }
; 932  :           else

	jmp	SHORT $LN10@RenderVide@2
$LN12@RenderVide@2:

; 933  :           {
; 934  :             //Color (0,0,0) is always transparent per Nuon architecture document
; 935  :             pixel = 0;

	mov	DWORD PTR _pixel$[ebp], 0
$LN10@RenderVide@2:

; 936  :           }
; 937  :           ((uint32 *)ptrMainDisplayBuffer)[0] = pixel;

	mov	edx, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	mov	eax, DWORD PTR _pixel$[ebp]
	mov	DWORD PTR [edx], eax

; 938  :           ptrMainDisplayBuffer += 4; //Always RGBA 32 bit

	mov	ecx, DWORD PTR _ptrMainDisplayBuffer$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ptrMainDisplayBuffer$[ebp], ecx
$LN13@RenderVide@2:

; 939  :         }
; 940  : 
; 941  :         ptrNuonFrameBuffer += pixWidth;

	cmp	BYTE PTR $T80497[ebp], 0
	jne	SHORT $LN134@RenderVide@2
	push	OFFSET $LN100@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN134@RenderVide@2:
	mov	edx, DWORD PTR _ptrNuonFrameBuffer$[ebp]
	add	edx, DWORD PTR _pixWidth$[ebp]
	mov	DWORD PTR _ptrNuonFrameBuffer$[ebp], edx

; 942  :       }

	jmp	$LN27@RenderVide@2
$LN26@RenderVide@2:

; 943  :     }

	jmp	$LN30@RenderVide@2
$LN29@RenderVide@2:
$LN32@RenderVide@2:
$LN35@RenderVide@2:
$render_main_buffer$78046:

; 944  :   }
; 945  : 
; 946  : render_main_buffer:
; 947  :   if(bMainChannelActive && nuonEnv->bMainBufferModified)

	movzx	eax, BYTE PTR ?bMainChannelActive@@3_NA	; bMainChannelActive
	test	eax, eax
	je	$render_overlay_buffer$78084
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+86]
	test	edx, edx
	je	$render_overlay_buffer$78084

; 948  :   {
; 949  :     glActiveTextureARB(mainTextureUnit);

	mov	esi, esp
	mov	eax, DWORD PTR ?mainTextureUnit@@3HA	; mainTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewActiveTextureARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 950  :     glBindTexture(TEXTURE_TARGET,videoTexInfo.mainTexName);

	mov	esi, esp
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+20
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 951  :     if(!bMainTextureCreated)

	movzx	ecx, BYTE PTR ?bMainTextureCreated@@3_NA ; bMainTextureCreated
	test	ecx, ecx
	jne	SHORT $LN8@RenderVide@2

; 952  :     {
; 953  :       glTexImage2D(TEXTURE_TARGET,0,mainInternalTextureFormat,ALLOCATED_TEXTURE_WIDTH,ALLOCATED_TEXTURE_HEIGHT,0,mainExternalTextureFormat,mainPixelType,pMainChannelBuffer);

	cmp	BYTE PTR $T80498[ebp], 0
	jne	SHORT $LN135@RenderVide@2
	push	OFFSET $LN136@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN135@RenderVide@2:
	mov	esi, esp
	mov	edx, DWORD PTR _pMainChannelBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR ?mainPixelType@@3HA	; mainPixelType
	push	eax
	mov	ecx, DWORD PTR ?mainExternalTextureFormat@@3HA ; mainExternalTextureFormat
	push	ecx
	push	0
	push	512					; 00000200H
	push	1024					; 00000400H
	mov	edx, DWORD PTR ?mainInternalTextureFormat@@3HA ; mainInternalTextureFormat
	push	edx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 954  :       bMainTextureCreated = true;

	mov	BYTE PTR ?bMainTextureCreated@@3_NA, 1	; bMainTextureCreated
$LN8@RenderVide@2:

; 955  :     }
; 956  : 
; 957  :     if(nuonEnv->videoOptions.bUseShaders)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	ecx, BYTE PTR [eax+121]
	test	ecx, ecx
	je	SHORT $LN7@RenderVide@2

; 958  :     {
; 959  :       glTexSubImage2D(TEXTURE_TARGET,0,0,0,structMainChannel.src_width,structMainChannel.src_height,mainExternalTextureFormat,mainPixelType,pMainChannelBuffer);

	cmp	BYTE PTR $T80498[ebp], 0
	jne	SHORT $LN137@RenderVide@2
	push	OFFSET $LN136@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN137@RenderVide@2:
	mov	esi, esp
	mov	edx, DWORD PTR _pMainChannelBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR ?mainPixelType@@3HA	; mainPixelType
	push	eax
	mov	ecx, DWORD PTR ?mainExternalTextureFormat@@3HA ; mainExternalTextureFormat
	push	ecx
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	push	edx
	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	push	eax
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 960  :     }
; 961  :     else

	jmp	SHORT $render_overlay_buffer$78084
$LN7@RenderVide@2:

; 962  :     {
; 963  :       glTexSubImage2D(TEXTURE_TARGET,0,0,0,structMainChannel.src_width,structMainChannel.src_height,mainExternalTextureFormat,mainPixelType,mainChannelBuffer);

	mov	esi, esp
	mov	ecx, DWORD PTR ?mainChannelBuffer@@3PAEA ; mainChannelBuffer
	push	ecx
	mov	edx, DWORD PTR ?mainPixelType@@3HA	; mainPixelType
	push	edx
	mov	eax, DWORD PTR ?mainExternalTextureFormat@@3HA ; mainExternalTextureFormat
	push	eax
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	push	ecx
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	push	edx
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$render_overlay_buffer$78084:

; 964  :     }
; 965  :   }
; 966  : 
; 967  : render_overlay_buffer:
; 968  :   if(bOverlayChannelActive && nuonEnv->bOverlayBufferModified)

	movzx	eax, BYTE PTR ?bOverlayChannelActive@@3_NA ; bOverlayChannelActive
	test	eax, eax
	je	$LN2@RenderVide@2
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+87]
	test	edx, edx
	je	$LN2@RenderVide@2

; 969  :   {
; 970  :     glActiveTextureARB(osdTextureUnit);

	mov	esi, esp
	mov	eax, DWORD PTR ?osdTextureUnit@@3HA	; osdTextureUnit
	push	eax
	mov	ecx, DWORD PTR __imp____glewActiveTextureARB
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 971  :     glBindTexture(TEXTURE_TARGET,videoTexInfo.osdTexName);

	mov	esi, esp
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+24
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 972  :     if(!bOverlayTextureCreated)

	movzx	ecx, BYTE PTR ?bOverlayTextureCreated@@3_NA ; bOverlayTextureCreated
	test	ecx, ecx
	jne	SHORT $LN4@RenderVide@2

; 973  :     {
; 974  :       glTexImage2D(TEXTURE_TARGET,0,osdInternalTextureFormat,ALLOCATED_TEXTURE_WIDTH,ALLOCATED_TEXTURE_HEIGHT,0,osdExternalTextureFormat,GL_UNSIGNED_BYTE,pOverlayChannelBuffer);

	cmp	BYTE PTR $T80503[ebp], 0
	jne	SHORT $LN138@RenderVide@2
	push	OFFSET $LN139@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN138@RenderVide@2:
	mov	esi, esp
	mov	edx, DWORD PTR _pOverlayChannelBuffer$[ebp]
	push	edx
	push	5121					; 00001401H
	mov	eax, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	eax
	push	0
	push	512					; 00000200H
	push	1024					; 00000400H
	mov	ecx, DWORD PTR ?osdInternalTextureFormat@@3HA ; osdInternalTextureFormat
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 975  :       bOverlayTextureCreated = true;

	mov	BYTE PTR ?bOverlayTextureCreated@@3_NA, 1 ; bOverlayTextureCreated
$LN4@RenderVide@2:

; 976  :     }
; 977  : 
; 978  :     if(nuonEnv->videoOptions.bUseShaders)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+121]
	test	eax, eax
	je	SHORT $LN3@RenderVide@2

; 979  :     {
; 980  :       glTexSubImage2D(TEXTURE_TARGET,0,0,0,structOverlayChannel.src_width,structOverlayChannel.src_height,osdExternalTextureFormat,GL_UNSIGNED_BYTE,pOverlayChannelBuffer);

	cmp	BYTE PTR $T80503[ebp], 0
	jne	SHORT $LN140@RenderVide@2
	push	OFFSET $LN139@RenderVide@2
	call	__RTC_UninitUse
	add	esp, 4
$LN140@RenderVide@2:
	mov	esi, esp
	mov	ecx, DWORD PTR _pOverlayChannelBuffer$[ebp]
	push	ecx
	push	5121					; 00001401H
	mov	edx, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	edx
	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	push	eax
	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	push	ecx
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 981  :     }
; 982  :     else

	jmp	SHORT $LN2@RenderVide@2
$LN3@RenderVide@2:

; 983  :     {
; 984  :       glTexSubImage2D(TEXTURE_TARGET,0,0,0,structOverlayChannel.src_width,structOverlayChannel.src_height,osdExternalTextureFormat,GL_UNSIGNED_BYTE,overlayChannelBuffer);

	mov	esi, esp
	mov	edx, DWORD PTR ?overlayChannelBuffer@@3PAEA ; overlayChannelBuffer
	push	edx
	push	5121					; 00001401H
	mov	eax, DWORD PTR ?osdExternalTextureFormat@@3HA ; osdExternalTextureFormat
	push	eax
	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	push	ecx
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	push	edx
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glTexSubImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@RenderVide@2:

; 985  :     }
; 986  :   }
; 987  : 
; 988  :   if(videoTexInfo.bUpdateDisplayList)

	movzx	eax, BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A
	test	eax, eax
	je	SHORT $LN1@RenderVide@2

; 989  :   {
; 990  :     UpdateDisplayList();

	call	?UpdateDisplayList@@YAXXZ		; UpdateDisplayList

; 991  :     videoTexInfo.bUpdateDisplayList = false;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 0
$LN1@RenderVide@2:

; 992  :   }
; 993  : 
; 994  :   activeChannels = (bOverlayChannelActive ? CHANNELSTATE_OVERLAY_ACTIVE: 0);

	movzx	ecx, BYTE PTR ?bOverlayChannelActive@@3_NA ; bOverlayChannelActive
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 2
	mov	DWORD PTR _activeChannels$[ebp], ecx

; 995  :   activeChannels |= (bMainChannelActive ? CHANNELSTATE_MAIN_ACTIVE : 0);

	movzx	edx, BYTE PTR ?bMainChannelActive@@3_NA	; bMainChannelActive
	neg	edx
	sbb	edx, edx
	neg	edx
	or	edx, DWORD PTR _activeChannels$[ebp]
	mov	DWORD PTR _activeChannels$[ebp], edx

; 996  :  
; 997  :   glCallList(videoTexInfo.displayListName[activeChannels]);

	mov	esi, esp
	mov	eax, DWORD PTR _activeChannels$[ebp]
	mov	ecx, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A[eax*4+4]
	push	ecx
	call	DWORD PTR __imp__glCallList@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 998  :   glFlush();

	mov	esi, esp
	call	DWORD PTR __imp__glFlush@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 999  : 
; 1000 :   nuonEnv->bMainBufferModified = false;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 0

; 1001 :   nuonEnv->bOverlayBufferModified = false;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 0
$LN83@RenderVide@2:

; 1002 : }

	pop	edi
	pop	esi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN141@RenderVide@2:
$LN139@RenderVide@2:
	DB	112					; 00000070H
	DB	79					; 0000004fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN136@RenderVide@2:
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN129@RenderVide@2:
	DB	65					; 00000041H
	DB	50					; 00000032H
	DB	0
$LN124@RenderVide@2:
	DB	67					; 00000043H
	DB	66					; 00000042H
	DB	50					; 00000032H
	DB	0
$LN122@RenderVide@2:
	DB	67					; 00000043H
	DB	82					; 00000052H
	DB	50					; 00000032H
	DB	0
$LN120@RenderVide@2:
	DB	89					; 00000059H
	DB	50					; 00000032H
	DB	0
$LN100@RenderVide@2:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN95@RenderVide@2:
	DB	65					; 00000041H
	DB	0
$LN93@RenderVide@2:
	DB	67					; 00000043H
	DB	66					; 00000042H
	DB	0
$LN91@RenderVide@2:
	DB	67					; 00000043H
	DB	82					; 00000052H
	DB	0
$LN89@RenderVide@2:
	DB	89					; 00000059H
	DB	0
$LN86@RenderVide@2:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	116					; 00000074H
	DB	0
	npad	1
$LN142@RenderVide@2:
	DD	$LN73@RenderVide@2
	DD	$LN72@RenderVide@2
	DD	$LN71@RenderVide@2
	DD	$LN70@RenderVide@2
	DD	$LN69@RenderVide@2
	DD	$LN68@RenderVide@2
	DD	$LN67@RenderVide@2
$LN143@RenderVide@2:
	DD	$LN46@RenderVide@2
	DD	$LN45@RenderVide@2
	DD	$LN44@RenderVide@2
	DD	$LN43@RenderVide@2
	DD	$LN42@RenderVide@2
	DD	$LN41@RenderVide@2
	DD	$LN40@RenderVide@2
$LN144@RenderVide@2:
	DD	$LN23@RenderVide@2
	DD	$LN22@RenderVide@2
	DD	$LN21@RenderVide@2
	DD	$LN20@RenderVide@2
	DD	$LN19@RenderVide@2
	DD	$LN18@RenderVide@2
?RenderVideo@@YAXHH@Z ENDP				; RenderVideo
_TEXT	ENDS
PUBLIC	?UpdateBufferLengths@@YAXXZ			; UpdateBufferLengths
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
?UpdateBufferLengths@@YAXXZ PROC			; UpdateBufferLengths

; 1007 : {

	push	ebp
	mov	ebp, esp

; 1008 :   if(bMainChannelActive)

	movzx	eax, BYTE PTR ?bMainChannelActive@@3_NA	; bMainChannelActive
	test	eax, eax
	je	SHORT $LN4@UpdateBuff

; 1009 :   {
; 1010 :     nuonEnv->mainChannelLowerLimit = (uint32)structMainChannel.base;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	mov	DWORD PTR [ecx+52], edx

; 1011 :     nuonEnv->mainChannelUpperLimit = nuonEnv->mainChannelLowerLimit + (structMainChannel.src_width * structMainChannel.src_height * pixTypeToPixWidth[(structMainChannel.dmaflags >> 4) & 0x7]) - 1;

	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	imul	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	sar	ecx, 4
	and	ecx, 7
	imul	eax, DWORD PTR ?pixTypeToPixWidth@@3PAIA[ecx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+52]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [eax+48], edx

; 1012 :   }
; 1013 :   else

	jmp	SHORT $LN3@UpdateBuff
$LN4@UpdateBuff:

; 1014 :   {
; 1015 :     nuonEnv->mainChannelLowerLimit = 0;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [ecx+52], 0

; 1016 :     nuonEnv->mainChannelUpperLimit = 0;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [edx+48], 0
$LN3@UpdateBuff:

; 1017 :   }
; 1018 : 
; 1019 :   if(bOverlayChannelActive)

	movzx	eax, BYTE PTR ?bOverlayChannelActive@@3_NA ; bOverlayChannelActive
	test	eax, eax
	je	SHORT $LN2@UpdateBuff

; 1020 :   {
; 1021 :     nuonEnv->overlayChannelLowerLimit = (uint32)structOverlayChannel.base;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	mov	DWORD PTR [ecx+60], edx

; 1022 :     nuonEnv->overlayChannelUpperLimit = nuonEnv->overlayChannelLowerLimit + (structOverlayChannel.src_width * structOverlayChannel.src_height * pixTypeToPixWidth[(structOverlayChannel.dmaflags >> 4) & 0x7]) - 1;

	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	imul	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	sar	ecx, 4
	and	ecx, 7
	imul	eax, DWORD PTR ?pixTypeToPixWidth@@3PAIA[ecx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+60]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [eax+56], edx

; 1023 :   }
; 1024 :   else

	jmp	SHORT $LN5@UpdateBuff
$LN2@UpdateBuff:

; 1025 :   {
; 1026 :     nuonEnv->overlayChannelLowerLimit = 0;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [ecx+60], 0

; 1027 :     nuonEnv->overlayChannelUpperLimit = 0;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [edx+56], 0
$LN5@UpdateBuff:

; 1028 :   }
; 1029 : }

	pop	ebp
	ret	0
?UpdateBufferLengths@@YAXXZ ENDP			; UpdateBufferLengths
_TEXT	ENDS
PUBLIC	?VidQueryConfig@@YAXPAVMPE@@@Z			; VidQueryConfig
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_displayStruct$ = -4					; size = 4
_mpe$ = 8						; size = 4
?VidQueryConfig@@YAXPAVMPE@@@Z PROC			; VidQueryConfig

; 1032 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1033 :   VidDisplay *displayStruct;
; 1034 : 
; 1035 :   displayStruct = (VidDisplay *)nuonEnv->GetPointerToMemory(mpe,mpe->regs[0]);

	push	1
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _displayStruct$[ebp], eax

; 1036 : 
; 1037 :   displayStruct->dispwidth = structMainDisplay.dispwidth;

	mov	eax, DWORD PTR _displayStruct$[ebp]
	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	mov	DWORD PTR [eax], ecx

; 1038 :   displayStruct->dispheight = structMainDisplay.dispheight;

	mov	edx, DWORD PTR _displayStruct$[ebp]
	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	mov	DWORD PTR [edx+4], eax

; 1039 :   displayStruct->bordcolor = structMainDisplay.bordcolor;

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8
	mov	DWORD PTR [ecx+8], edx

; 1040 :   displayStruct->progressive = structMainDisplay.progressive;

	mov	eax, DWORD PTR _displayStruct$[ebp]
	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+12
	mov	DWORD PTR [eax+12], ecx

; 1041 :   displayStruct->fps = structMainDisplay.fps;

	mov	edx, DWORD PTR _displayStruct$[ebp]
	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+16
	mov	DWORD PTR [edx+16], eax

; 1042 :   displayStruct->pixel_aspect_x = structMainDisplay.pixel_aspect_x;

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	mov	dx, WORD PTR ?structMainDisplay@@3UVidDisplay@@A+20
	mov	WORD PTR [ecx+20], dx

; 1043 :   displayStruct->pixel_aspect_y = structMainDisplay.pixel_aspect_y;

	mov	eax, DWORD PTR _displayStruct$[ebp]
	mov	cx, WORD PTR ?structMainDisplay@@3UVidDisplay@@A+22
	mov	WORD PTR [eax+22], cx

; 1044 :   displayStruct->screen_aspect_x = structMainDisplay.screen_aspect_x;

	mov	edx, DWORD PTR _displayStruct$[ebp]
	mov	ax, WORD PTR ?structMainDisplay@@3UVidDisplay@@A+24
	mov	WORD PTR [edx+24], ax

; 1045 :   displayStruct->screen_aspect_y = structMainDisplay.screen_aspect_y;

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	mov	dx, WORD PTR ?structMainDisplay@@3UVidDisplay@@A+26
	mov	WORD PTR [ecx+26], dx

; 1046 :   displayStruct->reserved[0] = structMainDisplay.reserved[0];

	mov	eax, DWORD PTR _displayStruct$[ebp]
	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+28
	mov	DWORD PTR [eax+28], ecx

; 1047 :   displayStruct->reserved[1] = structMainDisplay.reserved[1];

	mov	edx, DWORD PTR _displayStruct$[ebp]
	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+32
	mov	DWORD PTR [edx+32], eax

; 1048 :   displayStruct->reserved[2] = structMainDisplay.reserved[2];

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+36
	mov	DWORD PTR [ecx+36], edx

; 1049 : 
; 1050 :   SwapScalarBytes((uint32 *)&displayStruct->dispwidth);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1051 :   SwapScalarBytes((uint32 *)&displayStruct->dispheight);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 4
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1052 :   SwapScalarBytes((uint32 *)&displayStruct->bordcolor);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 8
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1053 :   SwapScalarBytes((uint32 *)&displayStruct->progressive);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 12					; 0000000cH
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1054 :   SwapScalarBytes((uint32 *)&displayStruct->fps);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 16					; 00000010H
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1055 :   SwapWordBytes((uint16 *)&displayStruct->pixel_aspect_x);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 20					; 00000014H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1056 :   SwapWordBytes((uint16 *)&displayStruct->pixel_aspect_y);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 22					; 00000016H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1057 :   SwapWordBytes((uint16 *)&displayStruct->screen_aspect_x);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 24					; 00000018H
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1058 :   SwapWordBytes((uint16 *)&displayStruct->screen_aspect_y);

	mov	ecx, DWORD PTR _displayStruct$[ebp]
	add	ecx, 26					; 0000001aH
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 1059 : 
; 1060 : 
; 1061 :   //Return 1 to specify NTSC
; 1062 :   mpe->regs[0] = 1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 1

; 1063 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VidQueryConfig@@YAXPAVMPE@@@Z ENDP			; VidQueryConfig
_TEXT	ENDS
PUBLIC	?VidConfig@@YAXPAVMPE@@@Z			; VidConfig
EXTRN	?SwapVectorBytes@@YIXPAI@Z:PROC			; SwapVectorBytes
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv612 = -244						; size = 4
tv611 = -240						; size = 4
tv610 = -236						; size = 4
$T80579 = -232						; size = 4
_bUpdateOpenGLData$ = -225				; size = 1
_pOSDChannel$ = -224					; size = 4
_pMainChannel$ = -220					; size = 4
_pMainDisplay$ = -216					; size = 4
_osdchannel$ = -208					; size = 64
_mainchannel$ = -136					; size = 64
_maindisplay$ = -64					; size = 40
_reserved$ = -20					; size = 4
_osd$ = -16						; size = 4
_main$ = -12						; size = 4
_display$ = -8						; size = 4
_map$ = -4						; size = 4
_mpe$ = 8						; size = 4
?VidConfig@@YAXPAVMPE@@@Z PROC				; VidConfig

; 1066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1067 :   uint32 map;
; 1068 :   uint32 display = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _display$[ebp], ecx

; 1069 :   uint32 main = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _main$[ebp], eax

; 1070 :   uint32 osd = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _osd$[ebp], edx

; 1071 :   uint32 reserved = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _reserved$[ebp], ecx

; 1072 :   VidDisplay maindisplay;
; 1073 :   VidChannel mainchannel, osdchannel;
; 1074 :   VidDisplay *pMainDisplay;
; 1075 :   VidChannel *pMainChannel, *pOSDChannel;
; 1076 : 
; 1077 :   bool bUpdateOpenGLData = false;

	mov	BYTE PTR _bUpdateOpenGLData$[ebp], 0

; 1078 : 
; 1079 :   channelStatePrev = channelState;

	mov	edx, DWORD PTR ?channelState@@3IA	; channelState
	mov	DWORD PTR ?channelStatePrev@@3IA, edx	; channelStatePrev

; 1080 :   channelState = 0;

	mov	DWORD PTR ?channelState@@3IA, 0		; channelState

; 1081 : 
; 1082 :   if(display)

	cmp	DWORD PTR _display$[ebp], 0
	je	SHORT $LN32@VidConfig

; 1083 :   {
; 1084 :     pMainDisplay = (VidDisplay *)nuonEnv->GetPointerToMemory(mpe, display);

	push	1
	mov	eax, DWORD PTR _display$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pMainDisplay$[ebp], eax

; 1085 :     memcpy(&maindisplay,pMainDisplay,sizeof(VidDisplay));

	push	40					; 00000028H
	mov	edx, DWORD PTR _pMainDisplay$[ebp]
	push	edx
	lea	eax, DWORD PTR _maindisplay$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1086 :     SwapScalarBytes((uint32 *)&maindisplay.bordcolor);

	lea	ecx, DWORD PTR _maindisplay$[ebp+8]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1087 : 
; 1088 :     maindisplay.dispwidth = 720;

	mov	DWORD PTR _maindisplay$[ebp], 720	; 000002d0H

; 1089 :     maindisplay.dispheight = 480;

	mov	DWORD PTR _maindisplay$[ebp+4], 480	; 000001e0H

; 1090 :     maindisplay.fps = 0;

	mov	DWORD PTR _maindisplay$[ebp+16], 0

; 1091 :     maindisplay.progressive = -1;

	mov	DWORD PTR _maindisplay$[ebp+12], -1
$LN32@VidConfig:

; 1092 :   }
; 1093 : 
; 1094 :   if(main)

	cmp	DWORD PTR _main$[ebp], 0
	je	SHORT $LN30@VidConfig

; 1095 :   {
; 1096 :     pMainChannel = (VidChannel *)nuonEnv->GetPointerToMemory(mpe, main);

	push	1
	mov	ecx, DWORD PTR _main$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pMainChannel$[ebp], eax

; 1097 :     memcpy(&mainchannel,pMainChannel,sizeof(VidChannel));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pMainChannel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mainchannel$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1098 :     SwapVectorBytes((uint32 *)&mainchannel.dmaflags);

	lea	ecx, DWORD PTR _mainchannel$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1099 :     SwapVectorBytes((uint32 *)&mainchannel.dest_width);

	lea	ecx, DWORD PTR _mainchannel$[ebp+16]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1100 :     SwapScalarBytes((uint32 *)&mainchannel.src_width);

	lea	ecx, DWORD PTR _mainchannel$[ebp+32]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1101 :     SwapScalarBytes((uint32 *)&mainchannel.src_height);

	lea	ecx, DWORD PTR _mainchannel$[ebp+36]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1102 :     if(mainchannel.base == 0)

	cmp	DWORD PTR _mainchannel$[ebp+4], 0
	jne	SHORT $LN30@VidConfig

; 1103 :     {
; 1104 :       //mpe->regs[0] = 0;
; 1105 :       //return;
; 1106 :       mainchannel.base = structMainChannel.base;

	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	mov	DWORD PTR _mainchannel$[ebp+4], edx
$LN30@VidConfig:

; 1107 :     }
; 1108 :   }
; 1109 : 
; 1110 :   if(osd)

	cmp	DWORD PTR _osd$[ebp], 0
	je	SHORT $LN28@VidConfig

; 1111 :   {
; 1112 :     pOSDChannel = (VidChannel *)nuonEnv->GetPointerToMemory(mpe, osd);

	push	1
	mov	eax, DWORD PTR _osd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pOSDChannel$[ebp], eax

; 1113 :     memcpy(&osdchannel,pOSDChannel,sizeof(VidChannel));

	push	64					; 00000040H
	mov	edx, DWORD PTR _pOSDChannel$[ebp]
	push	edx
	lea	eax, DWORD PTR _osdchannel$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1114 :     SwapVectorBytes((uint32 *)&osdchannel.dmaflags);

	lea	ecx, DWORD PTR _osdchannel$[ebp]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1115 :     SwapVectorBytes((uint32 *)&osdchannel.dest_width);

	lea	ecx, DWORD PTR _osdchannel$[ebp+16]
	call	?SwapVectorBytes@@YIXPAI@Z		; SwapVectorBytes

; 1116 :     SwapScalarBytes((uint32 *)&osdchannel.src_width);

	lea	ecx, DWORD PTR _osdchannel$[ebp+32]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1117 :     SwapScalarBytes((uint32 *)&osdchannel.src_height);

	lea	ecx, DWORD PTR _osdchannel$[ebp+36]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 1118 :     if(osdchannel.base == 0)

	cmp	DWORD PTR _osdchannel$[ebp+4], 0
	jne	SHORT $LN28@VidConfig

; 1119 :     {
; 1120 :       //mpe->regs[0] = 0;
; 1121 :       //return;
; 1122 :       osdchannel.base = structOverlayChannel.base;

	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	mov	DWORD PTR _osdchannel$[ebp+4], ecx
$LN28@VidConfig:

; 1123 :     }
; 1124 :   }
; 1125 : 
; 1126 :   if(display)

	cmp	DWORD PTR _display$[ebp], 0
	je	$LN27@VidConfig

; 1127 :   {
; 1128 :     memcpy(&structMainDisplayPrev,&structMainDisplay,sizeof(VidDisplay));

	push	40					; 00000028H
	push	OFFSET ?structMainDisplay@@3UVidDisplay@@A ; structMainDisplay
	push	OFFSET ?structMainDisplayPrev@@3UVidDisplay@@A ; structMainDisplayPrev
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1129 :     memcpy(&structMainDisplay,&maindisplay,sizeof(VidDisplay));

	push	40					; 00000028H
	lea	edx, DWORD PTR _maindisplay$[ebp]
	push	edx
	push	OFFSET ?structMainDisplay@@3UVidDisplay@@A ; structMainDisplay
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1130 : 
; 1131 :     borderTexture[0] = (structMainDisplay.bordcolor >> 24) & 0xFF;

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8
	sar	eax, 24					; 00000018H
	and	eax, 255				; 000000ffH
	mov	BYTE PTR ?borderTexture@@3PAEA, al

; 1132 :     borderTexture[1] = (structMainDisplay.bordcolor >> 16) & 0xFF;

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8
	sar	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR ?borderTexture@@3PAEA+1, cl

; 1133 :     borderTexture[2] = (structMainDisplay.bordcolor >> 8) & 0xFF;

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8
	sar	edx, 8
	and	edx, 255				; 000000ffH
	mov	BYTE PTR ?borderTexture@@3PAEA+2, dl

; 1134 :     borderTexture[3] = 0.0;

	mov	BYTE PTR ?borderTexture@@3PAEA+3, 0

; 1135 :     videoTexInfo.borderColor[0] = borderTexture[0];

	movzx	eax, BYTE PTR ?borderTexture@@3PAEA
	mov	DWORD PTR tv610[ebp], eax
	fild	DWORD PTR tv610[ebp]
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+36

; 1136 :     videoTexInfo.borderColor[1] = borderTexture[1];

	movzx	ecx, BYTE PTR ?borderTexture@@3PAEA+1
	mov	DWORD PTR tv611[ebp], ecx
	fild	DWORD PTR tv611[ebp]
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+40

; 1137 :     videoTexInfo.borderColor[2] = borderTexture[2];

	movzx	edx, BYTE PTR ?borderTexture@@3PAEA+2
	mov	DWORD PTR tv612[ebp], edx
	fild	DWORD PTR tv612[ebp]
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+44

; 1138 :     videoTexInfo.borderColor[3] = 0.0;

	fldz
	fstp	DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A+48

; 1139 : 
; 1140 :     bUpdateOpenGLData |= (structMainDisplay.bordcolor != structMainDisplayPrev.bordcolor);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainDisplayPrev@@3UVidDisplay@@A+8
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al
$LN27@VidConfig:

; 1141 :   }
; 1142 : 
; 1143 :   if(!mainDisplayBuffer)

	cmp	DWORD PTR ?mainDisplayBuffer@@3PAEA, 0	; mainDisplayBuffer
	jne	SHORT $LN26@VidConfig

; 1144 :   {
; 1145 :     mainDisplayBuffer = new uint8[structMainDisplay.dispwidth * structMainDisplay.dispheight * 4];

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	imul	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	shl	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T80579[ebp], eax
	mov	ecx, DWORD PTR $T80579[ebp]
	mov	DWORD PTR ?mainDisplayBuffer@@3PAEA, ecx ; mainDisplayBuffer
$LN26@VidConfig:

; 1146 :   }
; 1147 :   bMainChannelActive = false;

	mov	BYTE PTR ?bMainChannelActive@@3_NA, 0	; bMainChannelActive

; 1148 :   bOverlayChannelActive = false;

	mov	BYTE PTR ?bOverlayChannelActive@@3_NA, 0 ; bOverlayChannelActive

; 1149 : 
; 1150 :   if(main)

	cmp	DWORD PTR _main$[ebp], 0
	je	$LN25@VidConfig

; 1151 :   {
; 1152 :     memcpy(&structMainChannelPrev,&structMainChannel,sizeof(VidChannel));

	push	64					; 00000040H
	push	OFFSET ?structMainChannel@@3UVidChannel@@A ; structMainChannel
	push	OFFSET ?structMainChannelPrev@@3UVidChannel@@A ; structMainChannelPrev
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1153 :     memcpy(&structMainChannel,&mainchannel,sizeof(VidChannel));

	push	64					; 00000040H
	lea	edx, DWORD PTR _mainchannel$[ebp]
	push	edx
	push	OFFSET ?structMainChannel@@3UVidChannel@@A ; structMainChannel
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1154 : 
; 1155 :     map = (structMainChannel.dmaflags >> 4) & 0x0FUL;

	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	sar	eax, 4
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _map$[ebp], eax

; 1156 : 
; 1157 :     //Handle 16_16Z double and triple buffer frame buffers
; 1158 :     if((map >= 9) || (map == 5))

	cmp	DWORD PTR _map$[ebp], 9
	jae	SHORT $LN23@VidConfig
	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN24@VidConfig
$LN23@VidConfig:

; 1159 :     {
; 1160 :       if(map == 5)

	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN22@VidConfig

; 1161 :       {
; 1162 :         //16+16Z single buffer: map 0 contains 16-bit color map 1 contains 16 bit Z data
; 1163 :         map = 0;

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN19@VidConfig
$LN22@VidConfig:

; 1164 :       }
; 1165 :       else if(map < 13)

	cmp	DWORD PTR _map$[ebp], 13		; 0000000dH
	jae	SHORT $LN20@VidConfig

; 1166 :       {
; 1167 :         //16+16Z triple buffer: map 0,1 and 2 contain 16-bit color data, map 3 contains 16 bit Z data
; 1168 :         map = map - 9;

	mov	ecx, DWORD PTR _map$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 1169 :       }
; 1170 :       else

	jmp	SHORT $LN19@VidConfig
$LN20@VidConfig:

; 1171 :       {
; 1172 :         //16+16Z double buffer: map 0,1 contain 16-bit color data, map 2 contains 16 bit Z data
; 1173 :         map = map - 13;

	mov	edx, DWORD PTR _map$[ebp]
	sub	edx, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], edx
$LN19@VidConfig:

; 1174 :       }
; 1175 :       //The specified base address always points to the start of the first color buffer/map.  The pixel type
; 1176 :       //determines which map is to be displayed.  The proper byte offset from the start of the first map can be
; 1177 :       //computed using (map * src_width * src_height * bytes_per_pixel) where bytes_per_pixel is always two.
; 1178 :       structMainChannel.base = ((uint8 *)structMainChannel.base) + (map * structMainChannel.src_width * structMainChannel.src_height * 2);

	mov	eax, DWORD PTR _map$[ebp]
	imul	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	imul	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+4, edx

; 1179 :       //change the pixel type to 16-bit, no-Z
; 1180 :       structMainChannel.dmaflags = (structMainChannel.dmaflags & 0xFFFFFF0FUL) | (0x02 << 4);

	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	and	eax, -241				; ffffff0fH
	or	eax, 32					; 00000020H
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A, eax
$LN24@VidConfig:

; 1181 : 
; 1182 :       //It is safe to specify a pixel type of 12 or 15 but this will display Z-data and look really funky.
; 1183 :     }
; 1184 :     
; 1185 :     if(structMainChannel.dest_height == 0)

	cmp	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20, 0
	jne	SHORT $LN18@VidConfig

; 1186 :     {
; 1187 :       //Should the dest height default to the display height, or source height?
; 1188 :       //Is it even valid to leave this at zero?  The SDK docs say nothing about
; 1189 :       //this case, but Decaying Orbit sets dest height and dest width to zero!
; 1190 :       structMainChannel.dest_height = structMainDisplay.dispheight;

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20, ecx
$LN18@VidConfig:

; 1191 :     }
; 1192 : 
; 1193 :     if(structMainChannel.dest_width == 0)

	cmp	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16, 0
	jne	SHORT $LN17@VidConfig

; 1194 :     {
; 1195 :       //Should the dest height default to the display width, or source width?
; 1196 :       //Is it even valid to leave this at zero?  The SDK docs say nothing about
; 1197 :       //this case, but Decaying Orbit sets dest height and dest width to zero!
; 1198 :       structMainChannel.dest_width = structMainDisplay.dispwidth;

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16, edx
$LN17@VidConfig:

; 1199 :     }
; 1200 : 
; 1201 :     //check for -1 in dest_xoff or dest_yoff: if either is -1, compute proper
; 1202 :     //offset needed to center along x and/or y
; 1203 :     if(structMainChannel.dest_xoff == -1)

	cmp	DWORD PTR ?structMainChannel@@3UVidChannel@@A+8, -1
	jne	SHORT $LN16@VidConfig

; 1204 :     {
; 1205 :       structMainChannel.dest_xoff = (structMainDisplay.dispwidth - structMainChannel.dest_width) >> 1;

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	sub	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	sar	eax, 1
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+8, eax
$LN16@VidConfig:

; 1206 :     }
; 1207 : 
; 1208 :     if(structMainChannel.dest_yoff == -1)

	cmp	DWORD PTR ?structMainChannel@@3UVidChannel@@A+12, -1
	jne	SHORT $LN15@VidConfig

; 1209 :     {
; 1210 :       structMainChannel.dest_yoff = (structMainDisplay.dispheight - structMainChannel.dest_height) >> 1;

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	sub	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	sar	ecx, 1
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+12, ecx
$LN15@VidConfig:

; 1211 :     }
; 1212 : 
; 1213 :     //mainChannelBuffer = AllocateTextureMemory(((structMainChannel.src_width & 0xFFFF) * (structMainChannel.src_height & 0xFFFF)) << 2,false);
; 1214 :     mainChannelScaleX = (float)structMainChannel.dest_width/(float)structMainChannel.src_width;

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	fstp	DWORD PTR ?mainChannelScaleX@@3MA	; mainChannelScaleX

; 1215 :     mainChannelScaleY = (float)structMainChannel.dest_height/(float)structMainChannel.src_height;

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	fstp	DWORD PTR ?mainChannelScaleY@@3MA	; mainChannelScaleY

; 1216 :     bMainChannelActive = true;

	mov	BYTE PTR ?bMainChannelActive@@3_NA, 1	; bMainChannelActive

; 1217 :     channelState |= CHANNELSTATE_MAIN_ACTIVE;

	mov	edx, DWORD PTR ?channelState@@3IA	; channelState
	or	edx, 1
	mov	DWORD PTR ?channelState@@3IA, edx	; channelState

; 1218 : 
; 1219 :     bUpdateOpenGLData |= (structMainChannel.alpha != structMainChannelPrev.alpha);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	ecx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+41
	movzx	edx, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+41
	xor	ebx, ebx
	cmp	ecx, edx
	setne	bl
	or	eax, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1220 :     bUpdateOpenGLData |= (structMainChannel.clut_select != structMainChannelPrev.clut_select);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	ecx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+40
	movzx	edx, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+40
	xor	ebx, ebx
	cmp	ecx, edx
	setne	bl
	or	eax, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1221 :     bUpdateOpenGLData |= (structMainChannel.dest_height != structMainChannelPrev.dest_height);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+20
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1222 :     bUpdateOpenGLData |= (structMainChannel.dest_width != structMainChannelPrev.dest_width);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+16
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1223 :     bUpdateOpenGLData |= (structMainChannel.dest_xoff != structMainChannelPrev.dest_xoff);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+8
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+8
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1224 :     bUpdateOpenGLData |= (structMainChannel.dest_yoff != structMainChannelPrev.dest_yoff);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+12
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+12
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1225 :     bUpdateOpenGLData |= (structMainChannel.dmaflags != structMainChannelPrev.dmaflags);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1226 :     bUpdateOpenGLData |= (structMainChannel.hfilter != structMainChannelPrev.hfilter);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	ecx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+43
	movzx	edx, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+43
	xor	ebx, ebx
	cmp	ecx, edx
	setne	bl
	or	eax, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1227 :     bUpdateOpenGLData |= (structMainChannel.src_width != structMainChannelPrev.src_width);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+32
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1228 :     bUpdateOpenGLData |= (structMainChannel.src_height != structMainChannelPrev.src_height);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+36
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1229 :     bUpdateOpenGLData |= (structMainChannel.src_xoff != structMainChannelPrev.src_xoff);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+24
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+24
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1230 :     bUpdateOpenGLData |= (structMainChannel.src_yoff != structMainChannelPrev.src_yoff);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+28
	xor	edx, edx
	cmp	ecx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+28
	setne	dl
	or	eax, edx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al

; 1231 :     bUpdateOpenGLData |= (structMainChannel.vfilter != structMainChannelPrev.vfilter);

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	ecx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+42
	movzx	edx, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+42
	xor	ebx, ebx
	cmp	ecx, edx
	setne	bl
	or	eax, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], al
$LN25@VidConfig:

; 1232 :   }
; 1233 : 
; 1234 :   if(osd)

	cmp	DWORD PTR _osd$[ebp], 0
	je	$LN14@VidConfig

; 1235 :   {
; 1236 :     memcpy(&structOverlayChannelPrev,&structOverlayChannel,sizeof(VidChannel));

	push	64					; 00000040H
	push	OFFSET ?structOverlayChannel@@3UVidChannel@@A ; structOverlayChannel
	push	OFFSET ?structOverlayChannelPrev@@3UVidChannel@@A ; structOverlayChannelPrev
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1237 :     memcpy(&structOverlayChannel,&osdchannel,sizeof(VidChannel));

	push	64					; 00000040H
	lea	eax, DWORD PTR _osdchannel$[ebp]
	push	eax
	push	OFFSET ?structOverlayChannel@@3UVidChannel@@A ; structOverlayChannel
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1238 : 
; 1239 :     map = (structOverlayChannel.dmaflags >> 4) & 0x0FUL;

	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	sar	ecx, 4
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _map$[ebp], ecx

; 1240 : 
; 1241 :     //Handle 16_16Z double and triple buffer frame buffers
; 1242 :     if((map >= 9) || (map == 5))

	cmp	DWORD PTR _map$[ebp], 9
	jae	SHORT $LN12@VidConfig
	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN13@VidConfig
$LN12@VidConfig:

; 1243 :     {
; 1244 :       if(map == 5)

	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN11@VidConfig

; 1245 :       {
; 1246 :         //16+16Z single buffer: map 0 contains 16-bit color map 1 contains 16 bit Z data
; 1247 :         map = 0;

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN8@VidConfig
$LN11@VidConfig:

; 1248 :       }
; 1249 :       else if(map < 13)

	cmp	DWORD PTR _map$[ebp], 13		; 0000000dH
	jae	SHORT $LN9@VidConfig

; 1250 :       {
; 1251 :         //16+16Z triple buffer: map 0,1 and 2 contain 16-bit color data, map 3 contains 16 bit Z data
; 1252 :         map = map - 9;

	mov	edx, DWORD PTR _map$[ebp]
	sub	edx, 9
	mov	DWORD PTR _map$[ebp], edx

; 1253 :       }
; 1254 :       else

	jmp	SHORT $LN8@VidConfig
$LN9@VidConfig:

; 1255 :       {
; 1256 :         //16+16Z double buffer: map 0,1 contain 16-bit color data, map 2 contains 16 bit Z data
; 1257 :         map = map - 13;

	mov	eax, DWORD PTR _map$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax
$LN8@VidConfig:

; 1258 :       }
; 1259 :       //The specified base address always points to the start of the first color buffer/map.  The pixel type
; 1260 :       //determines which map is to be displayed.  The proper byte offset from the start of the first map can be
; 1261 :       //computed using (map * src_width * src_height * bytes_per_pixel) where bytes_per_pixel is always two.
; 1262 :       structOverlayChannel.base = ((uint8 *)structOverlayChannel.base) + (map * structOverlayChannel.src_width * structOverlayChannel.src_height * 2);

	mov	ecx, DWORD PTR _map$[ebp]
	imul	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	imul	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4, eax

; 1263 :       //change the pixel type to 16-bit, no-Z
; 1264 :       structOverlayChannel.dmaflags = (structOverlayChannel.dmaflags & 0xFFFFFF0FUL) | (0x02 << 4);

	mov	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	and	ecx, -241				; ffffff0fH
	or	ecx, 32					; 00000020H
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A, ecx
$LN13@VidConfig:

; 1265 : 
; 1266 :       //It is safe to specify a pixel type of 12 or 15 but this will display Z-data and look really funky.
; 1267 :     }
; 1268 : 
; 1269 :     if(structOverlayChannel.dest_height == 0)

	cmp	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20, 0
	jne	SHORT $LN7@VidConfig

; 1270 :     {
; 1271 :       //Should the dest height default to the display height, or source height?
; 1272 :       //Is it even valid to leave this at zero?  The SDK docs say nothing about
; 1273 :       //this case, but Decaying Orbit sets dest height and dest width to zero!
; 1274 :       structOverlayChannel.dest_height = structMainDisplay.dispheight;

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20, edx
$LN7@VidConfig:

; 1275 :     }
; 1276 : 
; 1277 :     if(structOverlayChannel.dest_width == 0)

	cmp	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16, 0
	jne	SHORT $LN6@VidConfig

; 1278 :     {
; 1279 :       //Should the dest height default to the display width, or source width?
; 1280 :       //Is it even valid to leave this at zero?  The SDK docs say nothing about
; 1281 :       //this case, but Decaying Orbit sets dest height and dest width to zero!
; 1282 :       structOverlayChannel.dest_width = structMainDisplay.dispwidth;

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16, eax
$LN6@VidConfig:

; 1283 :     }
; 1284 : 
; 1285 :     //check for -1 in dest_xoff or dest_yoff: if either is -1, compute proper
; 1286 :     //offset needed to center along x and/or y
; 1287 :     if(structOverlayChannel.dest_xoff == -1)

	cmp	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+8, -1
	jne	SHORT $LN5@VidConfig

; 1288 :     {
; 1289 :       structOverlayChannel.dest_xoff = (structMainDisplay.dispwidth - structOverlayChannel.dest_width) >> 1;

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	sub	ecx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16
	sar	ecx, 1
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+8, ecx
$LN5@VidConfig:

; 1290 :     }
; 1291 : 
; 1292 :     if(structOverlayChannel.dest_yoff == -1)

	cmp	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+12, -1
	jne	SHORT $LN4@VidConfig

; 1293 :     {
; 1294 :       structOverlayChannel.dest_yoff = (structMainDisplay.dispheight - structOverlayChannel.dest_height) >> 1;

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	sub	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20
	sar	edx, 1
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+12, edx
$LN4@VidConfig:

; 1295 :     }
; 1296 : 
; 1297 :     //overlayChannelBuffer = AllocateTextureMemory(((structOverlayChannel.src_width & 0xFFFF) * (structOverlayChannel.src_height & 0xFFFF)) << 2,true);
; 1298 :     overlayChannelScaleX = (float)structOverlayChannel.dest_width/(float)structOverlayChannel.src_width;

	fild	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	fstp	DWORD PTR ?overlayChannelScaleX@@3MA	; overlayChannelScaleX

; 1299 :     overlayChannelScaleY = (float)structOverlayChannel.dest_height/(float)structOverlayChannel.src_height;

	fild	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20
	fidiv	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	fstp	DWORD PTR ?overlayChannelScaleY@@3MA	; overlayChannelScaleY

; 1300 :     bOverlayChannelActive = true;

	mov	BYTE PTR ?bOverlayChannelActive@@3_NA, 1 ; bOverlayChannelActive

; 1301 :     channelState |= CHANNELSTATE_OVERLAY_ACTIVE;

	mov	eax, DWORD PTR ?channelState@@3IA	; channelState
	or	eax, 2
	mov	DWORD PTR ?channelState@@3IA, eax	; channelState

; 1302 : 
; 1303 :     bUpdateOpenGLData |= (structOverlayChannel.alpha != structOverlayChannelPrev.alpha);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structOverlayChannel@@3UVidChannel@@A+41
	movzx	eax, BYTE PTR ?structOverlayChannelPrev@@3UVidChannel@@A+41
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1304 :     bUpdateOpenGLData |= (structOverlayChannel.clut_select != structOverlayChannelPrev.clut_select);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structOverlayChannel@@3UVidChannel@@A+40
	movzx	eax, BYTE PTR ?structOverlayChannelPrev@@3UVidChannel@@A+40
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1305 :     bUpdateOpenGLData |= (structOverlayChannel.dest_height != structOverlayChannelPrev.dest_height);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+20
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+20
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1306 :     bUpdateOpenGLData |= (structOverlayChannel.dest_width != structOverlayChannelPrev.dest_width);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+16
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+16
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1307 :     bUpdateOpenGLData |= (structOverlayChannel.dest_xoff != structOverlayChannelPrev.dest_xoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+8
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+8
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1308 :     bUpdateOpenGLData |= (structOverlayChannel.dest_yoff != structOverlayChannelPrev.dest_yoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+12
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+12
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1309 :     bUpdateOpenGLData |= (structOverlayChannel.dmaflags != structOverlayChannelPrev.dmaflags);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1310 :     bUpdateOpenGLData |= (structOverlayChannel.hfilter != structOverlayChannelPrev.hfilter);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structOverlayChannel@@3UVidChannel@@A+43
	movzx	eax, BYTE PTR ?structOverlayChannelPrev@@3UVidChannel@@A+43
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1311 :     bUpdateOpenGLData |= (structOverlayChannel.src_width != structOverlayChannelPrev.src_width);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+32
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1312 :     bUpdateOpenGLData |= (structOverlayChannel.src_height != structOverlayChannelPrev.src_height);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+36
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1313 :     bUpdateOpenGLData |= (structOverlayChannel.src_xoff != structOverlayChannelPrev.src_xoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+24
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+24
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1314 :     bUpdateOpenGLData |= (structOverlayChannel.src_yoff != structOverlayChannelPrev.src_yoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+28
	xor	eax, eax
	cmp	edx, DWORD PTR ?structOverlayChannelPrev@@3UVidChannel@@A+28
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1315 :     bUpdateOpenGLData |= (structOverlayChannel.vfilter != structOverlayChannelPrev.vfilter);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structOverlayChannel@@3UVidChannel@@A+42
	movzx	eax, BYTE PTR ?structOverlayChannelPrev@@3UVidChannel@@A+42
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl
$LN14@VidConfig:

; 1316 :   }
; 1317 : 
; 1318 :   if(nuonEnv->systemBusDRAM)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN3@VidConfig

; 1319 :   {
; 1320 :     //Set the video config field counter to the current video field counter value
; 1321 : 
; 1322 :     *((uint32 *)&nuonEnv->systemBusDRAM[LAST_VIDEO_CONFIG_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK])
; 1323 :       = *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax+8388032]
	mov	DWORD PTR [edx+8388036], eax
$LN3@VidConfig:

; 1324 :   }
; 1325 : 
; 1326 :   bCanDisplayVideo = true;

	mov	BYTE PTR ?bCanDisplayVideo@@3_NA, 1	; bCanDisplayVideo

; 1327 :   nuonEnv->bMainBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+86], 1

; 1328 :   nuonEnv->bOverlayBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+87], 1

; 1329 :   UpdateBufferLengths();

	call	?UpdateBufferLengths@@YAXXZ		; UpdateBufferLengths

; 1330 : 
; 1331 :   if(bUpdateOpenGLData || (channelState != channelStatePrev))

	movzx	eax, BYTE PTR _bUpdateOpenGLData$[ebp]
	test	eax, eax
	jne	SHORT $LN1@VidConfig
	mov	ecx, DWORD PTR ?channelState@@3IA	; channelState
	cmp	ecx, DWORD PTR ?channelStatePrev@@3IA	; channelStatePrev
	je	SHORT $LN2@VidConfig
$LN1@VidConfig:

; 1332 :   {
; 1333 :     videoTexInfo.bUpdateDisplayList = true;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 1

; 1334 :     UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates
$LN2@VidConfig:

; 1335 :   }
; 1336 : 
; 1337 :   mpe->regs[0] = 1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 1

; 1338 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@VidConfig
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN39@VidConfig:
	DD	3
	DD	$LN38@VidConfig
$LN38@VidConfig:
	DD	-64					; ffffffc0H
	DD	40					; 00000028H
	DD	$LN35@VidConfig
	DD	-136					; ffffff78H
	DD	64					; 00000040H
	DD	$LN36@VidConfig
	DD	-208					; ffffff30H
	DD	64					; 00000040H
	DD	$LN37@VidConfig
$LN37@VidConfig:
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	100					; 00000064H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	0
$LN36@VidConfig:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	0
$LN35@VidConfig:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
?VidConfig@@YAXPAVMPE@@@Z ENDP				; VidConfig
_TEXT	ENDS
PUBLIC	?VidSetup@@YAXPAVMPE@@@Z			; VidSetup
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T80586 = -32						; size = 4
_bUpdateOpenGLData$ = -25				; size = 1
_map$ = -24						; size = 4
_filterType$ = -20					; size = 4
_sourceHeight$ = -16					; size = 4
_sourceWidth$ = -12					; size = 4
_dmaFlags$ = -8						; size = 4
_mainChannelBase$ = -4					; size = 4
_mpe$ = 8						; size = 4
?VidSetup@@YAXPAVMPE@@@Z PROC				; VidSetup

; 1344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1345 :   uint32 mainChannelBase = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mainChannelBase$[ebp], ecx

; 1346 :   uint32 dmaFlags = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dmaFlags$[ebp], eax

; 1347 :   uint32 sourceWidth = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _sourceWidth$[ebp], edx

; 1348 :   uint32 sourceHeight = mpe->regs[3];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _sourceHeight$[ebp], ecx

; 1349 :   uint32 filterType = mpe->regs[4];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _filterType$[ebp], eax

; 1350 :   uint32 map;
; 1351 :   bool bUpdateOpenGLData = false;

	mov	BYTE PTR _bUpdateOpenGLData$[ebp], 0

; 1352 : 
; 1353 :   structMainDisplay.bordcolor = 0x10808000; //Black

	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8, 276856832 ; 10808000H

; 1354 :   structMainDisplay.dispwidth = 720;

	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A, 720 ; 000002d0H

; 1355 :   structMainDisplay.dispheight = 480;

	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4, 480 ; 000001e0H

; 1356 :   structMainDisplay.fps = 0;

	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+16, 0

; 1357 :   structMainDisplay.progressive = 0;

	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+12, 0

; 1358 : 
; 1359 :   channelStatePrev = channelState;

	mov	ecx, DWORD PTR ?channelState@@3IA	; channelState
	mov	DWORD PTR ?channelStatePrev@@3IA, ecx	; channelStatePrev

; 1360 :   channelState = 0;

	mov	DWORD PTR ?channelState@@3IA, 0		; channelState

; 1361 : 
; 1362 :   if(mainChannelBase)

	cmp	DWORD PTR _mainChannelBase$[ebp], 0
	je	SHORT $LN13@VidSetup

; 1363 :   {
; 1364 :     structMainChannelPrev.base = structMainChannel.base;

	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	mov	DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+4, edx

; 1365 :     structMainChannel.base = (void *)mainChannelBase;

	mov	eax, DWORD PTR _mainChannelBase$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+4, eax

; 1366 :     channelState |= CHANNELSTATE_MAIN_ACTIVE;

	mov	ecx, DWORD PTR ?channelState@@3IA	; channelState
	or	ecx, 1
	mov	DWORD PTR ?channelState@@3IA, ecx	; channelState

; 1367 : 
; 1368 :     structMainChannelPrev.dmaflags = structMainChannel.dmaflags;

	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	mov	DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A, edx

; 1369 :     structMainChannelPrev.src_width = structMainChannel.src_width;

	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	mov	DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+32, eax

; 1370 :     structMainChannelPrev.src_height = structMainChannel.src_height;

	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+36, ecx

; 1371 :     structMainChannelPrev.clut_select = structMainChannel.clut_select;

	mov	dl, BYTE PTR ?structMainChannel@@3UVidChannel@@A+40
	mov	BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+40, dl

; 1372 :     structMainChannelPrev.vfilter = structMainChannel.vfilter;

	mov	al, BYTE PTR ?structMainChannel@@3UVidChannel@@A+42
	mov	BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+42, al
$LN13@VidSetup:

; 1373 :   }
; 1374 : 
; 1375 :   if(mainChannelBuffer)
; 1376 :   {
; 1377 :     //FreeTextureMemory(mainChannelBuffer,false);
; 1378 :   }
; 1379 : 
; 1380 :   //No overlay channel
; 1381 :   if(overlayChannelBuffer)
; 1382 :   {
; 1383 :     //FreeTextureMemory(overlayChannelBuffer,true);
; 1384 :   }
; 1385 : 
; 1386 :   if(!mainDisplayBuffer)

	cmp	DWORD PTR ?mainDisplayBuffer@@3PAEA, 0	; mainDisplayBuffer
	jne	SHORT $LN10@VidSetup

; 1387 :   {
; 1388 :     mainDisplayBuffer = new uint8[(structMainDisplay.dispwidth << 2) * structMainDisplay.dispheight];

	mov	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	shl	ecx, 2
	imul	ecx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T80586[ebp], eax
	mov	edx, DWORD PTR $T80586[ebp]
	mov	DWORD PTR ?mainDisplayBuffer@@3PAEA, edx ; mainDisplayBuffer
$LN10@VidSetup:

; 1389 :   }
; 1390 : 
; 1391 :   structMainChannel.dmaflags = dmaFlags;

	mov	eax, DWORD PTR _dmaFlags$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A, eax

; 1392 :   structMainChannel.dest_width = 720;

	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16, 720 ; 000002d0H

; 1393 :   structMainChannel.dest_height = 480;

	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20, 480 ; 000001e0H

; 1394 :   structMainChannel.src_width = sourceWidth;

	mov	ecx, DWORD PTR _sourceWidth$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+32, ecx

; 1395 :   structMainChannel.src_height = sourceHeight;

	mov	edx, DWORD PTR _sourceHeight$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+36, edx

; 1396 :   structMainChannel.clut_select = 0;

	mov	BYTE PTR ?structMainChannel@@3UVidChannel@@A+40, 0

; 1397 :   structMainChannel.alpha = 0;

	mov	BYTE PTR ?structMainChannel@@3UVidChannel@@A+41, 0

; 1398 :   structMainChannel.vfilter = filterType;

	mov	al, BYTE PTR _filterType$[ebp]
	mov	BYTE PTR ?structMainChannel@@3UVidChannel@@A+42, al

; 1399 : 
; 1400 :   //DMA Mode bits for Pixel transfers: 
; 1401 :   //[11:11]: Cluster addressing
; 1402 :   //[9:9]: B backwards flag
; 1403 :   //[8:8]: V Transfer Direction (0 = Horizontal, 1 = Vertical)
; 1404 :   //[7:4]: Pixel type
; 1405 :   //[3:1]: Z comparison type
; 1406 :   //[0:0]: A backwards flag
; 1407 :   //B,V,A and Z are ignored for video DMA transfers
; 1408 : 
; 1409 :   //Get pixel type
; 1410 :   map = (dmaFlags >> 4) & 0x0FUL;

	mov	ecx, DWORD PTR _dmaFlags$[ebp]
	shr	ecx, 4
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _map$[ebp], ecx

; 1411 : 
; 1412 :   //For pixel types 0 through 8, map 0 contains color data and map 1 contains Z data.  Because Z data is ignored
; 1413 :   //by the video DMA controller, transfers will always occur from map 0 so the main channel base address does not
; 1414 :   //need to be adjusted
; 1415 : 
; 1416 :   //Handle 16_16Z double and triple buffer frame buffers
; 1417 :   if((map >= 9) || (map == 5))

	cmp	DWORD PTR _map$[ebp], 9
	jae	SHORT $LN8@VidSetup
	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN9@VidSetup
$LN8@VidSetup:

; 1418 :   {
; 1419 :     if(map == 5)

	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN7@VidSetup

; 1420 :     {
; 1421 :       //16+16Z single buffer: map 0 contains 16-bit color map 1 contains 16 bit Z data
; 1422 :       map = 0;

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN4@VidSetup
$LN7@VidSetup:

; 1423 :     }
; 1424 :     else if(map < 13)

	cmp	DWORD PTR _map$[ebp], 13		; 0000000dH
	jae	SHORT $LN5@VidSetup

; 1425 :     {
; 1426 :       //16+16Z triple buffer: map 0,1 and 2 contain 16-bit color data, map 3 contains 16 bit Z data
; 1427 :       map = map - 9;

	mov	edx, DWORD PTR _map$[ebp]
	sub	edx, 9
	mov	DWORD PTR _map$[ebp], edx

; 1428 :     }
; 1429 :     else

	jmp	SHORT $LN4@VidSetup
$LN5@VidSetup:

; 1430 :     {
; 1431 :       //16+16Z double buffer: map 0,1 contain 16-bit color data, map 2 contains 16 bit Z data
; 1432 :       map = map - 13;

	mov	eax, DWORD PTR _map$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax
$LN4@VidSetup:

; 1433 :     }
; 1434 :     //The specified base address always points to the start of the first color buffer/map.  The pixel type
; 1435 :     //determines which map is to be displayed.  The proper byte offset from the start of the first map can be
; 1436 :     //computed using (map * src_width * src_height * bytes_per_pixel) where bytes_per_pixel is always two.
; 1437 :     structMainChannel.base = ((uint8 *)structMainChannel.base) + (map * structMainChannel.src_width * structMainChannel.src_height * 2);

	mov	ecx, DWORD PTR _map$[ebp]
	imul	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	imul	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+4, eax

; 1438 :     //change the pixel type to 16-bit, no-Z
; 1439 :     structMainChannel.dmaflags = (structMainChannel.dmaflags & 0xFFFFFF0FUL) | (0x02UL << 4);

	mov	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	and	ecx, -241				; ffffff0fH
	or	ecx, 32					; 00000020H
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A, ecx
$LN9@VidSetup:

; 1440 :      //It is safe to specify a pixel type of 12 or 15 but this will display Z-data and look really funky.
; 1441 :   }
; 1442 : 
; 1443 :   //Center along X
; 1444 :   structMainChannel.dest_xoff = (structMainDisplay.dispwidth - structMainChannel.dest_width) >> 1;

	mov	edx, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A
	sub	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	sar	edx, 1
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+8, edx

; 1445 :   //Center along Y
; 1446 :   structMainChannel.dest_yoff = (structMainDisplay.dispheight - structMainChannel.dest_height) >> 1;

	mov	eax, DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+4
	sub	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	sar	eax, 1
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+12, eax

; 1447 : 
; 1448 :   //mainChannelBuffer = AllocateTextureMemory(((structMainChannel.src_width & 0xFFFF) * (structMainChannel.src_height & 0xFFFF)) << 2,false);
; 1449 :   mainChannelScaleX = (float)structMainChannel.dest_width/(float)structMainChannel.src_width;

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	fstp	DWORD PTR ?mainChannelScaleX@@3MA	; mainChannelScaleX

; 1450 :   mainChannelScaleY = (float)structMainChannel.dest_height/(float)structMainChannel.src_height;

	fild	DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	fidiv	DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	fstp	DWORD PTR ?mainChannelScaleY@@3MA	; mainChannelScaleY

; 1451 :   bMainChannelActive = true;

	mov	BYTE PTR ?bMainChannelActive@@3_NA, 1	; bMainChannelActive

; 1452 :   bOverlayChannelActive = false;

	mov	BYTE PTR ?bOverlayChannelActive@@3_NA, 0 ; bOverlayChannelActive

; 1453 : 
; 1454 :   mpe->regs[0] = 1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 1

; 1455 :   bCanDisplayVideo = true;

	mov	BYTE PTR ?bCanDisplayVideo@@3_NA, 1	; bCanDisplayVideo

; 1456 : 
; 1457 :   nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 1458 :   nuonEnv->bOverlayBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 1

; 1459 :   
; 1460 :   UpdateBufferLengths();

	call	?UpdateBufferLengths@@YAXXZ		; UpdateBufferLengths

; 1461 : 
; 1462 :   bUpdateOpenGLData |= (channelState != channelStatePrev);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?channelState@@3IA	; channelState
	xor	eax, eax
	cmp	edx, DWORD PTR ?channelStatePrev@@3IA	; channelStatePrev
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1463 :     bUpdateOpenGLData |= (structMainChannel.alpha != structMainChannelPrev.alpha);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+41
	movzx	eax, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+41
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1464 :     bUpdateOpenGLData |= (structMainChannel.clut_select != structMainChannelPrev.clut_select);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+40
	movzx	eax, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+40
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1465 :     bUpdateOpenGLData |= (structMainChannel.dest_height != structMainChannelPrev.dest_height);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+20
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+20
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1466 :     bUpdateOpenGLData |= (structMainChannel.dest_width != structMainChannelPrev.dest_width);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+16
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+16
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1467 :     bUpdateOpenGLData |= (structMainChannel.dest_xoff != structMainChannelPrev.dest_xoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+8
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+8
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1468 :     bUpdateOpenGLData |= (structMainChannel.dest_yoff != structMainChannelPrev.dest_yoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+12
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+12
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1469 :     bUpdateOpenGLData |= (structMainChannel.dmaflags != structMainChannelPrev.dmaflags);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1470 :     bUpdateOpenGLData |= (structMainChannel.hfilter != structMainChannelPrev.hfilter);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+43
	movzx	eax, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+43
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1471 :     bUpdateOpenGLData |= (structMainChannel.src_width != structMainChannelPrev.src_width);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+32
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1472 :     bUpdateOpenGLData |= (structMainChannel.src_height != structMainChannelPrev.src_height);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+36
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1473 :     bUpdateOpenGLData |= (structMainChannel.src_xoff != structMainChannelPrev.src_xoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+24
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+24
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1474 :     bUpdateOpenGLData |= (structMainChannel.src_yoff != structMainChannelPrev.src_yoff);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+28
	xor	eax, eax
	cmp	edx, DWORD PTR ?structMainChannelPrev@@3UVidChannel@@A+28
	setne	al
	or	ecx, eax
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1475 :     bUpdateOpenGLData |= (structMainChannel.vfilter != structMainChannelPrev.vfilter);

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	movzx	edx, BYTE PTR ?structMainChannel@@3UVidChannel@@A+42
	movzx	eax, BYTE PTR ?structMainChannelPrev@@3UVidChannel@@A+42
	xor	ebx, ebx
	cmp	edx, eax
	setne	bl
	or	ecx, ebx
	mov	BYTE PTR _bUpdateOpenGLData$[ebp], cl

; 1476 : 
; 1477 :   if(bUpdateOpenGLData  || (channelState != channelStatePrev))

	movzx	ecx, BYTE PTR _bUpdateOpenGLData$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@VidSetup
	mov	edx, DWORD PTR ?channelState@@3IA	; channelState
	cmp	edx, DWORD PTR ?channelStatePrev@@3IA	; channelStatePrev
	je	SHORT $LN3@VidSetup
$LN2@VidSetup:

; 1478 :   {
; 1479 :     videoTexInfo.bUpdateDisplayList = true;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 1

; 1480 :     UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates
$LN3@VidSetup:

; 1481 :   }
; 1482 : 
; 1483 :   if(nuonEnv->systemBusDRAM)

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN1@VidSetup

; 1484 :   {
; 1485 :     //Set the video config field counter to the current video field counter value
; 1486 : 
; 1487 :     *((uint32 *)&nuonEnv->systemBusDRAM[LAST_VIDEO_CONFIG_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK])
; 1488 :       = *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [edx+8388032]
	mov	DWORD PTR [ecx+8388036], edx
$LN1@VidSetup:

; 1489 :   }
; 1490 : 
; 1491 :   bCanDisplayVideo = true;

	mov	BYTE PTR ?bCanDisplayVideo@@3_NA, 1	; bCanDisplayVideo

; 1492 : }

	pop	ebx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VidSetup@@YAXPAVMPE@@@Z ENDP				; VidSetup
_TEXT	ENDS
PUBLIC	?SetVideoMode@@YAXXZ				; SetVideoMode
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T80588 = -4						; size = 4
?SetVideoMode@@YAXXZ PROC				; SetVideoMode

; 1495 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1496 :   //always output in RGBA format
; 1497 :   if(!mainDisplayBuffer)

	cmp	DWORD PTR ?mainDisplayBuffer@@3PAEA, 0	; mainDisplayBuffer
	jne	SHORT $LN2@SetVideoMo

; 1498 :   {
; 1499 :     mainDisplayBuffer = new uint8[720 * 480 * 4];

	push	1382400					; 00151800H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T80588[ebp], eax
	mov	eax, DWORD PTR $T80588[ebp]
	mov	DWORD PTR ?mainDisplayBuffer@@3PAEA, eax ; mainDisplayBuffer
$LN2@SetVideoMo:

; 1500 :   }
; 1501 :   //NUON framebuffer size
; 1502 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetVideoMode@@YAXXZ ENDP				; SetVideoMode
_TEXT	ENDS
PUBLIC	?VidChangeBase@@YAXPAVMPE@@@Z			; VidChangeBase
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv77 = -20						; size = 4
_map$ = -16						; size = 4
_base$ = -12						; size = 4
_dmaflags$ = -8						; size = 4
_which$ = -4						; size = 4
_mpe$ = 8						; size = 4
?VidChangeBase@@YAXPAVMPE@@@Z PROC			; VidChangeBase

; 1505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1506 :   int32 which, dmaflags, base;
; 1507 :   uint32 map;
; 1508 : 
; 1509 :   which = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 1510 :   dmaflags = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _dmaflags$[ebp], eax

; 1511 :   base = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _base$[ebp], edx

; 1512 : 
; 1513 :   mpe->regs[0] = 1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 1

; 1514 : 
; 1515 :   if(!base)

	cmp	DWORD PTR _base$[ebp], 0
	jne	SHORT $LN22@VidChangeB

; 1516 :   {
; 1517 :     MessageBox(NULL,"VidChangeBase was called with a base parameter of 0","Invalid Video Pointer",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET $SG78245
	push	OFFSET $SG78246
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@VidChangeB:

; 1518 :   }
; 1519 : 
; 1520 :   if(((which == VID_CHANNEL_MAIN) && !mainChannelBuffer) ||
; 1521 :     ((which == VID_CHANNEL_OSD) && !overlayChannelBuffer))

	cmp	DWORD PTR _which$[ebp], 0
	jne	SHORT $LN19@VidChangeB
	cmp	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer
	je	SHORT $LN20@VidChangeB
$LN19@VidChangeB:
	cmp	DWORD PTR _which$[ebp], 1
	jne	SHORT $LN21@VidChangeB
	cmp	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer
	jne	SHORT $LN21@VidChangeB
$LN20@VidChangeB:

; 1522 :   {
; 1523 :     //Channel is not active, return 0
; 1524 :     mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0

; 1525 :   }
; 1526 :   else

	jmp	$LN18@VidChangeB
$LN21@VidChangeB:

; 1527 :   {
; 1528 :     map = (dmaflags >> 4) & 0x0FUL;

	mov	edx, DWORD PTR _dmaflags$[ebp]
	sar	edx, 4
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _map$[ebp], edx

; 1529 : 
; 1530 :     switch(which)

	mov	eax, DWORD PTR _which$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 0
	je	SHORT $LN15@VidChangeB
	cmp	DWORD PTR tv77[ebp], 1
	je	$LN8@VidChangeB
	jmp	$LN2@VidChangeB
$LN15@VidChangeB:

; 1531 :     {
; 1532 :       case VID_CHANNEL_MAIN:
; 1533 :         //valid channel, set dmaflags and base then return 1
; 1534 :         structMainChannel.dmaflags = dmaflags;

	mov	ecx, DWORD PTR _dmaflags$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A, ecx

; 1535 :         structMainChannel.base = (void *)base;

	mov	edx, DWORD PTR _base$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+4, edx

; 1536 :         //Handle 16_16Z double and triple buffer frame buffers
; 1537 :         if((map >= 9) || map == 5)

	cmp	DWORD PTR _map$[ebp], 9
	jae	SHORT $LN13@VidChangeB
	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN14@VidChangeB
$LN13@VidChangeB:

; 1538 :         {
; 1539 :           if(map == 5)

	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN12@VidChangeB

; 1540 :           {
; 1541 :             //16+16Z single buffer: map 0 contains 16-bit color map 1 contains 16 bit Z data
; 1542 :             map = 0;

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN11@VidChangeB
$LN12@VidChangeB:

; 1543 :           }
; 1544 :           else if(map < 13)

	cmp	DWORD PTR _map$[ebp], 13		; 0000000dH
	jae	SHORT $LN10@VidChangeB

; 1545 :           {
; 1546 :             //16+16Z triple buffer: map 0,1 and 2 contain 16-bit color data, map 3 contains 16 bit Z data
; 1547 :             map = map - 9;

	mov	eax, DWORD PTR _map$[ebp]
	sub	eax, 9
	mov	DWORD PTR _map$[ebp], eax

; 1548 :           }
; 1549 :           else

	jmp	SHORT $LN11@VidChangeB
$LN10@VidChangeB:

; 1550 :           {
; 1551 :             //16+16Z double buffer: map 0,1 contain 16-bit color data, map 2 contains 16 bit Z data
; 1552 :             map = map - 13;

	mov	ecx, DWORD PTR _map$[ebp]
	sub	ecx, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], ecx
$LN11@VidChangeB:

; 1553 :           }
; 1554 :           //The specified base address always points to the start of the first color buffer/map.  The pixel type
; 1555 :           //determines which map is to be displayed.  The proper byte offset from the start of the first map can be
; 1556 :           //computed using (map * src_width * src_height * bytes_per_pixel) where bytes_per_pixel is always two.
; 1557 :           structMainChannel.base = ((uint8 *)structMainChannel.base) + (map * structMainChannel.src_width * structMainChannel.src_height * 2);

	mov	edx, DWORD PTR _map$[ebp]
	imul	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+32
	imul	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	mov	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+4
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+4, ecx

; 1558 :           //change the pixel type to 16-bit, no-Z
; 1559 :           structMainChannel.dmaflags = (structMainChannel.dmaflags & 0xFFFFFF0FUL) | (0x02UL << 4);

	mov	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A
	and	edx, -241				; ffffff0fH
	or	edx, 32					; 00000020H
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A, edx
$LN14@VidChangeB:

; 1560 : 
; 1561 :           //It is safe to specify a pixel type of 12 or 15 but this will display Z-data and look really funky.
; 1562 :         }
; 1563 :         UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates

; 1564 :         //UpdateBufferLengths();
; 1565 :         nuonEnv->bMainBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+86], 1

; 1566 :         break;

	jmp	$LN18@VidChangeB
$LN8@VidChangeB:

; 1567 :       case VID_CHANNEL_OSD:
; 1568 :         //valid channel, set dmaflags and base then return 1
; 1569 :         structOverlayChannel.dmaflags = dmaflags;

	mov	ecx, DWORD PTR _dmaflags$[ebp]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A, ecx

; 1570 :         structOverlayChannel.base = (void *)base;

	mov	edx, DWORD PTR _base$[ebp]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4, edx

; 1571 :         //Handle 16_16Z double and triple buffer frame buffers
; 1572 :         if(map >= 9)

	cmp	DWORD PTR _map$[ebp], 9
	jb	SHORT $LN7@VidChangeB

; 1573 :         {
; 1574 :           if(map == 5)

	cmp	DWORD PTR _map$[ebp], 5
	jne	SHORT $LN6@VidChangeB

; 1575 :           {
; 1576 :             //16+16Z single buffer: map 0 contains 16-bit color map 1 contains 16 bit Z data
; 1577 :             map = 0;

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN5@VidChangeB
$LN6@VidChangeB:

; 1578 :           }
; 1579 :           else if(map < 13)

	cmp	DWORD PTR _map$[ebp], 13		; 0000000dH
	jae	SHORT $LN4@VidChangeB

; 1580 :           {
; 1581 :             //16+16Z triple buffer: map 0,1 and 2 contain 16-bit color data, map 3 contains 16 bit Z data
; 1582 :             map = map - 9;

	mov	eax, DWORD PTR _map$[ebp]
	sub	eax, 9
	mov	DWORD PTR _map$[ebp], eax

; 1583 :           }
; 1584 :           else

	jmp	SHORT $LN5@VidChangeB
$LN4@VidChangeB:

; 1585 :           {
; 1586 :             //16+16Z double buffer: map 0,1 contain 16-bit color data, map 2 contains 16 bit Z data
; 1587 :             map = map - 13;

	mov	ecx, DWORD PTR _map$[ebp]
	sub	ecx, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], ecx
$LN5@VidChangeB:

; 1588 :           }
; 1589 :           //The specified base address always points to the start of the first color buffer/map.  The pixel type
; 1590 :           //determines which map is to be displayed.  The proper byte offset from the start of the first map can be
; 1591 :           //computed using (map * src_width * src_height * bytes_per_pixel) where bytes_per_pixel is always two.
; 1592 :           structOverlayChannel.base = ((uint8 *)structOverlayChannel.base) + (map * structOverlayChannel.src_width * structOverlayChannel.src_height * 2);

	mov	edx, DWORD PTR _map$[ebp]
	imul	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+32
	imul	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+36
	mov	eax, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+4, ecx

; 1593 :           //change the pixel type to 16-bit, no-Z
; 1594 :           structOverlayChannel.dmaflags = (structOverlayChannel.dmaflags & 0xFFFFFF0FUL) | (0x02UL << 4);

	mov	edx, DWORD PTR ?structOverlayChannel@@3UVidChannel@@A
	and	edx, -241				; ffffff0fH
	or	edx, 32					; 00000020H
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A, edx
$LN7@VidChangeB:

; 1595 : 
; 1596 :           //It is safe to specify a pixel type of 12 or 15 but this will display Z-data and look really funky.
; 1597 :         }
; 1598 :         UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates

; 1599 :         //UpdateBufferLengths();
; 1600 :         nuonEnv->bOverlayBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 1

; 1601 :         break;

	jmp	SHORT $LN18@VidChangeB
$LN2@VidChangeB:

; 1602 :       default:
; 1603 :         //Invalid channel, return 0
; 1604 :         mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0
$LN18@VidChangeB:

; 1605 :         break;
; 1606 :     }
; 1607 :   }
; 1608 : 
; 1609 :   if(nuonEnv->systemBusDRAM)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN23@VidChangeB

; 1610 :   {
; 1611 :     //Set the video config field counter to the current video field counter value
; 1612 :     *((uint32 *)&nuonEnv->systemBusDRAM[LAST_VIDEO_CONFIG_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK])
; 1613 :       = *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [ecx+8388032]
	mov	DWORD PTR [eax+8388036], ecx
$LN23@VidChangeB:

; 1614 :   }
; 1615 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VidChangeBase@@YAXPAVMPE@@@Z ENDP			; VidChangeBase
_TEXT	ENDS
PUBLIC	?VidChangeScroll@@YAXPAVMPE@@@Z			; VidChangeScroll
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv70 = -16						; size = 4
_yoff$ = -12						; size = 4
_xoff$ = -8						; size = 4
_which$ = -4						; size = 4
_mpe$ = 8						; size = 4
?VidChangeScroll@@YAXPAVMPE@@@Z PROC			; VidChangeScroll

; 1618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1619 :   int32 which, xoff, yoff;
; 1620 : 
; 1621 :   which = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 1622 :   xoff = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _xoff$[ebp], eax

; 1623 :   yoff = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _yoff$[ebp], edx

; 1624 : 
; 1625 :   mpe->regs[0] = 1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 1

; 1626 : 
; 1627 :   if(((which == VID_CHANNEL_MAIN) && !mainChannelBuffer) ||
; 1628 :     ((which == VID_CHANNEL_OSD) && !overlayChannelBuffer))

	cmp	DWORD PTR _which$[ebp], 0
	jne	SHORT $LN8@VidChangeS
	cmp	DWORD PTR ?mainChannelBuffer@@3PAEA, 0	; mainChannelBuffer
	je	SHORT $LN9@VidChangeS
$LN8@VidChangeS:
	cmp	DWORD PTR _which$[ebp], 1
	jne	SHORT $LN10@VidChangeS
	cmp	DWORD PTR ?overlayChannelBuffer@@3PAEA, 0 ; overlayChannelBuffer
	jne	SHORT $LN10@VidChangeS
$LN9@VidChangeS:

; 1629 :   {
; 1630 :     //Channel is not active, return 0
; 1631 :     mpe->regs[0] = 0;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0

; 1632 :   }
; 1633 :   else

	jmp	SHORT $LN7@VidChangeS
$LN10@VidChangeS:

; 1634 :   {
; 1635 :     switch(which)

	mov	edx, DWORD PTR _which$[ebp]
	mov	DWORD PTR tv70[ebp], edx
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN4@VidChangeS
	cmp	DWORD PTR tv70[ebp], 1
	je	SHORT $LN3@VidChangeS
	jmp	SHORT $LN2@VidChangeS
$LN4@VidChangeS:

; 1636 :     {
; 1637 :       case VID_CHANNEL_MAIN:
; 1638 :         //valid channel, set offsets and return 1
; 1639 :         structMainChannel.src_xoff = xoff;

	mov	eax, DWORD PTR _xoff$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+24, eax

; 1640 :         structMainChannel.src_yoff = yoff;

	mov	ecx, DWORD PTR _yoff$[ebp]
	mov	DWORD PTR ?structMainChannel@@3UVidChannel@@A+28, ecx

; 1641 :         nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 1642 :         videoTexInfo.bUpdateDisplayList = true;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 1

; 1643 :         break;

	jmp	SHORT $LN5@VidChangeS
$LN3@VidChangeS:

; 1644 :       case VID_CHANNEL_OSD:
; 1645 :         //valid channel, set offsets and return 1
; 1646 :         structOverlayChannel.src_xoff = xoff;

	mov	eax, DWORD PTR _xoff$[ebp]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+24, eax

; 1647 :         structOverlayChannel.src_yoff = yoff;

	mov	ecx, DWORD PTR _yoff$[ebp]
	mov	DWORD PTR ?structOverlayChannel@@3UVidChannel@@A+28, ecx

; 1648 :         nuonEnv->bOverlayBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+87], 1

; 1649 :         videoTexInfo.bUpdateDisplayList = true;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 1

; 1650 :         break;

	jmp	SHORT $LN5@VidChangeS
$LN2@VidChangeS:

; 1651 :       default:
; 1652 :         //Invalid channel, return 0
; 1653 :         mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@VidChangeS:

; 1654 :         break;
; 1655 :     }
; 1656 : 
; 1657 :     UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates
$LN7@VidChangeS:

; 1658 :   }
; 1659 : 
; 1660 :   if(nuonEnv->systemBusDRAM)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN11@VidChangeS

; 1661 :   {
; 1662 :     //Set the video config field counter to the current video field counter value
; 1663 : 
; 1664 :     *((uint32 *)&nuonEnv->systemBusDRAM[LAST_VIDEO_CONFIG_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK])
; 1665 :       = *((uint32 *)&nuonEnv->systemBusDRAM[VIDEO_FIELD_COUNTER_ADDRESS & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax+8388032]
	mov	DWORD PTR [edx+8388036], eax
$LN11@VidChangeS:

; 1666 :   }
; 1667 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VidChangeScroll@@YAXPAVMPE@@@Z ENDP			; VidChangeScroll
_TEXT	ENDS
PUBLIC	?SetDefaultColor@@YAXPAVMPE@@@Z			; SetDefaultColor
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?SetDefaultColor@@YAXPAVMPE@@@Z PROC			; SetDefaultColor

; 1670 : {

	push	ebp
	mov	ebp, esp

; 1671 :   structMainDisplay.bordcolor = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?structMainDisplay@@3UVidDisplay@@A+8, ecx

; 1672 :   videoTexInfo.bUpdateDisplayList = true;

	mov	BYTE PTR ?videoTexInfo@@3UvidTexInfo@@A, 1

; 1673 :   UpdateTextureStates();

	call	?UpdateTextureStates@@YAXXZ		; UpdateTextureStates

; 1674 :   nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 1675 :   nuonEnv->bOverlayBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 1

; 1676 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?SetDefaultColor@@YAXPAVMPE@@@Z ENDP			; SetDefaultColor
_TEXT	ENDS
PUBLIC	?VidSetCLUTRange@@YAXPAVMPE@@@Z			; VidSetCLUTRange
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T80593 = -25						; size = 1
_pColors$ = -24						; size = 4
_pCLUT$ = -20						; size = 4
_count$ = -16						; size = 4
_colors$ = -12						; size = 4
_numColors$ = -8					; size = 4
_index$ = -4						; size = 4
_mpe$ = 8						; size = 4
?VidSetCLUTRange@@YAXPAVMPE@@@Z PROC			; VidSetCLUTRange

; 1679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	BYTE PTR $T80593[ebp], 0

; 1680 :   uint32 index, numColors, colors;
; 1681 :   uint32 count, *pCLUT, *pColors;
; 1682 : 
; 1683 :   index = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _index$[ebp], ecx

; 1684 :   numColors = mpe->regs[1];

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _numColors$[ebp], eax

; 1685 :   colors = mpe->regs[2];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _colors$[ebp], edx

; 1686 : 
; 1687 :   if(colors)

	cmp	DWORD PTR _colors$[ebp], 0
	je	$LN6@VidSetCLUT

; 1688 :   {
; 1689 :     pColors = (uint32 *)nuonEnv->GetPointerToMemory(mpe, colors);

	push	1
	mov	eax, DWORD PTR _colors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _pColors$[ebp], eax

; 1690 :     pCLUT = &vdgCLUT[index];

	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR ?vdgCLUT@@3PAIA[edx*4]
	mov	DWORD PTR _pCLUT$[ebp], eax

; 1691 : 
; 1692 :     for(count = 0; (index < 256) && (count < numColors); index++, count++)

	mov	BYTE PTR $T80593[ebp], 1
	mov	DWORD PTR _count$[ebp], 0
	jmp	SHORT $LN5@VidSetCLUT
$LN4@VidSetCLUT:
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$[ebp], ecx
	cmp	BYTE PTR $T80593[ebp], 0
	jne	SHORT $LN9@VidSetCLUT
	push	OFFSET $LN10@VidSetCLUT
	call	__RTC_UninitUse
	add	esp, 4
$LN9@VidSetCLUT:
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	BYTE PTR $T80593[ebp], 1
	mov	DWORD PTR _count$[ebp], edx
$LN5@VidSetCLUT:
	cmp	DWORD PTR _index$[ebp], 256		; 00000100H
	jae	SHORT $LN6@VidSetCLUT
	cmp	BYTE PTR $T80593[ebp], 0
	jne	SHORT $LN11@VidSetCLUT
	push	OFFSET $LN10@VidSetCLUT
	call	__RTC_UninitUse
	add	esp, 4
$LN11@VidSetCLUT:
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _numColors$[ebp]
	jae	SHORT $LN6@VidSetCLUT

; 1693 :     {
; 1694 :       *pCLUT = *pColors;

	mov	ecx, DWORD PTR _pCLUT$[ebp]
	mov	edx, DWORD PTR _pColors$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1695 :       //SwapScalarBytes(pCLUT);
; 1696 :       pColors++;

	mov	ecx, DWORD PTR _pColors$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pColors$[ebp], ecx

; 1697 :       pCLUT++;

	mov	edx, DWORD PTR _pCLUT$[ebp]
	add	edx, 4
	mov	DWORD PTR _pCLUT$[ebp], edx

; 1698 :     }

	jmp	SHORT $LN4@VidSetCLUT
$LN6@VidSetCLUT:

; 1699 :   }
; 1700 : 
; 1701 :   //Despite the fact that the BIOS documentation shows a function prototype returning void, a disassembly of the BIOS
; 1702 :   //shows that VidSetCLUTRange returns 1 if all entries were copied and 0 otherwise (e.g. the starting index was out
; 1703 :   //of bounds or there were not enough entries in the video clut to accept all of the colors)
; 1704 :   if(count == numColors)

	cmp	BYTE PTR $T80593[ebp], 0
	jne	SHORT $LN12@VidSetCLUT
	push	OFFSET $LN10@VidSetCLUT
	call	__RTC_UninitUse
	add	esp, 4
$LN12@VidSetCLUT:
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _numColors$[ebp]
	jne	SHORT $LN2@VidSetCLUT

; 1705 :   {
; 1706 :     mpe->regs[0] = 1;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 1

; 1707 :   }
; 1708 :   else

	jmp	SHORT $LN1@VidSetCLUT
$LN2@VidSetCLUT:

; 1709 :   {
; 1710 :     mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@VidSetCLUT:

; 1711 :   }
; 1712 : 
; 1713 :   nuonEnv->bOverlayBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+87], 1

; 1714 : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@VidSetCLUT:
$LN10@VidSetCLUT:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?VidSetCLUTRange@@YAXPAVMPE@@@Z ENDP			; VidSetCLUTRange
_TEXT	ENDS
PUBLIC	?VideoCleanup@@YAXXZ				; VideoCleanup
EXTRN	__imp__glDeleteLists@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
?VideoCleanup@@YAXXZ PROC				; VideoCleanup

; 1717 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1718 :   uint32 i;
; 1719 :   
; 1720 :   for(i = 0; i < 3; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@VideoClean
$LN3@VideoClean:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@VideoClean:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN5@VideoClean

; 1721 :   {
; 1722 :     if(videoTexInfo.displayListName)

	mov	ecx, OFFSET ?videoTexInfo@@3UvidTexInfo@@A+4
	test	ecx, ecx
	je	SHORT $LN1@VideoClean

; 1723 :     {
; 1724 :       glDeleteLists(videoTexInfo.displayListName[i],1);

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?videoTexInfo@@3UvidTexInfo@@A[edx*4+4]
	push	eax
	call	DWORD PTR __imp__glDeleteLists@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@VideoClean:

; 1725 :     }

	jmp	SHORT $LN3@VideoClean
$LN5@VideoClean:

; 1726 :   }
; 1727 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VideoCleanup@@YAXXZ ENDP				; VideoCleanup
_TEXT	ENDS
END
