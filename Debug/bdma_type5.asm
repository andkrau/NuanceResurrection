; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\bdma_type5.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12224
_DATA	ENDS
CONST	SEGMENT
$SG12224 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_0
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
EXTRN	?structMainChannel@@3UVidChannel@@A:BYTE	; structMainChannel
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\bdma_type5.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv299 = -212						; size = 4
tv286 = -208						; size = 4
tv283 = -204						; size = 4
$T43708 = -197						; size = 1
_ztransfer$41396 = -192					; size = 2
_ztarget$41395 = -180					; size = 2
_result$41394 = -170					; size = 1
_bZTestResult$ = -169					; size = 1
_bUpdateZ$ = -168					; size = 1
_bUpdatePixel$ = -167					; size = 1
_bCompareZ$ = -166					; size = 1
_bTrigger$ = -165					; size = 1
_bRemote$ = -164					; size = 1
_bDup$ = -163						; size = 1
_bDirect$ = -162					; size = 1
_bRead$ = -161						; size = 1
_srcStrideShift$ = -160					; size = 4
_mpeBase$ = -156					; size = 4
_sdramBase$ = -152					; size = 4
_mode$ = -148						; size = 4
_bva$ = -144						; size = 4
_zcompare$ = -140					; size = 4
_ypos$ = -136						; size = 4
_ylen$ = -132						; size = 4
_xpos$ = -128						; size = 4
_xlen$ = -124						; size = 4
_xsize$ = -120						; size = 4
_destBStep$ = -116					; size = 4
_destAStep$ = -112					; size = 4
_srcBStep$ = -108					; size = 4
_srcAStep$ = -104					; size = 4
_destOffset$ = -100					; size = 4
_srcOffset$ = -96					; size = 4
_destB$ = -92						; size = 4
_destA$ = -88						; size = 4
_srcB$ = -84						; size = 4
_srcA$ = -80						; size = 4
_bCount$ = -76						; size = 4
_aCount$ = -72						; size = 4
_zmap$ = -68						; size = 4
_map$ = -64						; size = 4
_directValue$ = -60					; size = 4
_pixtype$ = -56						; size = 4
_type$ = -52						; size = 4
_directZ$ = -44						; size = 2
_directColor$ = -32					; size = 2
_baseMemory$ = -24					; size = 4
_intMemory$ = -20					; size = 4
_pDestZ$ = -16						; size = 4
_pSrcZ$ = -12						; size = 4
_pDestColor$ = -8					; size = 4
_pSrcColor$ = -4					; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_0

; 11   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 12   :   uint16 *pSrcColor, *pDestColor, *pSrcZ, *pDestZ;
; 13   :   void *intMemory, *baseMemory;
; 14   :   uint16 directColor, directZ;
; 15   :   uint32 type, pixtype, directValue, map, zmap;
; 16   :   uint32 aCount, bCount;
; 17   :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset;
; 18   :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 19   :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 20   :   uint32 mode, sdramBase, mpeBase, srcStrideShift;
; 21   : 
; 22   :   bool bRead, bDirect, bDup, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 23   : 
; 24   :   bRemote = flags & (1UL << 28);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bRemote$[ebp], cl

; 25   :   bDirect = flags & (1UL << 27);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 134217728				; 08000000H
	setne	al
	mov	BYTE PTR _bDirect$[ebp], al

; 26   :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 201326592				; 0c000000H
	setne	dl
	mov	BYTE PTR _bDup$[ebp], dl

; 27   :   bTrigger = flags & (1UL << 25);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 33554432				; 02000000H
	setne	cl
	mov	BYTE PTR _bTrigger$[ebp], cl

; 28   :   bRead = flags & (1UL << 13);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8192				; 00002000H
	setne	al
	mov	BYTE PTR _bRead$[ebp], al

; 29   :   xsize = (flags >> 13) & 0x7F8UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 13					; 0000000dH
	and	ecx, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], ecx

; 30   :   type = (flags >> 14) & 0x03UL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 14					; 0000000eH
	and	edx, 3
	mov	DWORD PTR _type$[ebp], edx

; 31   :   mode = flags & 0xFFFUL;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], eax

; 32   :   zcompare = (flags >> 1) & 0x07UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 1
	and	ecx, 7
	mov	DWORD PTR _zcompare$[ebp], ecx

; 33   :   pixtype = (flags >> 4) & 0x0FUL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 4
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], edx

; 34   :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 7
	and	eax, 6
	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	or	eax, ecx
	mov	DWORD PTR _bva$[ebp], eax

; 35   :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	edx, DWORD PTR _baseaddr$[ebp]
	and	edx, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], edx

; 36   :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], eax

; 37   :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	ecx, DWORD PTR _xinfo$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], ecx

; 38   :   xpos = xinfo & 0x7FFUL;

	mov	edx, DWORD PTR _xinfo$[ebp]
	and	edx, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], edx

; 39   :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	eax, DWORD PTR _yinfo$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], eax

; 40   :   ypos = yinfo & 0x7FFUL;

	mov	ecx, DWORD PTR _yinfo$[ebp]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], ecx

; 41   : 
; 42   :   directValue = intaddr;

	mov	edx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], edx

; 43   : 
; 44   :   map = 0;

	mov	DWORD PTR _map$[ebp], 0

; 45   :   zmap = 1;

	mov	DWORD PTR _zmap$[ebp], 1

; 46   : 
; 47   :   if(pixtype >= 13)

	cmp	DWORD PTR _pixtype$[ebp], 13		; 0000000dH
	jb	SHORT $LN36@BDMA_Type5

; 48   :   {
; 49   :     map = pixtype - 13;

	mov	eax, DWORD PTR _pixtype$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax

; 50   :     zmap = 2;

	mov	DWORD PTR _zmap$[ebp], 2
	jmp	SHORT $LN35@BDMA_Type5
$LN36@BDMA_Type5:

; 51   :   }
; 52   :   else if(pixtype >= 9)

	cmp	DWORD PTR _pixtype$[ebp], 9
	jb	SHORT $LN35@BDMA_Type5

; 53   :   {
; 54   :     map = pixtype - 9;

	mov	ecx, DWORD PTR _pixtype$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 55   :     zmap = 3;

	mov	DWORD PTR _zmap$[ebp], 3
$LN35@BDMA_Type5:

; 56   :   }
; 57   : 
; 58   :   if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN33@BDMA_Type5

; 59   :   {
; 60   :     bCompareZ = (zcompare ? true : false);

	cmp	DWORD PTR _zcompare$[ebp], 0
	setne	dl
	mov	BYTE PTR _bCompareZ$[ebp], dl

; 61   :     //pixel+Z write (16 + 16Z)
; 62   :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 63   :     bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 64   :     srcStrideShift = 1;

	mov	DWORD PTR _srcStrideShift$[ebp], 1

; 65   :   }
; 66   :   else

	jmp	SHORT $LN32@BDMA_Type5
$LN33@BDMA_Type5:

; 67   :   {
; 68   :     //pixel only write (16 bit)
; 69   :     bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 70   :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 71   :     bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 72   :     srcStrideShift = 0;

	mov	DWORD PTR _srcStrideShift$[ebp], 0
$LN32@BDMA_Type5:

; 73   :   }
; 74   : 
; 75   :   if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	SHORT $LN31@BDMA_Type5

; 76   :   {
; 77   :     //internal address is system address (but still in MPE memory)
; 78   :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	ecx, DWORD PTR _mpeBase$[ebp]
	and	ecx, 545259519				; 207fffffH
	push	ecx
	mov	edx, DWORD PTR _mpeBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 79   :   }
; 80   :   else

	jmp	SHORT $LN30@BDMA_Type5
$LN31@BDMA_Type5:

; 81   :   {
; 82   :     //internal address is local to MPE
; 83   :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase & 0x207FFFFF, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	and	edx, 545259519				; 207fffffH
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN30@BDMA_Type5:

; 84   :   }
; 85   : 
; 86   :   //base address is always a system address (absolute)
; 87   :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdramBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 88   : 
; 89   :   pSrcColor = (uint16 *)intMemory;

	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pSrcColor$[ebp], edx

; 90   :   pSrcZ = pSrcColor+1;

	mov	eax, DWORD PTR _pSrcColor$[ebp]
	add	eax, 2
	mov	DWORD PTR _pSrcZ$[ebp], eax

; 91   :   pDestColor = ((uint16 *)baseMemory) + (xsize * structMainChannel.src_height * map);

	mov	ecx, DWORD PTR _xsize$[ebp]
	imul	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	imul	ecx, DWORD PTR _map$[ebp]
	mov	edx, DWORD PTR _baseMemory$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pDestColor$[ebp], eax

; 92   :   pDestZ = ((uint16 *)baseMemory) + (xsize * structMainChannel.src_height * zmap);

	mov	ecx, DWORD PTR _xsize$[ebp]
	imul	ecx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	imul	ecx, DWORD PTR _zmap$[ebp]
	mov	edx, DWORD PTR _baseMemory$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pDestZ$[ebp], eax

; 93   : 
; 94   :   if(bDirect & !bDup)

	movzx	ecx, BYTE PTR _bDirect$[ebp]
	movzx	edx, BYTE PTR _bDup$[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	and	ecx, edx
	je	SHORT $LN29@BDMA_Type5

; 95   :   {
; 96   :     bDirect = true;

	mov	BYTE PTR _bDirect$[ebp], 1
$LN29@BDMA_Type5:

; 97   :   }
; 98   :   if(bDup)

	movzx	eax, BYTE PTR _bDup$[ebp]
	test	eax, eax
	je	SHORT $LN28@BDMA_Type5

; 99   :   {
; 100  :     if(bDirect)

	movzx	ecx, BYTE PTR _bDirect$[ebp]
	test	ecx, ecx
	je	SHORT $LN27@BDMA_Type5

; 101  :     {
; 102  :       //Direct and Dup: intaddr is data.
; 103  :       directColor = intaddr >> 16;

	mov	edx, DWORD PTR _intaddr$[ebp]
	shr	edx, 16					; 00000010H
	mov	WORD PTR _directColor$[ebp], dx

; 104  :       directZ = intaddr & 0xFFFFUL;

	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	WORD PTR _directZ$[ebp], ax

; 105  :       //swap back to big endian format
; 106  :       SwapWordBytes(&directColor);

	lea	ecx, DWORD PTR _directColor$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 107  :       SwapWordBytes(&directZ);

	lea	ecx, DWORD PTR _directZ$[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 108  :     }
; 109  :     else

	jmp	SHORT $LN26@BDMA_Type5
$LN27@BDMA_Type5:

; 110  :     {
; 111  :       //Dup but not Direct: read scalar from memory, no need to swap
; 112  :       directColor = *((uint16 *)intMemory);

	mov	ecx, DWORD PTR _intMemory$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _directColor$[ebp], dx

; 113  :       directZ = *(((uint16 *)intMemory) + 1);

	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR _directZ$[ebp], cx
$LN26@BDMA_Type5:

; 114  :     }
; 115  : 
; 116  :     pSrcColor = &directColor;

	lea	edx, DWORD PTR _directColor$[ebp]
	mov	DWORD PTR _pSrcColor$[ebp], edx

; 117  :     pSrcZ = &directZ;

	lea	eax, DWORD PTR _directZ$[ebp]
	mov	DWORD PTR _pSrcZ$[ebp], eax

; 118  :     srcAStep = 0;

	mov	DWORD PTR _srcAStep$[ebp], 0

; 119  :     srcBStep = 0;

	mov	DWORD PTR _srcBStep$[ebp], 0

; 120  :   }
; 121  :   else

	jmp	SHORT $LN25@BDMA_Type5
$LN28@BDMA_Type5:

; 122  :   {
; 123  :     //if zcompare = 7 then then mpe pixel type is 16-bit without Z and the stride shift value is 0
; 124  :     //if zcompare != 7 then the mpe pixel type is 16+16Z and the stride shift value is 1
; 125  :     srcAStep = 1 << srcStrideShift;

	mov	edx, 1
	mov	ecx, DWORD PTR _srcStrideShift$[ebp]
	shl	edx, cl
	mov	DWORD PTR _srcAStep$[ebp], edx

; 126  :     srcBStep = xsize << srcStrideShift;

	mov	eax, DWORD PTR _xsize$[ebp]
	mov	ecx, DWORD PTR _srcStrideShift$[ebp]
	shl	eax, cl
	mov	DWORD PTR _srcBStep$[ebp], eax
$LN25@BDMA_Type5:

; 127  :   }
; 128  : 
; 129  :   srcOffset = 0;

	mov	DWORD PTR _srcOffset$[ebp], 0

; 130  :   destOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	ecx, DWORD PTR _ypos$[ebp]
	imul	ecx, DWORD PTR _xsize$[ebp]
	add	ecx, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _destOffset$[ebp], ecx

; 131  : 
; 132  :   //BVA = 000 (horizontal DMA, x increment, y increment)
; 133  :   destAStep = 1;

	mov	DWORD PTR _destAStep$[ebp], 1

; 134  :   destBStep = xsize;

	mov	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destBStep$[ebp], edx

; 135  :   aCount = xlen;

	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax

; 136  :   bCount = ylen;

	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 137  : 
; 138  :   pDestColor += destOffset;

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _pDestColor$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pDestColor$[ebp], ecx

; 139  :   pDestZ += destOffset;

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _pDestZ$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pDestZ$[ebp], ecx

; 140  :   srcB = 0;

	mov	DWORD PTR _srcB$[ebp], 0

; 141  :   destB = 0;

	mov	DWORD PTR _destB$[ebp], 0

; 142  : 
; 143  :   if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->mainChannelUpperLimit) ||
; 144  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->mainChannelUpperLimit))

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+52]
	jb	SHORT $LN22@BDMA_Type5
	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+48]
	jbe	SHORT $LN23@BDMA_Type5
$LN22@BDMA_Type5:
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+52]
	jb	SHORT $LN24@BDMA_Type5
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+48]
	ja	SHORT $LN24@BDMA_Type5
$LN23@BDMA_Type5:

; 145  :   {
; 146  :     nuonEnv->bMainBufferModified = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+86], 1

; 147  :   }
; 148  :   else if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->overlayChannelUpperLimit) ||

	jmp	$LN17@BDMA_Type5
$LN24@BDMA_Type5:

; 149  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->overlayChannelUpperLimit))

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+60]
	jb	SHORT $LN18@BDMA_Type5
	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+56]
	jbe	SHORT $LN19@BDMA_Type5
$LN18@BDMA_Type5:
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+60]
	jb	SHORT $LN17@BDMA_Type5
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+56]
	ja	SHORT $LN17@BDMA_Type5
$LN19@BDMA_Type5:

; 150  :   {
; 151  :     nuonEnv->bOverlayBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+87], 1
$LN17@BDMA_Type5:

; 152  :   }
; 153  : 
; 154  :   while(bCount--)

	mov	eax, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv283[ebp], eax
	mov	ecx, DWORD PTR _bCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _bCount$[ebp], ecx
	cmp	DWORD PTR tv283[ebp], 0
	je	$LN37@BDMA_Type5

; 155  :   {
; 156  :     srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 157  :     destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 158  :     aCount = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx
$LN15@BDMA_Type5:

; 159  : 
; 160  :     while(aCount--)

	mov	eax, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR _aCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _aCount$[ebp], ecx
	cmp	DWORD PTR tv286[ebp], 0
	je	$LN14@BDMA_Type5

; 161  :     {
; 162  :       bZTestResult = false;

	mov	BYTE PTR _bZTestResult$[ebp], 0

; 163  : 
; 164  :       if(bCompareZ && (zcompare != 0))

	movzx	edx, BYTE PTR _bCompareZ$[ebp]
	test	edx, edx
	je	$LN13@BDMA_Type5
	cmp	DWORD PTR _zcompare$[ebp], 0
	je	$LN13@BDMA_Type5
	mov	BYTE PTR $T43708[ebp], 0

; 165  :       {
; 166  :         bool result;
; 167  :         uint16 ztarget, ztransfer;
; 168  : 
; 169  :         ztarget = pDestZ[destA + destB];

	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pDestZ$[ebp]
	mov	dx, WORD PTR [ecx+eax*2]
	mov	WORD PTR _ztarget$41395[ebp], dx

; 170  :         ztransfer = pSrcZ[srcA + srcB];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _pSrcZ$[ebp]
	mov	dx, WORD PTR [ecx+eax*2]
	mov	WORD PTR _ztransfer$41396[ebp], dx

; 171  :         SwapWordBytes((uint16 *)&ztarget);

	lea	ecx, DWORD PTR _ztarget$41395[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 172  :         SwapWordBytes((uint16 *)&ztransfer);

	lea	ecx, DWORD PTR _ztransfer$41396[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 173  : 
; 174  :         switch(zcompare)

	mov	eax, DWORD PTR _zcompare$[ebp]
	mov	DWORD PTR tv299[ebp], eax
	cmp	DWORD PTR tv299[ebp], 7
	ja	$LN11@BDMA_Type5
	mov	ecx, DWORD PTR tv299[ebp]
	jmp	DWORD PTR $LN47@BDMA_Type5[ecx*4]
$LN10@BDMA_Type5:

; 175  :         {
; 176  :           case 0x0:
; 177  :             result = false;

	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], 0

; 178  :             break;

	jmp	$LN11@BDMA_Type5
$LN9@BDMA_Type5:

; 179  :           case 0x1:
; 180  :             result = (ztarget < ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setl	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 181  :             break;

	jmp	$LN11@BDMA_Type5
$LN8@BDMA_Type5:

; 182  :           case 0x2:
; 183  :             result = (ztarget == ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	sete	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 184  :             break;

	jmp	$LN11@BDMA_Type5
$LN7@BDMA_Type5:

; 185  :           case 0x3:
; 186  :             result = (ztarget <= ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setle	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 187  :             break;

	jmp	SHORT $LN11@BDMA_Type5
$LN6@BDMA_Type5:

; 188  :           case 0x4:
; 189  :             result = (ztarget > ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setg	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 190  :             break;

	jmp	SHORT $LN11@BDMA_Type5
$LN5@BDMA_Type5:

; 191  :           case 0x5:
; 192  :             result = (ztarget != ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setne	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 193  :             break;

	jmp	SHORT $LN11@BDMA_Type5
$LN4@BDMA_Type5:

; 194  :           case 0x6:
; 195  :             result = (ztarget >= ztransfer);

	movzx	edx, WORD PTR _ztarget$41395[ebp]
	movzx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setge	cl
	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 196  :             break;

	jmp	SHORT $LN11@BDMA_Type5
$LN3@BDMA_Type5:

; 197  :           case 0x7:
; 198  :             result = false;

	mov	BYTE PTR $T43708[ebp], 1
	mov	BYTE PTR _result$41394[ebp], 0
$LN11@BDMA_Type5:

; 199  :             break;
; 200  :         }
; 201  : 
; 202  :         bZTestResult = result;

	cmp	BYTE PTR $T43708[ebp], 0
	jne	SHORT $LN39@BDMA_Type5
	push	OFFSET $LN40@BDMA_Type5
	call	__RTC_UninitUse
	add	esp, 4
$LN39@BDMA_Type5:
	mov	dl, BYTE PTR _result$41394[ebp]
	mov	BYTE PTR _bZTestResult$[ebp], dl
$LN13@BDMA_Type5:

; 203  :       }
; 204  : 
; 205  :       if(!bZTestResult)

	movzx	eax, BYTE PTR _bZTestResult$[ebp]
	test	eax, eax
	jne	SHORT $LN2@BDMA_Type5

; 206  :       {
; 207  :         pDestColor[destA + destB] = pSrcColor[srcA + srcB];

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcB$[ebp]
	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, DWORD PTR _destB$[ebp]
	mov	eax, DWORD PTR _pDestColor$[ebp]
	mov	esi, DWORD PTR _pSrcColor$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx*2], cx

; 208  :         if(bUpdateZ)

	movzx	edx, BYTE PTR _bUpdateZ$[ebp]
	test	edx, edx
	je	SHORT $LN2@BDMA_Type5

; 209  :         {
; 210  :           pDestZ[destA + destB] = pSrcZ[srcA + srcB];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _pDestZ$[ebp]
	mov	esi, DWORD PTR _pSrcZ$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx*2], ax
$LN2@BDMA_Type5:

; 211  :         }
; 212  :       }
; 213  : 
; 214  :       srcA += srcAStep;

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcAStep$[ebp]
	mov	DWORD PTR _srcA$[ebp], ecx

; 215  :       destA += 1;

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, 1
	mov	DWORD PTR _destA$[ebp], edx

; 216  :     }

	jmp	$LN15@BDMA_Type5
$LN14@BDMA_Type5:

; 217  : 
; 218  :     srcB += srcBStep;

	mov	eax, DWORD PTR _srcB$[ebp]
	add	eax, DWORD PTR _srcBStep$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 219  :     destB += xsize;

	mov	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 220  :   }

	jmp	$LN17@BDMA_Type5
$LN37@BDMA_Type5:

; 221  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN46@BDMA_Type5
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN46@BDMA_Type5:
	DD	4
	DD	$LN45@BDMA_Type5
$LN45@BDMA_Type5:
	DD	-32					; ffffffe0H
	DD	2
	DD	$LN41@BDMA_Type5
	DD	-44					; ffffffd4H
	DD	2
	DD	$LN42@BDMA_Type5
	DD	-180					; ffffff4cH
	DD	2
	DD	$LN43@BDMA_Type5
	DD	-192					; ffffff40H
	DD	2
	DD	$LN44@BDMA_Type5
$LN44@BDMA_Type5:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN43@BDMA_Type5:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN42@BDMA_Type5:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	90					; 0000005aH
	DB	0
$LN41@BDMA_Type5:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN40@BDMA_Type5:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
	npad	3
$LN47@BDMA_Type5:
	DD	$LN10@BDMA_Type5
	DD	$LN9@BDMA_Type5
	DD	$LN8@BDMA_Type5
	DD	$LN7@BDMA_Type5
	DD	$LN6@BDMA_Type5
	DD	$LN5@BDMA_Type5
	DD	$LN4@BDMA_Type5
	DD	$LN3@BDMA_Type5
?BDMA_Type5_Write_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_0
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_1@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_1

; 224  : {

	push	ebp
	mov	ebp, esp

; 225  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_1
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_2@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_2

; 228  : {

	push	ebp
	mov	ebp, esp

; 229  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_2
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_3@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_3

; 232  : {

	push	ebp
	mov	ebp, esp

; 233  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_3
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_4@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_4

; 236  : {

	push	ebp
	mov	ebp, esp

; 237  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_4
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_5@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_5

; 240  : {

	push	ebp
	mov	ebp, esp

; 241  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_5
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_6@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_6

; 244  : {

	push	ebp
	mov	ebp, esp

; 245  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_6
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Write_7@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Write_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Write_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Write_7

; 248  : {

	push	ebp
	mov	ebp, esp

; 249  : }

	pop	ebp
	ret	0
?BDMA_Type5_Write_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Write_7
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_0@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_0
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv231 = -236						; size = 4
tv228 = -232						; size = 4
tv215 = -228						; size = 4
tv212 = -224						; size = 4
_bUpdateZ$ = -218					; size = 1
_bUpdatePixel$ = -217					; size = 1
_bCompareZ$ = -216					; size = 1
_bTrigger$ = -215					; size = 1
_bRemote$ = -214					; size = 1
_bChain$ = -213						; size = 1
_bBatch$ = -212						; size = 1
_bDup$ = -211						; size = 1
_bDirect$ = -210					; size = 1
_skipsize$ = -196					; size = 4
_mpeBase$ = -192					; size = 4
_sdramBase$ = -188					; size = 4
_mode$ = -176						; size = 4
_bva$ = -172						; size = 4
_zcompare$ = -168					; size = 4
_ypos$ = -164						; size = 4
_ylen$ = -160						; size = 4
_xpos$ = -156						; size = 4
_xlen$ = -152						; size = 4
_xsize$ = -148						; size = 4
_destBStep$ = -144					; size = 4
_destAStep$ = -140					; size = 4
_srcBStep$ = -136					; size = 4
_srcAStep$ = -132					; size = 4
_zmap$ = -128						; size = 4
_map$ = -124						; size = 4
_destOffset$ = -120					; size = 4
_srcOffset$ = -116					; size = 4
_destB$ = -112						; size = 4
_destA$ = -108						; size = 4
_srcB$ = -104						; size = 4
_srcA$ = -100						; size = 4
_aCountInit$ = -96					; size = 4
_bCount$ = -92						; size = 4
_aCount$ = -88						; size = 4
_destBStart$ = -84					; size = 4
_destAStart$ = -80					; size = 4
_srcAStart$ = -72					; size = 4
_srcStrideShift$ = -68					; size = 4
_pixtype$ = -64						; size = 4
_type$ = -60						; size = 4
_directValue$ = -56					; size = 4
_pDest32$ = -52						; size = 4
_pSrc32$ = -48						; size = 4
_pDest16$ = -44						; size = 4
_pDest$ = -40						; size = 4
_pSrc$ = -36						; size = 4
_baseMemory$ = -32					; size = 4
_intMemory$ = -28					; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_0

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 253  :   uint16 *pSrcColor, *pDestColor, *pSrcZ, *pDestZ;
; 254  :   uint16 directColor, directZ;
; 255  :   void *intMemory, *baseMemory, *pSrc, *pDest;
; 256  :   uint16 *pDest16;
; 257  :   uint32 *pSrc32, *pDest32;
; 258  :   uint32 directValue, type, pixtype, srcStrideShift;
; 259  :   uint32 srcAStart, srcBStart, destAStart, destBStart, aCount, bCount, aCountInit;
; 260  :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset, map, zmap;
; 261  :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 262  :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 263  :   uint32 mode, wordsize, pixsize, sdramBase, mpeBase, skipsize;
; 264  :   uint32 lowerLimit, upperLimit, whichRoutine;
; 265  : 
; 266  :   bool bReadZ, bDirect, bDup, bBatch, bChain, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 267  : 
; 268  :   bBatch = flags & (1UL << 30);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1073741824				; 40000000H
	setne	cl
	mov	BYTE PTR _bBatch$[ebp], cl

; 269  :   bChain = flags & (1UL << 29);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 536870912				; 20000000H
	setne	al
	mov	BYTE PTR _bChain$[ebp], al

; 270  :   bRemote = flags & (1UL << 28);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 268435456				; 10000000H
	setne	dl
	mov	BYTE PTR _bRemote$[ebp], dl

; 271  :   bDirect = flags & (1UL << 27);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 134217728				; 08000000H
	setne	cl
	mov	BYTE PTR _bDirect$[ebp], cl

; 272  :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 201326592				; 0c000000H
	setne	al
	mov	BYTE PTR _bDup$[ebp], al

; 273  :   bTrigger = flags & (1UL << 25);

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 33554432				; 02000000H
	setne	dl
	mov	BYTE PTR _bTrigger$[ebp], dl

; 274  :   xsize = (flags >> 13) & 0x7F8UL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 13					; 0000000dH
	and	eax, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], eax

; 275  :   type = (flags >> 14) & 0x03UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 14					; 0000000eH
	and	ecx, 3
	mov	DWORD PTR _type$[ebp], ecx

; 276  :   mode = flags & 0xFFFUL;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], edx

; 277  :   zcompare = (flags >> 1) & 0x07UL;

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 1
	and	eax, 7
	mov	DWORD PTR _zcompare$[ebp], eax

; 278  :   pixtype = (flags >> 4) & 0x0FUL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 4
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], ecx

; 279  :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 7
	and	edx, 6
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	or	edx, eax
	mov	DWORD PTR _bva$[ebp], edx

; 280  :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	ecx, DWORD PTR _baseaddr$[ebp]
	and	ecx, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], ecx

; 281  :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	edx, DWORD PTR _intaddr$[ebp]
	and	edx, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], edx

; 282  :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	eax, DWORD PTR _xinfo$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], eax

; 283  :   xpos = xinfo & 0x7FFUL;

	mov	ecx, DWORD PTR _xinfo$[ebp]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], ecx

; 284  :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	edx, DWORD PTR _yinfo$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], edx

; 285  :   ypos = yinfo & 0x7FFUL;

	mov	eax, DWORD PTR _yinfo$[ebp]
	and	eax, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], eax

; 286  :   skipsize = 0;

	mov	DWORD PTR _skipsize$[ebp], 0

; 287  :   bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 288  :   bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 289  :   bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 290  : 
; 291  :   directValue = intaddr;

	mov	ecx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], ecx

; 292  : 
; 293  :   if(bChain)

	movzx	edx, BYTE PTR _bChain$[ebp]
	test	edx, edx
	je	SHORT $LN18@BDMA_Type5@2

; 294  :   {
; 295  :     return;

	jmp	$LN19@BDMA_Type5@2
$LN18@BDMA_Type5@2:

; 296  :   }
; 297  : 
; 298  :   map = 0;

	mov	DWORD PTR _map$[ebp], 0

; 299  : 
; 300  :   if(pixtype >= 13)

	cmp	DWORD PTR _pixtype$[ebp], 13		; 0000000dH
	jb	SHORT $LN17@BDMA_Type5@2

; 301  :   {
; 302  :     map = pixtype - 13;

	mov	eax, DWORD PTR _pixtype$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax

; 303  :     zmap = 2;

	mov	DWORD PTR _zmap$[ebp], 2
	jmp	SHORT $LN16@BDMA_Type5@2
$LN17@BDMA_Type5@2:

; 304  :   }
; 305  :   else if(pixtype >= 9)

	cmp	DWORD PTR _pixtype$[ebp], 9
	jb	SHORT $LN16@BDMA_Type5@2

; 306  :   {
; 307  :     map = pixtype - 9;

	mov	ecx, DWORD PTR _pixtype$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 308  :     zmap = 3;

	mov	DWORD PTR _zmap$[ebp], 3
$LN16@BDMA_Type5@2:

; 309  :   }
; 310  : 
; 311  :   if(zcompare != 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	je	SHORT $LN14@BDMA_Type5@2

; 312  :   {
; 313  :     //pixel+Z write (16 + 16Z)
; 314  :     bCompareZ = (zcompare ? true : false);

	cmp	DWORD PTR _zcompare$[ebp], 0
	setne	dl
	mov	BYTE PTR _bCompareZ$[ebp], dl

; 315  :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 316  :     bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 317  :     srcStrideShift = 1;

	mov	DWORD PTR _srcStrideShift$[ebp], 1

; 318  :   }
; 319  :   else

	jmp	SHORT $LN13@BDMA_Type5@2
$LN14@BDMA_Type5@2:

; 320  :   {
; 321  :     //pixel only write (16 bit)
; 322  :     bCompareZ = false;

	mov	BYTE PTR _bCompareZ$[ebp], 0

; 323  :     bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 324  :     bUpdateZ = false;

	mov	BYTE PTR _bUpdateZ$[ebp], 0

; 325  :     srcStrideShift = 0;

	mov	DWORD PTR _srcStrideShift$[ebp], 0
$LN13@BDMA_Type5@2:

; 326  :   }
; 327  : 
; 328  :   if(bRemote)

	movzx	eax, BYTE PTR _bRemote$[ebp]
	test	eax, eax
	je	SHORT $LN12@BDMA_Type5@2

; 329  :   {
; 330  :     //internal address is system address (but still in MPE memory)
; 331  :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	ecx, DWORD PTR _mpeBase$[ebp]
	and	ecx, 545259519				; 207fffffH
	push	ecx
	mov	edx, DWORD PTR _mpeBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 332  :   }
; 333  :   else

	jmp	SHORT $LN11@BDMA_Type5@2
$LN12@BDMA_Type5@2:

; 334  :   {
; 335  :     //internal address is local to MPE
; 336  :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _the_mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN11@BDMA_Type5@2:

; 337  :   }
; 338  : 
; 339  :   //base address is always a system address (absolute)
; 340  : 
; 341  :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdramBase$[ebp]
	shr	edx, 23					; 00000017H
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 342  : 
; 343  :   pSrc = (void *)baseMemory;

	mov	edx, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], edx

; 344  :   pDest = (void *)intMemory;

	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], eax

; 345  :   srcOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	ecx, DWORD PTR _ypos$[ebp]
	imul	ecx, DWORD PTR _xsize$[ebp]
	add	ecx, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _srcOffset$[ebp], ecx

; 346  :   destOffset = 0;

	mov	DWORD PTR _destOffset$[ebp], 0

; 347  : 
; 348  :   destAStart = 0;

	mov	DWORD PTR _destAStart$[ebp], 0

; 349  :   destAStep = 1;

	mov	DWORD PTR _destAStep$[ebp], 1

; 350  :   destBStart = 0;

	mov	DWORD PTR _destBStart$[ebp], 0

; 351  :   destBStep = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destBStep$[ebp], edx

; 352  : 
; 353  : /*
; 354  :   if(((intaddr & MPE_LOCAL_MEMORY_MASK) >= MPE_IROM_BASE) &&
; 355  :     ((intaddr & MPE_LOCAL_MEMORY_MASK) < MPE_DTAGS_BASE))
; 356  :   {
; 357  :     //Maintain cache coherency!  This assumes that code will not be
; 358  :     //dynamically created in the dtrom/dtram section, bypassing the need
; 359  :     //to flush the cache on data writes.
; 360  :     if(bRemote)
; 361  :     {
; 362  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->InvalidateICache();
; 363  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->nativeCodeCache->Flush();
; 364  :       nuonEnv->mpe[(intaddr >> 23) & 0x1FUL]->UpdateInvalidateRegion(MPE_IRAM_BASE, length << 2);
; 365  :     }
; 366  :     else
; 367  :     {
; 368  :       the_mpe->InvalidateICache();
; 369  :       the_mpe->nativeCodeCache->Flush();
; 370  :       the_mpe->UpdateInvalidateRegion(MPE_IRAM_BASE, length << 2)
; 371  :     }
; 372  :   }
; 373  : */
; 374  : 
; 375  :   srcAStart = 0;

	mov	DWORD PTR _srcAStart$[ebp], 0

; 376  :   srcAStep = 1;

	mov	DWORD PTR _srcAStep$[ebp], 1

; 377  :   srcBStep = xsize;

	mov	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], eax

; 378  : 
; 379  :   bCount = ylen;

	mov	ecx, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], ecx

; 380  :   aCountInit = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCountInit$[ebp], edx

; 381  : 
; 382  :   pSrc32 = (uint32 *)pSrc;

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 383  :   pSrc32 += srcOffset;

	mov	ecx, DWORD PTR _srcOffset$[ebp]
	mov	edx, DWORD PTR _pSrc32$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 384  :   pDest16 = (uint16 *)pDest;

	mov	ecx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest16$[ebp], ecx

; 385  :   pDest16 += destOffset;

	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _pDest16$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _pDest16$[ebp], ecx

; 386  :   pDest32 = (uint32 *)pDest;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _pDest32$[ebp], edx

; 387  :   pDest32 += destOffset;

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _pDest32$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pDest32$[ebp], edx

; 388  :   srcB = 0;

	mov	DWORD PTR _srcB$[ebp], 0

; 389  :   destB = 0;

	mov	DWORD PTR _destB$[ebp], 0

; 390  : 
; 391  : #define GetPixBaseAddr(base,offset,shift) (base + (offset << shift))
; 392  : 
; 393  :   if(zcompare == 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	jne	$LN4@BDMA_Type5@2
$LN9@BDMA_Type5@2:

; 394  :   {
; 395  :     while(bCount--)

	mov	eax, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv212[ebp], eax
	mov	ecx, DWORD PTR _bCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _bCount$[ebp], ecx
	cmp	DWORD PTR tv212[ebp], 0
	je	SHORT $LN8@BDMA_Type5@2

; 396  :     {
; 397  :       srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 398  :       destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 399  :       aCount = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx
$LN7@BDMA_Type5@2:

; 400  : 
; 401  :       while(aCount--)

	mov	eax, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv215[ebp], eax
	mov	ecx, DWORD PTR _aCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _aCount$[ebp], ecx
	cmp	DWORD PTR tv215[ebp], 0
	je	SHORT $LN6@BDMA_Type5@2

; 402  :       {
; 403  :         pDest16[destA + destB] = ((uint16 *)(&pSrc32[srcA + srcB]))[0];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	mov	ecx, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	dx, WORD PTR [esi+edx*4]
	mov	WORD PTR [ecx+eax*2], dx

; 404  : 
; 405  :         srcA += 1;

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, 1
	mov	DWORD PTR _srcA$[ebp], eax

; 406  :         destA += 1;

	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, 1
	mov	DWORD PTR _destA$[ebp], ecx

; 407  :       }

	jmp	SHORT $LN7@BDMA_Type5@2
$LN6@BDMA_Type5@2:

; 408  : 
; 409  :       srcB += xsize;

	mov	edx, DWORD PTR _srcB$[ebp]
	add	edx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcB$[ebp], edx

; 410  :       destB += xlen;

	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destB$[ebp], eax

; 411  :     }

	jmp	$LN9@BDMA_Type5@2
$LN8@BDMA_Type5@2:

; 412  :   }
; 413  :   else

	jmp	$LN19@BDMA_Type5@2
$LN4@BDMA_Type5@2:

; 414  :   {
; 415  :     while(bCount--)

	mov	ecx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	mov	edx, DWORD PTR _bCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _bCount$[ebp], edx
	cmp	DWORD PTR tv228[ebp], 0
	je	SHORT $LN19@BDMA_Type5@2

; 416  :     {
; 417  :       srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 418  :       destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 419  :       aCount = xlen;

	mov	eax, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], eax
$LN2@BDMA_Type5@2:

; 420  : 
; 421  :       while(aCount--)

	mov	ecx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv231[ebp], ecx
	mov	edx, DWORD PTR _aCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _aCount$[ebp], edx
	cmp	DWORD PTR tv231[ebp], 0
	je	SHORT $LN1@BDMA_Type5@2

; 422  :       {
; 423  :         pDest32[destA + destB] = pSrc32[srcA + srcB];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	mov	edx, DWORD PTR _pDest32$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 424  :         //((uint16 *)(&pDest32[destA + destB]))[0] = ((uint16 *)(&pSrc32[srcA + srcB]))[0];
; 425  : 
; 426  :         srcA += 1;

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, 1
	mov	DWORD PTR _srcA$[ebp], ecx

; 427  :         destA += 1;

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, 1
	mov	DWORD PTR _destA$[ebp], edx

; 428  :       }

	jmp	SHORT $LN2@BDMA_Type5@2
$LN1@BDMA_Type5@2:

; 429  : 
; 430  :       srcB += xsize;

	mov	eax, DWORD PTR _srcB$[ebp]
	add	eax, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 431  :       destB += xlen;

	mov	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 432  :     }

	jmp	$LN4@BDMA_Type5@2
$LN19@BDMA_Type5@2:

; 433  :   }
; 434  : }

	pop	edi
	pop	esi
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?BDMA_Type5_Read_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_0
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_1@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_1

; 437  : {

	push	ebp
	mov	ebp, esp

; 438  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_1
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_2@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_2

; 441  : {

	push	ebp
	mov	ebp, esp

; 442  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_2
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_3@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_3

; 445  : {

	push	ebp
	mov	ebp, esp

; 446  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_3
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_4@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_4

; 449  : {

	push	ebp
	mov	ebp, esp

; 450  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_4
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_5@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_5

; 453  : {

	push	ebp
	mov	ebp, esp

; 454  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_5
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_6@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_6

; 457  : {

	push	ebp
	mov	ebp, esp

; 458  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_6
_TEXT	ENDS
PUBLIC	?BDMA_Type5_Read_7@@YAXPAVMPE@@IIIII@Z		; BDMA_Type5_Read_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type5_Read_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type5_Read_7

; 461  : {

	push	ebp
	mov	ebp, esp

; 462  : }

	pop	ebp
	ret	0
?BDMA_Type5_Read_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type5_Read_7
_TEXT	ENDS
END
