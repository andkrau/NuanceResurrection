; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\InstructionCache.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?Invalidate@InstructionCache@@QAEXXZ		; InstructionCache::Invalidate
PUBLIC	??0InstructionCache@@QAE@I@Z			; InstructionCache::InstructionCache
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\instructioncache.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
$T2671 = -16						; size = 4
$T2670 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_desiredEntries$ = 8					; size = 4
??0InstructionCache@@QAE@I@Z PROC			; InstructionCache::InstructionCache
; _this$ = ecx

; 5    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 6    :   uint32 i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 7    : 
; 8    :   cacheEntries = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 9    :   numEntries = desiredEntries;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _desiredEntries$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 10   : 
; 11   :   if(!numEntries)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN1@Instructio

; 12   :   {
; 13   :     numEntries = DEFAULT_NUM_CACHE_ENTRIES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 8192			; 00002000H
$LN1@Instructio:

; 14   :   }
; 15   : 
; 16   :   validBitmap = new uint32[(numEntries/32) + 1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shr	eax, 5
	add	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2670[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2670[ebp]
	mov	DWORD PTR [eax], ecx

; 17   :   cacheEntries = new InstructionCacheEntry[numEntries];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 268				; 0000010cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2671[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2671[ebp]
	mov	DWORD PTR [eax+4], ecx

; 18   : 
; 19   :   Invalidate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Invalidate@InstructionCache@@QAEXXZ	; InstructionCache::Invalidate

; 20   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0InstructionCache@@QAE@I@Z ENDP			; InstructionCache::InstructionCache
_TEXT	ENDS
PUBLIC	??1InstructionCache@@QAE@XZ			; InstructionCache::~InstructionCache
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T2681 = -12						; size = 4
$T2680 = -8						; size = 4
_this$ = -4						; size = 4
??1InstructionCache@@QAE@XZ PROC			; InstructionCache::~InstructionCache
; _this$ = ecx

; 23   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 24   :   if(cacheEntries)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Instructio@2

; 25   :   {
; 26   :     delete [] cacheEntries;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T2680[ebp], edx
	mov	eax, DWORD PTR $T2680[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Instructio@2:

; 27   :   }
; 28   : 
; 29   :   if(validBitmap)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Instructio@2

; 30   :   {
; 31   :     delete [] validBitmap;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T2681[ebp], eax
	mov	ecx, DWORD PTR $T2681[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@Instructio@2:

; 32   :   }
; 33   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1InstructionCache@@QAE@XZ ENDP			; InstructionCache::~InstructionCache
; Function compile flags: /Odtp /RTCsu
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?Invalidate@InstructionCache@@QAEXXZ PROC		; InstructionCache::Invalidate
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 37   :   uint32 i;
; 38   : 
; 39   :   for(i = 0; i < ((numEntries/32) + 1); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Invalidate
$LN2@Invalidate:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Invalidate:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shr	edx, 5
	add	edx, 1
	cmp	DWORD PTR _i$[ebp], edx
	jae	SHORT $LN4@Invalidate

; 40   :   {
; 41   :     validBitmap[i] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
	jmp	SHORT $LN2@Invalidate
$LN4@Invalidate:

; 42   :   }
; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Invalidate@InstructionCache@@QAEXXZ ENDP		; InstructionCache::Invalidate
_TEXT	ENDS
PUBLIC	?InvalidateRegion@InstructionCache@@QAEXII@Z	; InstructionCache::InvalidateRegion
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$2651 = -20						; size = 4
_validBitmapIndex$ = -16				; size = 4
_mask$ = -12						; size = 4
_tag$ = -8						; size = 4
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
?InvalidateRegion@InstructionCache@@QAEXII@Z PROC	; InstructionCache::InvalidateRegion
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 47   :   uint32 tag;
; 48   :   uint32 mask = 0x80000000UL;

	mov	DWORD PTR _mask$[ebp], -2147483648	; 80000000H

; 49   :   uint32 validBitmapIndex = 0;

	mov	DWORD PTR _validBitmapIndex$[ebp], 0

; 50   : 
; 51   :   for(uint32 i = 0; i < numEntries; i++)

	mov	DWORD PTR _i$2651[ebp], 0
	jmp	SHORT $LN6@Invalidate@2
$LN5@Invalidate@2:
	mov	eax, DWORD PTR _i$2651[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2651[ebp], eax
$LN6@Invalidate@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$2651[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN7@Invalidate@2

; 52   :   {
; 53   :     tag = cacheEntries[i].pcexec;

	mov	eax, DWORD PTR _i$2651[ebp]
	imul	eax, 268				; 0000010cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR _tag$[ebp], eax

; 54   :     if((tag >= start) && (tag <= end))

	mov	ecx, DWORD PTR _tag$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jb	SHORT $LN3@Invalidate@2
	mov	edx, DWORD PTR _tag$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	ja	SHORT $LN3@Invalidate@2

; 55   :     {
; 56   :       validBitmap[validBitmapIndex] &= ~mask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mask$[ebp]
	not	edx
	mov	eax, DWORD PTR _validBitmapIndex$[ebp]
	and	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _validBitmapIndex$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$LN3@Invalidate@2:

; 57   :     }
; 58   :     if(mask == 0x01)

	cmp	DWORD PTR _mask$[ebp], 1
	jne	SHORT $LN2@Invalidate@2

; 59   :     {
; 60   :       validBitmapIndex++;

	mov	edx, DWORD PTR _validBitmapIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _validBitmapIndex$[ebp], edx

; 61   :       mask = 0x80000000UL;

	mov	DWORD PTR _mask$[ebp], -2147483648	; 80000000H

; 62   :     }
; 63   :     else

	jmp	SHORT $LN1@Invalidate@2
$LN2@Invalidate@2:

; 64   :     {
; 65   :       mask >>= 1;

	mov	eax, DWORD PTR _mask$[ebp]
	shr	eax, 1
	mov	DWORD PTR _mask$[ebp], eax
$LN1@Invalidate@2:

; 66   :     }

	jmp	SHORT $LN5@Invalidate@2
$LN7@Invalidate@2:

; 67   :   }
; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InvalidateRegion@InstructionCache@@QAEXII@Z ENDP	; InstructionCache::InvalidateRegion
_TEXT	ENDS
PUBLIC	?CopyInstructionData@InstructionCacheEntry@@QAEXIPAV1@I@Z ; InstructionCacheEntry::CopyInstructionData
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_toSlot$ = 8						; size = 4
_src$ = 12						; size = 4
_fromSlot$ = 16						; size = 4
?CopyInstructionData@InstructionCacheEntry@@QAEXIPAV1@I@Z PROC ; InstructionCacheEntry::CopyInstructionData
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 72   :   nuances[FIXED_FIELD(toSlot,0)] = src->nuances[FIXED_FIELD(fromSlot,0)];

	mov	eax, DWORD PTR _fromSlot$[ebp]
	imul	eax, 5
	mov	ecx, DWORD PTR _toSlot$[ebp]
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+88]
	mov	DWORD PTR [edx+ecx*4+88], eax

; 73   :   nuances[FIXED_FIELD(toSlot,1)] = src->nuances[FIXED_FIELD(fromSlot,1)];

	mov	ecx, DWORD PTR _fromSlot$[ebp]
	imul	ecx, 5
	mov	edx, DWORD PTR _toSlot$[ebp]
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+92]
	mov	DWORD PTR [eax+edx*4+92], ecx

; 74   :   nuances[FIXED_FIELD(toSlot,2)] = src->nuances[FIXED_FIELD(fromSlot,2)];

	mov	edx, DWORD PTR _fromSlot$[ebp]
	imul	edx, 5
	mov	eax, DWORD PTR _toSlot$[ebp]
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+96]
	mov	DWORD PTR [ecx+eax*4+96], edx

; 75   :   nuances[FIXED_FIELD(toSlot,3)] = src->nuances[FIXED_FIELD(fromSlot,3)];

	mov	eax, DWORD PTR _fromSlot$[ebp]
	imul	eax, 5
	mov	ecx, DWORD PTR _toSlot$[ebp]
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+100]
	mov	DWORD PTR [edx+ecx*4+100], eax

; 76   :   nuances[FIXED_FIELD(toSlot,4)] = src->nuances[FIXED_FIELD(fromSlot,4)];

	mov	ecx, DWORD PTR _fromSlot$[ebp]
	imul	ecx, 5
	mov	edx, DWORD PTR _toSlot$[ebp]
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+104]
	mov	DWORD PTR [eax+edx*4+104], ecx

; 77   :   scalarInputDependencies[toSlot] = src->scalarInputDependencies[fromSlot];

	mov	edx, DWORD PTR _toSlot$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fromSlot$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+188]
	mov	DWORD PTR [eax+edx*4+188], ecx

; 78   :   miscInputDependencies[toSlot] = src->miscInputDependencies[fromSlot];

	mov	edx, DWORD PTR _toSlot$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fromSlot$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+208]
	mov	DWORD PTR [eax+edx*4+208], ecx

; 79   :   scalarOutputDependencies[toSlot] = src->scalarOutputDependencies[fromSlot];

	mov	edx, DWORD PTR _toSlot$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fromSlot$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+228]
	mov	DWORD PTR [eax+edx*4+228], ecx

; 80   :   miscOutputDependencies[toSlot] = src->miscOutputDependencies[fromSlot];

	mov	edx, DWORD PTR _toSlot$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fromSlot$[ebp]
	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+248]
	mov	DWORD PTR [eax+edx*4+248], ecx

; 81   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CopyInstructionData@InstructionCacheEntry@@QAEXIPAV1@I@Z ENDP ; InstructionCacheEntry::CopyInstructionData
_TEXT	ENDS
END
