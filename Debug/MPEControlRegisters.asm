; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\MPEControlRegisters.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?pixel_type_width@@3PAHA			; pixel_type_width
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12227
	ORG $+4
?pixel_type_width@@3PAHA DD 0fffffffeH			; pixel_type_width
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	02H
	DD	02H
	DD	03H
	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
$SG12227 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\mpecontrolregisters.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv200 = -20						; size = 4
tv190 = -16						; size = 4
tv183 = -12						; size = 4
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_entry$ = 12						; size = 4
?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z PROC ; MPE::ReadControlRegister
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 32   :   switch(address >> 4)

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 4
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 255		; 000000ffH
	ja	SHORT $LN74@ReadContro
	cmp	DWORD PTR tv65[ebp], 255		; 000000ffH
	je	$LN9@ReadContro
	cmp	DWORD PTR tv65[ebp], 129		; 00000081H
	ja	$LN1@ReadContro
	mov	ecx, DWORD PTR tv65[ebp]
	movzx	edx, BYTE PTR $LN75@ReadContro[ecx]
	jmp	DWORD PTR $LN79@ReadContro[edx*4]
$LN74@ReadContro:
	jmp	$LN1@ReadContro
$LN69@ReadContro:

; 33   :   {
; 34   :     case 0x0:
; 35   :       //mpectl: bits 0,2,4,6,8,10,12,14 and 23 read as 0
; 36   :       //bits 16,17,18,19,20,21,22,28,29,30 and 31 are reserved
; 37   :       //and also forced to 0
; 38   :       return mpectl & ~(0xF0FF5555UL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+384]
	and	eax, 251701930				; 0f00aaaaH
	jmp	$LN72@ReadContro
$LN68@ReadContro:

; 39   :     case 0x1:
; 40   :       //excepsrc
; 41   :       return excepsrc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+388]
	jmp	$LN72@ReadContro
$LN67@ReadContro:

; 42   :     case 0x2:
; 43   :       //excepclr: always reads as zero
; 44   :       return 0;

	xor	eax, eax
	jmp	$LN72@ReadContro
$LN66@ReadContro:

; 45   :     case 0x3:
; 46   :       //excephalten
; 47   :       return excephalten & 0x1FFFUL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	and	eax, 8191				; 00001fffH
	jmp	$LN72@ReadContro
$LN65@ReadContro:

; 48   :     case 0x4:
; 49   :       return tempCC & 0x7FFUL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]
	and	eax, 2047				; 000007ffH
	jmp	$LN72@ReadContro
$LN64@ReadContro:

; 50   :     case 0x5:
; 51   :       return pcfetch;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+400]
	jmp	$LN72@ReadContro
$LN63@ReadContro:

; 52   :     case 0x6:
; 53   :       return pcroute & 0xFFFFFFFE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+404]
	and	eax, -2					; fffffffeH
	jmp	$LN72@ReadContro
$LN62@ReadContro:

; 54   :     case 0x7:
; 55   :       return pcexec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+408]
	jmp	$LN72@ReadContro
$LN61@ReadContro:

; 56   :     case 0x8:
; 57   :       return *(entry->pRzRegs);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]
	jmp	$LN72@ReadContro
$LN60@ReadContro:

; 58   :     case 0x9:
; 59   :       return rzi1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	jmp	$LN72@ReadContro
$LN59@ReadContro:

; 60   :     case 0xA:
; 61   :       return rzi2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+164]
	jmp	$LN72@ReadContro
$LN58@ReadContro:

; 62   :     case 0xB:
; 63   :       return intvec1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+412]
	jmp	$LN72@ReadContro
$LN57@ReadContro:

; 64   :     case 0xC:
; 65   :       return intvec2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+416]
	jmp	$LN72@ReadContro
$LN56@ReadContro:

; 66   :     case 0xD:
; 67   :       return intsrc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+420]
	jmp	$LN72@ReadContro
$LN55@ReadContro:

; 68   :     case 0xE:
; 69   :       //intclr: always reads as zero
; 70   :       return 0;

	xor	eax, eax
	jmp	$LN72@ReadContro
$LN54@ReadContro:

; 71   :     case 0xF:
; 72   :       //intctl
; 73   :       return (intctl & 0xAA);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+428]
	and	eax, 170				; 000000aaH
	jmp	$LN72@ReadContro
$LN53@ReadContro:

; 74   :     case 0x10:
; 75   :       //inten1
; 76   :     case 0x11:
; 77   :       //inten1set: always reads the same as inten1
; 78   :       return inten1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+432]
	jmp	$LN72@ReadContro
$LN52@ReadContro:

; 79   :     case 0x12:
; 80   :       //inten1clr: always reads as zero
; 81   :       return 0;

	xor	eax, eax
	jmp	$LN72@ReadContro
$LN51@ReadContro:

; 82   :     case 0x13:
; 83   :       //inten2sel
; 84   :       return (inten2sel & 0x1F);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+444]
	and	eax, 31					; 0000001fH
	jmp	$LN72@ReadContro
$LN50@ReadContro:

; 85   :     case 0x1E:
; 86   :       return (entry->pCounterRegs)[0] & 0xFFFF;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax]
	and	eax, 65535				; 0000ffffH
	jmp	$LN72@ReadContro
$LN49@ReadContro:

; 87   :     case 0x1F:
; 88   :       return (entry->pCounterRegs)[1] & 0xFFFF;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 65535				; 0000ffffH
	jmp	$LN72@ReadContro
$LN48@ReadContro:

; 89   :     case 0x20:
; 90   :       //rx
; 91   :       return (entry->pIndexRegs)[0];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx]
	jmp	$LN72@ReadContro
$LN47@ReadContro:

; 92   :     case 0x21:
; 93   :       //ry
; 94   :       return (entry->pIndexRegs)[1];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN72@ReadContro
$LN46@ReadContro:

; 95   :     case 0x22:
; 96   :       return *(entry->pXyrange) & ((0x3FFUL << 16) | 0x3FFUL);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	and	eax, 67044351				; 03ff03ffH
	jmp	$LN72@ReadContro
$LN45@ReadContro:

; 97   :     case 0x23:
; 98   :       return xybase & 0xFFFFFFFC;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+448]
	and	eax, -4					; fffffffcH
	jmp	$LN72@ReadContro
$LN44@ReadContro:

; 99   :     case 0x24:
; 100  :       return *(entry->pXyctl) & ~((1UL << 11) | (1UL << 27) | (1UL << 31));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx]
	and	eax, 2013263871				; 77fff7ffH
	jmp	$LN72@ReadContro
$LN43@ReadContro:

; 101  :     case 0x25:
; 102  :       //ru
; 103  :       return (entry->pIndexRegs)[2];

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [ecx+8]
	jmp	$LN72@ReadContro
$LN42@ReadContro:

; 104  :     case 0x26:
; 105  :       //rv
; 106  :       return (entry->pIndexRegs)[3];

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [eax+12]
	jmp	$LN72@ReadContro
$LN41@ReadContro:

; 107  :     case 0x27:
; 108  :       return *(entry->pUvrange) & ((0x3FFUL << 16) | 0x3FFUL);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [edx]
	and	eax, 67044351				; 03ff03ffH
	jmp	$LN72@ReadContro
$LN40@ReadContro:

; 109  :     case 0x28:
; 110  :       return uvbase & 0xFFFFFFFC;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]
	and	eax, -4					; fffffffcH
	jmp	$LN72@ReadContro
$LN39@ReadContro:

; 111  :     case 0x29:
; 112  :       return *(entry->pUvctl) & ~((1UL << 11) | (1UL << 27) | (1UL << 31));

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR [edx]
	and	eax, 2013263871				; 77fff7ffH
	jmp	$LN72@ReadContro
$LN38@ReadContro:

; 113  :     case 0x2A:
; 114  :       return linpixctl & ((1UL << 28) | (15UL << 20));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+456]
	and	eax, 284164096				; 10f00000H
	jmp	$LN72@ReadContro
$LN37@ReadContro:

; 115  :     case 0x2B:
; 116  :       return clutbase & 0xFFFFFFC0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+460]
	and	eax, -64				; ffffffc0H
	jmp	$LN72@ReadContro
$LN36@ReadContro:

; 117  :     case 0x2C:
; 118  :       return *(entry->pSvshift) & 0x03UL;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	eax, DWORD PTR [eax]
	and	eax, 3
	jmp	$LN72@ReadContro
$LN35@ReadContro:

; 119  :     case 0x2D:
; 120  :       return (((int32)(*(entry->pAcshift) << 25)) >> 25);

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx]
	shl	eax, 25					; 00000019H
	sar	eax, 25					; 00000019H
	jmp	$LN72@ReadContro
$LN34@ReadContro:

; 121  :     case 0x2E:
; 122  :       return sp & 0xFFFFFFF0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+464]
	and	eax, -16				; fffffff0H
	jmp	$LN72@ReadContro
$LN33@ReadContro:

; 123  :     case 0x2F:
; 124  :       return dabreak;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+468]
	jmp	$LN72@ReadContro
$LN32@ReadContro:

; 125  :     case 0x30:
; 126  :     case 0x31:
; 127  :     case 0x32:
; 128  :     case 0x33:
; 129  :     case 0x34:
; 130  :     case 0x35:
; 131  :     case 0x36:
; 132  :     case 0x37:
; 133  :     case 0x38:
; 134  :     case 0x39:
; 135  :     case 0x3A:
; 136  :     case 0x3B:
; 137  :     case 0x3C:
; 138  :     case 0x3D:
; 139  :     case 0x3E:
; 140  :     case 0x3F:
; 141  :     case 0x40:
; 142  :     case 0x41:
; 143  :     case 0x42:
; 144  :     case 0x43:
; 145  :     case 0x44:
; 146  :     case 0x45:
; 147  :     case 0x46:
; 148  :     case 0x47:
; 149  :     case 0x48:
; 150  :     case 0x49:
; 151  :     case 0x4A:
; 152  :     case 0x4B:
; 153  :     case 0x4C:
; 154  :     case 0x4D:
; 155  :     case 0x4E:
; 156  :     case 0x4F:
; 157  :       return (entry->pScalarRegs)[(address >> 4) - 0x30];

	mov	edx, DWORD PTR _address$[ebp]
	shr	edx, 4
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx+edx*4-192]
	jmp	$LN72@ReadContro
$LN31@ReadContro:

; 158  :     case 0x50:
; 159  :       return odmactl & 0x60;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+472]
	and	eax, 96					; 00000060H
	jmp	$LN72@ReadContro
$LN30@ReadContro:

; 160  :     case 0x51:
; 161  :       return odmacptr & 0x207FFFF0UL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+476]
	and	eax, 545259504				; 207ffff0H
	jmp	$LN72@ReadContro
$LN29@ReadContro:

; 162  :     case 0x60:
; 163  :       return mdmactl & ~((3UL << 14) | (1UL << 8) | 0xF);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+480]
	and	eax, -49424				; ffff3ef0H
	jmp	$LN72@ReadContro
$LN28@ReadContro:

; 164  :     case 0x61:
; 165  :       return mdmacptr & 0x207FFFF0UL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+484]
	and	eax, 545259504				; 207ffff0H
	jmp	$LN72@ReadContro
$LN27@ReadContro:

; 166  :     case 0x7E:
; 167  :       //comminfo
; 168  :       return comminfo & ((0xFFUL << 16) | 0xFFUL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+488]
	and	eax, 16711935				; 00ff00ffH
	jmp	$LN72@ReadContro
$LN26@ReadContro:

; 169  :     case 0x7F:
; 170  :       //commctl
; 171  :       return commctl & ~((0xFUL << 8) | (0x3FUL << 24));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+492]
	and	eax, -1056968449			; c0fff0ffH
	jmp	$LN72@ReadContro
$LN25@ReadContro:

; 172  :     case 0x80:
; 173  :     {
; 174  :       switch(address & 0x0F)

	mov	edx, DWORD PTR _address$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR tv183[ebp], edx
	cmp	DWORD PTR tv183[ebp], 12		; 0000000cH
	ja	SHORT $LN18@ReadContro
	mov	eax, DWORD PTR tv183[ebp]
	movzx	ecx, BYTE PTR $LN76@ReadContro[eax]
	jmp	DWORD PTR $LN80@ReadContro[ecx*4]
$LN22@ReadContro:

; 175  :       {
; 176  :         //scalar commxmit register
; 177  :         case 0x00:
; 178  :           return commxmit0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+496]
	jmp	$LN72@ReadContro
$LN21@ReadContro:

; 179  :         case 0x04:
; 180  :           return commxmit1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+500]
	jmp	$LN72@ReadContro
$LN20@ReadContro:

; 181  :         case 0x08:
; 182  :           return commxmit2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+504]
	jmp	$LN72@ReadContro
$LN19@ReadContro:

; 183  :         case 0x0C:
; 184  :           return commxmit3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+508]
	jmp	$LN72@ReadContro
$LN18@ReadContro:

; 185  :         default:
; 186  :           return 0;

	xor	eax, eax
	jmp	$LN72@ReadContro
$LN17@ReadContro:

; 187  :       }
; 188  :     }
; 189  :     case 0x81:
; 190  :     {
; 191  :       switch(address & 0x0F)

	mov	eax, DWORD PTR _address$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR tv190[ebp], eax
	cmp	DWORD PTR tv190[ebp], 12		; 0000000cH
	ja	SHORT $LN10@ReadContro
	mov	ecx, DWORD PTR tv190[ebp]
	movzx	edx, BYTE PTR $LN77@ReadContro[ecx]
	jmp	DWORD PTR $LN81@ReadContro[edx*4]
$LN14@ReadContro:

; 192  :       {
; 193  :         //scalar commrecv register
; 194  :         case 0x00:
; 195  :           return commrecv0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+512]
	jmp	$LN72@ReadContro
$LN13@ReadContro:

; 196  :         case 0x04:
; 197  :           return commrecv1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+516]
	jmp	$LN72@ReadContro
$LN12@ReadContro:

; 198  :         case 0x08:
; 199  :           return commrecv2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+520]
	jmp	$LN72@ReadContro
$LN11@ReadContro:

; 200  :         case 0x0C:
; 201  :           //commrecv3: reading this register clears recv
; 202  :           //buffer full bit in commctl
; 203  :           commctl &= ~COMM_RECV_BUFFER_FULL_BIT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, 2147483647				; 7fffffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], ecx

; 204  :           return commrecv3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+524]
	jmp	SHORT $LN72@ReadContro
$LN10@ReadContro:

; 205  :         default:
; 206  :           return 0;

	xor	eax, eax
	jmp	SHORT $LN72@ReadContro
$LN9@ReadContro:

; 207  :       }
; 208  :     }
; 209  :     case 0xFF:
; 210  :     {
; 211  :       switch(address & 0x0F)

	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR tv200[ebp], ecx
	cmp	DWORD PTR tv200[ebp], 12		; 0000000cH
	ja	SHORT $LN2@ReadContro
	mov	edx, DWORD PTR tv200[ebp]
	movzx	eax, BYTE PTR $LN78@ReadContro[edx]
	jmp	DWORD PTR $LN82@ReadContro[eax*4]
$LN6@ReadContro:

; 212  :       {
; 213  :         case 0x00:
; 214  :         //configa
; 215  :           return configa;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+528]
	jmp	SHORT $LN72@ReadContro
$LN5@ReadContro:

; 216  :         case 0x04:
; 217  :           //configb: reserved
; 218  :           return configb;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+532]
	jmp	SHORT $LN72@ReadContro
$LN4@ReadContro:

; 219  :         case 0x08:
; 220  :           //dcachectl
; 221  :           return dcachectl;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]
	jmp	SHORT $LN72@ReadContro
$LN3@ReadContro:

; 222  :         case 0x0C:
; 223  :           //icachectl
; 224  :           return icachectl;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+540]
	jmp	SHORT $LN72@ReadContro
$LN2@ReadContro:

; 225  :         default:
; 226  :           return 0;

	xor	eax, eax
	jmp	SHORT $LN72@ReadContro
$LN1@ReadContro:

; 227  :       }
; 228  :     }
; 229  :     default:
; 230  :       //no special handling: return control register contents verbatim
; 231  :       return *(&mpectl + (address >> 4));

	mov	edx, DWORD PTR _address$[ebp]
	shr	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+384]
$LN72@ReadContro:

; 232  :   }
; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN79@ReadContro:
	DD	$LN69@ReadContro
	DD	$LN68@ReadContro
	DD	$LN67@ReadContro
	DD	$LN66@ReadContro
	DD	$LN65@ReadContro
	DD	$LN64@ReadContro
	DD	$LN63@ReadContro
	DD	$LN62@ReadContro
	DD	$LN61@ReadContro
	DD	$LN60@ReadContro
	DD	$LN59@ReadContro
	DD	$LN58@ReadContro
	DD	$LN57@ReadContro
	DD	$LN56@ReadContro
	DD	$LN55@ReadContro
	DD	$LN54@ReadContro
	DD	$LN53@ReadContro
	DD	$LN52@ReadContro
	DD	$LN51@ReadContro
	DD	$LN50@ReadContro
	DD	$LN49@ReadContro
	DD	$LN48@ReadContro
	DD	$LN47@ReadContro
	DD	$LN46@ReadContro
	DD	$LN45@ReadContro
	DD	$LN44@ReadContro
	DD	$LN43@ReadContro
	DD	$LN42@ReadContro
	DD	$LN41@ReadContro
	DD	$LN40@ReadContro
	DD	$LN39@ReadContro
	DD	$LN38@ReadContro
	DD	$LN37@ReadContro
	DD	$LN36@ReadContro
	DD	$LN35@ReadContro
	DD	$LN34@ReadContro
	DD	$LN33@ReadContro
	DD	$LN32@ReadContro
	DD	$LN31@ReadContro
	DD	$LN30@ReadContro
	DD	$LN29@ReadContro
	DD	$LN28@ReadContro
	DD	$LN27@ReadContro
	DD	$LN26@ReadContro
	DD	$LN25@ReadContro
	DD	$LN17@ReadContro
	DD	$LN1@ReadContro
$LN75@ReadContro:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	46					; 0000002eH
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	npad	2
$LN80@ReadContro:
	DD	$LN22@ReadContro
	DD	$LN21@ReadContro
	DD	$LN20@ReadContro
	DD	$LN19@ReadContro
	DD	$LN18@ReadContro
$LN76@ReadContro:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
	npad	3
$LN81@ReadContro:
	DD	$LN14@ReadContro
	DD	$LN13@ReadContro
	DD	$LN12@ReadContro
	DD	$LN11@ReadContro
	DD	$LN10@ReadContro
$LN77@ReadContro:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
	npad	3
$LN82@ReadContro:
	DD	$LN6@ReadContro
	DD	$LN5@ReadContro
	DD	$LN4@ReadContro
	DD	$LN3@ReadContro
	DD	$LN2@ReadContro
$LN78@ReadContro:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ENDP ; MPE::ReadControlRegister
_TEXT	ENDS
PUBLIC	?InvalidateICache@MPE@@QAEXXZ			; MPE::InvalidateICache
PUBLIC	?WriteControlRegister@MPE@@QAEXII@Z		; MPE::WriteControlRegister
EXTRN	?ExecuteSyscall@@YAXPAVMPE@@I@Z:PROC		; ExecuteSyscall
EXTRN	?DMABiLinear@@YAXPAVMPE@@IIIII@Z:PROC		; DMABiLinear
EXTRN	?DMALinear@@YAXPAVMPE@@III@Z:PROC		; DMALinear
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z:PROC	; Syscall_InterruptTriggered
EXTRN	?Flush@NativeCodeCache@@QAEXXZ:PROC		; NativeCodeCache::Flush
EXTRN	__RTC_CheckEsp:PROC
;	COMDAT ?yptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?yptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::yptr
_BSS	ENDS
;	COMDAT ?xptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?xptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::xptr
_BSS	ENDS
;	COMDAT ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::done_cnt_rd
_BSS	ENDS
;	COMDAT ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::done_cnt_wr
_BSS	ENDS
;	COMDAT ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::intaddr
_BSS	ENDS
;	COMDAT ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::baseaddr
_BSS	ENDS
;	COMDAT ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
_BSS	SEGMENT
?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::dmaflags
_BSS	ENDS
;	COMDAT ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
_BSS	SEGMENT
?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA DD 01H DUP (?) ; `MPE::WriteControlRegister'::`2'::dmacmd
; Function compile flags: /Odtp /RTCsu
_BSS	ENDS
_TEXT	SEGMENT
tv476 = -36						; size = 4
tv459 = -32						; size = 4
tv363 = -28						; size = 4
tv361 = -24						; size = 4
tv65 = -20						; size = 4
_setBits$ = -16						; size = 4
_clearBits$ = -12					; size = 4
_prevGoState$ = -8					; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_data$ = 12						; size = 4
?WriteControlRegister@MPE@@QAEXII@Z PROC		; MPE::WriteControlRegister
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 237  :   static uint32 dmaflags;
; 238  :   static uint32 baseaddr;
; 239  :   static uint32 intaddr;
; 240  :   static uint32 xptr;
; 241  :   static uint32 yptr;
; 242  :   static uint32 done_cnt_wr;
; 243  :   static uint32 done_cnt_rd;
; 244  :   uint32 prevGoState;
; 245  :   uint32 clearBits;
; 246  :   uint32 setBits;
; 247  :   static uint32 *dmacmd;
; 248  : 
; 249  :   switch(address >> 4)

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 4
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 255		; 000000ffH
	ja	SHORT $LN110@WriteContr
	cmp	DWORD PTR tv65[ebp], 255		; 000000ffH
	je	$LN8@WriteContr
	cmp	DWORD PTR tv65[ebp], 129		; 00000081H
	ja	$LN1@WriteContr
	mov	ecx, DWORD PTR tv65[ebp]
	movzx	edx, BYTE PTR $LN112@WriteContr[ecx]
	jmp	DWORD PTR $LN116@WriteContr[edx*4]
$LN110@WriteContr:
	jmp	$LN1@WriteContr
$LN105@WriteContr:

; 250  :   {
; 251  :     case 0x0:
; 252  :       //Conditionally clear all bits according to their associated bit clear bit
; 253  : 
; 254  :       prevGoState = mpectl & MPECTRL_MPEGO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 2
	mov	DWORD PTR _prevGoState$[ebp], ecx

; 255  :       clearBits = data & 
; 256  :         (MPECTRL_MPEGOCLR | 
; 257  :          MPECTRL_MPESINGLESTEPCLR |
; 258  :          MPECTRL_MPEDARDBRKENCLR |
; 259  :          MPECTRL_MPEDAWRBRKENCLR |
; 260  :          MPECTRL_MPEIS2XCLR |
; 261  :          MPECTRL_MPEINTTOHOSTCLR |
; 262  :          MPECTRL_MPEWASRESETCLR);

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 17749				; 00004555H
	mov	DWORD PTR _clearBits$[ebp], edx

; 263  :       setBits = data & ~clearBits;

	mov	eax, DWORD PTR _clearBits$[ebp]
	not	eax
	and	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _setBits$[ebp], eax

; 264  : 
; 265  :       mpectl &= ~(clearBits << 1);

	mov	ecx, DWORD PTR _clearBits$[ebp]
	shl	ecx, 1
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	and	ecx, DWORD PTR [edx+384]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+384], ecx

; 266  : 
; 267  :       //Even though they should already be clear, explicitly set the bit clear bits to zero
; 268  :       mpectl &=  
; 269  :         ~(MPECTRL_MPEGOCLR | 
; 270  :           MPECTRL_MPESINGLESTEPCLR |
; 271  :           MPECTRL_MPEDARDBRKENCLR |
; 272  :           MPECTRL_MPEDAWRBRKENCLR |
; 273  :           MPECTRL_MPEIS2XCLR |
; 274  :           MPECTRL_MPEINTTOHOSTCLR |
; 275  :           MPECTRL_MPEWASRESETCLR);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, -17750				; ffffbaaaH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+384], edx

; 276  : 
; 277  :       mpectl |= (setBits & 0xFFFF);

	mov	ecx, DWORD PTR _setBits$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+384]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+384], ecx

; 278  : 
; 279  :       //If the cycleType_wren bit is set, write the cycleType bits
; 280  :       if(setBits & MPECTRL_MPECYCLETYPEWREN)

	mov	ecx, DWORD PTR _setBits$[ebp]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN103@WriteContr

; 281  :       {
; 282  :         mpectl = (mpectl & 0xFFFF) | (setBits & MPECTRL_MPECYCLETYPE);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _setBits$[ebp]
	and	ecx, 251658240				; 0f000000H
	or	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], eax
$LN103@WriteContr:

; 283  :       }
; 284  : 
; 285  :       //If the resetMpe bit is set, handle the MPE reset
; 286  :       if(data & MPECTRL_MPERESET)
; 287  :       {
; 288  :         //????????
; 289  :       }
; 290  : 
; 291  :       if(!prevGoState && (mpectl & MPECTRL_MPEGO))

	cmp	DWORD PTR _prevGoState$[ebp], 0
	jne	$LN102@WriteContr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, 2
	je	SHORT $LN102@WriteContr

; 292  :       {
; 293  :         if(((mpectl & MPECTRL_MPECYCLETYPE) >> 24) == 9)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 251658240				; 0f000000H
	shr	ecx, 24					; 00000018H
	cmp	ecx, 9
	jne	SHORT $LN101@WriteContr

; 294  :         {
; 295  :           pcexec = pcfetch;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR [edx+408], ecx

; 296  :           mpectl &= ~MPECTRL_MPECYCLETYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+384]
	and	eax, -251658241				; f0ffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+384], eax

; 297  :           ecuSkipCounter = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+576], 0
$LN101@WriteContr:

; 298  :         }
; 299  :         InvalidateICache();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidateICache@MPE@@QAEXXZ		; MPE::InvalidateICache

; 300  :         nativeCodeCache->Flush();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	call	?Flush@NativeCodeCache@@QAEXXZ		; NativeCodeCache::Flush

; 301  :         invalidateRegionStart = MPE_IRAM_BASE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+624], 540016640		; 20300000H

; 302  :         invalidateRegionEnd = MPE_IRAM_BASE+OVERLAY_SIZE-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+628], 540024831		; 20301fffH
$LN102@WriteContr:

; 303  :       }
; 304  : 
; 305  :       return;

	jmp	$LN108@WriteContr
$LN100@WriteContr:

; 306  :     case 0x1:
; 307  :       //excepsrc: writing 0 has no effect, writing 1 sets bit
; 308  :       excepsrc |= data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	or	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], ecx

; 309  :       return;

	jmp	$LN108@WriteContr
$LN99@WriteContr:

; 310  :     case 0x2:
; 311  :       //excepclr: clear corresponding bits in excepsrc
; 312  :       excepsrc &= ~data;

	mov	eax, DWORD PTR _data$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+388]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], eax

; 313  :       return;

	jmp	$LN108@WriteContr
$LN98@WriteContr:

; 314  :     case 0x3:
; 315  :       //excephalten
; 316  :       excephalten = data & 0x1FFFUL;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 8191				; 00001fffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 317  :       return;

	jmp	$LN108@WriteContr
$LN97@WriteContr:

; 318  :     case 0x4:
; 319  :       cc = data & 0x7FFUL;

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 2047				; 000007ffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx

; 320  :       return;

	jmp	$LN108@WriteContr
$LN96@WriteContr:

; 321  :     case 0x5:
; 322  :       pcfetch = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+400], edx

; 323  :       return;

	jmp	$LN108@WriteContr
$LN95@WriteContr:

; 324  :     case 0x6:
; 325  :       pcroute = data & 0xFFFFFFFE;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], eax

; 326  :       return;

	jmp	$LN108@WriteContr
$LN94@WriteContr:

; 327  :     case 0x7:
; 328  :       pcexec = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+408], eax

; 329  :       return;

	jmp	$LN108@WriteContr
$LN93@WriteContr:

; 330  :     case 0x8:
; 331  :       rz = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+156], edx

; 332  :       return;

	jmp	$LN108@WriteContr
$LN92@WriteContr:

; 333  :     case 0x9:
; 334  :       rzi1 = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+160], ecx

; 335  :       return;

	jmp	$LN108@WriteContr
$LN91@WriteContr:

; 336  :     case 0xA:
; 337  :       rzi2 = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+164], eax

; 338  :       return;

	jmp	$LN108@WriteContr
$LN90@WriteContr:

; 339  :     case 0xB:
; 340  :       intvec1 = data & 0xFFFFFFFEUL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+412], ecx

; 341  :       return;

	jmp	$LN108@WriteContr
$LN89@WriteContr:

; 342  :     case 0xC:
; 343  :       intvec2 = data & 0xFFFFFFFEUL;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], eax

; 344  :       return;

	jmp	$LN108@WriteContr
$LN88@WriteContr:

; 345  :     case 0xD:
; 346  :       //intsrc: writing 0 has no effect, writing 1 sets bit
; 347  :       intsrc |= data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+420]
	or	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+420], eax

; 348  :       if(data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN87@WriteContr

; 349  :       {
; 350  :         Syscall_InterruptTriggered(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z ; Syscall_InterruptTriggered
	add	esp, 4
$LN87@WriteContr:

; 351  :       }
; 352  :       return;

	jmp	$LN108@WriteContr
$LN86@WriteContr:

; 353  :     case 0xE:
; 354  :       //intclr: clears corresponding bit in intsrc
; 355  :       if((data & 0x10) && (pcexec > 0x80000000) && (commctl & 0x80000000) && ((pcexec < 0x807604C0) || (pcexec > 0x807604C8)))

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN85@WriteContr
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+408], -2147483648	; 80000000H
	jbe	SHORT $LN85@WriteContr
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+492]
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN85@WriteContr
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+408], -2139749184	; 807604c0H
	jb	SHORT $LN84@WriteContr
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+408], -2139749176	; 807604c8H
	jbe	SHORT $LN85@WriteContr
$LN84@WriteContr:

; 356  :       {
; 357  :         intsrc &= ~data;

	mov	eax, DWORD PTR _data$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+420]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], eax
$LN85@WriteContr:

; 358  :       }
; 359  :       intsrc &= ~data;

	mov	eax, DWORD PTR _data$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+420]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], eax

; 360  :       return;

	jmp	$LN108@WriteContr
$LN83@WriteContr:

; 361  :     case 0xF:
; 362  :       //intctl
; 363  :       intctl |= (data & 0xAAUL);

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 170				; 000000aaH
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+428]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+428], eax

; 364  :       intctl &= ~((data << 1) & 0xAAUL);

	mov	eax, DWORD PTR _data$[ebp]
	shl	eax, 1
	and	eax, 170				; 000000aaH
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+428]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+428], eax

; 365  :       return;

	jmp	$LN108@WriteContr
$LN82@WriteContr:

; 366  :     case 0x10:
; 367  :       //inten1
; 368  :       inten1 = data & (~((3UL << 2) | (3UL << 10) | (3UL << 14)));

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -52237				; ffff33f3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 369  :       return;

	jmp	$LN108@WriteContr
$LN81@WriteContr:

; 370  :     case 0x11:
; 371  :       //inten1set: sets corresponding bits of inten1
; 372  :       inten1 |= data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+432]
	or	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 373  :       return;

	jmp	$LN108@WriteContr
$LN80@WriteContr:

; 374  :     case 0x12:
; 375  :       //inten1clr: clears corresponding bits of inten1
; 376  :       inten1 &= ~data;

	mov	edx, DWORD PTR _data$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+432]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], edx

; 377  :       return;

	jmp	$LN108@WriteContr
$LN79@WriteContr:

; 378  :     case 0x13:
; 379  :       //inten2sel
; 380  :       inten2sel = data & 0x1FUL;

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+444], edx

; 381  :       return;

	jmp	$LN108@WriteContr
$LN78@WriteContr:

; 382  :     case 0x1E:
; 383  :       //rc0: lower 16 bits only
; 384  :       rc0 = data & 0xFFFFUL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], ecx

; 385  :       cc |= CC_COUNTER0_ZERO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 386  : 
; 387  :       if(rc0 != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	SHORT $LN77@WriteContr

; 388  :       {
; 389  :         cc &= (~CC_COUNTER0_ZERO);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN77@WriteContr:

; 390  :       }
; 391  :       return;

	jmp	$LN108@WriteContr
$LN76@WriteContr:

; 392  :     case 0x1F:
; 393  :       //rc1: lower 16 bits only
; 394  :       rc1 = data & 0xFFFFUL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], ecx

; 395  :       cc |= CC_COUNTER1_ZERO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 396  : 
; 397  :       if(rc1 != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 0
	je	SHORT $LN75@WriteContr

; 398  :       {
; 399  :         cc &= (~CC_COUNTER1_ZERO);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx
$LN75@WriteContr:

; 400  :       }
; 401  :       return;

	jmp	$LN108@WriteContr
$LN74@WriteContr:

; 402  :     case 0x20:
; 403  :       //Rx
; 404  :       rx = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+140], edx

; 405  :       return;

	jmp	$LN108@WriteContr
$LN73@WriteContr:

; 406  :     case 0x21:
; 407  :       //Ry
; 408  :       ry = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+144], ecx

; 409  :       return;

	jmp	$LN108@WriteContr
$LN72@WriteContr:

; 410  :     case 0x22:
; 411  :       xyrange = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+176], eax

; 412  :       return;

	jmp	$LN108@WriteContr
$LN71@WriteContr:

; 413  :     case 0x23:
; 414  :       //xybase: always on scalar boundary
; 415  :       xybase = data & 0xFFFFFFFCUL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+448], ecx

; 416  :       return;

	jmp	$LN108@WriteContr
$LN70@WriteContr:

; 417  :     case 0x24:
; 418  :       //xyctl
; 419  :       xyctl = data & ~((1UL << 31) | (1UL << 27) | (1UL << 11));

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 2013263871				; 77fff7ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 420  :       return;

	jmp	$LN108@WriteContr
$LN69@WriteContr:

; 421  :     case 0x25:
; 422  :       //Ru
; 423  :       ru = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+148], eax

; 424  :       return;

	jmp	$LN108@WriteContr
$LN68@WriteContr:

; 425  :     case 0x26:
; 426  :       //Rv
; 427  :       rv = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+152], edx

; 428  :       return;

	jmp	$LN108@WriteContr
$LN67@WriteContr:

; 429  :     case 0x27:
; 430  :       uvrange = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 431  :       return;

	jmp	$LN108@WriteContr
$LN66@WriteContr:

; 432  :     case 0x28:
; 433  :       //uvbase: always on scalar boundary
; 434  :       uvbase = data & 0xFFFFFFFCUL;

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, -4					; fffffffcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+452], edx

; 435  :       return;

	jmp	$LN108@WriteContr
$LN65@WriteContr:

; 436  :     case 0x29:
; 437  :       //uvctl
; 438  :       uvctl = data & ~((1UL << 31) | (1UL << 27) | (1UL << 11));

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 2013263871				; 77fff7ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+172], ecx

; 439  :       return;

	jmp	$LN108@WriteContr
$LN64@WriteContr:

; 440  :     case 0x2A:
; 441  :       //linpixctl: bits 20-23 and 28 only
; 442  :       linpixctl = data & ((0x01UL << 28) | (0xFUL << 20));

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 284164096				; 10f00000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+456], eax

; 443  :       if(data & 0xFUL)

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 15					; 0000000fH
	je	SHORT $LN63@WriteContr

; 444  :       {
; 445  :         //M3DL sets the lower four bits in MPR_START, and the value seems
; 446  :         //to be the pixel type, so this hack allows bits 0-3 to be mapped
; 447  :         //to linpixctl bits 20-23
; 448  :         linpixctl |= ((data & 0x0FUL) << 20);

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 15					; 0000000fH
	shl	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+456]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], eax
$LN63@WriteContr:

; 449  :       }
; 450  :       return;

	jmp	$LN108@WriteContr
$LN62@WriteContr:

; 451  :     case 0x2B:
; 452  :       //clutbase: always on 64 byte boundary (possibly 1024 byte boundary)
; 453  :       clutbase = data & 0xFFFFFFC0UL;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -64				; ffffffc0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+460], eax

; 454  :       return;

	jmp	$LN108@WriteContr
$LN61@WriteContr:

; 455  :     case 0x2C:
; 456  :       //svshift: lower 2 bits
; 457  :       svshift = data & 0x03UL;

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+188], edx

; 458  :       return;

	jmp	$LN108@WriteContr
$LN60@WriteContr:

; 459  :     case 0x2D:
; 460  :       //acshift: lower 7 bits, sign extended
; 461  :       acshift = ((int32)(data << 25)) >> 25;

	mov	ecx, DWORD PTR _data$[ebp]
	shl	ecx, 25					; 00000019H
	sar	ecx, 25					; 00000019H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], ecx

; 462  :       return;

	jmp	$LN108@WriteContr
$LN59@WriteContr:

; 463  :     case 0x2E:
; 464  :       //stack pointer: always lies on vector boundary
; 465  :       sp = data & 0xFFFFFFF0UL;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -16				; fffffff0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 466  :       return;

	jmp	$LN108@WriteContr
$LN58@WriteContr:

; 467  :     case 0x2F:
; 468  :       dabreak = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+468], eax

; 469  :       return;

	jmp	$LN108@WriteContr
$LN57@WriteContr:

; 470  :     case 0x30:
; 471  :     case 0x31:
; 472  :     case 0x32:
; 473  :     case 0x33:
; 474  :     case 0x34:
; 475  :     case 0x35:
; 476  :     case 0x36:
; 477  :     case 0x37:
; 478  :     case 0x38:
; 479  :     case 0x39:
; 480  :     case 0x3A:
; 481  :     case 0x3B:
; 482  :     case 0x3C:
; 483  :     case 0x3D:
; 484  :     case 0x3E:
; 485  :     case 0x3F:
; 486  :     case 0x40:
; 487  :     case 0x41:
; 488  :     case 0x42:
; 489  :     case 0x43:
; 490  :     case 0x44:
; 491  :     case 0x45:
; 492  :     case 0x46:
; 493  :     case 0x47:
; 494  :     case 0x48:
; 495  :     case 0x49:
; 496  :     case 0x4A:
; 497  :     case 0x4B:
; 498  :     case 0x4C:
; 499  :     case 0x4D:
; 500  :     case 0x4E:
; 501  :     case 0x4F:
; 502  :       regs[(address >> 4) - 0x30] = data;

	mov	ecx, DWORD PTR _address$[ebp]
	shr	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4-192], eax

; 503  :       return;

	jmp	$LN108@WriteContr
$LN56@WriteContr:

; 504  :     case 0x50:
; 505  :       //odmactl: bits 0 through 4 are read only and bits
; 506  :       //7 through 31 are unused
; 507  : 
; 508  :       //force bits 0 through 4 to 0 since DMA transfers
; 509  :       //will execute immediately so commands are never
; 510  :       //pending nor does data transfer ever appear active
; 511  :       odmactl = data & 0x60UL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+472], ecx

; 512  :       return;

	jmp	$LN108@WriteContr
$LN55@WriteContr:

; 513  :     case 0x51:
; 514  :       //odmacptr: writing triggers Other BUS DMA
; 515  :       odmacptr = data & 0x207FFFF0UL;

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 545259504				; 207ffff0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+476], eax

; 516  :       //Call GetPointerToMemory to warn if the address is invalid
; 517  :       nuonEnv->GetPointerToMemory(this,odmacptr & 0xFFFFFFF0);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+476]
	and	eax, -16				; fffffff0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory

; 518  : 
; 519  :       if(odmactl & 0x60UL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+472]
	and	eax, 96					; 00000060H
	je	$LN54@WriteContr

; 520  :       {
; 521  :         //other bus DMA is enabled so do it!
; 522  :         dmacmd = (uint32 *)(&dtrom[odmacptr & MPE_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+560]
	mov	DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA, edx

; 523  :         dmaflags = *dmacmd;

	mov	ecx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx

; 524  :         baseaddr = *(dmacmd + 1);

	mov	eax, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 525  :         intaddr = *(dmacmd + 2);

	mov	edx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 526  :         SwapScalarBytes(&dmaflags);

	mov	ecx, OFFSET ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 527  :         SwapScalarBytes(&baseaddr);

	mov	ecx, OFFSET ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 528  :         SwapScalarBytes(&intaddr);

	mov	ecx, OFFSET ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 529  :         //clear all bits except bits 13, 16 - 23, and 28
; 530  :         dmaflags &= ((1UL << 28) | (0xFFUL << 16) | (1UL << 13));

	mov	ecx, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	ecx, 285155328				; 10ff2000H
	mov	DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 531  :         if(((baseaddr >= 0x20700000) && (baseaddr < 0x30000000)) || ((intaddr >= 0x20700000) && (intaddr < 0x30000000)))

	cmp	DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 544210944 ; 20700000H
	jb	SHORT $LN51@WriteContr
	cmp	DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 805306368 ; 30000000H
	jb	SHORT $LN52@WriteContr
$LN51@WriteContr:
	cmp	DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 544210944 ; 20700000H
	jb	SHORT $LN53@WriteContr
	cmp	DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 805306368 ; 30000000H
	jae	SHORT $LN53@WriteContr
$LN52@WriteContr:

; 532  :         {
; 533  :           dmacmd = 0;

	mov	DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA, 0
$LN53@WriteContr:

; 534  :           //return;
; 535  :         }
; 536  : 
; 537  :         DMALinear(this,dmaflags,baseaddr,intaddr);

	mov	edx, DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	edx
	mov	eax, DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	eax
	mov	ecx, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?DMALinear@@YAXPAVMPE@@III@Z		; DMALinear
	add	esp, 16					; 00000010H
$LN54@WriteContr:

; 538  :       }
; 539  :       return;

	jmp	$LN108@WriteContr
$LN50@WriteContr:

; 540  :     case 0x60:
; 541  :       //mdmactl;
; 542  :       //clear pending and active bits since DMA transfers always execute immediately
; 543  : 
; 544  :       done_cnt_wr = mdmactl >> 24;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	shr	ecx, 24					; 00000018H
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 545  :       done_cnt_rd = (mdmactl >> 16) & 0xFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 546  : 
; 547  :       //clear all existing mdmactl bits except for done_cnt_enable
; 548  :       mdmactl &= (~(1UL << 9));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], edx

; 549  : 
; 550  :       //if done cnt disable bit is to be set
; 551  :       if(data & (1UL << 8))

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN49@WriteContr

; 552  :       {
; 553  :         //if the done count enable bit is also to be set
; 554  :         if(data & (1UL << 9))

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 512				; 00000200H
	je	SHORT $LN48@WriteContr

; 555  :         {
; 556  :           //clear any errors, and reset the read and write counts to zero
; 557  :           done_cnt_wr = done_cnt_rd = 0;

	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 0
	mov	eax, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 558  :           mdmactl |= (1UL << 9);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], edx

; 559  :         }
; 560  :         else

	jmp	SHORT $LN47@WriteContr
$LN48@WriteContr:

; 561  :         {
; 562  :           //clear the enable bit
; 563  :           mdmactl &= (~(1UL << 9));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], edx
$LN47@WriteContr:

; 564  :         }

	jmp	SHORT $LN46@WriteContr
$LN49@WriteContr:

; 565  :       }
; 566  :       else if(data & (1UL << 9))

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN46@WriteContr

; 567  :       {
; 568  :         mdmactl |= (1UL << 9);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax
$LN46@WriteContr:

; 569  :       }
; 570  : 
; 571  :       //if done_cnt_wr_dec is set and done count enabled
; 572  :       if((data & (1UL << 11)) && (mdmactl & (1UL << 9)))

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN44@WriteContr
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+480]
	and	ecx, 512				; 00000200H
	je	SHORT $LN44@WriteContr

; 573  :       {
; 574  :         //if the write counter is not at an error state
; 575  :         if(done_cnt_wr < 0xFEUL)

	cmp	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
	jae	SHORT $LN44@WriteContr

; 576  :         {
; 577  :           //decrement the write counter
; 578  :           done_cnt_wr--;

	mov	edx, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	sub	edx, 1
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx
$LN44@WriteContr:

; 579  :         }
; 580  :       }
; 581  : 
; 582  :       //if done_cnt_rd_dec is set and done count enabled
; 583  :       if((data & (1UL << 10)) && (mdmactl & (1UL << 9)))

	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN42@WriteContr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	and	edx, 512				; 00000200H
	je	SHORT $LN42@WriteContr

; 584  :       {
; 585  :         //if the read counter is not at an error state
; 586  :         if(done_cnt_rd < 0xFEUL)

	cmp	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
	jae	SHORT $LN42@WriteContr

; 587  :         {
; 588  :           //decrement the read counter
; 589  :           done_cnt_rd--;

	mov	eax, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	sub	eax, 1
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax
$LN42@WriteContr:

; 590  :         }
; 591  :       }
; 592  : 
; 593  :       mdmactl |= ((done_cnt_wr << 24) | (done_cnt_rd << 16) | (data & 0x60));

	mov	ecx, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shl	edx, 16					; 00000010H
	or	ecx, edx
	mov	eax, DWORD PTR _data$[ebp]
	and	eax, 96					; 00000060H
	or	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+480]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], ecx

; 594  :       return;

	jmp	$LN108@WriteContr
$LN40@WriteContr:

; 595  :     case 0x61:
; 596  :       //mdmacptr: writing triggers Main BUS DMA
; 597  :       mdmacptr = data & 0x207FFFF0UL;

	mov	ecx, DWORD PTR _data$[ebp]
	and	ecx, 545259504				; 207ffff0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], ecx

; 598  :       //Call GetPointerToMemory to warn if the address is invalid
; 599  :       nuonEnv->GetPointerToMemory(this,data & 0xFFFFFFF0);

	push	1
	mov	eax, DWORD PTR _data$[ebp]
	and	eax, -16				; fffffff0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
$do_mdmacmd$41498:

; 600  : do_mdmacmd:
; 601  :       dmacmd = (uint32 *)(&dtrom[mdmacptr & MPE_VALID_MEMORY_MASK]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+484]
	and	eax, 8388607				; 007fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+560]
	mov	DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA, eax

; 602  :       dmaflags = *dmacmd;

	mov	edx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 603  :       baseaddr = *(dmacmd + 1);

	mov	ecx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx

; 604  :       intaddr = *(dmacmd + 2);

	mov	eax, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 605  :       SwapScalarBytes(&dmaflags);

	mov	ecx, OFFSET ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 606  :       SwapScalarBytes(&baseaddr);

	mov	ecx, OFFSET ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 607  :       SwapScalarBytes(&intaddr);

	mov	ecx, OFFSET ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 608  :       switch((dmaflags >> 14) & 0x03UL)

	mov	edx, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shr	edx, 14					; 0000000eH
	and	edx, 3
	mov	DWORD PTR tv361[ebp], edx
	je	SHORT $LN37@WriteContr
	cmp	DWORD PTR tv361[ebp], 3
	je	$LN26@WriteContr
	jmp	$LN19@WriteContr
$LN37@WriteContr:

; 609  :       {
; 610  :         case 0:
; 611  :           //linear DMA
; 612  :           switch(baseaddr >> 28)

	mov	eax, DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv363[ebp], eax
	mov	ecx, DWORD PTR tv363[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv363[ebp], ecx
	cmp	DWORD PTR tv363[ebp], 13		; 0000000dH
	ja	SHORT $LN33@WriteContr
	mov	edx, DWORD PTR tv363[ebp]
	movzx	eax, BYTE PTR $LN113@WriteContr[edx]
	jmp	DWORD PTR $LN117@WriteContr[eax*4]
$LN34@WriteContr:

; 613  :           {
; 614  :             case 0x2:
; 615  :             case 0x4:
; 616  :             case 0x8:
; 617  :             case 0xF:
; 618  :               break;

	jmp	SHORT $LN35@WriteContr
$LN33@WriteContr:

; 619  :             default:
; 620  :               return;

	jmp	$LN108@WriteContr
$LN35@WriteContr:

; 621  :           }
; 622  :           DMALinear(this,dmaflags,baseaddr,intaddr);

	mov	ecx, DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	ecx
	mov	edx, DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	edx
	mov	eax, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?DMALinear@@YAXPAVMPE@@III@Z		; DMALinear
	add	esp, 16					; 00000010H

; 623  :           if(data & (1UL << 30))

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN32@WriteContr

; 624  :           {
; 625  :             mdmacptr += 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+484]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], ecx

; 626  :             goto do_mdmacmd;

	jmp	$do_mdmacmd$41498

; 627  :           }
; 628  :           else

	jmp	$LN31@WriteContr
$LN32@WriteContr:

; 629  :           {
; 630  :             if(dmaflags & (1UL << 13))

	mov	eax, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	eax, 8192				; 00002000H
	je	SHORT $LN30@WriteContr

; 631  :             {
; 632  :               mdmactl &= (~(0xFFUL << 16));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	and	edx, -16711681				; ff00ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], edx

; 633  :               //increment done_rd_cnt in mdmactl
; 634  :               done_cnt_rd = (mdmactl >> 16) & 0xFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx

; 635  :               done_cnt_rd++;

	mov	eax, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	add	eax, 1
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 636  : 
; 637  :               if(done_cnt_rd > 0x1D)

	cmp	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 29 ; 0000001dH
	jbe	SHORT $LN29@WriteContr

; 638  :               {
; 639  :                 //overflow
; 640  :                 done_cnt_wr = 0xFE;

	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
$LN29@WriteContr:

; 641  :               }
; 642  : 
; 643  :               mdmactl |= ((done_cnt_rd & 0xFF) << 16);

	mov	ecx, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	ecx, 255				; 000000ffH
	shl	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+480]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], ecx

; 644  :             }
; 645  :             else

	jmp	SHORT $LN31@WriteContr
$LN30@WriteContr:

; 646  :             {
; 647  :               mdmactl &= (~(0xFFUL << 24));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	and	edx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], edx

; 648  :               //increment done_cnt_wr in mdmactl
; 649  :               done_cnt_wr = mdmactl >> 24;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+480]
	shr	edx, 24					; 00000018H
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx

; 650  :               done_cnt_wr++;

	mov	eax, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	add	eax, 1
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 651  : 
; 652  :               if(done_cnt_wr > 0x1D)

	cmp	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 29 ; 0000001dH
	jbe	SHORT $LN27@WriteContr

; 653  :               {
; 654  :                 //overflow
; 655  :                 done_cnt_wr = 0xFE;

	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
$LN27@WriteContr:

; 656  :               }
; 657  : 
; 658  :               mdmactl |= (done_cnt_wr << 24);

	mov	ecx, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+480]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], ecx
$LN31@WriteContr:

; 659  :             }
; 660  :           }
; 661  :           return;

	jmp	$LN108@WriteContr
$LN26@WriteContr:

; 662  :         case 3:
; 663  :           //bilinear pixel DMA
; 664  :           xptr = intaddr;

	mov	ecx, DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	mov	DWORD PTR ?xptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 665  :           yptr = *(dmacmd + 3);

	mov	edx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR ?yptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 666  :           intaddr = *(dmacmd + 4);

	mov	ecx, DWORD PTR ?dmacmd@?1??WriteControlRegister@MPE@@QAEXII@Z@4PAIA
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, edx

; 667  :           SwapScalarBytes(&yptr);

	mov	ecx, OFFSET ?yptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 668  :           SwapScalarBytes(&intaddr);

	mov	ecx, OFFSET ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 669  :           DMABiLinear(this,dmaflags,baseaddr,xptr,yptr,intaddr);

	mov	eax, DWORD PTR ?intaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	eax
	mov	ecx, DWORD PTR ?yptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	ecx
	mov	edx, DWORD PTR ?xptr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	edx
	mov	eax, DWORD PTR ?baseaddr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	eax
	mov	ecx, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?DMABiLinear@@YAXPAVMPE@@IIIII@Z	; DMABiLinear
	add	esp, 24					; 00000018H

; 670  :           if(dmaflags & (1UL << 30))

	mov	eax, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN25@WriteContr

; 671  :           {
; 672  :             mdmacptr += 16;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	add	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+484], edx

; 673  :             goto do_mdmacmd;

	jmp	$do_mdmacmd$41498

; 674  :           }
; 675  :           else

	jmp	$LN24@WriteContr
$LN25@WriteContr:

; 676  :           {
; 677  :             if(dmaflags & (1UL << 13))

	mov	ecx, DWORD PTR ?dmaflags@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	ecx, 8192				; 00002000H
	je	SHORT $LN23@WriteContr

; 678  :             {
; 679  :               mdmactl &= (~(0xFFUL << 16));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	and	eax, -16711681				; ff00ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax

; 680  :               //increament done_rd_cnt in mdmactl
; 681  :               done_cnt_rd = (mdmactl >> 16) & 0xFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 682  :               done_cnt_rd++;

	mov	ecx, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	add	ecx, 1
	mov	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 683  : 
; 684  :               if(done_cnt_rd > 0x1D)

	cmp	DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 29 ; 0000001dH
	jbe	SHORT $LN22@WriteContr

; 685  :               {
; 686  :                 //overflow
; 687  :                 done_cnt_wr = 0xFE;

	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
$LN22@WriteContr:

; 688  :               }
; 689  : 
; 690  :               mdmactl |= ((done_cnt_rd & 0xFF) << 16);

	mov	edx, DWORD PTR ?done_cnt_rd@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	and	edx, 255				; 000000ffH
	shl	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+480]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], edx

; 691  :             }
; 692  :             else

	jmp	SHORT $LN24@WriteContr
$LN23@WriteContr:

; 693  :             {
; 694  :               mdmactl &= (~(0xFFUL << 24));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax

; 695  :               //increment done_cnt_wr in mdmactl
; 696  :               done_cnt_wr = mdmactl >> 24;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+480]
	shr	eax, 24					; 00000018H
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, eax

; 697  :               done_cnt_wr++;

	mov	ecx, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	add	ecx, 1
	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, ecx

; 698  : 
; 699  :               if(done_cnt_wr > 0x1D)

	cmp	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 29 ; 0000001dH
	jbe	SHORT $LN20@WriteContr

; 700  :               {
; 701  :                 //overflow
; 702  :                 done_cnt_wr = 0xFE;

	mov	DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA, 254 ; 000000feH
$LN20@WriteContr:

; 703  :               }
; 704  : 
; 705  :               mdmactl |= (done_cnt_wr << 24);

	mov	edx, DWORD PTR ?done_cnt_wr@?1??WriteControlRegister@MPE@@QAEXII@Z@4IA
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+480]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], edx
$LN24@WriteContr:

; 706  :             }
; 707  :           }
; 708  :           return;

	jmp	$LN108@WriteContr
$LN19@WriteContr:

; 709  :         default:
; 710  :           return;

	jmp	$LN108@WriteContr

; 711  :       }
; 712  : 
; 713  :       return;

	jmp	$LN108@WriteContr
$LN18@WriteContr:

; 714  :     case 0x7E:
; 715  :       //comminfo: only lower 8 bits are writable
; 716  :       comminfo &= (~0xFFUL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+488]
	and	eax, -256				; ffffff00H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], eax

; 717  :       comminfo |= (data & 0xFFUL);

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+488]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], edx

; 718  :       return;

	jmp	$LN108@WriteContr
$LN17@WriteContr:

; 719  :     case 0x7F:
; 720  :       //commctl:
; 721  :       commctl &= (~((1UL << 30) | (0x3FFFUL)));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+492]
	and	eax, -1073758208			; bfffc000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], eax

; 722  :       commctl |= (data & ((1UL << 30) | (1UL << 13) | (1UL << 12) | 0xFFUL));

	mov	edx, DWORD PTR _data$[ebp]
	and	edx, 1073754367				; 400030ffH
	mov	eax, DWORD PTR _this$[ebp]
	or	edx, DWORD PTR [eax+492]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], edx

; 723  :       return;

	jmp	$LN108@WriteContr
$LN16@WriteContr:

; 724  :     case 0x80:
; 725  :     {
; 726  :       //commxmit: scalar write
; 727  :       switch(address & 0x0F)

	mov	edx, DWORD PTR _address$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR tv459[ebp], edx
	cmp	DWORD PTR tv459[ebp], 12		; 0000000cH
	ja	$LN9@WriteContr
	mov	eax, DWORD PTR tv459[ebp]
	movzx	ecx, BYTE PTR $LN114@WriteContr[eax]
	jmp	DWORD PTR $LN118@WriteContr[ecx*4]
$LN13@WriteContr:

; 728  :       {
; 729  :         case 0x00:
; 730  :           commxmit0 = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+496], eax

; 731  :           return;

	jmp	$LN108@WriteContr
$LN12@WriteContr:

; 732  :         case 0x04:
; 733  :           commxmit1 = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+500], edx

; 734  :           return;

	jmp	$LN108@WriteContr
$LN11@WriteContr:

; 735  :         case 0x08:
; 736  :           commxmit2 = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+504], ecx

; 737  :           return;

	jmp	$LN108@WriteContr
$LN10@WriteContr:

; 738  :         case 0x0C:
; 739  :           //commxmit3: trigger comm bus xmit request
; 740  :           commxmit3 = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+508], eax

; 741  :           commctl &= ~(COMM_XMIT_FAILED_BIT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	and	edx, -16385				; ffffbfffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+492], edx

; 742  :           commctl |= COMM_XMIT_BUFFER_FULL_BIT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+492]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+492], edx

; 743  :           nuonEnv->pendingCommRequests++;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 1
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	DWORD PTR [eax+44], edx

; 744  :           return;

	jmp	SHORT $LN108@WriteContr
$LN9@WriteContr:

; 745  :       }
; 746  :     }
; 747  :     case 0x81:
; 748  :       //commrecv: read only
; 749  :       return;

	jmp	SHORT $LN108@WriteContr
$LN8@WriteContr:

; 750  :     case 0xFF:
; 751  :     {
; 752  :       switch(address & 0x0F)

	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR tv476[ebp], ecx
	cmp	DWORD PTR tv476[ebp], 12		; 0000000cH
	ja	SHORT $LN1@WriteContr
	mov	edx, DWORD PTR tv476[ebp]
	movzx	eax, BYTE PTR $LN115@WriteContr[edx]
	jmp	DWORD PTR $LN119@WriteContr[eax*4]
$LN5@WriteContr:

; 753  :       {
; 754  :         case 0x00:
; 755  :           //configa: treat as syscall
; 756  :           ExecuteSyscall(this, data);

	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?ExecuteSyscall@@YAXPAVMPE@@I@Z		; ExecuteSyscall
	add	esp, 8

; 757  :           return;

	jmp	SHORT $LN108@WriteContr
$LN4@WriteContr:

; 758  :         case 0x04:
; 759  :           //configb: read only
; 760  :           return;

	jmp	SHORT $LN108@WriteContr
$LN3@WriteContr:

; 761  :         case 0x08:
; 762  :           //dcachectl
; 763  :           dcachectl = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+536], ecx

; 764  :           return;

	jmp	SHORT $LN108@WriteContr
$LN2@WriteContr:

; 765  :         case 0x0C:
; 766  :           //icachectl
; 767  :           icachectl = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+540], eax

; 768  :           return;

	jmp	SHORT $LN108@WriteContr
$LN1@WriteContr:

; 769  :       }
; 770  :     }
; 771  :     default:
; 772  :       //no special handling: write control register contents verbatim
; 773  :       *(&mpectl + (address >> 4)) = data;

	mov	ecx, DWORD PTR _address$[ebp]
	shr	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+ecx*4+384], eax
$LN108@WriteContr:

; 774  :       return;
; 775  :   }
; 776  : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN116@WriteContr:
	DD	$LN105@WriteContr
	DD	$LN100@WriteContr
	DD	$LN99@WriteContr
	DD	$LN98@WriteContr
	DD	$LN97@WriteContr
	DD	$LN96@WriteContr
	DD	$LN95@WriteContr
	DD	$LN94@WriteContr
	DD	$LN93@WriteContr
	DD	$LN92@WriteContr
	DD	$LN91@WriteContr
	DD	$LN90@WriteContr
	DD	$LN89@WriteContr
	DD	$LN88@WriteContr
	DD	$LN86@WriteContr
	DD	$LN83@WriteContr
	DD	$LN82@WriteContr
	DD	$LN81@WriteContr
	DD	$LN80@WriteContr
	DD	$LN79@WriteContr
	DD	$LN78@WriteContr
	DD	$LN76@WriteContr
	DD	$LN74@WriteContr
	DD	$LN73@WriteContr
	DD	$LN72@WriteContr
	DD	$LN71@WriteContr
	DD	$LN70@WriteContr
	DD	$LN69@WriteContr
	DD	$LN68@WriteContr
	DD	$LN67@WriteContr
	DD	$LN66@WriteContr
	DD	$LN65@WriteContr
	DD	$LN64@WriteContr
	DD	$LN62@WriteContr
	DD	$LN61@WriteContr
	DD	$LN60@WriteContr
	DD	$LN59@WriteContr
	DD	$LN58@WriteContr
	DD	$LN57@WriteContr
	DD	$LN56@WriteContr
	DD	$LN55@WriteContr
	DD	$LN50@WriteContr
	DD	$LN40@WriteContr
	DD	$LN18@WriteContr
	DD	$LN17@WriteContr
	DD	$LN16@WriteContr
	DD	$LN9@WriteContr
	DD	$LN1@WriteContr
$LN112@WriteContr:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	npad	2
$LN117@WriteContr:
	DD	$LN34@WriteContr
	DD	$LN33@WriteContr
$LN113@WriteContr:
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	npad	2
$LN118@WriteContr:
	DD	$LN13@WriteContr
	DD	$LN12@WriteContr
	DD	$LN11@WriteContr
	DD	$LN10@WriteContr
	DD	$LN9@WriteContr
$LN114@WriteContr:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
	npad	3
$LN119@WriteContr:
	DD	$LN5@WriteContr
	DD	$LN4@WriteContr
	DD	$LN3@WriteContr
	DD	$LN2@WriteContr
	DD	$LN1@WriteContr
$LN115@WriteContr:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
?WriteControlRegister@MPE@@QAEXII@Z ENDP		; MPE::WriteControlRegister
_TEXT	ENDS
EXTRN	?Invalidate@InstructionCache@@QAEXXZ:PROC	; InstructionCache::Invalidate
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
;	COMDAT ?InvalidateICache@MPE@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InvalidateICache@MPE@@QAEXXZ PROC			; MPE::InvalidateICache, COMDAT
; _this$ = ecx

; 454  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 455  :     numInterpreterCacheFlushes++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+644], ecx

; 456  :     instructionCache->Invalidate();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	call	?Invalidate@InstructionCache@@QAEXXZ	; InstructionCache::Invalidate

; 457  :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InvalidateICache@MPE@@QAEXXZ ENDP			; MPE::InvalidateICache
_TEXT	ENDS
END
