; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\mpe_alloc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?mpeFlags@@3PAIA				; mpeFlags
_BSS	SEGMENT
?mpeFlags@@3PAIA DD 04H DUP (?)				; mpeFlags
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12232
_DATA	ENDS
CONST	SEGMENT
$SG12232 DB	'bad allocation', 00H
	ORG $+1
_mpeFlags_init DD 0fH
	DD	00H
	DD	00H
	DD	03H
CONST	ENDS
PUBLIC	?ResetMPEFlags@@YAXPAVMPE@@@Z			; ResetMPEFlags
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\mpe_alloc.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_i$ = -4						; size = 4
_mpe$ = 8						; size = 4
?ResetMPEFlags@@YAXPAVMPE@@@Z PROC			; ResetMPEFlags

; 23   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 24   :   uint32 i;
; 25   : 
; 26   :   for(i = 0; i < 4; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ResetMPEFl
$LN2@ResetMPEFl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ResetMPEFl:
	cmp	DWORD PTR _i$[ebp], 4
	jae	SHORT $LN1@ResetMPEFl

; 27   :   {
; 28   :     mpeFlags[i] = mpeFlags_init[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _mpeFlags_init[edx*4]
	mov	DWORD PTR ?mpeFlags@@3PAIA[ecx*4], eax

; 29   :   }

	jmp	SHORT $LN2@ResetMPEFl
$LN1@ResetMPEFl:

; 30   : 
; 31   :   mpeFlags[mpe->mpeIndex] |= (MPE_ALLOC_BIOS|MPE_ALLOC_USER);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	eax, DWORD PTR ?mpeFlags@@3PAIA[edx*4]
	or	eax, 50331648				; 03000000H
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	DWORD PTR ?mpeFlags@@3PAIA[edx*4], eax

; 32   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetMPEFlags@@YAXPAVMPE@@@Z ENDP			; ResetMPEFlags
_TEXT	ENDS
PUBLIC	?MPEAlloc@@YAXPAVMPE@@@Z			; MPEAlloc
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$41332 = -12						; size = 4
_bRequestedMiniBIOS$ = -5				; size = 1
_requestedFlags$ = -4					; size = 4
_mpe$ = 8						; size = 4
?MPEAlloc@@YAXPAVMPE@@@Z PROC				; MPEAlloc

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 36   :   uint32 requestedFlags = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _requestedFlags$[ebp], ecx

; 37   :   bool bRequestedMiniBIOS;
; 38   : 
; 39   :   mpe->regs[0] = 0xFFFFFFFF; //-1

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1

; 40   : 
; 41   :   for(uint32 i = 0; i < 3; i++)

	mov	DWORD PTR _i$41332[ebp], 0
	jmp	SHORT $LN7@MPEAlloc
$LN6@MPEAlloc:
	mov	eax, DWORD PTR _i$41332[ebp]
	add	eax, 1
	mov	DWORD PTR _i$41332[ebp], eax
$LN7@MPEAlloc:
	cmp	DWORD PTR _i$41332[ebp], 3
	jae	$LN8@MPEAlloc

; 42   :   {
; 43   :     if(!(mpeFlags[i] & MPE_ALLOC_USER))

	mov	ecx, DWORD PTR _i$41332[ebp]
	mov	edx, DWORD PTR ?mpeFlags@@3PAIA[ecx*4]
	and	edx, 16777216				; 01000000H
	jne	SHORT $LN4@MPEAlloc

; 44   :     {
; 45   :       //The MPE is not allocated by the USER so it is available
; 46   :       if((mpeFlags[i] & ~(MPE_ALLOC_USER|MPE_ALLOC_BIOS)) == (requestedFlags & ~(MPE_ALLOC_USER|MPE_ALLOC_BIOS)))

	mov	eax, DWORD PTR _i$41332[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	and	ecx, -50331649				; fcffffffH
	mov	edx, DWORD PTR _requestedFlags$[ebp]
	and	edx, -50331649				; fcffffffH
	cmp	ecx, edx
	jne	SHORT $LN4@MPEAlloc

; 47   :       {
; 48   :         //The MPE matched all requested flags
; 49   :         bRequestedMiniBIOS = requestedFlags & MPE_HAS_MINI_BIOS;

	mov	eax, DWORD PTR _requestedFlags$[ebp]
	and	eax, 16					; 00000010H
	setne	cl
	mov	BYTE PTR _bRequestedMiniBIOS$[ebp], cl

; 50   :         if(!bRequestedMiniBIOS && (mpeFlags[i] & MPE_HAS_MINI_BIOS))

	movzx	edx, BYTE PTR _bRequestedMiniBIOS$[ebp]
	test	edx, edx
	jne	SHORT $LN2@MPEAlloc
	mov	eax, DWORD PTR _i$41332[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	and	ecx, 16					; 00000010H
	je	SHORT $LN2@MPEAlloc

; 51   :         {          
; 52   :           //MINIBIOS was not explicitly requested and this MPE
; 53   :           //has MINIBIOS so don't allocate it
; 54   :           continue;

	jmp	SHORT $LN6@MPEAlloc
$LN2@MPEAlloc:

; 55   :         }
; 56   : 
; 57   :         if(mpeFlags_init[i] != (requestedFlags & ~(MPE_ALLOC_USER|MPE_ALLOC_BIOS)))

	mov	edx, DWORD PTR _requestedFlags$[ebp]
	and	edx, -50331649				; fcffffffH
	mov	eax, DWORD PTR _i$41332[ebp]
	cmp	DWORD PTR _mpeFlags_init[eax*4], edx
	je	SHORT $LN1@MPEAlloc

; 58   :         {
; 59   :           //The requested flags don't match the initial flags so don't allocate it
; 60   :           //This is something the VMLabs BIOS checks but probably isnt necessary
; 61   :           continue;

	jmp	SHORT $LN6@MPEAlloc
$LN1@MPEAlloc:

; 62   :         }
; 63   : 
; 64   :         mpeFlags[i] |= MPE_ALLOC_USER;

	mov	ecx, DWORD PTR _i$41332[ebp]
	mov	edx, DWORD PTR ?mpeFlags@@3PAIA[ecx*4]
	or	edx, 16777216				; 01000000H
	mov	eax, DWORD PTR _i$41332[ebp]
	mov	DWORD PTR ?mpeFlags@@3PAIA[eax*4], edx

; 65   :         mpe->regs[0] = i;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR _i$41332[ebp]
	mov	DWORD PTR [ecx], edx

; 66   :         return;

	jmp	SHORT $LN8@MPEAlloc
$LN4@MPEAlloc:

; 67   :       }
; 68   :     }

	jmp	$LN6@MPEAlloc
$LN8@MPEAlloc:

; 69   :   }
; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MPEAlloc@@YAXPAVMPE@@@Z ENDP				; MPEAlloc
_TEXT	ENDS
PUBLIC	?MPEAllocSpecific@@YAXPAVMPE@@@Z		; MPEAllocSpecific
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?MPEAllocSpecific@@YAXPAVMPE@@@Z PROC			; MPEAllocSpecific

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :   if(mpe->regs[0] < 3)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax], 3
	jae	SHORT $LN4@MPEAllocSp

; 75   :   {
; 76   :     if(mpeFlags[mpe->regs[0]] & MPE_ALLOC_ANY)

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?mpeFlags@@3PAIA[edx*4]
	and	eax, 50331648				; 03000000H
	je	SHORT $LN3@MPEAllocSp

; 77   :     {
; 78   :       //MPE already allocated
; 79   :       mpe->regs[0] = 0xFFFFFFFF; //-1

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], -1

; 80   :     }
; 81   :     else

	jmp	SHORT $LN2@MPEAllocSp
$LN3@MPEAllocSp:

; 82   :     {
; 83   :       //Mark MPE as allocated
; 84   :       mpeFlags[mpe->regs[0]] |= MPE_ALLOC_USER;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	or	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR ?mpeFlags@@3PAIA[eax*4], ecx
$LN2@MPEAllocSp:

; 85   :     }
; 86   :   }
; 87   :   else

	jmp	SHORT $LN5@MPEAllocSp
$LN4@MPEAllocSp:

; 88   :   {
; 89   :     //Invalid MPE number, return already allocated
; 90   :     mpe->regs[0] = 0xFFFFFFFF; //-1

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], -1
$LN5@MPEAllocSp:

; 91   :   }
; 92   : }

	pop	ebp
	ret	0
?MPEAllocSpecific@@YAXPAVMPE@@@Z ENDP			; MPEAllocSpecific
_TEXT	ENDS
PUBLIC	?MPEFree@@YAXPAVMPE@@@Z				; MPEFree
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?MPEFree@@YAXPAVMPE@@@Z PROC				; MPEFree

; 95   : {

	push	ebp
	mov	ebp, esp

; 96   :   if(mpe->regs[0] < 3)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax], 3
	jae	SHORT $LN3@MPEFree

; 97   :   {
; 98   :     if(mpeFlags[mpe->regs[0]] & MPE_ALLOC_USER)

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?mpeFlags@@3PAIA[edx*4]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN2@MPEFree

; 99   :     {
; 100  :       //MPE allocated by user: mark as free for user allocation
; 101  :       mpeFlags[mpe->regs[0]] &= ~MPE_ALLOC_USER;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?mpeFlags@@3PAIA[edx*4]
	and	eax, -16777217				; feffffffH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR ?mpeFlags@@3PAIA[edx*4], eax

; 102  :       mpe->regs[0] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@MPEFree:

; 103  :     }
; 104  :   }
; 105  :   else

	jmp	SHORT $LN4@MPEFree
$LN3@MPEFree:

; 106  :   {
; 107  :     //Invalid MPE number, return already free
; 108  :     mpe->regs[0] = 0xFFFFFFFF; //-1

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], -1
$LN4@MPEFree:

; 109  :   }
; 110  : }

	pop	ebp
	ret	0
?MPEFree@@YAXPAVMPE@@@Z ENDP				; MPEFree
_TEXT	ENDS
PUBLIC	?MPEStatus@@YAXPAVMPE@@@Z			; MPEStatus
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?MPEStatus@@YAXPAVMPE@@@Z PROC				; MPEStatus

; 113  : {

	push	ebp
	mov	ebp, esp

; 114  :   if(mpe->regs[0] < 4)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax], 4
	jae	SHORT $LN2@MPEStatus

; 115  :   {
; 116  :     mpe->regs[0] = mpeFlags[mpe->regs[0]];

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[edx*4]
	mov	DWORD PTR [eax], ecx

; 117  :   }
; 118  :   else

	jmp	SHORT $LN3@MPEStatus
$LN2@MPEStatus:

; 119  :   {
; 120  :     mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0
$LN3@MPEStatus:

; 121  :   }
; 122  : }

	pop	ebp
	ret	0
?MPEStatus@@YAXPAVMPE@@@Z ENDP				; MPEStatus
_TEXT	ENDS
PUBLIC	?MPEsAvailable@@YAXPAVMPE@@@Z			; MPEsAvailable
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$41363 = -4						; size = 4
_mpe$ = 8						; size = 4
?MPEsAvailable@@YAXPAVMPE@@@Z PROC			; MPEsAvailable

; 125  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 126  :   if(mpe->regs[0] == 1)

	mov	eax, DWORD PTR _mpe$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN6@MPEsAvaila

; 127  :   {
; 128  :     //Return number of MPEs in system
; 129  :     mpe->regs[0] = 4;

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 4

; 130  :   }
; 131  :   else

	jmp	SHORT $LN7@MPEsAvaila
$LN6@MPEsAvaila:

; 132  :   {
; 133  :     mpe->regs[0] = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 0

; 134  : 
; 135  :     for(int i = 0; i < 3; i++)

	mov	DWORD PTR _i$41363[ebp], 0
	jmp	SHORT $LN4@MPEsAvaila
$LN3@MPEsAvaila:
	mov	eax, DWORD PTR _i$41363[ebp]
	add	eax, 1
	mov	DWORD PTR _i$41363[ebp], eax
$LN4@MPEsAvaila:
	cmp	DWORD PTR _i$41363[ebp], 3
	jge	SHORT $LN7@MPEsAvaila

; 136  :     {
; 137  :       if(!(mpeFlags[i] & MPE_ALLOC_ANY))

	mov	ecx, DWORD PTR _i$41363[ebp]
	mov	edx, DWORD PTR ?mpeFlags@@3PAIA[ecx*4]
	and	edx, 50331648				; 03000000H
	jne	SHORT $LN1@MPEsAvaila

; 138  :       {
; 139  :         mpe->regs[0] += 1;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@MPEsAvaila:

; 140  :       }
; 141  :     }

	jmp	SHORT $LN3@MPEsAvaila
$LN7@MPEsAvaila:

; 142  :   }
; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MPEsAvailable@@YAXPAVMPE@@@Z ENDP			; MPEsAvailable
_TEXT	ENDS
PUBLIC	?Halt@MPE@@QAEXXZ				; MPE::Halt
PUBLIC	?Go@MPE@@QAEXXZ					; MPE::Go
PUBLIC	?MPERun@@YAXPAVMPE@@@Z				; MPERun
EXTRN	?UpdateInvalidateRegion@MPE@@QAEXII@Z:PROC	; MPE::UpdateInvalidateRegion
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	?media_mpe@@3IA:DWORD				; media_mpe
EXTRN	?media_mpe_allocated@@3IA:DWORD			; media_mpe_allocated
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_entrypoint$ = -8					; size = 4
_which$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?MPERun@@YAXPAVMPE@@@Z PROC				; MPERun

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 147  :   uint32 which = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 148  :   uint32 entrypoint = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _entrypoint$[ebp], eax

; 149  : 
; 150  :   /*
; 151  :   The following behavior differs from the real BIOS particularly in that
; 152  :   if the target MPE is allocated the minibios, MPERun should use CommSendInfo
; 153  :   to send the target MPE a comm packet with the first scalar set to the entry point
; 154  :   address and comminfo set to $C2.  CommSendInfo does not return until the packet is
; 155  :   sent, so this behavior requires a native assembly implementation.  This code simply
; 156  :   duplicates the C2 handler logic, which is normally triggered by a software interrupt
; 157  :   injected by the level2 handler.  The level1 handler gets called and eventually handles
; 158  :   the queued C2 packet.  The C2 handler sets rzi1 to the entry point so that it gets called
; 159  :   when the level1 handler exits
; 160  :   */
; 161  : 
; 162  :   if(media_mpe_allocated && (which == media_mpe))

	cmp	DWORD PTR ?media_mpe_allocated@@3IA, 0	; media_mpe_allocated
	je	SHORT $LN2@MPERun
	mov	ecx, DWORD PTR _which$[ebp]
	cmp	ecx, DWORD PTR ?media_mpe@@3IA		; media_mpe
	jne	SHORT $LN2@MPERun

; 163  :   {
; 164  :     //nuonEnv->mpe[which]->rz = nuonEnv->mpe[which]->pcexec;
; 165  :     //nuonEnv->mpe[which]->pcexec = entrypoint;
; 166  :     //nuonEnv->mpe[which]->ecuSkipCounter = 0;
; 167  :     //nuonEnv->mpe[which]->excephalten = 0xFFFFFFFE;
; 168  :     //nuonEnv->mpe[which]->sp = 0x20102000;
; 169  :     //Invalidate cached instruction packets
; 170  :     //nuonEnv->mpe[which]->InvalidateICache();
; 171  :     nuonEnv->mpe[which]->UpdateInvalidateRegion(MPE_IRAM_BASE, OVERLAY_SIZE);

	push	8192					; 00002000H
	push	540016640				; 20300000H
	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion

; 172  :     nuonEnv->mpe[which]->Go();

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?Go@MPE@@QAEXXZ				; MPE::Go

; 173  :     nuonEnv->bProcessorStartStopChange = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+85], 1

; 174  :     //Let MPERunMediaMPE set a comm packet to the media MPE to start it
; 175  :     the_mpe->regs[2] = the_mpe->rz;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	DWORD PTR [ecx+8], eax

; 176  :     the_mpe->rz = MPERUNMEDIAMPE_ADDRESS;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [ecx+156], -2139749624	; 80760308H

; 177  :     the_mpe->ecuSkipCounter = 0;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [edx+576], 0

; 178  :   }
; 179  :   else

	jmp	$LN3@MPERun
$LN2@MPERun:

; 180  :   {
; 181  :     nuonEnv->mpe[which]->Halt();

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?Halt@MPE@@QAEXXZ			; MPE::Halt

; 182  :     //Set up entry point
; 183  :     nuonEnv->mpe[which]->pcexec = entrypoint;

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _entrypoint$[ebp]
	mov	DWORD PTR [ecx+408], edx

; 184  :     //set return address to zero, per vmlabs implementation (MML3D uses this to halt after the pipeline finishes)
; 185  :     nuonEnv->mpe[which]->rz = 0;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+156], 0

; 186  :     nuonEnv->mpe[which]->ecuSkipCounter = 0;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+576], 0

; 187  :     //Clear exceptions 
; 188  :     nuonEnv->mpe[which]->excepsrc = 0;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+388], 0

; 189  :     //Mask level1 and level2 interupts
; 190  :     nuonEnv->mpe[which]->intctl = 0x88;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+428], 136		; 00000088H

; 191  :     nuonEnv->mpe[which]->sp = 0x20101000;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+464], 537923584		; 20101000H

; 192  :     //Invalidate cached instruction packets
; 193  :     //nuonEnv->mpe[which]->InvalidateICache();
; 194  :     //nuonEnv->mpe[which]->nativeCodeCache->Flush();
; 195  :     nuonEnv->mpe[which]->UpdateInvalidateRegion(MPE_IRAM_BASE, OVERLAY_SIZE);

	push	8192					; 00002000H
	push	540016640				; 20300000H
	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion

; 196  :     //Sets mpego bit
; 197  :     nuonEnv->mpe[which]->Go();

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?Go@MPE@@QAEXXZ				; MPE::Go

; 198  :     nuonEnv->bProcessorStartStopChange = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+85], 1
$LN3@MPERun:

; 199  :   }
; 200  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MPERun@@YAXPAVMPE@@@Z ENDP				; MPERun
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
_TEXT	ENDS
;	COMDAT ?Halt@MPE@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Halt@MPE@@QAEXXZ PROC					; MPE::Halt, COMDAT
; _this$ = ecx

; 471  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 472  :     mpectl &= ~MPECTRL_MPEGO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], ecx

; 473  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?Halt@MPE@@QAEXXZ ENDP					; MPE::Halt
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?Go@MPE@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Go@MPE@@QAEXXZ PROC					; MPE::Go, COMDAT
; _this$ = ecx

; 476  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 477  :     mpectl |= MPECTRL_MPEGO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], ecx

; 478  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?Go@MPE@@QAEXXZ ENDP					; MPE::Go
_TEXT	ENDS
PUBLIC	?MPERunThread@@YAXPAVMPE@@@Z			; MPERunThread
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe_alloc.cpp
_TEXT	SEGMENT
_stacktop$ = -16					; size = 4
_arg$ = -12						; size = 4
_funcptr$ = -8						; size = 4
_which$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?MPERunThread@@YAXPAVMPE@@@Z PROC			; MPERunThread

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 204  :   uint32 which = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 205  :   uint32 funcptr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _funcptr$[ebp], eax

; 206  :   uint32 arg = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _arg$[ebp], edx

; 207  :   uint32 stacktop = the_mpe->regs[3];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _stacktop$[ebp], ecx

; 208  : 
; 209  :   //assume failure
; 210  :   the_mpe->regs[0] = 0;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [edx], 0

; 211  : 
; 212  :   //Official implementation requires that the MPE is not allocated by BIOS and 
; 213  :   //that the MPE has both icache and dcache
; 214  :   if((mpeFlags[which] & (MPE_ALLOC_BIOS | MPE_HAS_CACHES)) == MPE_HAS_CACHES)

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?mpeFlags@@3PAIA[eax*4]
	and	ecx, 33554435				; 02000003H
	cmp	ecx, 3
	jne	$LN2@MPERunThre

; 215  :   {
; 216  :     //Official implementation simply modifies stacktop to be vector aligned
; 217  :     stacktop &= 0xFFFFFFF0;    nuonEnv->mpe[which]->ecuSkipCounter = 0;

	mov	edx, DWORD PTR _stacktop$[ebp]
	and	edx, -16				; fffffff0H
	mov	DWORD PTR _stacktop$[ebp], edx
	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+576], 0

; 218  : 
; 219  : 
; 220  :     nuonEnv->mpe[which]->Halt();

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?Halt@MPE@@QAEXXZ			; MPE::Halt

; 221  :     //Invalidate cached instruction packets
; 222  :     //nuonEnv->mpe[which]->InvalidateICache();
; 223  :     //nuonEnv->mpe[which]->nativeCodeCache->Flush();
; 224  :     nuonEnv->mpe[which]->UpdateInvalidateRegion(MPE_IRAM_BASE, OVERLAY_SIZE);

	push	8192					; 00002000H
	push	540016640				; 20300000H
	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion

; 225  :     nuonEnv->mpe[which]->rz = MPE_THREAD_RETURN_ADDRESS;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+156], -2139095200	; 807fff60H

; 226  :     //Set up entry point
; 227  :     nuonEnv->mpe[which]->pcexec = funcptr;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _funcptr$[ebp]
	mov	DWORD PTR [eax+408], ecx

; 228  :     nuonEnv->mpe[which]->ecuSkipCounter = 0;

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+576], 0

; 229  :     //Set up argument using C calling convention (first arg is r0)
; 230  :     nuonEnv->mpe[which]->regs[0] = arg;

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _arg$[ebp]
	mov	DWORD PTR [ecx], edx

; 231  :     //Set up C stack pointer (r31)
; 232  :     nuonEnv->mpe[which]->regs[31] = stacktop;

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _stacktop$[ebp]
	mov	DWORD PTR [edx+124], eax

; 233  :   
; 234  :     //** Stuff done by MPERun
; 235  :     //Clear exceptions 
; 236  :     nuonEnv->mpe[which]->excepsrc = 0;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+388], 0

; 237  :     //Mask level1 and level2 interupts
; 238  :     nuonEnv->mpe[which]->intctl = 0x88;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+428], 136		; 00000088H

; 239  : 
; 240  :     //** Stuff done by MPERunThread bootcode
; 241  : 
; 242  :     //Clear inten1 
; 243  :     nuonEnv->mpe[which]->inten1 = 0;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+432], 0

; 244  :     //Clear interrupts 
; 245  :     nuonEnv->mpe[which]->intsrc = 0;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+420], 0

; 246  :     //Clear dtags
; 247  :     //Clear itags
; 248  :     //Clear acshift
; 249  :     nuonEnv->mpe[which]->acshift = 0;

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+184], 0

; 250  : 
; 251  :     //Sets mpego bit
; 252  :     nuonEnv->mpe[which]->Go();

	mov	ecx, DWORD PTR _which$[ebp]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [edx+ecx*4]
	call	?Go@MPE@@QAEXXZ				; MPE::Go

; 253  :     //Return 1 to indicate success;
; 254  :     the_mpe->regs[0] = 1;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [eax], 1

; 255  :     nuonEnv->bProcessorStartStopChange = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+85], 1
$LN2@MPERunThre:

; 256  :   }
; 257  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MPERunThread@@YAXPAVMPE@@@Z ENDP			; MPERunThread
_TEXT	ENDS
PUBLIC	?MPEStop@@YAXPAVMPE@@@Z				; MPEStop
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
?MPEStop@@YAXPAVMPE@@@Z PROC				; MPEStop

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   if(the_mpe->regs[0] < 4)

	mov	eax, DWORD PTR _the_mpe$[ebp]
	cmp	DWORD PTR [eax], 4
	jae	SHORT $LN2@MPEStop

; 262  :   {
; 263  :     nuonEnv->mpe[the_mpe->regs[0]]->mpectl &= ~MPECTRL_MPEGO;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+384], edx

; 264  :     nuonEnv->bProcessorStartStopChange = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+85], 1
$LN2@MPEStop:

; 265  :   }
; 266  : }

	pop	ebp
	ret	0
?MPEStop@@YAXPAVMPE@@@Z ENDP				; MPEStop
_TEXT	ENDS
PUBLIC	?GetPointerToMemory@MPE@@QAEPAXXZ		; MPE::GetPointerToMemory
PUBLIC	?MPELoad@@YAXPAVMPE@@@Z				; MPELoad
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_count$41401 = -28					; size = 4
_systemMemPtr$ = -24					; size = 4
_mpeMemPtr$ = -20					; size = 4
_size$ = -16						; size = 4
_linkaddr$ = -12					; size = 4
_mpeaddr$ = -8						; size = 4
_which$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?MPELoad@@YAXPAVMPE@@@Z PROC				; MPELoad

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 270  :   uint32 which = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 271  :   uint32 mpeaddr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mpeaddr$[ebp], eax

; 272  :   uint32 linkaddr = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _linkaddr$[ebp], edx

; 273  :   uint32 size = the_mpe->regs[3];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _size$[ebp], ecx

; 274  :   uint8 *mpeMemPtr, *systemMemPtr;
; 275  : 
; 276  :   if(which < 4)

	cmp	DWORD PTR _which$[ebp], 4
	jae	$LN8@MPELoad

; 277  :   {
; 278  :     if((size + (mpeaddr & MPE_VALID_MEMORY_MASK) - 1) <= MPE_VALID_MEMORY_MASK)

	mov	edx, DWORD PTR _mpeaddr$[ebp]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	cmp	ecx, 8388607				; 007fffffH
	ja	$LN8@MPELoad

; 279  :     {
; 280  :       if(linkaddr < SYSTEM_BUS_BASE)

	cmp	DWORD PTR _linkaddr$[ebp], -2147483648	; 80000000H
	jae	SHORT $LN5@MPELoad

; 281  :       {
; 282  :         systemMemPtr = &(nuonEnv->mainBusDRAM[linkaddr & MAIN_BUS_VALID_MEMORY_MASK]);

	mov	edx, DWORD PTR _linkaddr$[ebp]
	and	edx, 8388607				; 007fffffH
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	add	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _systemMemPtr$[ebp], edx

; 283  :       }
; 284  :       else

	jmp	SHORT $LN4@MPELoad
$LN5@MPELoad:

; 285  :       {
; 286  :         systemMemPtr = &(nuonEnv->systemBusDRAM[linkaddr & SYSTEM_BUS_VALID_MEMORY_MASK]);

	mov	ecx, DWORD PTR _linkaddr$[ebp]
	and	ecx, 8388607				; 007fffffH
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _systemMemPtr$[ebp], ecx
$LN4@MPELoad:

; 287  :       }
; 288  : 
; 289  :       mpeMemPtr = &(((uint8 *)(nuonEnv->mpe[which]->GetPointerToMemory()))[mpeaddr & MPE_VALID_MEMORY_MASK]);

	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?GetPointerToMemory@MPE@@QAEPAXXZ	; MPE::GetPointerToMemory
	mov	edx, DWORD PTR _mpeaddr$[ebp]
	and	edx, 8388607				; 007fffffH
	add	eax, edx
	mov	DWORD PTR _mpeMemPtr$[ebp], eax

; 290  : 
; 291  :       for(uint32 count = 0; count < size; count++)

	mov	DWORD PTR _count$41401[ebp], 0
	jmp	SHORT $LN3@MPELoad
$LN2@MPELoad:
	mov	eax, DWORD PTR _count$41401[ebp]
	add	eax, 1
	mov	DWORD PTR _count$41401[ebp], eax
$LN3@MPELoad:
	mov	ecx, DWORD PTR _count$41401[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@MPELoad

; 292  :       {
; 293  :         *mpeMemPtr = *systemMemPtr;

	mov	edx, DWORD PTR _mpeMemPtr$[ebp]
	mov	eax, DWORD PTR _systemMemPtr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 294  : 
; 295  :         mpeMemPtr++;

	mov	edx, DWORD PTR _mpeMemPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _mpeMemPtr$[ebp], edx

; 296  :         systemMemPtr++;

	mov	eax, DWORD PTR _systemMemPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _systemMemPtr$[ebp], eax

; 297  :       }

	jmp	SHORT $LN2@MPELoad
$LN1@MPELoad:

; 298  : 
; 299  :       //nuonEnv->mpe[which]->InvalidateICacheRegion(mpeaddr, mpeaddr + size - 1);
; 300  :       //nuonEnv->mpe[which]->InvalidateICache();
; 301  :       //nuonEnv->mpe[which]->nativeCodeCache->FlushRegion(mpeaddr, mpeaddr + size - 1);
; 302  :       nuonEnv->mpe[which]->UpdateInvalidateRegion(mpeaddr, size - 1);

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _mpeaddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?UpdateInvalidateRegion@MPE@@QAEXII@Z	; MPE::UpdateInvalidateRegion
$LN8@MPELoad:

; 303  :       //nuonEnv->mpe[which]->nativeCodeCache->FlushRegion(0x20300000, mpeaddr + size - 1);
; 304  :     }
; 305  :   }
; 306  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MPELoad@@YAXPAVMPE@@@Z ENDP				; MPELoad
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe.h
_TEXT	ENDS
;	COMDAT ?GetPointerToMemory@MPE@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPointerToMemory@MPE@@QAEPAXXZ PROC			; MPE::GetPointerToMemory, COMDAT
; _this$ = ecx

; 487  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 488  :     return dtrom;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+560]

; 489  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPointerToMemory@MPE@@QAEPAXXZ ENDP			; MPE::GetPointerToMemory
_TEXT	ENDS
PUBLIC	?MPEReadRegister@@YAXPAVMPE@@@Z			; MPEReadRegister
EXTRN	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z:PROC ; MPE::ReadControlRegister
EXTRN	?SaveRegisters@MPE@@QAEXXZ:PROC			; MPE::SaveRegisters
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\mpe_alloc.cpp
_TEXT	SEGMENT
_mpeaddr$ = -284					; size = 4
_which$ = -280						; size = 4
_entry$ = -272						; size = 268
_the_mpe$ = 8						; size = 4
?MPEReadRegister@@YAXPAVMPE@@@Z PROC			; MPEReadRegister

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 310  :   InstructionCacheEntry entry;
; 311  :   uint32 which = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 312  :   uint32 mpeaddr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mpeaddr$[ebp], eax

; 313  : 
; 314  :   entry.pScalarRegs = the_mpe->regs;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR _entry$[ebp+36], ecx

; 315  :   entry.pIndexRegs = &the_mpe->rx;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	add	edx, 140				; 0000008cH
	mov	DWORD PTR _entry$[ebp+40], edx

; 316  :   entry.pCounterRegs = &the_mpe->rc0;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	add	eax, 132				; 00000084H
	mov	DWORD PTR _entry$[ebp+44], eax

; 317  :   entry.pRzRegs = &the_mpe->rz;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	add	ecx, 156				; 0000009cH
	mov	DWORD PTR _entry$[ebp+48], ecx

; 318  :   entry.pXyctl = &the_mpe->xyctl;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	add	edx, 168				; 000000a8H
	mov	DWORD PTR _entry$[ebp+60], edx

; 319  :   entry.pUvctl = &the_mpe->uvctl;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	add	eax, 172				; 000000acH
	mov	DWORD PTR _entry$[ebp+64], eax

; 320  :   entry.pXyrange = &the_mpe->xyrange;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR _entry$[ebp+68], ecx

; 321  :   entry.pUvrange = &the_mpe->uvrange;

	mov	edx, DWORD PTR _the_mpe$[ebp]
	add	edx, 180				; 000000b4H
	mov	DWORD PTR _entry$[ebp+72], edx

; 322  :   entry.pAcshift = &the_mpe->acshift;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	add	eax, 184				; 000000b8H
	mov	DWORD PTR _entry$[ebp+52], eax

; 323  :   entry.pSvshift = &the_mpe->svshift;

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _entry$[ebp+56], ecx

; 324  : 
; 325  :   if((which < 4) && (mpeaddr >= MPE_CTRL_BASE) && (mpeaddr < MPE1_ADDR_BASE))

	cmp	DWORD PTR _which$[ebp], 4
	jae	SHORT $LN2@MPEReadReg
	cmp	DWORD PTR _mpeaddr$[ebp], 542113792	; 20500000H
	jb	SHORT $LN2@MPEReadReg
	cmp	DWORD PTR _mpeaddr$[ebp], 545259520	; 20800000H
	jae	SHORT $LN2@MPEReadReg

; 326  :   {
; 327  :     //Make sure that the temporary scalar and index registers are in sync
; 328  :     //with the standard registers so that r0-r31, rx, ry, ru, rv and cc will
; 329  :     //be read correctly.  Doing this means that MPEReadRegister is no longer
; 330  :     //safe to use on a running MPE unless done so in between cycle emulation
; 331  :     //on the target processor (this will always be the case when a single
; 332  :     //thread handles emulation of all four processors)
; 333  : 
; 334  :     nuonEnv->mpe[which]->SaveRegisters();

	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?SaveRegisters@MPE@@QAEXXZ		; MPE::SaveRegisters

; 335  : 
; 336  :     the_mpe->regs[0] =
; 337  :       nuonEnv->mpe[which]->ReadControlRegister(mpeaddr - MPE_CTRL_BASE, &entry);

	lea	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpeaddr$[ebp]
	sub	edx, 542113792				; 20500000H
	push	edx
	mov	eax, DWORD PTR _which$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?ReadControlRegister@MPE@@QAEIIPAVInstructionCacheEntry@@@Z ; MPE::ReadControlRegister
	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@MPEReadReg:

; 338  :   }
; 339  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@MPEReadReg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@MPEReadReg:
	DD	1
	DD	$LN5@MPEReadReg
$LN5@MPEReadReg:
	DD	-272					; fffffef0H
	DD	268					; 0000010cH
	DD	$LN4@MPEReadReg
$LN4@MPEReadReg:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
?MPEReadRegister@@YAXPAVMPE@@@Z ENDP			; MPEReadRegister
_TEXT	ENDS
PUBLIC	?MPEWriteRegister@@YAXPAVMPE@@@Z		; MPEWriteRegister
EXTRN	?WriteControlRegister@MPE@@QAEXII@Z:PROC	; MPE::WriteControlRegister
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_value$ = -12						; size = 4
_mpeaddr$ = -8						; size = 4
_which$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
?MPEWriteRegister@@YAXPAVMPE@@@Z PROC			; MPEWriteRegister

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 343  :   uint32 which = the_mpe->regs[0];

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _which$[ebp], ecx

; 344  :   uint32 mpeaddr = the_mpe->regs[1];

	mov	edx, DWORD PTR _the_mpe$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mpeaddr$[ebp], eax

; 345  :   uint32 value = the_mpe->regs[2];

	mov	ecx, DWORD PTR _the_mpe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _value$[ebp], edx

; 346  : 
; 347  :   if((which < 4) && (mpeaddr >= MPE_CTRL_BASE) && (mpeaddr < MPE1_ADDR_BASE))

	cmp	DWORD PTR _which$[ebp], 4
	jae	SHORT $LN2@MPEWriteRe
	cmp	DWORD PTR _mpeaddr$[ebp], 542113792	; 20500000H
	jb	SHORT $LN2@MPEWriteRe
	cmp	DWORD PTR _mpeaddr$[ebp], 545259520	; 20800000H
	jae	SHORT $LN2@MPEWriteRe

; 348  :   {
; 349  :     nuonEnv->mpe[which]->WriteControlRegister(mpeaddr - MPE_CTRL_BASE,value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpeaddr$[ebp]
	sub	ecx, 542113792				; 20500000H
	push	ecx
	mov	edx, DWORD PTR _which$[ebp]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?WriteControlRegister@MPE@@QAEXII@Z	; MPE::WriteControlRegister
$LN2@MPEWriteRe:

; 350  :   }
; 351  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MPEWriteRegister@@YAXPAVMPE@@@Z ENDP			; MPEWriteRegister
_TEXT	ENDS
END
