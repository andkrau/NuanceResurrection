; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\PageMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0PageMap@@QAE@XZ				; PageMap::PageMap
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\pagemap.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_i$4123 = -8						; size = 4
_this$ = -4						; size = 4
??0PageMap@@QAE@XZ PROC					; PageMap::PageMap
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 7    :   for(uint32 i = 0; i < NUM_ROOT_PAGENODE_ENTRIES; i++)

	mov	DWORD PTR _i$4123[ebp], 0
	jmp	SHORT $LN3@PageMap
$LN2@PageMap:
	mov	eax, DWORD PTR _i$4123[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4123[ebp], eax
$LN3@PageMap:
	cmp	DWORD PTR _i$4123[ebp], 512		; 00000200H
	jae	SHORT $LN4@PageMap

; 8    :   {
; 9    :     root.entries[i] = 0;

	mov	ecx, DWORD PTR _i$4123[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0
	jmp	SHORT $LN2@PageMap
$LN4@PageMap:

; 10   :   }
; 11   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PageMap@@QAE@XZ ENDP					; PageMap::PageMap
_TEXT	ENDS
PUBLIC	??1PageMap@@QAE@XZ				; PageMap::~PageMap
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T4247 = -28						; size = 4
$T4246 = -24						; size = 4
_pL2$ = -20						; size = 4
_pL1$ = -16						; size = 4
_nL1$ = -12						; size = 4
_nRoot$ = -8						; size = 4
_this$ = -4						; size = 4
??1PageMap@@QAE@XZ PROC					; PageMap::~PageMap
; _this$ = ecx

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 15   :   uint32 nRoot, nL1;
; 16   :   Level1PageNode *pL1;
; 17   :   NativeCodeCacheEntry *pL2;
; 18   : 
; 19   :   for(nRoot = 0; nRoot < NUM_ROOT_PAGENODE_ENTRIES; nRoot++)

	mov	DWORD PTR _nRoot$[ebp], 0
	jmp	SHORT $LN8@PageMap@2
$LN7@PageMap@2:
	mov	eax, DWORD PTR _nRoot$[ebp]
	add	eax, 1
	mov	DWORD PTR _nRoot$[ebp], eax
$LN8@PageMap@2:
	cmp	DWORD PTR _nRoot$[ebp], 512		; 00000200H
	jae	SHORT $LN9@PageMap@2

; 20   :   {
; 21   :     pL1 = root.entries[nRoot];

	mov	ecx, DWORD PTR _nRoot$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pL1$[ebp], eax

; 22   :     if(pL1)

	cmp	DWORD PTR _pL1$[ebp], 0
	je	SHORT $LN5@PageMap@2

; 23   :     {
; 24   :       for(nL1 = 0; nL1 < NUM_LEVEL1_PAGENODE_ENTRIES; nL1++)

	mov	DWORD PTR _nL1$[ebp], 0
	jmp	SHORT $LN4@PageMap@2
$LN3@PageMap@2:
	mov	ecx, DWORD PTR _nL1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nL1$[ebp], ecx
$LN4@PageMap@2:
	cmp	DWORD PTR _nL1$[ebp], 8192		; 00002000H
	jae	SHORT $LN2@PageMap@2

; 25   :       {
; 26   :         pL2 = pL1->entries[nL1];

	mov	edx, DWORD PTR _nL1$[ebp]
	mov	eax, DWORD PTR _pL1$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pL2$[ebp], ecx

; 27   : 
; 28   :         if(pL2)

	cmp	DWORD PTR _pL2$[ebp], 0
	je	SHORT $LN1@PageMap@2

; 29   :         {
; 30   :           delete [] pL2;

	mov	edx, DWORD PTR _pL2$[ebp]
	mov	DWORD PTR $T4246[ebp], edx
	mov	eax, DWORD PTR $T4246[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@PageMap@2:

; 31   :         }
; 32   :       }

	jmp	SHORT $LN3@PageMap@2
$LN2@PageMap@2:

; 33   :       delete pL1;

	mov	ecx, DWORD PTR _pL1$[ebp]
	mov	DWORD PTR $T4247[ebp], ecx
	mov	edx, DWORD PTR $T4247[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@PageMap@2:
	jmp	SHORT $LN7@PageMap@2
$LN9@PageMap@2:

; 34   :     }
; 35   :   }
; 36   : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1PageMap@@QAE@XZ ENDP					; PageMap::~PageMap
_TEXT	ENDS
PUBLIC	?AllocatePage@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ; PageMap::AllocatePage
PUBLIC	?AllocateEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ; PageMap::AllocateEntry
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 4
?AllocateEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z PROC ; PageMap::AllocateEntry
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 40   :   return &((AllocatePage(address))[address & 0x3FFUL]);

	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocatePage@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ; PageMap::AllocatePage
	mov	ecx, DWORD PTR _address$[ebp]
	and	ecx, 1023				; 000003ffH
	imul	ecx, 36					; 00000024H
	add	eax, ecx

; 41   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ENDP ; PageMap::AllocateEntry
_TEXT	ENDS
PUBLIC	?UpdateEntry@PageMap@@QAEXIAAVNativeCodeCacheEntry@@@Z ; PageMap::UpdateEntry
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 4
_entry$ = 12						; size = 4
?UpdateEntry@PageMap@@QAEXIAAVNativeCodeCacheEntry@@@Z PROC ; PageMap::UpdateEntry
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 45   :   *(AllocateEntry(address)) = entry;

	mov	esi, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ; PageMap::AllocateEntry
	mov	ecx, 9
	mov	edi, eax
	rep movsd

; 46   : }

	pop	edi
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateEntry@PageMap@@QAEXIAAVNativeCodeCacheEntry@@@Z ENDP ; PageMap::UpdateEntry
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:PROC				; operator new
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T4253 = -36						; size = 4
$T4252 = -32						; size = 4
_i$4171 = -28						; size = 4
_i$4164 = -24						; size = 4
_pL2Node$ = -20						; size = 4
_pL1Node$ = -16						; size = 4
_l1Index$ = -12						; size = 4
_rootIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
?AllocatePage@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z PROC ; PageMap::AllocatePage
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 50   :   uint32 rootIndex = address >> 23;

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 23					; 00000017H
	mov	DWORD PTR _rootIndex$[ebp], eax

; 51   :   uint32 l1Index = (address >> 10) & 0x1FFFUL;

	mov	ecx, DWORD PTR _address$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _l1Index$[ebp], ecx

; 52   : 
; 53   :   Level1PageNode *pL1Node;
; 54   :   NativeCodeCacheEntry *pL2Node;
; 55   : 
; 56   :   pL1Node = root.entries[rootIndex];

	mov	edx, DWORD PTR _rootIndex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pL1Node$[ebp], ecx

; 57   : 
; 58   :   if(!pL1Node)

	cmp	DWORD PTR _pL1Node$[ebp], 0
	jne	SHORT $LN8@AllocatePa

; 59   :   {
; 60   :     pL1Node = new Level1PageNode;

	push	32768					; 00008000H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4252[ebp], eax
	mov	edx, DWORD PTR $T4252[ebp]
	mov	DWORD PTR _pL1Node$[ebp], edx

; 61   :     for(uint32 i = 0; i < NUM_LEVEL1_PAGENODE_ENTRIES; i++)

	mov	DWORD PTR _i$4164[ebp], 0
	jmp	SHORT $LN7@AllocatePa
$LN6@AllocatePa:
	mov	eax, DWORD PTR _i$4164[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4164[ebp], eax
$LN7@AllocatePa:
	cmp	DWORD PTR _i$4164[ebp], 8192		; 00002000H
	jae	SHORT $LN5@AllocatePa

; 62   :     {
; 63   :       pL1Node->entries[i] = 0;  

	mov	ecx, DWORD PTR _i$4164[ebp]
	mov	edx, DWORD PTR _pL1Node$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 64   :     }

	jmp	SHORT $LN6@AllocatePa
$LN5@AllocatePa:

; 65   :     root.entries[rootIndex] = pL1Node;

	mov	eax, DWORD PTR _rootIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pL1Node$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN8@AllocatePa:

; 66   :   }
; 67   : 
; 68   :   pL2Node = pL1Node->entries[l1Index];

	mov	eax, DWORD PTR _l1Index$[ebp]
	mov	ecx, DWORD PTR _pL1Node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pL2Node$[ebp], edx

; 69   :   if(!pL2Node)

	cmp	DWORD PTR _pL2Node$[ebp], 0
	jne	SHORT $LN4@AllocatePa

; 70   :   {
; 71   :     pL2Node = new NativeCodeCacheEntry[NUM_LEVEL2_PAGENODE_ENTRIES];

	push	36864					; 00009000H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4253[ebp], eax
	mov	eax, DWORD PTR $T4253[ebp]
	mov	DWORD PTR _pL2Node$[ebp], eax

; 72   :     for(uint32 i = 0; i < NUM_LEVEL2_PAGENODE_ENTRIES; i++)

	mov	DWORD PTR _i$4171[ebp], 0
	jmp	SHORT $LN3@AllocatePa
$LN2@AllocatePa:
	mov	ecx, DWORD PTR _i$4171[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$4171[ebp], ecx
$LN3@AllocatePa:
	cmp	DWORD PTR _i$4171[ebp], 1024		; 00000400H
	jae	SHORT $LN1@AllocatePa

; 73   :     {
; 74   :       pL2Node[i].virtualAddress = 1;  

	mov	edx, DWORD PTR _i$4171[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _pL2Node$[ebp]
	mov	DWORD PTR [eax+edx+4], 1

; 75   :     }

	jmp	SHORT $LN2@AllocatePa
$LN1@AllocatePa:

; 76   :     pL1Node->entries[l1Index] = pL2Node;

	mov	ecx, DWORD PTR _l1Index$[ebp]
	mov	edx, DWORD PTR _pL1Node$[ebp]
	mov	eax, DWORD PTR _pL2Node$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN4@AllocatePa:

; 77   :   }
; 78   : 
; 79   :   return pL2Node;

	mov	eax, DWORD PTR _pL2Node$[ebp]

; 80   : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocatePage@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ENDP ; PageMap::AllocatePage
_TEXT	ENDS
PUBLIC	?FindEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ; PageMap::FindEntry
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pL2Node$ = -24						; size = 4
_pL1Node$ = -20						; size = 4
_l2Index$ = -16						; size = 4
_l1Index$ = -12						; size = 4
_rootIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
?FindEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z PROC ; PageMap::FindEntry
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 84   :   uint32 rootIndex = address >> 23;

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 23					; 00000017H
	mov	DWORD PTR _rootIndex$[ebp], eax

; 85   :   uint32 l1Index;
; 86   :   uint32 l2Index;
; 87   : 
; 88   :   Level1PageNode *pL1Node;
; 89   :   NativeCodeCacheEntry *pL2Node;
; 90   : 
; 91   :   pL1Node = root.entries[rootIndex];

	mov	ecx, DWORD PTR _rootIndex$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pL1Node$[ebp], eax

; 92   : 
; 93   :   if(!pL1Node)

	cmp	DWORD PTR _pL1Node$[ebp], 0
	jne	SHORT $LN2@FindEntry

; 94   :   {
; 95   :     return 0;

	xor	eax, eax
	jmp	SHORT $LN3@FindEntry
$LN2@FindEntry:

; 96   :   }
; 97   :   
; 98   :   l1Index = (address >> 10) & 0x1FFFUL;

	mov	ecx, DWORD PTR _address$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _l1Index$[ebp], ecx

; 99   :   pL2Node = pL1Node->entries[l1Index];

	mov	edx, DWORD PTR _l1Index$[ebp]
	mov	eax, DWORD PTR _pL1Node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pL2Node$[ebp], ecx

; 100  :   
; 101  :   if(!pL2Node)

	cmp	DWORD PTR _pL2Node$[ebp], 0
	jne	SHORT $LN1@FindEntry

; 102  :   {
; 103  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN3@FindEntry
$LN1@FindEntry:

; 104  :   }
; 105  : 
; 106  :   l2Index = address & 0x3FFUL;

	mov	edx, DWORD PTR _address$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _l2Index$[ebp], edx

; 107  :   return &(pL2Node[l2Index]);

	mov	eax, DWORD PTR _l2Index$[ebp]
	imul	eax, 36					; 00000024H
	add	eax, DWORD PTR _pL2Node$[ebp]
$LN3@FindEntry:

; 108  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindEntry@PageMap@@QAEPAVNativeCodeCacheEntry@@I@Z ENDP ; PageMap::FindEntry
_TEXT	ENDS
PUBLIC	?InvalidateEntry@PageMap@@QAEXI@Z		; PageMap::InvalidateEntry
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_pL2Node$ = -24						; size = 4
_pL1Node$ = -20						; size = 4
_l2Index$ = -16						; size = 4
_l1Index$ = -12						; size = 4
_rootIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 4
?InvalidateEntry@PageMap@@QAEXI@Z PROC			; PageMap::InvalidateEntry
; _this$ = ecx

; 111  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 112  :   uint32 rootIndex = (address >> 23);

	mov	eax, DWORD PTR _address$[ebp]
	shr	eax, 23					; 00000017H
	mov	DWORD PTR _rootIndex$[ebp], eax

; 113  :   uint32 l1Index;
; 114  :   uint32 l2Index;
; 115  : 
; 116  :   Level1PageNode *pL1Node;
; 117  :   NativeCodeCacheEntry *pL2Node;
; 118  : 
; 119  :   pL1Node = root.entries[rootIndex];

	mov	ecx, DWORD PTR _rootIndex$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pL1Node$[ebp], eax

; 120  : 
; 121  :   if(pL1Node)

	cmp	DWORD PTR _pL1Node$[ebp], 0
	je	SHORT $LN3@Invalidate

; 122  :   {
; 123  :     l1Index = (address >> 10) & 0x1FFFUL;

	mov	ecx, DWORD PTR _address$[ebp]
	shr	ecx, 10					; 0000000aH
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _l1Index$[ebp], ecx

; 124  :     pL2Node = pL1Node->entries[l1Index];

	mov	edx, DWORD PTR _l1Index$[ebp]
	mov	eax, DWORD PTR _pL1Node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pL2Node$[ebp], ecx

; 125  :     {
; 126  :       if(pL2Node)

	cmp	DWORD PTR _pL2Node$[ebp], 0
	je	SHORT $LN3@Invalidate

; 127  :       {
; 128  :         l2Index = address & 0x3FFUL;

	mov	edx, DWORD PTR _address$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _l2Index$[ebp], edx

; 129  :         pL2Node[l2Index].virtualAddress = 1;

	mov	eax, DWORD PTR _l2Index$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _pL2Node$[ebp]
	mov	DWORD PTR [ecx+eax+4], 1
$LN3@Invalidate:

; 130  :       }
; 131  :     }
; 132  :   }
; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InvalidateEntry@PageMap@@QAEXI@Z ENDP			; PageMap::InvalidateEntry
_TEXT	ENDS
PUBLIC	?Invalidate@PageMap@@QAEIXZ			; PageMap::Invalidate
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_l2Index$ = -28						; size = 4
_l1Index$ = -24						; size = 4
_rootIndex$ = -20					; size = 4
_numInvalidations$ = -16				; size = 4
_pL2Node$ = -12						; size = 4
_pL1Node$ = -8						; size = 4
_this$ = -4						; size = 4
?Invalidate@PageMap@@QAEIXZ PROC			; PageMap::Invalidate
; _this$ = ecx

; 136  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  :   Level1PageNode *pL1Node;
; 138  :   NativeCodeCacheEntry *pL2Node;
; 139  :   uint32 numInvalidations = 0;

	mov	DWORD PTR _numInvalidations$[ebp], 0

; 140  :   uint32 rootIndex, l1Index, l2Index;
; 141  :   uint32 lastRootIndex, lastL1Index, lastL2Index;
; 142  : 
; 143  :   for(rootIndex = 0; rootIndex < NUM_ROOT_PAGENODE_ENTRIES; rootIndex++)

	mov	DWORD PTR _rootIndex$[ebp], 0
	jmp	SHORT $LN11@Invalidate@2
$LN10@Invalidate@2:
	mov	eax, DWORD PTR _rootIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rootIndex$[ebp], eax
$LN11@Invalidate@2:
	cmp	DWORD PTR _rootIndex$[ebp], 512		; 00000200H
	jae	$LN9@Invalidate@2

; 144  :   {
; 145  :     if(root.entries[rootIndex])

	mov	ecx, DWORD PTR _rootIndex$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN8@Invalidate@2

; 146  :     {
; 147  :       pL1Node = root.entries[rootIndex];

	mov	eax, DWORD PTR _rootIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pL1Node$[ebp], edx

; 148  :       for(l1Index = 0; l1Index < NUM_LEVEL1_PAGENODE_ENTRIES; l1Index++)

	mov	DWORD PTR _l1Index$[ebp], 0
	jmp	SHORT $LN7@Invalidate@2
$LN6@Invalidate@2:
	mov	eax, DWORD PTR _l1Index$[ebp]
	add	eax, 1
	mov	DWORD PTR _l1Index$[ebp], eax
$LN7@Invalidate@2:
	cmp	DWORD PTR _l1Index$[ebp], 8192		; 00002000H
	jae	SHORT $LN8@Invalidate@2

; 149  :       {
; 150  :         if(pL1Node->entries[l1Index])

	mov	ecx, DWORD PTR _l1Index$[ebp]
	mov	edx, DWORD PTR _pL1Node$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN4@Invalidate@2

; 151  :         {
; 152  :           pL2Node = pL1Node->entries[l1Index];

	mov	eax, DWORD PTR _l1Index$[ebp]
	mov	ecx, DWORD PTR _pL1Node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pL2Node$[ebp], edx

; 153  :           for(l2Index = 0; l2Index < NUM_LEVEL2_PAGENODE_ENTRIES; l2Index++)

	mov	DWORD PTR _l2Index$[ebp], 0
	jmp	SHORT $LN3@Invalidate@2
$LN2@Invalidate@2:
	mov	eax, DWORD PTR _l2Index$[ebp]
	add	eax, 1
	mov	DWORD PTR _l2Index$[ebp], eax
$LN3@Invalidate@2:
	cmp	DWORD PTR _l2Index$[ebp], 1024		; 00000400H
	jae	SHORT $LN4@Invalidate@2

; 154  :           {
; 155  :             pL2Node[l2Index].virtualAddress = 1;

	mov	ecx, DWORD PTR _l2Index$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _pL2Node$[ebp]
	mov	DWORD PTR [edx+ecx+4], 1

; 156  :           }

	jmp	SHORT $LN2@Invalidate@2
$LN4@Invalidate@2:

; 157  :         }
; 158  :       }

	jmp	SHORT $LN6@Invalidate@2
$LN8@Invalidate@2:

; 159  :     }
; 160  :   }

	jmp	$LN10@Invalidate@2
$LN9@Invalidate@2:

; 161  : 
; 162  :    return numInvalidations;

	mov	eax, DWORD PTR _numInvalidations$[ebp]

; 163  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Invalidate@PageMap@@QAEIXZ ENDP			; PageMap::Invalidate
_TEXT	ENDS
PUBLIC	?InvalidateRegion@PageMap@@QAEXII@Z		; PageMap::InvalidateRegion
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_address$ = -8						; size = 4
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
?InvalidateRegion@PageMap@@QAEXII@Z PROC		; PageMap::InvalidateRegion
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 167  :   uint32 address = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _address$[ebp], eax
$LN2@Invalidate@3:

; 168  :   NativeCodeCacheEntry *entry;
; 169  : 
; 170  :   while(address <= end)

	mov	ecx, DWORD PTR _address$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	ja	SHORT $LN3@Invalidate@3

; 171  :   {
; 172  :     InvalidateEntry(address);

	mov	edx, DWORD PTR _address$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidateEntry@PageMap@@QAEXI@Z	; PageMap::InvalidateEntry

; 173  :     address++;

	mov	eax, DWORD PTR _address$[ebp]
	add	eax, 1
	mov	DWORD PTR _address$[ebp], eax

; 174  :   }

	jmp	SHORT $LN2@Invalidate@3
$LN3@Invalidate@3:

; 175  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?InvalidateRegion@PageMap@@QAEXII@Z ENDP		; PageMap::InvalidateRegion
_TEXT	ENDS
END
