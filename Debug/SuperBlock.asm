; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\SuperBlock.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?tempStr@@3PADA					; tempStr
PUBLIC	?dummyVar@@3IC					; dummyVar
PUBLIC	?blockFile@@3PAU_iobuf@@A			; blockFile
_BSS	SEGMENT
?tempStr@@3PADA DB 0800H DUP (?)			; tempStr
?dummyVar@@3IC DD 01H DUP (?)				; dummyVar
?blockFile@@3PAU_iobuf@@A DD 01H DUP (?)		; blockFile
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12404
_DATA	ENDS
CONST	SEGMENT
$SG12404 DB	'bad allocation', 00H
$SG41784 DB	00H
$SG41729 DB	'SuperBlocks%li.txt', 00H
$SG41786 DB	00H
$SG41730 DB	'w', 00H
$SG41788 DB	00H
$SG41790 DB	00H
$SG41749 DB	'SUPERBLOCKINFO_PACKETSTART', 0aH, 00H
$SG41751 DB	'SUPERBLOCKINFO_PACKETEND', 0aH, 00H
$SG41792 DB	00H
$SG41794 DB	00H
$SG41753 DB	'SUPERBLOCKINFO_LOCKED', 0aH, 00H
$SG41796 DB	00H
$SG41755 DB	'SUPERBLOCKINFO_NONATIVECOMPILE', 0aH, 00H
$SG41757 DB	'SUPERBLOCKINFO_DEAD', 0aH, 00H
$SG41798 DB	00H
$SG41800 DB	00H
$SG41802 DB	00H
$SG41759 DB	'SUPERBLOCKINFO_SYNC', 0aH, 00H
$SG41804 DB	00H
	ORG $+2
$SG41761 DB	'SUPERBLOCKINFO_INHIBIT_ECU', 0aH, 00H
$SG41763 DB	'SUPERBLOCKINFO_CHECK_ECU_INHIBIT', 0aH, 00H
	ORG $+2
$SG41765 DB	'SUPERBLOCKINFO_CHECK_ECU_SKIPCOUNTER', 0aH, 00H
	ORG $+2
$SG41767 DB	'NONE', 0aH, 00H
	ORG $+2
$SG41783 DB	'CF1 ', 00H
	ORG $+3
$SG41785 DB	'CF0 ', 00H
	ORG $+3
$SG41787 DB	'MODMI ', 00H
	ORG $+1
$SG41789 DB	'MODGE ', 00H
	ORG $+1
$SG41791 DB	'C1Z ', 00H
	ORG $+3
$SG41793 DB	'C0Z ', 00H
	ORG $+3
$SG41795 DB	'MV ', 00H
$SG41797 DB	'C ', 00H
	ORG $+1
$SG41799 DB	'Z ', 00H
	ORG $+1
$SG41801 DB	'V ', 00H
	ORG $+1
$SG41803 DB	'N ', 00H
	ORG $+1
$SG41805 DB	'[%s%s%s%s%s%s%s%s%s%s%s]', 00H
	ORG $+3
$SG41910 DB	'****************************************', 0aH, 00H
	ORG $+2
$SG41911 DB	'Virtual Address: $%8lx', 0aH, 00H
$SG41913 DB	'Constants Propagated: TRUE', 0aH, 00H
$SG41915 DB	'Constants Propagated: FALSE', 0aH, 00H
	ORG $+3
$SG41916 DB	'Instruction Count: %li', 0aH, 00H
$SG41917 DB	'Packet Count: %li', 0aH, 00H
	ORG $+1
$SG41918 DB	'Code Size: %lu bytes', 0aH, 00H
	ORG $+2
$SG41919 DB	'Code Cache Usage: %lu bytes', 0aH, 00H
	ORG $+3
$SG41921 DB	'Compile Type: IL single', 0aH, 0aH, 00H
	ORG $+2
$SG41924 DB	'Compile Type: IL block', 0aH, 0aH, 00H
	ORG $+3
$SG41927 DB	'Compile Type: Native block', 0aH, 0aH, 00H
	ORG $+3
$SG41929 DB	'Compile Type: Unknown', 0aH, 0aH, 00H
$SG41937 DB	'*DEAD*: ', 00H
	ORG $+3
$SG41938 DB	'%s ', 00H
$SG41942 DB	'FlagsOutDep: %s)', 0aH, 00H
	ORG $+2
$SG41940 DB	'(ScalarInDep: $%8.8LX, MiscInDep: $%8.8LX, ScalarOutDep:'
	DB	' $%8.8LX, MiscOutDep: $%8.8LX, ', 00H
$SG41941 DB	'FlagsInDep: %s ', 00H
$SG41946 DB	'(IL) ', 00H
	ORG $+2
$SG41948 DB	'(NATIVE) ', 00H
	ORG $+2
$SG41950 DB	'(DEPENDENCY_PRESENT)', 00H
	ORG $+3
$SG41951 DB	0aH, 00H
	ORG $+2
$SG41953 DB	0aH, 00H
	ORG $+2
$SG41954 DB	0aH, 00H
	ORG $+2
$SG41956 DB	'EMPTY BLOCK', 0aH, 0aH, 00H
	ORG $+2
$SG41957 DB	'Next Virtual Address: $%8lx', 0aH, 00H
	ORG $+3
$SG41958 DB	'Next Delay Counter: $%lx', 0aH, 00H
	ORG $+2
$SG41959 DB	'****************************************', 0aH, 0aH, 00H
CONST	ENDS
PUBLIC	?IsBranchConditionCompilable@@YA_NIII@Z		; IsBranchConditionCompilable
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\superblock.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv64 = -4						; size = 4
_startAddress$ = 8					; size = 4
_mpeIndex$ = 12						; size = 4
_condition$ = 16					; size = 4
?IsBranchConditionCompilable@@YA_NIII@Z PROC		; IsBranchConditionCompilable

; 21   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 22   : 
; 23   :   switch(condition)

	mov	eax, DWORD PTR _condition$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 31			; 0000001fH
	ja	$LN1@IsBranchCo
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN38@IsBranchCo[ecx*4]
$LN33@IsBranchCo:

; 24   :   {
; 25   :     case 0:
; 26   :       //ne
; 27   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN32@IsBranchCo:

; 28   :     case 1:
; 29   :       //c0z
; 30   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN31@IsBranchCo:

; 31   :     case 2:
; 32   :       //c1z
; 33   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN30@IsBranchCo:

; 34   :     case 3:
; 35   :       //cc
; 36   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN29@IsBranchCo:

; 37   :     case 4:
; 38   :       //eq
; 39   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN28@IsBranchCo:

; 40   :     case 5:
; 41   :       //cs
; 42   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN27@IsBranchCo:

; 43   :     case 6:
; 44   :       //vc
; 45   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN26@IsBranchCo:

; 46   :     case 7:
; 47   :       //vs
; 48   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN25@IsBranchCo:

; 49   :     case 8:
; 50   :       //lt
; 51   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN24@IsBranchCo:

; 52   :     case 9:
; 53   :       //mvc
; 54   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN23@IsBranchCo:

; 55   :     case 10:
; 56   :       //mvs
; 57   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN22@IsBranchCo:

; 58   :     case 11:
; 59   :       //hi
; 60   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN21@IsBranchCo:

; 61   :     case 12:
; 62   :       //le
; 63   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN20@IsBranchCo:

; 64   :     case 13:
; 65   :       //ls
; 66   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN19@IsBranchCo:

; 67   :     case 14:
; 68   :       //pl
; 69   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN18@IsBranchCo:

; 70   :     case 15:
; 71   :       //mi
; 72   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN17@IsBranchCo:

; 73   :     case 16:
; 74   :       //gt
; 75   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN16@IsBranchCo:

; 76   :     case 17:
; 77   :       //always
; 78   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN15@IsBranchCo:

; 79   :     case 18:
; 80   :       //modmi
; 81   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN14@IsBranchCo:

; 82   :     case 19:
; 83   :       //modpl
; 84   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN13@IsBranchCo:

; 85   :     case 20:
; 86   :       //ge
; 87   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN12@IsBranchCo:

; 88   :     case 21:
; 89   :       //modge
; 90   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN11@IsBranchCo:

; 91   :     case 22:
; 92   :       //modlt
; 93   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN10@IsBranchCo:

; 94   :     case 23:
; 95   :       //never
; 96   :       return false;

	xor	al, al
	jmp	SHORT $LN36@IsBranchCo
$LN9@IsBranchCo:

; 97   :     case 24:
; 98   :       //c0ne
; 99   :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN8@IsBranchCo:

; 100  :     case 25:
; 101  :       //never
; 102  :       return false;

	xor	al, al
	jmp	SHORT $LN36@IsBranchCo
$LN7@IsBranchCo:

; 103  :     case 26:
; 104  :       //never
; 105  :       return false;

	xor	al, al
	jmp	SHORT $LN36@IsBranchCo
$LN6@IsBranchCo:

; 106  :     case 27:
; 107  :       //cf0lo
; 108  :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN5@IsBranchCo:

; 109  :     case 28:
; 110  :       //c1ne
; 111  :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN4@IsBranchCo:

; 112  :     case 29:
; 113  :       //cf0hi
; 114  :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN3@IsBranchCo:

; 115  :     case 30:
; 116  :       //cf1lo
; 117  :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN2@IsBranchCo:

; 118  :     case 31:
; 119  :       //cf1hi
; 120  :       return true;

	mov	al, 1
	jmp	SHORT $LN36@IsBranchCo
$LN1@IsBranchCo:

; 121  :      default:
; 122  :       return false;

	xor	al, al
$LN36@IsBranchCo:

; 123  :   }
; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN38@IsBranchCo:
	DD	$LN33@IsBranchCo
	DD	$LN32@IsBranchCo
	DD	$LN31@IsBranchCo
	DD	$LN30@IsBranchCo
	DD	$LN29@IsBranchCo
	DD	$LN28@IsBranchCo
	DD	$LN27@IsBranchCo
	DD	$LN26@IsBranchCo
	DD	$LN25@IsBranchCo
	DD	$LN24@IsBranchCo
	DD	$LN23@IsBranchCo
	DD	$LN22@IsBranchCo
	DD	$LN21@IsBranchCo
	DD	$LN20@IsBranchCo
	DD	$LN19@IsBranchCo
	DD	$LN18@IsBranchCo
	DD	$LN17@IsBranchCo
	DD	$LN16@IsBranchCo
	DD	$LN15@IsBranchCo
	DD	$LN14@IsBranchCo
	DD	$LN13@IsBranchCo
	DD	$LN12@IsBranchCo
	DD	$LN11@IsBranchCo
	DD	$LN10@IsBranchCo
	DD	$LN9@IsBranchCo
	DD	$LN8@IsBranchCo
	DD	$LN7@IsBranchCo
	DD	$LN6@IsBranchCo
	DD	$LN5@IsBranchCo
	DD	$LN4@IsBranchCo
	DD	$LN3@IsBranchCo
	DD	$LN2@IsBranchCo
?IsBranchConditionCompilable@@YA_NIII@Z ENDP		; IsBranchConditionCompilable
_TEXT	ENDS
PUBLIC	??0SuperBlock@@QAE@PAVMPE@@II@Z			; SuperBlock::SuperBlock
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fopen:PROC
EXTRN	_sprintf:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??0SuperBlockConstants@@QAE@PAVMPE@@PAVSuperBlock@@@Z:PROC ; SuperBlockConstants::SuperBlockConstants
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
xdata$x	SEGMENT
__unwindtable$??0SuperBlock@@QAE@PAVMPE@@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SuperBlock@@QAE@PAVMPE@@II@Z$0
__ehfuncinfo$??0SuperBlock@@QAE@PAVMPE@@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SuperBlock@@QAE@PAVMPE@@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv78 = -172						; size = 4
$T44218 = -168						; size = 4
$T44217 = -164						; size = 4
$T44214 = -160						; size = 4
$T44213 = -156						; size = 4
_fileStr$ = -148					; size = 128
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_mpe$ = 8						; size = 4
_maxPackets$ = 12					; size = 4
_maxInstructionsPerPacket$ = 16				; size = 4
??0SuperBlock@@QAE@PAVMPE@@II@Z PROC			; SuperBlock::SuperBlock
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SuperBlock@@QAE@PAVMPE@@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 160				; 000000a0H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  :   char fileStr[128];
; 130  :   maxPacketsPerSuperBlock = maxPackets;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _maxPackets$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 131  :   pMPE = mpe;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+52], eax

; 132  :   this->maxInstructionsPerPacket = maxInstructionsPerPacket;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _maxInstructionsPerPacket$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 133  :   this->constants = new SuperBlockConstants(pMPE,this);

	push	576					; 00000240H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T44214[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44214[ebp], 0
	je	SHORT $LN3@SuperBlock
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	ecx, DWORD PTR $T44214[ebp]
	call	??0SuperBlockConstants@@QAE@PAVMPE@@PAVSuperBlock@@@Z ; SuperBlockConstants::SuperBlockConstants
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN4@SuperBlock
$LN3@SuperBlock:
	mov	DWORD PTR tv78[ebp], 0
$LN4@SuperBlock:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T44213[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T44213[ebp]
	mov	DWORD PTR [ecx+36], edx

; 134  :   //allocate enough instruction entries to account for packet start/end IL
; 135  :   instructions = new InstructionEntry[(maxPackets + 2) * (maxInstructionsPerPacket + 2)];

	mov	eax, DWORD PTR _maxPackets$[ebp]
	add	eax, 2
	mov	ecx, DWORD PTR _maxInstructionsPerPacket$[ebp]
	add	ecx, 2
	imul	eax, ecx
	xor	ecx, ecx
	mov	edx, 56					; 00000038H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T44217[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T44217[ebp]
	mov	DWORD PTR [eax+32], ecx

; 136  :   packets = new PacketEntry[maxPackets + 2];

	mov	eax, DWORD PTR _maxPackets$[ebp]
	add	eax, 2
	xor	ecx, ecx
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T44218[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T44218[ebp]
	mov	DWORD PTR [eax+28], ecx

; 137  :   numInstructions = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 138  :   numPackets = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 139  :   sprintf(fileStr,"SuperBlocks%li.txt",mpe->mpeIndex);

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	push	edx
	push	OFFSET $SG41729
	lea	eax, DWORD PTR _fileStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 140  :   blockFile = fopen(fileStr,"w");

	push	OFFSET $SG41730
	lea	ecx, DWORD PTR _fileStr$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], eax

; 141  : }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@SuperBlock
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN9@SuperBlock:
	DD	1
	DD	$LN8@SuperBlock
$LN8@SuperBlock:
	DD	-148					; ffffff6cH
	DD	128					; 00000080H
	DD	$LN6@SuperBlock
$LN6@SuperBlock:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SuperBlock@@QAE@PAVMPE@@II@Z$0:
	mov	eax, DWORD PTR $T44214[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0SuperBlock@@QAE@PAVMPE@@II@Z:
	mov	eax, OFFSET __ehfuncinfo$??0SuperBlock@@QAE@PAVMPE@@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SuperBlock@@QAE@PAVMPE@@II@Z ENDP			; SuperBlock::SuperBlock
PUBLIC	??_GSuperBlockConstants@@QAEPAXI@Z		; SuperBlockConstants::`scalar deleting destructor'
PUBLIC	??1SuperBlock@@QAE@XZ				; SuperBlock::~SuperBlock
EXTRN	_fclose:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv73 = -24						; size = 4
$T44236 = -20						; size = 4
$T44235 = -16						; size = 4
$T44234 = -12						; size = 4
$T44233 = -8						; size = 4
_this$ = -4						; size = 4
??1SuperBlock@@QAE@XZ PROC				; SuperBlock::~SuperBlock
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 145  :   delete [] instructions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T44233[ebp], ecx
	mov	edx, DWORD PTR $T44233[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 146  :   delete [] packets;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T44234[ebp], ecx
	mov	edx, DWORD PTR $T44234[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 147  :   delete constants;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR $T44236[ebp], ecx
	mov	edx, DWORD PTR $T44236[ebp]
	mov	DWORD PTR $T44235[ebp], edx
	cmp	DWORD PTR $T44235[ebp], 0
	je	SHORT $LN4@SuperBlock@2
	push	1
	mov	ecx, DWORD PTR $T44235[ebp]
	call	??_GSuperBlockConstants@@QAEPAXI@Z
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@SuperBlock@2
$LN4@SuperBlock@2:
	mov	DWORD PTR tv73[ebp], 0
$LN5@SuperBlock@2:

; 148  :   if(blockFile)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN2@SuperBlock@2

; 149  :   {
; 150  :     fclose(blockFile);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fclose
	add	esp, 4
$LN2@SuperBlock@2:

; 151  :   }
; 152  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SuperBlock@@QAE@XZ ENDP				; SuperBlock::~SuperBlock
_TEXT	ENDS
EXTRN	??1SuperBlockConstants@@QAE@XZ:PROC		; SuperBlockConstants::~SuperBlockConstants
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GSuperBlockConstants@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSuperBlockConstants@@QAEPAXI@Z PROC			; SuperBlockConstants::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SuperBlockConstants@@QAE@XZ		; SuperBlockConstants::~SuperBlockConstants
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSuperBlockConstants@@QAEPAXI@Z ENDP			; SuperBlockConstants::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetFlagString@@YAXIPAD@Z			; GetFlagString
EXTRN	_strcat:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_tempStr$ = -132					; size = 128
_flags$ = 8						; size = 4
_buffer$ = 12						; size = 4
?GetFlagString@@YAXIPAD@Z PROC				; GetFlagString

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	edi
	lea	edi, DWORD PTR [ebp-136]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 161  :   char tempStr[128];
; 162  : 
; 163  :   buffer[0] = '\0';

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [eax], 0

; 164  : 
; 165  :   if(flags & SUPERBLOCKINFO_PACKETSTART)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN10@GetFlagStr

; 166  :   {
; 167  :     sprintf(tempStr,"SUPERBLOCKINFO_PACKETSTART\n");

	push	OFFSET $SG41749
	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 168  :     strcat(buffer,tempStr);

	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN10@GetFlagStr:

; 169  :   }
; 170  :   
; 171  :   if(flags & SUPERBLOCKINFO_PACKETEND)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 131072				; 00020000H
	je	SHORT $LN9@GetFlagStr

; 172  :   {
; 173  :     sprintf(tempStr,"SUPERBLOCKINFO_PACKETEND\n");

	push	OFFSET $SG41751
	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 174  :     strcat(buffer,tempStr);

	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN9@GetFlagStr:

; 175  :   }
; 176  : 
; 177  :   if(flags & SUPERBLOCKINFO_LOCKED)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN8@GetFlagStr

; 178  :   {
; 179  :     sprintf(tempStr,"SUPERBLOCKINFO_LOCKED\n");

	push	OFFSET $SG41753
	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 180  :     strcat(buffer,tempStr);

	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN8@GetFlagStr:

; 181  :   }
; 182  : 
; 183  :   if(flags & SUPERBLOCKINFO_NONATIVECOMPILE)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN7@GetFlagStr

; 184  :   {
; 185  :     sprintf(tempStr,"SUPERBLOCKINFO_NONATIVECOMPILE\n");

	push	OFFSET $SG41755
	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 186  :     strcat(buffer,tempStr);

	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN7@GetFlagStr:

; 187  :   }
; 188  : 
; 189  :   if(flags & SUPERBLOCKINFO_DEAD)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32768				; 00008000H
	je	SHORT $LN6@GetFlagStr

; 190  :   {
; 191  :     sprintf(tempStr,"SUPERBLOCKINFO_DEAD\n");

	push	OFFSET $SG41757
	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 192  :     strcat(buffer,tempStr);

	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN6@GetFlagStr:

; 193  :   }
; 194  : 
; 195  :   if(flags & SUPERBLOCKINFO_SYNC)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 524288				; 00080000H
	je	SHORT $LN5@GetFlagStr

; 196  :   {
; 197  :     sprintf(tempStr,"SUPERBLOCKINFO_SYNC\n");

	push	OFFSET $SG41759
	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 198  :     strcat(buffer,tempStr);

	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN5@GetFlagStr:

; 199  :   }
; 200  : 
; 201  :   if(flags & SUPERBLOCKINFO_INHIBIT_ECU)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4194304				; 00400000H
	je	SHORT $LN4@GetFlagStr

; 202  :   {
; 203  :     sprintf(tempStr,"SUPERBLOCKINFO_INHIBIT_ECU\n");

	push	OFFSET $SG41761
	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 204  :     strcat(buffer,tempStr);

	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN4@GetFlagStr:

; 205  :   }
; 206  : 
; 207  :   if(flags & SUPERBLOCKINFO_CHECK_ECU_INHIBIT)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2097152				; 00200000H
	je	SHORT $LN3@GetFlagStr

; 208  :   {
; 209  :     sprintf(tempStr,"SUPERBLOCKINFO_CHECK_ECU_INHIBIT\n");

	push	OFFSET $SG41763
	lea	eax, DWORD PTR _tempStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 210  :     strcat(buffer,tempStr);

	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN3@GetFlagStr:

; 211  :   }
; 212  : 
; 213  :   if(flags & SUPERBLOCKINFO_CHECK_ECUSKIPCOUNTER)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN2@GetFlagStr

; 214  :   {
; 215  :     sprintf(tempStr,"SUPERBLOCKINFO_CHECK_ECU_SKIPCOUNTER\n");

	push	OFFSET $SG41765
	lea	ecx, DWORD PTR _tempStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 216  :     strcat(buffer,tempStr);

	lea	edx, DWORD PTR _tempStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN2@GetFlagStr:

; 217  :   }
; 218  : 
; 219  :   if(buffer[0] == '\0')

	mov	ecx, DWORD PTR _buffer$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@GetFlagStr

; 220  :   {
; 221  :     sprintf(buffer,"NONE\n");

	push	OFFSET $SG41767
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN11@GetFlagStr:

; 222  :   }
; 223  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@GetFlagStr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 136				; 00000088H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@GetFlagStr:
	DD	1
	DD	$LN14@GetFlagStr
$LN14@GetFlagStr:
	DD	-132					; ffffff7cH
	DD	128					; 00000080H
	DD	$LN13@GetFlagStr
$LN13@GetFlagStr:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
?GetFlagString@@YAXIPAD@Z ENDP				; GetFlagString
_TEXT	ENDS
PUBLIC	?GetIFlagsString@@YAXPADI@Z			; GetIFlagsString
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv172 = -56						; size = 4
tv168 = -52						; size = 4
tv164 = -48						; size = 4
tv160 = -44						; size = 4
tv156 = -40						; size = 4
tv152 = -36						; size = 4
tv148 = -32						; size = 4
tv144 = -28						; size = 4
tv140 = -24						; size = 4
tv136 = -20						; size = 4
tv132 = -16						; size = 4
_bCF1$ = -11						; size = 1
_bCF0$ = -10						; size = 1
_bMODMI$ = -9						; size = 1
_bMODGE$ = -8						; size = 1
_bC1Z$ = -7						; size = 1
_bC0Z$ = -6						; size = 1
_bMV$ = -5						; size = 1
_bC$ = -4						; size = 1
_bZ$ = -3						; size = 1
_bV$ = -2						; size = 1
_bN$ = -1						; size = 1
_buffer$ = 8						; size = 4
_dep$ = 12						; size = 4
?GetIFlagsString@@YAXPADI@Z PROC			; GetIFlagsString

; 226  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 227  :   bool bN = dep & DEPENDENCY_FLAG_N;

	mov	eax, DWORD PTR _dep$[ebp]
	and	eax, 262144				; 00040000H
	setne	cl
	mov	BYTE PTR _bN$[ebp], cl

; 228  :   bool bV = dep & DEPENDENCY_FLAG_V;

	mov	edx, DWORD PTR _dep$[ebp]
	and	edx, 131072				; 00020000H
	setne	al
	mov	BYTE PTR _bV$[ebp], al

; 229  :   bool bZ = dep & DEPENDENCY_FLAG_Z;

	mov	ecx, DWORD PTR _dep$[ebp]
	and	ecx, 32768				; 00008000H
	setne	dl
	mov	BYTE PTR _bZ$[ebp], dl

; 230  :   bool bC = dep & DEPENDENCY_FLAG_C;

	mov	eax, DWORD PTR _dep$[ebp]
	and	eax, 65536				; 00010000H
	setne	cl
	mov	BYTE PTR _bC$[ebp], cl

; 231  :   bool bMV = dep & DEPENDENCY_FLAG_MV;

	mov	edx, DWORD PTR _dep$[ebp]
	and	edx, 524288				; 00080000H
	setne	al
	mov	BYTE PTR _bMV$[ebp], al

; 232  :   bool bC0Z = dep & DEPENDENCY_FLAG_C0Z;

	mov	ecx, DWORD PTR _dep$[ebp]
	and	ecx, 1048576				; 00100000H
	setne	dl
	mov	BYTE PTR _bC0Z$[ebp], dl

; 233  :   bool bC1Z = dep & DEPENDENCY_FLAG_C1Z;

	mov	eax, DWORD PTR _dep$[ebp]
	and	eax, 2097152				; 00200000H
	setne	cl
	mov	BYTE PTR _bC1Z$[ebp], cl

; 234  :   bool bMODGE = dep & DEPENDENCY_FLAG_MODGE;

	mov	edx, DWORD PTR _dep$[ebp]
	and	edx, 4194304				; 00400000H
	setne	al
	mov	BYTE PTR _bMODGE$[ebp], al

; 235  :   bool bMODMI = dep & DEPENDENCY_FLAG_MODMI;

	mov	ecx, DWORD PTR _dep$[ebp]
	and	ecx, 8388608				; 00800000H
	setne	dl
	mov	BYTE PTR _bMODMI$[ebp], dl

; 236  :   bool bCF0 = dep & DEPENDENCY_FLAG_CP0;

	mov	eax, DWORD PTR _dep$[ebp]
	and	eax, 16777216				; 01000000H
	setne	cl
	mov	BYTE PTR _bCF0$[ebp], cl

; 237  :   bool bCF1 = dep & DEPENDENCY_FLAG_CP1;

	mov	edx, DWORD PTR _dep$[ebp]
	and	edx, 33554432				; 02000000H
	setne	al
	mov	BYTE PTR _bCF1$[ebp], al

; 238  : 
; 239  :   sprintf(buffer,"[%s%s%s%s%s%s%s%s%s%s%s]",
; 240  :     bN ? "N " : "",
; 241  :     bV ? "V " : "",
; 242  :     bZ ? "Z " : "",
; 243  :     bC ? "C " : "",
; 244  :     bMV ? "MV " : "",
; 245  :     bC0Z ? "C0Z " : "",
; 246  :     bC1Z ? "C1Z " : "",
; 247  :     bMODGE ? "MODGE " : "",
; 248  :     bMODMI ? "MODMI " : "",
; 249  :     bCF0 ? "CF0 " : "",
; 250  :     bCF1 ? "CF1 " : "");

	movzx	ecx, BYTE PTR _bCF1$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetIFlagsS
	mov	DWORD PTR tv132[ebp], OFFSET $SG41783
	jmp	SHORT $LN4@GetIFlagsS
$LN3@GetIFlagsS:
	mov	DWORD PTR tv132[ebp], OFFSET $SG41784
$LN4@GetIFlagsS:
	movzx	edx, BYTE PTR _bCF0$[ebp]
	test	edx, edx
	je	SHORT $LN5@GetIFlagsS
	mov	DWORD PTR tv136[ebp], OFFSET $SG41785
	jmp	SHORT $LN6@GetIFlagsS
$LN5@GetIFlagsS:
	mov	DWORD PTR tv136[ebp], OFFSET $SG41786
$LN6@GetIFlagsS:
	movzx	eax, BYTE PTR _bMODMI$[ebp]
	test	eax, eax
	je	SHORT $LN7@GetIFlagsS
	mov	DWORD PTR tv140[ebp], OFFSET $SG41787
	jmp	SHORT $LN8@GetIFlagsS
$LN7@GetIFlagsS:
	mov	DWORD PTR tv140[ebp], OFFSET $SG41788
$LN8@GetIFlagsS:
	movzx	ecx, BYTE PTR _bMODGE$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@GetIFlagsS
	mov	DWORD PTR tv144[ebp], OFFSET $SG41789
	jmp	SHORT $LN10@GetIFlagsS
$LN9@GetIFlagsS:
	mov	DWORD PTR tv144[ebp], OFFSET $SG41790
$LN10@GetIFlagsS:
	movzx	edx, BYTE PTR _bC1Z$[ebp]
	test	edx, edx
	je	SHORT $LN11@GetIFlagsS
	mov	DWORD PTR tv148[ebp], OFFSET $SG41791
	jmp	SHORT $LN12@GetIFlagsS
$LN11@GetIFlagsS:
	mov	DWORD PTR tv148[ebp], OFFSET $SG41792
$LN12@GetIFlagsS:
	movzx	eax, BYTE PTR _bC0Z$[ebp]
	test	eax, eax
	je	SHORT $LN13@GetIFlagsS
	mov	DWORD PTR tv152[ebp], OFFSET $SG41793
	jmp	SHORT $LN14@GetIFlagsS
$LN13@GetIFlagsS:
	mov	DWORD PTR tv152[ebp], OFFSET $SG41794
$LN14@GetIFlagsS:
	movzx	ecx, BYTE PTR _bMV$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@GetIFlagsS
	mov	DWORD PTR tv156[ebp], OFFSET $SG41795
	jmp	SHORT $LN16@GetIFlagsS
$LN15@GetIFlagsS:
	mov	DWORD PTR tv156[ebp], OFFSET $SG41796
$LN16@GetIFlagsS:
	movzx	edx, BYTE PTR _bC$[ebp]
	test	edx, edx
	je	SHORT $LN17@GetIFlagsS
	mov	DWORD PTR tv160[ebp], OFFSET $SG41797
	jmp	SHORT $LN18@GetIFlagsS
$LN17@GetIFlagsS:
	mov	DWORD PTR tv160[ebp], OFFSET $SG41798
$LN18@GetIFlagsS:
	movzx	eax, BYTE PTR _bZ$[ebp]
	test	eax, eax
	je	SHORT $LN19@GetIFlagsS
	mov	DWORD PTR tv164[ebp], OFFSET $SG41799
	jmp	SHORT $LN20@GetIFlagsS
$LN19@GetIFlagsS:
	mov	DWORD PTR tv164[ebp], OFFSET $SG41800
$LN20@GetIFlagsS:
	movzx	ecx, BYTE PTR _bV$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@GetIFlagsS
	mov	DWORD PTR tv168[ebp], OFFSET $SG41801
	jmp	SHORT $LN22@GetIFlagsS
$LN21@GetIFlagsS:
	mov	DWORD PTR tv168[ebp], OFFSET $SG41802
$LN22@GetIFlagsS:
	movzx	edx, BYTE PTR _bN$[ebp]
	test	edx, edx
	je	SHORT $LN23@GetIFlagsS
	mov	DWORD PTR tv172[ebp], OFFSET $SG41803
	jmp	SHORT $LN24@GetIFlagsS
$LN23@GetIFlagsS:
	mov	DWORD PTR tv172[ebp], OFFSET $SG41804
$LN24@GetIFlagsS:
	mov	eax, DWORD PTR tv132[ebp]
	push	eax
	mov	ecx, DWORD PTR tv136[ebp]
	push	ecx
	mov	edx, DWORD PTR tv140[ebp]
	push	edx
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	mov	ecx, DWORD PTR tv148[ebp]
	push	ecx
	mov	edx, DWORD PTR tv152[ebp]
	push	edx
	mov	eax, DWORD PTR tv156[ebp]
	push	eax
	mov	ecx, DWORD PTR tv160[ebp]
	push	ecx
	mov	edx, DWORD PTR tv164[ebp]
	push	edx
	mov	eax, DWORD PTR tv168[ebp]
	push	eax
	mov	ecx, DWORD PTR tv172[ebp]
	push	ecx
	push	OFFSET $SG41805
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 52					; 00000034H

; 251  : }

	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIFlagsString@@YAXPADI@Z ENDP			; GetIFlagsString
_TEXT	ENDS
PUBLIC	?GetEmitPointer@NativeCodeCache@@QAEPAEXZ	; NativeCodeCache::GetEmitPointer
PUBLIC	?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ	; NativeCodeCache::IsBeyondThreshold
PUBLIC	?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z	; NativeCodeCache::LockBuffer
PUBLIC	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
PUBLIC	?EmitCodeBlock@SuperBlock@@QAE_NAAVNativeCodeCache@@W4SuperBlockCompileType@@_N@Z ; SuperBlock::EmitCodeBlock
EXTRN	?X86Emit_RETN@NativeCodeCache@@QAEXG@Z:PROC	; NativeCodeCache::X86Emit_RETN
EXTRN	?X86Emit_POPAD@NativeCodeCache@@QAEXXZ:PROC	; NativeCodeCache::X86Emit_POPAD
EXTRN	?X86Emit_EMMS@NativeCodeCache@@QAEXXZ:PROC	; NativeCodeCache::X86Emit_EMMS
EXTRN	?Emit_SaveRegs@@YAXPAVEmitterVariables@@AAVNuance@@@Z:PROC ; Emit_SaveRegs
EXTRN	?emitHandlers@@3PAP6AXPAVEmitterVariables@@AAVNuance@@@ZA:BYTE ; emitHandlers
EXTRN	?X86Emit_MOVIM@NativeCodeCache@@QAEXHW4x86MemPtr@@IW4x86IndexReg@@W4x86ScaleVal@@H@Z:PROC ; NativeCodeCache::X86Emit_MOVIM
EXTRN	?X86Emit_MOVIR@NativeCodeCache@@QAEXHW4x86Reg@@@Z:PROC ; NativeCodeCache::X86Emit_MOVIR
EXTRN	?X86Emit_PUSHAD@NativeCodeCache@@QAEXXZ:PROC	; NativeCodeCache::X86Emit_PUSHAD
EXTRN	?ReleaseBuffer@NativeCodeCache@@QAE_NP6AXXZIIIIIW4SuperBlockCompileType@@II@Z:PROC ; NativeCodeCache::ReleaseBuffer
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bResult$ = -33						; size = 1
_pInstruction$ = -32					; size = 4
_flags$ = -28						; size = 4
_numLiveInstructions$ = -24				; size = 4
_i$ = -20						; size = 4
_emittedBytes$ = -16					; size = 4
_ptrEmitNuance$ = -12					; size = 4
_entryPoint$ = -8					; size = 4
_this$ = -4						; size = 4
_codeCache$ = 8						; size = 4
_compileType$ = 12					; size = 4
_bContainsBranch$ = 16					; size = 1
?EmitCodeBlock@SuperBlock@@QAE_NAAVNativeCodeCache@@W4SuperBlockCompileType@@_N@Z PROC ; SuperBlock::EmitCodeBlock
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 259  :   uint8 *entryPoint = 0;

	mov	DWORD PTR _entryPoint$[ebp], 0

; 260  :   Nuance *ptrEmitNuance = 0;

	mov	DWORD PTR _ptrEmitNuance$[ebp], 0

; 261  :   uint32 emittedBytes = 0;

	mov	DWORD PTR _emittedBytes$[ebp], 0

; 262  :   uint32 i,numLiveInstructions, flags;
; 263  :   InstructionEntry *pInstruction;
; 264  :   bool bResult = false;

	mov	BYTE PTR _bResult$[ebp], 0

; 265  : 
; 266  :   pInstruction = instructions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _pInstruction$[ebp], ecx

; 267  :   numLiveInstructions = 0;

	mov	DWORD PTR _numLiveInstructions$[ebp], 0

; 268  : 
; 269  :   codeCache.GetEmitVars()->bSaveRegs = false;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	BYTE PTR [eax+17], 0

; 270  :   codeCache.GetEmitVars()->bCheckECUSkipCounter = false;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	BYTE PTR [eax+16], 0

; 271  :   codeCache.GetEmitVars()->bUsesMMX = false;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	BYTE PTR [eax+18], 0

; 272  : 
; 273  :   if(!bAllowBlockCompile)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+25]
	test	eax, eax
	jne	SHORT $LN37@EmitCodeBl

; 274  :   {
; 275  :     compileType = SUPERBLOCKCOMPILETYPE_IL_SINGLE;

	mov	DWORD PTR _compileType$[ebp], 1
	jmp	SHORT $LN36@EmitCodeBl
$LN37@EmitCodeBl:

; 276  :   }
; 277  :   else if(compileType != SUPERBLOCKCOMPILETYPE_IL_SINGLE)

	cmp	DWORD PTR _compileType$[ebp], 1
	je	SHORT $LN36@EmitCodeBl

; 278  :   {
; 279  :     if(!bCanEmitNativeCode)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	test	edx, edx
	jne	SHORT $LN34@EmitCodeBl

; 280  :     {
; 281  :       compileType = SUPERBLOCKCOMPILETYPE_IL_BLOCK;

	mov	DWORD PTR _compileType$[ebp], 2

; 282  :     }
; 283  :     else

	jmp	SHORT $LN36@EmitCodeBl
$LN34@EmitCodeBl:

; 284  :     {
; 285  :       compileType = compileType;

	mov	eax, DWORD PTR _compileType$[ebp]
	mov	DWORD PTR _compileType$[ebp], eax
$LN36@EmitCodeBl:

; 286  :     }
; 287  :   }
; 288  : 
; 289  :   if((compileType == SUPERBLOCKCOMPILETYPE_IL_SINGLE) || (compileType == SUPERBLOCKCOMPILETYPE_IL_BLOCK))

	cmp	DWORD PTR _compileType$[ebp], 1
	je	SHORT $LN31@EmitCodeBl
	cmp	DWORD PTR _compileType$[ebp], 2
	jne	$LN32@EmitCodeBl
$LN31@EmitCodeBl:

; 290  :   {
; 291  :     entryPoint = codeCache.LockBuffer(NULL,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z ; NativeCodeCache::LockBuffer
	mov	DWORD PTR _entryPoint$[ebp], eax

; 292  :     ptrEmitNuance = (Nuance *)entryPoint;

	mov	ecx, DWORD PTR _entryPoint$[ebp]
	mov	DWORD PTR _ptrEmitNuance$[ebp], ecx

; 293  : 
; 294  :     for(i = numInstructions; i > 0; i--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN30@EmitCodeBl
$LN29@EmitCodeBl:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN30@EmitCodeBl:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	$LN28@EmitCodeBl

; 295  :     {
; 296  :       flags = pInstruction->flags;

	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _flags$[ebp], eax

; 297  :       if(!(flags & (SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_PACKETEND)))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 393216				; 00060000H
	jne	SHORT $LN27@EmitCodeBl

; 298  :       {
; 299  :         if(!(flags & SUPERBLOCKINFO_DEAD))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN26@EmitCodeBl

; 300  :         {
; 301  :           numLiveInstructions++;

	mov	eax, DWORD PTR _numLiveInstructions$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLiveInstructions$[ebp], eax

; 302  :           *ptrEmitNuance = pInstruction->instruction;

	mov	ecx, DWORD PTR _pInstruction$[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx

; 303  :           ptrEmitNuance++;

	mov	edx, DWORD PTR _ptrEmitNuance$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _ptrEmitNuance$[ebp], edx
$LN26@EmitCodeBl:

; 304  :         }
; 305  :       }

	jmp	$LN25@EmitCodeBl
$LN27@EmitCodeBl:

; 306  :       else if(flags & SUPERBLOCKINFO_PACKETSTART)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 262144				; 00040000H
	je	$LN24@EmitCodeBl

; 307  :       {
; 308  :         //Emit SaveRegs or SaveFlags only if the packet contains live instructions
; 309  :         if(pInstruction->packet->liveCount)

	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+36], 0
	je	$LN23@EmitCodeBl

; 310  :         {
; 311  :           numLiveInstructions++;

	mov	eax, DWORD PTR _numLiveInstructions$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLiveInstructions$[ebp], eax

; 312  : 
; 313  :           if(flags & PACKETINFO_DEPENDENCY_PRESENT)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN22@EmitCodeBl

; 314  :           {
; 315  :             pInstruction->instruction.fields[0] = Handler_SaveRegs;

	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [edx+4], 223			; 000000dfH

; 316  :             ptrEmitNuance->fields[0] = Handler_SaveRegs;

	mov	eax, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [eax], 223			; 000000dfH

; 317  :             ptrEmitNuance->fields[1] = pInstruction->scalarOpDependencies;

	mov	ecx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+4], eax

; 318  :             ptrEmitNuance->fields[2] = pInstruction->miscOpDependencies;

	mov	ecx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+8], eax

; 319  :             if(pInstruction->scalarOpDependencies | (pInstruction->miscOpDependencies & ~DEPENDENCY_FLAG_ALLFLAGS))

	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	and	edx, -67076097				; fc007fffH
	mov	eax, DWORD PTR _pInstruction$[ebp]
	or	edx, DWORD PTR [eax+48]
	je	SHORT $LN21@EmitCodeBl

; 320  :             {
; 321  :               codeCache.GetEmitVars()->bSaveRegs = true;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	BYTE PTR [eax+17], 1
$LN21@EmitCodeBl:

; 322  :             }
; 323  :           }
; 324  :           else

	jmp	SHORT $LN20@EmitCodeBl
$LN22@EmitCodeBl:

; 325  :           {
; 326  :             pInstruction->instruction.fields[0] = Handler_SaveFlags;

	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [ecx+4], 222			; 000000deH

; 327  :             ptrEmitNuance->fields[0] = Handler_SaveFlags;

	mov	edx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [edx], 222			; 000000deH

; 328  :             ptrEmitNuance->fields[1] = 0;

	mov	eax, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [eax+4], 0

; 329  :             ptrEmitNuance->fields[2] = 0;

	mov	ecx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN20@EmitCodeBl:

; 330  :           }
; 331  :           ptrEmitNuance++;

	mov	edx, DWORD PTR _ptrEmitNuance$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _ptrEmitNuance$[ebp], edx
$LN23@EmitCodeBl:

; 332  :         }
; 333  :       }
; 334  :       else //PACKET_END

	jmp	SHORT $LN25@EmitCodeBl
$LN24@EmitCodeBl:

; 335  :       {
; 336  :         //Emit CheckECUSkipCounter only if there are live instructions (nu uh!)
; 337  :         //if(pInstruction->packet->liveCount)
; 338  :         {
; 339  :           numLiveInstructions++;

	mov	eax, DWORD PTR _numLiveInstructions$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLiveInstructions$[ebp], eax

; 340  : 
; 341  :           ptrEmitNuance->fields[0] = Handler_CheckECUSkipCounter;

	mov	ecx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [ecx], 221			; 000000ddH

; 342  :           ptrEmitNuance->fields[1] = 0;

	mov	edx, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [edx+4], 0

; 343  :           ptrEmitNuance->fields[2] = 0;

	mov	eax, DWORD PTR _ptrEmitNuance$[ebp]
	mov	DWORD PTR [eax+8], 0

; 344  :           ptrEmitNuance++;

	mov	ecx, DWORD PTR _ptrEmitNuance$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _ptrEmitNuance$[ebp], ecx
$LN25@EmitCodeBl:

; 345  :         }
; 346  :       }
; 347  :       pInstruction++;

	mov	edx, DWORD PTR _pInstruction$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR _pInstruction$[ebp], edx

; 348  :     }

	jmp	$LN29@EmitCodeBl
$LN28@EmitCodeBl:

; 349  :     emittedBytes = numLiveInstructions * sizeof(Nuance);

	mov	eax, DWORD PTR _numLiveInstructions$[ebp]
	imul	eax, 20					; 00000014H
	mov	DWORD PTR _emittedBytes$[ebp], eax

; 350  :     codeCache.ReleaseBuffer((NativeCodeCacheEntryPoint)entryPoint, startAddress, exitAddress, emittedBytes, packetsProcessed, numLiveInstructions, compileType, nextDelayCounter,4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _compileType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numLiveInstructions$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _emittedBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _entryPoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?ReleaseBuffer@NativeCodeCache@@QAE_NP6AXXZIIIIIW4SuperBlockCompileType@@II@Z ; NativeCodeCache::ReleaseBuffer

; 351  :     return codeCache.IsBeyondThreshold();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ ; NativeCodeCache::IsBeyondThreshold
	jmp	$LN38@EmitCodeBl
	jmp	$LN18@EmitCodeBl
$LN32@EmitCodeBl:

; 352  :   }
; 353  :   else if(compileType == SUPERBLOCKCOMPILETYPE_NATIVE_CODE_BLOCK)

	cmp	DWORD PTR _compileType$[ebp], 3
	jne	$LN18@EmitCodeBl

; 354  :   {
; 355  :     entryPoint = codeCache.LockBuffer(NULL,4);

	push	4
	push	0
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z ; NativeCodeCache::LockBuffer
	mov	DWORD PTR _entryPoint$[ebp], eax

; 356  :     codeCache.GetEmitVars()->pInstructionEntry = pInstruction;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 357  :     
; 358  :     if(numInstructions > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN16@EmitCodeBl

; 359  :     {
; 360  :       codeCache.X86Emit_PUSHAD();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_PUSHAD@NativeCodeCache@@QAEXXZ	; NativeCodeCache::X86Emit_PUSHAD

; 361  :       codeCache.X86Emit_MOVIR(codeCache.GetEmitVars()->regBase, x86Reg_esi);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	eax, DWORD PTR [eax+20]
	push	eax
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_MOVIR@NativeCodeCache@@QAEXHW4x86Reg@@@Z ; NativeCodeCache::X86Emit_MOVIR

; 362  :       codeCache.X86Emit_MOVIR(codeCache.GetEmitVars()->tempRegBase, x86Reg_edi);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_MOVIR@NativeCodeCache@@QAEXHW4x86Reg@@@Z ; NativeCodeCache::X86Emit_MOVIR

; 363  :       if(bContainsBranch)

	movzx	edx, BYTE PTR _bContainsBranch$[ebp]
	test	edx, edx
	je	SHORT $LN16@EmitCodeBl

; 364  :       {
; 365  :         codeCache.X86Emit_MOVIM(exitAddress, x86MemPtr_dword, (uint32)&(codeCache.GetEmitVars()->mpe->pcfetchnext));

	push	0
	push	0
	push	4
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	eax, DWORD PTR [eax]
	add	eax, 564				; 00000234H
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_MOVIM@NativeCodeCache@@QAEXHW4x86MemPtr@@IW4x86IndexReg@@W4x86ScaleVal@@H@Z ; NativeCodeCache::X86Emit_MOVIM
$LN16@EmitCodeBl:

; 366  :       }
; 367  :     }
; 368  : 
; 369  :     for(i = numInstructions; i > 0; i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN14@EmitCodeBl
$LN13@EmitCodeBl:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN14@EmitCodeBl:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	$LN12@EmitCodeBl

; 370  :     {
; 371  :       codeCache.GetEmitVars()->pInstructionEntry = pInstruction;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 372  :       flags = pInstruction->flags;

	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _flags$[ebp], eax

; 373  :       if(!(flags & (SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_PACKETEND)))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 393216				; 00060000H
	jne	SHORT $LN11@EmitCodeBl

; 374  :       {
; 375  :         if(!(flags & SUPERBLOCKINFO_DEAD))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN10@EmitCodeBl

; 376  :         {
; 377  :           numLiveInstructions++;

	mov	eax, DWORD PTR _numLiveInstructions$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLiveInstructions$[ebp], eax

; 378  :           codeCache.GetEmitVars()->scalarRegOutDep = pInstruction->scalarOutputDependencies;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+36], edx

; 379  :           codeCache.GetEmitVars()->miscRegOutDep = pInstruction->miscOutputDependencies;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+40], edx

; 380  : 
; 381  :           ((NativeEmitHandler)(emitHandlers[pInstruction->instruction.fields[0]]))(codeCache.GetEmitVars(),pInstruction->instruction);

	mov	eax, DWORD PTR _pInstruction$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	push	eax
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?emitHandlers@@3PAP6AXPAVEmitterVariables@@AAVNuance@@@ZA[edx*4]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@EmitCodeBl:

; 382  :         }
; 383  :       }

	jmp	$LN9@EmitCodeBl
$LN11@EmitCodeBl:

; 384  :       else if(flags & SUPERBLOCKINFO_PACKETSTART)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	$LN9@EmitCodeBl

; 385  :       {
; 386  :         //Emit SaveRegs or SaveFlags only if the packet contains live instructions
; 387  :         if(pInstruction->packet->liveCount)

	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+36], 0
	je	$LN9@EmitCodeBl

; 388  :         {
; 389  :           numLiveInstructions++;

	mov	ecx, DWORD PTR _numLiveInstructions$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numLiveInstructions$[ebp], ecx

; 390  :           pInstruction->instruction.fields[0] = Handler_SaveRegs;

	mov	edx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [edx+4], 223			; 000000dfH

; 391  :           codeCache.GetEmitVars()->scalarRegDep = 0;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	DWORD PTR [eax+28], 0

; 392  :           codeCache.GetEmitVars()->miscRegDep = 0;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	DWORD PTR [eax+32], 0

; 393  : 
; 394  :           if(flags & PACKETINFO_DEPENDENCY_PRESENT)

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN6@EmitCodeBl

; 395  :           {
; 396  :             codeCache.GetEmitVars()->scalarRegDep = pInstruction->scalarOpDependencies;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+28], edx

; 397  :             codeCache.GetEmitVars()->miscRegDep = pInstruction->miscOpDependencies;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+32], edx

; 398  : 
; 399  :             pInstruction->instruction.fields[1] = pInstruction->scalarOpDependencies;

	mov	eax, DWORD PTR _pInstruction$[ebp]
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+8], edx

; 400  :             pInstruction->instruction.fields[2] = pInstruction->miscOpDependencies;

	mov	eax, DWORD PTR _pInstruction$[ebp]
	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+12], edx

; 401  :             if(pInstruction->scalarOpDependencies | (pInstruction->miscOpDependencies & ~DEPENDENCY_FLAG_ALLFLAGS))

	mov	eax, DWORD PTR _pInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, -67076097				; fc007fffH
	mov	edx, DWORD PTR _pInstruction$[ebp]
	or	ecx, DWORD PTR [edx+48]
	je	SHORT $LN5@EmitCodeBl

; 402  :             {
; 403  :               codeCache.GetEmitVars()->bSaveRegs = true;

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	BYTE PTR [eax+17], 1
$LN5@EmitCodeBl:

; 404  :             }
; 405  :           }
; 406  :           else

	jmp	SHORT $LN4@EmitCodeBl
$LN6@EmitCodeBl:

; 407  :           {
; 408  :             pInstruction->instruction.fields[1] = 0;

	mov	eax, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [eax+8], 0

; 409  :             pInstruction->instruction.fields[2] = 0;

	mov	ecx, DWORD PTR _pInstruction$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN4@EmitCodeBl:

; 410  :           }
; 411  :           Emit_SaveRegs(codeCache.GetEmitVars(),pInstruction->instruction);

	mov	edx, DWORD PTR _pInstruction$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	push	eax
	call	?Emit_SaveRegs@@YAXPAVEmitterVariables@@AAVNuance@@@Z ; Emit_SaveRegs
	add	esp, 8
$LN9@EmitCodeBl:

; 412  :         }
; 413  :       }
; 414  :       pInstruction++;

	mov	eax, DWORD PTR _pInstruction$[ebp]
	add	eax, 56					; 00000038H
	mov	DWORD PTR _pInstruction$[ebp], eax

; 415  :     }

	jmp	$LN13@EmitCodeBl
$LN12@EmitCodeBl:

; 416  : 
; 417  :     codeCache.X86Emit_MOVIM(exitAddress, x86MemPtr_dword,(uint32)&(codeCache.GetEmitVars()->mpe->pcexec));

	push	0
	push	0
	push	4
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	mov	ecx, DWORD PTR [eax]
	add	ecx, 408				; 00000198H
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_MOVIM@NativeCodeCache@@QAEXHW4x86MemPtr@@IW4x86IndexReg@@W4x86ScaleVal@@H@Z ; NativeCodeCache::X86Emit_MOVIM

; 418  : 
; 419  :     if(codeCache.GetEmitVars()->bSaveRegs || codeCache.GetEmitVars()->bUsesMMX)

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	movzx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN2@EmitCodeBl
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ; NativeCodeCache::GetEmitVars
	movzx	edx, BYTE PTR [eax+18]
	test	edx, edx
	je	SHORT $LN3@EmitCodeBl
$LN2@EmitCodeBl:

; 420  :     {
; 421  :       codeCache.X86Emit_EMMS();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_EMMS@NativeCodeCache@@QAEXXZ	; NativeCodeCache::X86Emit_EMMS
$LN3@EmitCodeBl:

; 422  :     }
; 423  : 
; 424  :     if(numInstructions > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jbe	SHORT $LN1@EmitCodeBl

; 425  :     {
; 426  :       codeCache.X86Emit_POPAD();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_POPAD@NativeCodeCache@@QAEXXZ	; NativeCodeCache::X86Emit_POPAD
$LN1@EmitCodeBl:

; 427  :     }
; 428  : 
; 429  :     codeCache.X86Emit_RETN();

	push	0
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?X86Emit_RETN@NativeCodeCache@@QAEXG@Z	; NativeCodeCache::X86Emit_RETN

; 430  :     emittedBytes = (uint32)(codeCache.GetEmitPointer() - entryPoint);

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitPointer@NativeCodeCache@@QAEPAEXZ ; NativeCodeCache::GetEmitPointer
	sub	eax, DWORD PTR _entryPoint$[ebp]
	mov	DWORD PTR _emittedBytes$[ebp], eax

; 431  :     codeCache.ReleaseBuffer((NativeCodeCacheEntryPoint)entryPoint,startAddress,exitAddress,emittedBytes,packetsProcessed,numLiveInstructions,compileType,nextDelayCounter,4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _compileType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numLiveInstructions$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _emittedBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _entryPoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?ReleaseBuffer@NativeCodeCache@@QAE_NP6AXXZIIIIIW4SuperBlockCompileType@@II@Z ; NativeCodeCache::ReleaseBuffer

; 432  :     return codeCache.IsBeyondThreshold();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ ; NativeCodeCache::IsBeyondThreshold
	jmp	SHORT $LN38@EmitCodeBl
$LN18@EmitCodeBl:

; 433  :   }
; 434  : 
; 435  :   return bResult;

	mov	al, BYTE PTR _bResult$[ebp]
$LN38@EmitCodeBl:

; 436  : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?EmitCodeBlock@SuperBlock@@QAE_NAAVNativeCodeCache@@W4SuperBlockCompileType@@_N@Z ENDP ; SuperBlock::EmitCodeBlock
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\nativecodecache.h
_TEXT	ENDS
;	COMDAT ?GetEmitPointer@NativeCodeCache@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmitPointer@NativeCodeCache@@QAEPAEXZ PROC		; NativeCodeCache::GetEmitPointer, COMDAT
; _this$ = ecx

; 51   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 52   :     return pEmitLoc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 53   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmitPointer@NativeCodeCache@@QAEPAEXZ ENDP		; NativeCodeCache::GetEmitPointer
_TEXT	ENDS
PUBLIC	?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ ; NativeCodeCache::GetAvailableCodeBufferSize
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pByteCount$ = 8					; size = 4
_alignment$ = 12					; size = 4
?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z PROC		; NativeCodeCache::LockBuffer, COMDAT
; _this$ = ecx

; 82   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 83   :     if(pByteCount)

	cmp	DWORD PTR _pByteCount$[ebp], 0
	je	SHORT $LN1@LockBuffer

; 84   :     {
; 85   :       *pByteCount = GetAvailableCodeBufferSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ ; NativeCodeCache::GetAvailableCodeBufferSize
	mov	ecx, DWORD PTR _pByteCount$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@LockBuffer:

; 86   :     }
; 87   : 
; 88   :     return pEmitLoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]

; 89   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?LockBuffer@NativeCodeCache@@QAEPAEPAII@Z ENDP		; NativeCodeCache::LockBuffer
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ PROC ; NativeCodeCache::GetAvailableCodeBufferSize, COMDAT
; _this$ = ecx

; 72   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 73   :     return numBytes - (uint32)(pEmitLoc - ptrNativeCodeBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, edx

; 74   :   }  

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ ENDP ; NativeCodeCache::GetAvailableCodeBufferSize
_TEXT	ENDS
PUBLIC	?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ	; NativeCodeCache::GetUsedCodeBufferSize
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ PROC	; NativeCodeCache::IsBeyondThreshold, COMDAT
; _this$ = ecx

; 102  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 103  :     return GetUsedCodeBufferSize() > warningThreshold;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ ; NativeCodeCache::GetUsedCodeBufferSize
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	sbb	eax, eax
	neg	eax

; 104  :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBeyondThreshold@NativeCodeCache@@QAE_NXZ ENDP	; NativeCodeCache::IsBeyondThreshold
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ PROC	; NativeCodeCache::GetUsedCodeBufferSize, COMDAT
; _this$ = ecx

; 77   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 78   :     return (uint32)(pEmitLoc - ptrNativeCodeBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+8]

; 79   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ ENDP	; NativeCodeCache::GetUsedCodeBufferSize
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ PROC ; NativeCodeCache::GetEmitVars, COMDAT
; _this$ = ecx

; 107  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  :     return &emitVars;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH

; 109  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmitVars@NativeCodeCache@@QAEPAVEmitterVariables@@XZ ENDP ; NativeCodeCache::GetEmitVars
_TEXT	ENDS
PUBLIC	?PerformDeadCodeElimination@SuperBlock@@QAEIXZ	; SuperBlock::PerformDeadCodeElimination
PUBLIC	?PerformConstantPropagation@SuperBlock@@QAEXXZ	; SuperBlock::PerformConstantPropagation
PUBLIC	?UpdateDependencyInfo@SuperBlock@@QAEXXZ	; SuperBlock::UpdateDependencyInfo
PUBLIC	?FetchSuperBlock@SuperBlock@@QAEHAAVMPE@@IAA_N@Z ; SuperBlock::FetchSuperBlock
PUBLIC	?CompileBlock@SuperBlock@@QAEP6AXXZPAVMPE@@IAAVNativeCodeCache@@W4SuperBlockCompileType@@_NAA_N@Z ; SuperBlock::CompileBlock
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\superblock.cpp
_TEXT	SEGMENT
_bContainsBranch$ = -17					; size = 1
_fetchSuperBlockResult$ = -12				; size = 4
_entryPoint$ = -8					; size = 4
_this$ = -4						; size = 4
_mpe$ = 8						; size = 4
_address$ = 12						; size = 4
_codeCache$ = 16					; size = 4
_compileType$ = 20					; size = 4
_bLimitToSinglePacket$ = 24				; size = 1
_bError$ = 28						; size = 4
?CompileBlock@SuperBlock@@QAEP6AXXZPAVMPE@@IAAVNativeCodeCache@@W4SuperBlockCompileType@@_NAA_N@Z PROC ; SuperBlock::CompileBlock
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 440  :   NativeCodeCacheEntryPoint entryPoint = (NativeCodeCacheEntryPoint)codeCache.GetEmitPointer();

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetEmitPointer@NativeCodeCache@@QAEPAEXZ ; NativeCodeCache::GetEmitPointer
	mov	DWORD PTR _entryPoint$[ebp], eax

; 441  :   bCanEmitNativeCode = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+60], 1

; 442  :   bSinglePacket = bLimitToSinglePacket;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _bLimitToSinglePacket$[ebp]
	mov	BYTE PTR [ecx+24], dl

; 443  :   int32 fetchSuperBlockResult;
; 444  :   bool bContainsBranch = false;

	mov	BYTE PTR _bContainsBranch$[ebp], 0

; 445  : 
; 446  :   bError = false;

	mov	eax, DWORD PTR _bError$[ebp]
	mov	BYTE PTR [eax], 0

; 447  :   constants->bConstantPropagated = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	BYTE PTR [edx+36], 0

; 448  : 
; 449  :   if(compileType == SUPERBLOCKCOMPILETYPE_IL_SINGLE)

	cmp	DWORD PTR _compileType$[ebp], 1
	jne	SHORT $LN10@CompileBlo

; 450  :   {
; 451  :     bAllowBlockCompile = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+25], 0

; 452  :   }
; 453  :   else

	jmp	SHORT $LN9@CompileBlo
$LN10@CompileBlo:

; 454  :   {
; 455  :     bAllowBlockCompile = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+25], 1
$LN9@CompileBlo:

; 456  :   }
; 457  : 
; 458  :   //Step 1, fetch the block (or superblock)
; 459  :   if((fetchSuperBlockResult = FetchSuperBlock(*mpe,address,bContainsBranch)) <= 0)

	lea	edx, DWORD PTR _bContainsBranch$[ebp]
	push	edx
	mov	eax, DWORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FetchSuperBlock@SuperBlock@@QAEHAAVMPE@@IAA_N@Z ; SuperBlock::FetchSuperBlock
	mov	DWORD PTR _fetchSuperBlockResult$[ebp], eax
	cmp	DWORD PTR _fetchSuperBlockResult$[ebp], 0
	jg	SHORT $LN8@CompileBlo

; 460  :   {
; 461  :     //For whatever reason, no entries were added to the instruction list.  This is most likely due to the first instruction candidate being
; 462  :     //a delayed branch followed by an instruction that cannot be compiled in a delay slot such as a control register memory operation or
; 463  :     //another branch instruction.  In such cases, CompileBlock returns a negative result and the caller should assume the packet needs to
; 464  :     //be interpreted.
; 465  : 
; 466  :     bError = true;

	mov	edx, DWORD PTR _bError$[ebp]
	mov	BYTE PTR [edx], 1

; 467  :     return (NativeCodeCacheEntryPoint)-1;

	or	eax, -1
	jmp	$LN11@CompileBlo
$LN8@CompileBlo:

; 468  :   }
; 469  : 
; 470  :   if(codeCache.GetAvailableCodeBufferSize() <= (numInstructions * sizeof(Nuance)))

	mov	ecx, DWORD PTR _codeCache$[ebp]
	call	?GetAvailableCodeBufferSize@NativeCodeCache@@QAEIXZ ; NativeCodeCache::GetAvailableCodeBufferSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 20					; 00000014H
	cmp	eax, edx
	ja	SHORT $LN7@CompileBlo

; 471  :   {
; 472  :     //Not enough room, or too close for comfort: return false to indicate cache should be
; 473  :     //flushed and compile request reissued
; 474  : 
; 475  :     //Note that this check only works for code blocks being emitted as Nuances.  In this case,
; 476  :     //the required size will always be less than or equal to the number of Nuances in the 
; 477  :     //SuperBlock multiplied by the number of fields per Nuance multiplied by the number of
; 478  :     //bytes per field.  In all but the most trivial cases, if there is enough room to emit
; 479  :     //native code for a block, there will also be enough room to emit the Nuances directly.
; 480  :     //This means that this check wont cause many early failures when compiling
; 481  :     //to native code.  Native code emission will still require a more robust check at the
; 482  :     //end of the emit phase
; 483  : 
; 484  :     return (NativeCodeCacheEntryPoint)0;

	xor	eax, eax
	jmp	$LN11@CompileBlo
$LN7@CompileBlo:

; 485  :   }
; 486  : 
; 487  :   //Step 2, perform constant propagation
; 488  :   if(bSinglePacket)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN6@CompileBlo

; 489  :   {
; 490  :     UpdateDependencyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateDependencyInfo@SuperBlock@@QAEXXZ ; SuperBlock::UpdateDependencyInfo

; 491  :   }
; 492  :   else

	jmp	SHORT $LN5@CompileBlo
$LN6@CompileBlo:

; 493  :   {
; 494  :     if(nuonEnv->compilerOptions.bConstantPropagation)

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	eax, BYTE PTR [edx+117]
	test	eax, eax
	je	SHORT $LN4@CompileBlo

; 495  :     {
; 496  :       //Step 2, perform constant propagation
; 497  :       UpdateDependencyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateDependencyInfo@SuperBlock@@QAEXXZ ; SuperBlock::UpdateDependencyInfo

; 498  :       PerformConstantPropagation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PerformConstantPropagation@SuperBlock@@QAEXXZ ; SuperBlock::PerformConstantPropagation
$LN4@CompileBlo:

; 499  :     }
; 500  :     
; 501  :     if(nuonEnv->compilerOptions.bDeadCodeElimination)

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	movzx	edx, BYTE PTR [ecx+118]
	test	edx, edx
	je	SHORT $LN3@CompileBlo

; 502  :     {
; 503  :       //Step 3, perform dead code elimination
; 504  :       UpdateDependencyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateDependencyInfo@SuperBlock@@QAEXXZ ; SuperBlock::UpdateDependencyInfo

; 505  :       PerformDeadCodeElimination();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PerformDeadCodeElimination@SuperBlock@@QAEIXZ ; SuperBlock::PerformDeadCodeElimination
$LN3@CompileBlo:

; 506  :     }
; 507  : 
; 508  :     UpdateDependencyInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateDependencyInfo@SuperBlock@@QAEXXZ ; SuperBlock::UpdateDependencyInfo
$LN5@CompileBlo:

; 509  :   }
; 510  :   
; 511  :   //Step 4, emit native code or IL nodes based on compile type and
; 512  :   //update code cache entry fields appropriately
; 513  :   if(!EmitCodeBlock(codeCache, compileType, bContainsBranch))

	mov	al, BYTE PTR _bContainsBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _compileType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _codeCache$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmitCodeBlock@SuperBlock@@QAE_NAAVNativeCodeCache@@W4SuperBlockCompileType@@_N@Z ; SuperBlock::EmitCodeBlock
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@CompileBlo

; 514  :   {
; 515  :     return entryPoint;

	mov	eax, DWORD PTR _entryPoint$[ebp]
	jmp	SHORT $LN11@CompileBlo

; 516  :   }
; 517  :   else

	jmp	SHORT $LN11@CompileBlo
$LN2@CompileBlo:

; 518  :   {
; 519  :     bError = true;

	mov	ecx, DWORD PTR _bError$[ebp]
	mov	BYTE PTR [ecx], 1

; 520  :     return (NativeCodeCacheEntryPoint)0;

	xor	eax, eax
$LN11@CompileBlo:

; 521  :   }
; 522  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@CompileBlo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN15@CompileBlo:
	DD	1
	DD	$LN14@CompileBlo
$LN14@CompileBlo:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN13@CompileBlo
$LN13@CompileBlo:
	DB	98					; 00000062H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	66					; 00000042H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	0
?CompileBlock@SuperBlock@@QAEP6AXXZPAVMPE@@IAAVNativeCodeCache@@W4SuperBlockCompileType@@_NAA_N@Z ENDP ; SuperBlock::CompileBlock
_TEXT	ENDS
PUBLIC	?NextInstruction@SuperBlockConstants@@QAE_NXZ	; SuperBlockConstants::NextInstruction
PUBLIC	?PropagateConstants@SuperBlockConstants@@QAEXXZ	; SuperBlockConstants::PropagateConstants
PUBLIC	?FirstInstruction@SuperBlockConstants@@QAEXXZ	; SuperBlockConstants::FirstInstruction
PUBLIC	?ClearConstants@SuperBlockConstants@@QAEXXZ	; SuperBlockConstants::ClearConstants
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?PerformConstantPropagation@SuperBlock@@QAEXXZ PROC	; SuperBlock::PerformConstantPropagation
; _this$ = ecx

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 526  :   uint32 i;
; 527  :   
; 528  :   constants->ClearConstants();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?ClearConstants@SuperBlockConstants@@QAEXXZ ; SuperBlockConstants::ClearConstants

; 529  :   constants->FirstInstruction();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	call	?FirstInstruction@SuperBlockConstants@@QAEXXZ ; SuperBlockConstants::FirstInstruction

; 530  :   for(i = numInstructions; i > 0; i--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@PerformCon
$LN2@PerformCon:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@PerformCon:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	SHORT $LN4@PerformCon

; 531  :   {     
; 532  :     constants->PropagateConstants();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?PropagateConstants@SuperBlockConstants@@QAEXXZ ; SuperBlockConstants::PropagateConstants

; 533  :     constants->NextInstruction();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?NextInstruction@SuperBlockConstants@@QAE_NXZ ; SuperBlockConstants::NextInstruction
	jmp	SHORT $LN2@PerformCon
$LN4@PerformCon:

; 534  :   }
; 535  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PerformConstantPropagation@SuperBlock@@QAEXXZ ENDP	; SuperBlock::PerformConstantPropagation
_TEXT	ENDS
EXTRN	?ConstantHandlers@@3PAP6AXAAVSuperBlockConstants@@@ZA:BYTE ; ConstantHandlers
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\superblockconstants.h
;	COMDAT ?PropagateConstants@SuperBlockConstants@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PropagateConstants@SuperBlockConstants@@QAEXXZ PROC	; SuperBlockConstants::PropagateConstants, COMDAT
; _this$ = ecx

; 59   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 60   :     (ConstantHandlers[pCurrentInstructionEntry->instruction.fields[0]])(*this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?ConstantHandlers@@3PAP6AXAAVSuperBlockConstants@@@ZA[eax*4]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 61   :   }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PropagateConstants@SuperBlockConstants@@QAEXXZ ENDP	; SuperBlockConstants::PropagateConstants
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?FirstInstruction@SuperBlockConstants@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FirstInstruction@SuperBlockConstants@@QAEXXZ PROC	; SuperBlockConstants::FirstInstruction, COMDAT
; _this$ = ecx

; 63   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 64   :     bConstantPropagated = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+36], 0

; 65   :     currentInstructionIndex = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 66   :     pCurrentInstructionEntry = &pSuperBlock->instructions[0];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+572]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+8], edx

; 67   :     nuance = &(pSuperBlock->instructions[0].instruction);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 68   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?FirstInstruction@SuperBlockConstants@@QAEXXZ ENDP	; SuperBlockConstants::FirstInstruction
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?NextInstruction@SuperBlockConstants@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NextInstruction@SuperBlockConstants@@QAE_NXZ PROC	; SuperBlockConstants::NextInstruction, COMDAT
; _this$ = ecx

; 70   :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 71   :     currentInstructionIndex++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 72   :     pCurrentInstructionEntry++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 73   :     nuance = &(pCurrentInstructionEntry->instruction);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 74   :     return currentInstructionIndex < pSuperBlock->numInstructions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 75   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?NextInstruction@SuperBlockConstants@@QAE_NXZ ENDP	; SuperBlockConstants::NextInstruction
; Function compile flags: /Odtp /RTCsu
_TEXT	ENDS
;	COMDAT ?ClearConstants@SuperBlockConstants@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearConstants@SuperBlockConstants@@QAEXXZ PROC	; SuperBlockConstants::ClearConstants, COMDAT
; _this$ = ecx

; 178  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 179  :     scalarRegisterConstantsStatus = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+556], 0

; 180  :     miscRegisterConstantsStatus = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], 0

; 181  :     tempScalarRegisterConstantsStatus = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], 0

; 182  :     tempMiscRegisterConstantsStatus = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+568], 0

; 183  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearConstants@SuperBlockConstants@@QAEXXZ ENDP	; SuperBlockConstants::ClearConstants
_TEXT	ENDS
PUBLIC	?PrintBlockToFile@SuperBlock@@QAEXW4SuperBlockCompileType@@I@Z ; SuperBlock::PrintBlockToFile
EXTRN	_fflush:PROC
EXTRN	?printHandlers@@3PAP6AIPADAAVNuance@@_N@ZA:BYTE	; printHandlers
EXTRN	_fprintf:PROC
; Function compile flags: /Odtp /RTCsu
; File c:\nuanceexperimental\superblock.cpp
_TEXT	SEGMENT
_j$41931 = -16						; size = 4
_handler$ = -12						; size = 4
_pCurrentInstruction$ = -8				; size = 4
_this$ = -4						; size = 4
_compileType$ = 8					; size = 4
_size$ = 12						; size = 4
?PrintBlockToFile@SuperBlock@@QAEXW4SuperBlockCompileType@@I@Z PROC ; SuperBlock::PrintBlockToFile
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 541  :   InstructionEntry *pCurrentInstruction = instructions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _pCurrentInstruction$[ebp], ecx

; 542  :   uint32 handler;
; 543  :   
; 544  :   if(!blockFile)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN23@PrintBlock

; 545  :   {
; 546  :     return;

	jmp	$LN24@PrintBlock
$LN23@PrintBlock:

; 547  :   }
; 548  : 
; 549  :   //fprintf(blockFile,"***\n");
; 550  :   fprintf(blockFile,"****************************************\n");

	push	OFFSET $SG41910
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 8

; 551  :   fprintf(blockFile,"Virtual Address: $%8lx\n",startAddress);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	push	OFFSET $SG41911
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 552  :   if(constants->bConstantPropagated)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+36]
	test	edx, edx
	je	SHORT $LN22@PrintBlock

; 553  :   {
; 554  :     fprintf(blockFile,"Constants Propagated: TRUE\n");

	push	OFFSET $SG41913
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 8

; 555  :   }
; 556  :   else

	jmp	SHORT $LN21@PrintBlock
$LN22@PrintBlock:

; 557  :   {
; 558  :     fprintf(blockFile,"Constants Propagated: FALSE\n");

	push	OFFSET $SG41915
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 8
$LN21@PrintBlock:

; 559  :   }
; 560  :   fprintf(blockFile,"Instruction Count: %li\n",numInstructions);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG41916
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 561  :   fprintf(blockFile,"Packet Count: %li\n",packetsProcessed);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET $SG41917
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 562  :   fprintf(blockFile,"Code Size: %lu bytes\n",size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET $SG41918
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 563  :   fprintf(blockFile,"Code Cache Usage: %lu bytes\n",pMPE->nativeCodeCache->GetUsedCodeBufferSize());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR [ecx+680]
	call	?GetUsedCodeBufferSize@NativeCodeCache@@QAEIXZ ; NativeCodeCache::GetUsedCodeBufferSize
	push	eax
	push	OFFSET $SG41919
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 564  :   if(compileType == SUPERBLOCKCOMPILETYPE_IL_SINGLE)

	cmp	DWORD PTR _compileType$[ebp], 1
	jne	SHORT $LN20@PrintBlock

; 565  :   {
; 566  :     fprintf(blockFile,"Compile Type: IL single\n\n");

	push	OFFSET $SG41921
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN19@PrintBlock
$LN20@PrintBlock:

; 567  :   }
; 568  :   else if(compileType == SUPERBLOCKCOMPILETYPE_IL_BLOCK)

	cmp	DWORD PTR _compileType$[ebp], 2
	jne	SHORT $LN18@PrintBlock

; 569  :   {
; 570  :     fprintf(blockFile,"Compile Type: IL block\n\n");

	push	OFFSET $SG41924
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN19@PrintBlock
$LN18@PrintBlock:

; 571  :   }
; 572  :   else if(compileType == SUPERBLOCKCOMPILETYPE_NATIVE_CODE_BLOCK)

	cmp	DWORD PTR _compileType$[ebp], 3
	jne	SHORT $LN16@PrintBlock

; 573  :   {
; 574  :     fprintf(blockFile,"Compile Type: Native block\n\n");

	push	OFFSET $SG41927
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 8

; 575  :   }
; 576  :   else

	jmp	SHORT $LN19@PrintBlock
$LN16@PrintBlock:

; 577  :   {
; 578  :     fprintf(blockFile,"Compile Type: Unknown\n\n");

	push	OFFSET $SG41929
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 8
$LN19@PrintBlock:

; 579  :   }
; 580  : 
; 581  :   if(numInstructions > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jbe	$LN14@PrintBlock

; 582  :   {
; 583  :     for(uint32 j = numInstructions; j > 0; j--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _j$41931[ebp], edx
	jmp	SHORT $LN13@PrintBlock
$LN12@PrintBlock:
	mov	eax, DWORD PTR _j$41931[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$41931[ebp], eax
$LN13@PrintBlock:
	cmp	DWORD PTR _j$41931[ebp], 0
	jbe	$LN11@PrintBlock

; 584  :     {
; 585  :       handler = pCurrentInstruction->instruction.fields[0];

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _handler$[ebp], edx

; 586  :       if((handler == Handler_PacketEnd) && (pCurrentInstruction->packet->flags & SUPERBLOCKINFO_CHECK_ECUSKIPCOUNTER))

	cmp	DWORD PTR _handler$[ebp], 220		; 000000dcH
	jne	SHORT $LN10@PrintBlock
	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 1048576				; 00100000H
	je	SHORT $LN10@PrintBlock

; 587  :       {
; 588  :         handler = Handler_CheckECUSkipCounter;

	mov	DWORD PTR _handler$[ebp], 221		; 000000ddH
$LN10@PrintBlock:

; 589  :       }
; 590  :       if(pCurrentInstruction->flags & SUPERBLOCKINFO_DEAD)

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN9@PrintBlock

; 591  :       {
; 592  :         fprintf(blockFile,"*DEAD*: ");

	push	OFFSET $SG41937
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 8
$LN9@PrintBlock:

; 593  :       }
; 594  :       (printHandlers[handler])(tempStr, pCurrentInstruction->instruction, false);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	add	ecx, 4
	push	ecx
	push	OFFSET ?tempStr@@3PADA			; tempStr
	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR ?printHandlers@@3PAP6AIPADAAVNuance@@_N@ZA[edx*4]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 595  :       fprintf(blockFile,"%s ",tempStr);

	push	OFFSET ?tempStr@@3PADA			; tempStr
	push	OFFSET $SG41938
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 596  :       if(!(pCurrentInstruction->flags & (SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_PACKETEND)))

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 393216				; 00060000H
	jne	$LN8@PrintBlock

; 597  :       //if(0)
; 598  :       {
; 599  :         fprintf(blockFile,"(ScalarInDep: $%8.8LX, MiscInDep: $%8.8LX, ScalarOutDep: $%8.8LX, MiscOutDep: $%8.8LX, ",
; 600  :           pCurrentInstruction->scalarInputDependencies,pCurrentInstruction->miscInputDependencies,
; 601  :           pCurrentInstruction->scalarOutputDependencies,pCurrentInstruction->miscOutputDependencies);

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	OFFSET $SG41940
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 24					; 00000018H

; 602  :         GetIFlagsString(tempStr,pCurrentInstruction->miscInputDependencies);

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	push	OFFSET ?tempStr@@3PADA			; tempStr
	call	?GetIFlagsString@@YAXPADI@Z		; GetIFlagsString
	add	esp, 8

; 603  :         fprintf(blockFile,"FlagsInDep: %s ",tempStr);

	push	OFFSET ?tempStr@@3PADA			; tempStr
	push	OFFSET $SG41941
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 604  :         GetIFlagsString(tempStr,pCurrentInstruction->miscOutputDependencies);

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	push	OFFSET ?tempStr@@3PADA			; tempStr
	call	?GetIFlagsString@@YAXPADI@Z		; GetIFlagsString
	add	esp, 8

; 605  :         fprintf(blockFile,"FlagsOutDep: %s)\n",tempStr);

	push	OFFSET ?tempStr@@3PADA			; tempStr
	push	OFFSET $SG41942
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	$LN7@PrintBlock
$LN8@PrintBlock:

; 606  :       }
; 607  :       else if(pCurrentInstruction->flags & SUPERBLOCKINFO_PACKETSTART)

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 262144				; 00040000H
	je	SHORT $LN6@PrintBlock

; 608  :       {
; 609  :         if(pCurrentInstruction->packet->flags & SUPERBLOCKINFO_NONATIVECOMPILE)

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 16384				; 00004000H
	je	SHORT $LN5@PrintBlock

; 610  :         {
; 611  :           fprintf(blockFile,"(IL) ");

	push	OFFSET $SG41946
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 8

; 612  :         }
; 613  :         else

	jmp	SHORT $LN4@PrintBlock
$LN5@PrintBlock:

; 614  :         {
; 615  :           fprintf(blockFile,"(NATIVE) ");

	push	OFFSET $SG41948
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN4@PrintBlock:

; 616  :         }
; 617  : 
; 618  :         if(pCurrentInstruction->flags & PACKETINFO_DEPENDENCY_PRESENT)

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 128				; 00000080H
	je	SHORT $LN3@PrintBlock

; 619  :         {
; 620  :           fprintf(blockFile,"(DEPENDENCY_PRESENT)");        

	push	OFFSET $SG41950
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 8
$LN3@PrintBlock:

; 621  :         }
; 622  :         
; 623  :         fprintf(blockFile,"\n");

	push	OFFSET $SG41951
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 8

; 624  :       }
; 625  :       else

	jmp	SHORT $LN7@PrintBlock
$LN6@PrintBlock:

; 626  :       {
; 627  :         fprintf(blockFile,"\n");

	push	OFFSET $SG41953
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 8
$LN7@PrintBlock:

; 628  :       }
; 629  :       
; 630  :       pCurrentInstruction++;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR _pCurrentInstruction$[ebp], ecx

; 631  :     }

	jmp	$LN12@PrintBlock
$LN11@PrintBlock:

; 632  :     fprintf(blockFile,"\n");

	push	OFFSET $SG41954
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 8

; 633  :   }
; 634  :   else

	jmp	SHORT $LN1@PrintBlock
$LN14@PrintBlock:

; 635  :   {
; 636  :     fprintf(blockFile,"EMPTY BLOCK\n\n");  

	push	OFFSET $SG41956
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fprintf
	add	esp, 8
$LN1@PrintBlock:

; 637  :   }
; 638  :   fprintf(blockFile,"Next Virtual Address: $%8lx\n",exitAddress);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	OFFSET $SG41957
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 639  :   fprintf(blockFile,"Next Delay Counter: $%lx\n",nextDelayCounter);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET $SG41958
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 640  :   //fprintf(blockFile,"***\n\n",tempStr);
; 641  :   fprintf(blockFile,"****************************************\n\n",tempStr);

	push	OFFSET ?tempStr@@3PADA			; tempStr
	push	OFFSET $SG41959
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 642  :   fflush(blockFile);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_fflush
	add	esp, 4
$LN24@PrintBlock:

; 643  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?PrintBlockToFile@SuperBlock@@QAEXW4SuperBlockCompileType@@I@Z ENDP ; SuperBlock::PrintBlockToFile
_TEXT	ENDS
PUBLIC	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_comboMiscOutDep$ = -24					; size = 4
_comboScalarOutDep$ = -20				; size = 4
_comboMiscInDep$ = -16					; size = 4
_comboScalarInDep$ = -12				; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
_index$ = 12						; size = 4
?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z PROC ; SuperBlock::AddPacketToList
; _this$ = ecx

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 647  :   uint32 i, comboScalarInDep, comboMiscInDep, comboScalarOutDep, comboMiscOutDep;
; 648  : 
; 649  :   packets[index].pcexec = packet.pcexec;

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+edx], ecx

; 650  :   packets[index].pcroute = packet.pcroute;

	mov	edx, DWORD PTR _index$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx+edx+4], eax

; 651  :   packets[index].pcfetchnext = packet.pcfetchnext;

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+ecx+8], edx

; 652  :   packets[index].instructionCount = packet.nuanceCount; 

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+eax+12], ecx

; 653  :   packets[index].flags = packet.packetInfo;

	mov	edx, DWORD PTR _index$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+edx+32], eax

; 654  : 
; 655  :   comboScalarInDep = 0;

	mov	DWORD PTR _comboScalarInDep$[ebp], 0

; 656  :   comboMiscInDep = 0;

	mov	DWORD PTR _comboMiscInDep$[ebp], 0

; 657  :   comboScalarOutDep = packet.scalarOutputDependencies[0];

	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR _comboScalarOutDep$[ebp], edx

; 658  :   comboMiscOutDep = packet.miscOutputDependencies[0];

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	mov	DWORD PTR _comboMiscOutDep$[ebp], ecx

; 659  : 
; 660  :   for(i = 1; i < packet.nuanceCount; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN3@AddPacketT
$LN2@AddPacketT:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@AddPacketT:
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN1@AddPacketT

; 661  :   {
; 662  :     comboScalarInDep |= (packet.scalarInputDependencies[i] & comboScalarOutDep);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+188]
	and	ecx, DWORD PTR _comboScalarOutDep$[ebp]
	or	ecx, DWORD PTR _comboScalarInDep$[ebp]
	mov	DWORD PTR _comboScalarInDep$[ebp], ecx

; 663  :     comboMiscInDep |= (packet.miscInputDependencies[i] & comboMiscOutDep);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+208]
	and	ecx, DWORD PTR _comboMiscOutDep$[ebp]
	or	ecx, DWORD PTR _comboMiscInDep$[ebp]
	mov	DWORD PTR _comboMiscInDep$[ebp], ecx

; 664  :     comboScalarOutDep |= packet.scalarOutputDependencies[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _comboScalarOutDep$[ebp]
	or	ecx, DWORD PTR [eax+edx*4+228]
	mov	DWORD PTR _comboScalarOutDep$[ebp], ecx

; 665  :     comboMiscOutDep |= packet.miscOutputDependencies[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _comboMiscOutDep$[ebp]
	or	ecx, DWORD PTR [eax+edx*4+248]
	mov	DWORD PTR _comboMiscOutDep$[ebp], ecx

; 666  :   }

	jmp	SHORT $LN2@AddPacketT
$LN1@AddPacketT:

; 667  : 
; 668  :   packets[index].comboMiscInputDependencies = comboMiscInDep;

	mov	edx, DWORD PTR _index$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _comboMiscInDep$[ebp]
	mov	DWORD PTR [ecx+edx+20], eax

; 669  :   packets[index].comboScalarInputDependencies = comboScalarInDep;

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _comboScalarInDep$[ebp]
	mov	DWORD PTR [eax+ecx+16], edx

; 670  :   packets[index].comboMiscOutputDependencies = comboMiscOutDep;

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _comboMiscOutDep$[ebp]
	mov	DWORD PTR [edx+eax+28], ecx

; 671  :   packets[index].comboScalarOutputDependencies = comboScalarOutDep;

	mov	edx, DWORD PTR _index$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _comboScalarOutDep$[ebp]
	mov	DWORD PTR [ecx+edx+24], eax

; 672  : 
; 673  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ENDP ; SuperBlock::AddPacketToList
_TEXT	ENDS
PUBLIC	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv174 = -44						; size = 4
_j$41997 = -40						; size = 4
_bCanEmitNativeCode$ = -33				; size = 1
_pCurrentInstruction$ = -32				; size = 4
_nuanceBase$ = -28					; size = 4
_comboMiscOutDep$ = -24					; size = 4
_comboScalarOutDep$ = -20				; size = 4
_comboMiscInDep$ = -16					; size = 4
_comboScalarInDep$ = -12				; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_packet$ = 8						; size = 4
_pPacketEntry$ = 12					; size = 4
_index$ = 16						; size = 4
_bExplicitNOP$ = 20					; size = 1
?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z PROC ; SuperBlock::AddInstructionsToList
; _this$ = ecx

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 677  :   uint32 i;
; 678  :   uint32 comboScalarInDep = 0;

	mov	DWORD PTR _comboScalarInDep$[ebp], 0

; 679  :   uint32 comboMiscInDep = 0;

	mov	DWORD PTR _comboMiscInDep$[ebp], 0

; 680  :   uint32 comboScalarOutDep = packet.scalarOutputDependencies[0];

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR _comboScalarOutDep$[ebp], ecx

; 681  :   uint32 comboMiscOutDep = packet.miscOutputDependencies[0];

	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+248]
	mov	DWORD PTR _comboMiscOutDep$[ebp], eax

; 682  :   uint32 nuanceBase = 0;

	mov	DWORD PTR _nuanceBase$[ebp], 0

; 683  :   InstructionEntry *pCurrentInstruction = &instructions[index];

	mov	ecx, DWORD PTR _index$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _pCurrentInstruction$[ebp], ecx

; 684  :   bool bCanEmitNativeCode = true;

	mov	BYTE PTR _bCanEmitNativeCode$[ebp], 1

; 685  : 
; 686  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[0] = Handler_PacketStart;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [eax+4], 219			; 000000dbH

; 687  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[1] = pPacketEntry->pcexec;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _pPacketEntry$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 688  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[2] = (uint32)pPacketEntry;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 689  :   pCurrentInstruction->packet = pPacketEntry;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [eax], ecx

; 690  :   pCurrentInstruction->scalarInputDependencies = pPacketEntry->comboScalarInputDependencies;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+32], ecx

; 691  :   pCurrentInstruction->miscInputDependencies = pPacketEntry->comboMiscInputDependencies;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+36], ecx

; 692  :   pCurrentInstruction->scalarOutputDependencies = pPacketEntry->comboScalarOutputDependencies;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+40], ecx

; 693  :   pCurrentInstruction->miscOutputDependencies = pPacketEntry->comboMiscOutputDependencies;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+44], ecx

; 694  :   pCurrentInstruction->flags = pPacketEntry->flags | SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_LOCKED;

	mov	edx, DWORD PTR _pPacketEntry$[ebp]
	mov	eax, DWORD PTR [edx+32]
	or	eax, 262144				; 00040000H
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 695  :   pCurrentInstruction++;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR _pCurrentInstruction$[ebp], edx

; 696  : 
; 697  :   if(bExplicitNOP && (packet.nuanceCount == 0))

	movzx	eax, BYTE PTR _bExplicitNOP$[ebp]
	test	eax, eax
	je	SHORT $LN10@AddInstruc
	mov	ecx, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN10@AddInstruc

; 698  :   {
; 699  :     packet.nuanceCount = 1;

	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [edx+20], 1

; 700  :     ((Nuance &)(packet.nuances[nuanceBase])).fields[0] = Handler_ECU_NOP;

	mov	eax, DWORD PTR _nuanceBase$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+eax*4+88], 0
$LN10@AddInstruc:

; 701  :   }
; 702  : 
; 703  :   for(i = 0; i < packet.nuanceCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@AddInstruc
$LN8@AddInstruc:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@AddInstruc:
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	$LN7@AddInstruc

; 704  :   {
; 705  :     for(uint32 j = 0; j < FIELDS_PER_NUANCE; j++)

	mov	DWORD PTR _j$41997[ebp], 0
	jmp	SHORT $LN6@AddInstruc
$LN5@AddInstruc:
	mov	edx, DWORD PTR _j$41997[ebp]
	add	edx, 1
	mov	DWORD PTR _j$41997[ebp], edx
$LN6@AddInstruc:
	cmp	DWORD PTR _j$41997[ebp], 5
	jae	SHORT $LN4@AddInstruc

; 706  :     {
; 707  :       ((Nuance &)(pCurrentInstruction->instruction)).fields[j] = ((Nuance &)(packet.nuances[nuanceBase])).fields[j];

	mov	eax, DWORD PTR _nuanceBase$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+88]
	mov	eax, DWORD PTR _j$41997[ebp]
	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	esi, DWORD PTR _j$41997[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 708  :     }

	jmp	SHORT $LN5@AddInstruc
$LN4@AddInstruc:

; 709  : 
; 710  :     if(((Nuance &)(packet.nuances[nuanceBase])).fields[FIELD_MEM_HANDLER] == Handler_LoadScalarControlRegisterAbsolute)

	mov	eax, DWORD PTR _nuanceBase$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [ecx+eax*4+88], 164		; 000000a4H
	jne	SHORT $LN3@AddInstruc

; 711  :     {
; 712  :       //Check for ld_s pcexec, Sk and replace it with mv_s <pcroute>, Sk: some programs read from pcexec
; 713  :       //which has been updated to point to the next packet prior to execution.  That is, when pcexec is
; 714  :       //read in packet N, the result is always the address of packet N+1
; 715  :       if(((Nuance &)(packet.nuances[nuanceBase])).fields[FIELD_MEM_FROM] == 0x20500070)

	mov	edx, DWORD PTR _nuanceBase$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+edx*4+100], 542113904	; 20500070H
	jne	SHORT $LN3@AddInstruc

; 716  :       {
; 717  :         ((Nuance &)(pCurrentInstruction->instruction)).fields[FIELD_MEM_HANDLER] = Handler_MV_SImmediate;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+4], 152			; 00000098H

; 718  :         ((Nuance &)(pCurrentInstruction->instruction)).fields[FIELD_MEM_FROM] = pPacketEntry->pcroute;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+16], ecx
$LN3@AddInstruc:

; 719  :       }
; 720  :     }
; 721  : 
; 722  :     bCanEmitNativeCode = bCanEmitNativeCode && ((bool)emitHandlers[((Nuance &)(packet.nuances[nuanceBase])).fields[0]]);

	movzx	edx, BYTE PTR _bCanEmitNativeCode$[ebp]
	test	edx, edx
	je	SHORT $LN13@AddInstruc
	mov	eax, DWORD PTR _nuanceBase$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+88]
	cmp	DWORD PTR ?emitHandlers@@3PAP6AXPAVEmitterVariables@@AAVNuance@@@ZA[edx*4], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@AddInstruc
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN14@AddInstruc
$LN13@AddInstruc:
	mov	DWORD PTR tv174[ebp], 0
$LN14@AddInstruc:
	mov	dl, BYTE PTR tv174[ebp]
	mov	BYTE PTR _bCanEmitNativeCode$[ebp], dl

; 723  :     pCurrentInstruction->packet = pPacketEntry;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [eax], ecx

; 724  :     pCurrentInstruction->scalarInputDependencies = packet.scalarInputDependencies[i];

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+188]
	mov	DWORD PTR [edx+32], eax

; 725  :     pCurrentInstruction->miscInputDependencies = packet.miscInputDependencies[i];

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+208]
	mov	DWORD PTR [ecx+36], edx

; 726  :     pCurrentInstruction->scalarOutputDependencies = packet.scalarOutputDependencies[i];

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+228]
	mov	DWORD PTR [eax+40], ecx

; 727  :     pCurrentInstruction->miscOutputDependencies = packet.miscOutputDependencies[i];

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+248]
	mov	DWORD PTR [edx+44], eax

; 728  :     pCurrentInstruction->flags = 0;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 729  :     nuanceBase += FIELDS_PER_NUANCE;

	mov	edx, DWORD PTR _nuanceBase$[ebp]
	add	edx, 5
	mov	DWORD PTR _nuanceBase$[ebp], edx

; 730  :     pCurrentInstruction++;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	add	eax, 56					; 00000038H
	mov	DWORD PTR _pCurrentInstruction$[ebp], eax

; 731  :   }

	jmp	$LN8@AddInstruc
$LN7@AddInstruc:

; 732  :   
; 733  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[0] = Handler_PacketEnd;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+4], 220			; 000000dcH

; 734  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[1] = pPacketEntry->pcroute;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 735  :   ((Nuance &)(pCurrentInstruction->instruction)).fields[2] = (uint32)pPacketEntry;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [edx+12], eax

; 736  :   pCurrentInstruction->packet = pPacketEntry;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [ecx], edx

; 737  :   pCurrentInstruction->scalarInputDependencies = 0;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [eax+32], 0

; 738  :   pCurrentInstruction->miscInputDependencies = 0;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 739  :   pCurrentInstruction->scalarOutputDependencies = 0;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [edx+40], 0

; 740  :   pCurrentInstruction->miscOutputDependencies = 0;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [eax+44], 0

; 741  :   pCurrentInstruction->flags = (SUPERBLOCKINFO_PACKETEND | SUPERBLOCKINFO_LOCKED);

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR [ecx+28], 196608		; 00030000H

; 742  :   if(!bCanEmitNativeCode)

	movzx	edx, BYTE PTR _bCanEmitNativeCode$[ebp]
	test	edx, edx
	jne	SHORT $LN1@AddInstruc

; 743  :   {
; 744  :     pPacketEntry->flags |= SUPERBLOCKINFO_NONATIVECOMPILE;

	mov	eax, DWORD PTR _pPacketEntry$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR _pPacketEntry$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN1@AddInstruc:

; 745  :   }
; 746  :   return bCanEmitNativeCode;

	mov	al, BYTE PTR _bCanEmitNativeCode$[ebp]

; 747  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ENDP ; SuperBlock::AddInstructionsToList
; Function compile flags: /Odtp /RTCsu
_bLocked$ = -53					; size = 1
_flags$ = -52						; size = 4
_scalarInDep$ = -48					; size = 4
_miscInDep$ = -44					; size = 4
_scalarOutDep$ = -40					; size = 4
_miscOutDep$ = -36					; size = 4
_j$ = -32						; size = 4
_numLive$ = -28						; size = 4
_miscRegMaskNext$ = -24					; size = 4
_scalarRegMaskNext$ = -20				; size = 4
_scalarRegMask$ = -16					; size = 4
_miscRegMask$ = -12					; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?PerformDeadCodeElimination@SuperBlock@@QAEIXZ PROC	; SuperBlock::PerformDeadCodeElimination
; _this$ = ecx

; 750  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 751  :   uint32 i, miscRegMask, scalarRegMask, scalarRegMaskNext, miscRegMaskNext, numLive;
; 752  :   uint32 j, miscOutDep, scalarOutDep, miscInDep, scalarInDep, flags;
; 753  :   bool bLocked;
; 754  : 
; 755  :   //scalarRegMask and miscRegMask represent all registers which do not need to be 
; 756  :   //output by the instruction being processed
; 757  : 
; 758  :   //scalarRegMaskNext and miscRegMaskNext work the same way except they aggregrate the
; 759  :   //mask values to be applied to the instructions in the next packet to be processed.  
; 760  :   //These variables would not be needed on a single (instruction) issue architecture
; 761  :   //but enclosing single instructions within packets does not add significant overhead
; 762  :   //to the compilation process.
; 763  : 
; 764  :   numLive = 0;

	mov	DWORD PTR _numLive$[ebp], 0

; 765  :   i = numInstructions - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 766  : 
; 767  :   scalarRegMask = scalarRegMaskNext = 0;

	mov	DWORD PTR _scalarRegMaskNext$[ebp], 0
	mov	edx, DWORD PTR _scalarRegMaskNext$[ebp]
	mov	DWORD PTR _scalarRegMask$[ebp], edx

; 768  :   miscRegMask = miscRegMaskNext = 0;

	mov	DWORD PTR _miscRegMaskNext$[ebp], 0
	mov	eax, DWORD PTR _miscRegMaskNext$[ebp]
	mov	DWORD PTR _miscRegMask$[ebp], eax

; 769  :  
; 770  :   for(j = numInstructions; j > 0; j--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _j$[ebp], edx
	jmp	SHORT $LN11@PerformDea
$LN10@PerformDea:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN11@PerformDea:
	cmp	DWORD PTR _j$[ebp], 0
	jbe	$LN9@PerformDea

; 771  :   {
; 772  :     flags = instructions[i].flags;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+ecx+28]
	mov	DWORD PTR _flags$[ebp], ecx

; 773  : 
; 774  :     if(!(flags & SUPERBLOCKINFO_DEAD))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 32768				; 00008000H
	jne	$LN8@PerformDea

; 775  :     {
; 776  :       numLive++;

	mov	eax, DWORD PTR _numLive$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLive$[ebp], eax

; 777  : 
; 778  :       if(!(flags & (SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_PACKETEND)))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 393216				; 00060000H
	jne	$LN7@PerformDea

; 779  :       {
; 780  :         bLocked = flags & SUPERBLOCKINFO_LOCKED;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 65536				; 00010000H
	setne	al
	mov	BYTE PTR _bLocked$[ebp], al

; 781  :         if(!bLocked)

	movzx	ecx, BYTE PTR _bLocked$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@PerformDea

; 782  :         {
; 783  :           //Remove output dependencies which are not used as inputs prior to being modified
; 784  :           instructions[i].scalarOutputDependencies &= ~scalarRegMask;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR _scalarRegMask$[ebp]
	not	eax
	and	eax, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [edx+ecx+40], eax

; 785  :           instructions[i].miscOutputDependencies &= ~miscRegMask;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _miscRegMask$[ebp]
	not	ecx
	and	ecx, DWORD PTR [edx+eax+44]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+edx+44], ecx
$LN6@PerformDea:

; 786  :         }
; 787  :        
; 788  :         scalarOutDep = instructions[i].scalarOutputDependencies;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR _scalarOutDep$[ebp], ecx

; 789  :         miscOutDep = instructions[i].miscOutputDependencies;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+edx+44]
	mov	DWORD PTR _miscOutDep$[ebp], edx

; 790  : 
; 791  :         //Keep a running total of all input dependencies for this packet
; 792  :         scalarInDep |= instructions[i].scalarInputDependencies;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _scalarInDep$[ebp]
	or	ecx, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _scalarInDep$[ebp], ecx

; 793  :         miscInDep |= (instructions[i].miscInputDependencies & DEPENDENCY_MASK_ALLMISC_NON_MEM);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+edx+36]
	and	edx, 67108863				; 03ffffffH
	or	edx, DWORD PTR _miscInDep$[ebp]
	mov	DWORD PTR _miscInDep$[ebp], edx

; 794  : 
; 795  :         //Add all registers which are modified by this instruction
; 796  :         scalarRegMaskNext |= scalarOutDep;

	mov	eax, DWORD PTR _scalarRegMaskNext$[ebp]
	or	eax, DWORD PTR _scalarOutDep$[ebp]
	mov	DWORD PTR _scalarRegMaskNext$[ebp], eax

; 797  :         miscRegMaskNext |= miscOutDep;

	mov	ecx, DWORD PTR _miscRegMaskNext$[ebp]
	or	ecx, DWORD PTR _miscOutDep$[ebp]
	mov	DWORD PTR _miscRegMaskNext$[ebp], ecx

; 798  : 
; 799  :         //Remove all registers which are input dependencies of this packet
; 800  :         scalarRegMaskNext &= ~scalarInDep;

	mov	edx, DWORD PTR _scalarInDep$[ebp]
	not	edx
	and	edx, DWORD PTR _scalarRegMaskNext$[ebp]
	mov	DWORD PTR _scalarRegMaskNext$[ebp], edx

; 801  :         miscRegMaskNext &= ~miscInDep;

	mov	eax, DWORD PTR _miscInDep$[ebp]
	not	eax
	and	eax, DWORD PTR _miscRegMaskNext$[ebp]
	mov	DWORD PTR _miscRegMaskNext$[ebp], eax

; 802  : 
; 803  :         if(!bLocked && !(scalarOutDep | miscOutDep))

	movzx	ecx, BYTE PTR _bLocked$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@PerformDea
	mov	edx, DWORD PTR _scalarOutDep$[ebp]
	or	edx, DWORD PTR _miscOutDep$[ebp]
	jne	SHORT $LN5@PerformDea

; 804  :         {
; 805  :           //If there are no output dependencies then the current instruction can be eliminated.
; 806  :           //Locked instructions must not be eliminated (e.g. memory stores to control registers)
; 807  :           numLive--;

	mov	eax, DWORD PTR _numLive$[ebp]
	sub	eax, 1
	mov	DWORD PTR _numLive$[ebp], eax

; 808  :           instructions[i].flags |= SUPERBLOCKINFO_DEAD;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax+ecx+28]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+edx+28], ecx
$LN5@PerformDea:

; 809  :         }
; 810  :       }

	jmp	SHORT $LN8@PerformDea
$LN7@PerformDea:

; 811  :       else if(flags & SUPERBLOCKINFO_PACKETEND)

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN8@PerformDea

; 812  :       {
; 813  :         if(flags & SUPERBLOCKINFO_SYNC)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 524288				; 00080000H
	je	SHORT $LN2@PerformDea

; 814  :         {
; 815  :           //When the sync flag is set, the register masks are reset so that all output dependencies are preserved.  
; 816  :           //This is primarily used when allowing superblocks to contain multiple conditional branches.
; 817  :           scalarRegMask = 0;

	mov	DWORD PTR _scalarRegMask$[ebp], 0

; 818  :           miscRegMask = 0;

	mov	DWORD PTR _miscRegMask$[ebp], 0

; 819  :         }
; 820  :         else

	jmp	SHORT $LN1@PerformDea
$LN2@PerformDea:

; 821  :         {
; 822  :           //Grab the dependency information collected from the previously processed packet
; 823  :           scalarRegMask = scalarRegMaskNext;

	mov	eax, DWORD PTR _scalarRegMaskNext$[ebp]
	mov	DWORD PTR _scalarRegMask$[ebp], eax

; 824  :           miscRegMask = miscRegMaskNext;

	mov	ecx, DWORD PTR _miscRegMaskNext$[ebp]
	mov	DWORD PTR _miscRegMask$[ebp], ecx
$LN1@PerformDea:

; 825  :         }
; 826  : 
; 827  :         scalarInDep = 0;

	mov	DWORD PTR _scalarInDep$[ebp], 0

; 828  :         miscInDep = 0;

	mov	DWORD PTR _miscInDep$[ebp], 0

; 829  :         //The initial state of the the masks for the packet above the current one should be the same as the initial state for the current
; 830  :         //packet.  This is because the masks indicate which dependencies a packet does not need to update: assuming the current packet is empty
; 831  :         //then the dependencies haven't changed.
; 832  : 
; 833  :         scalarRegMaskNext = scalarRegMask;

	mov	edx, DWORD PTR _scalarRegMask$[ebp]
	mov	DWORD PTR _scalarRegMaskNext$[ebp], edx

; 834  :         miscRegMaskNext = miscRegMask;

	mov	eax, DWORD PTR _miscRegMask$[ebp]
	mov	DWORD PTR _miscRegMaskNext$[ebp], eax
$LN8@PerformDea:

; 835  :       }
; 836  :     }
; 837  :   
; 838  :     i--;

	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 839  :   }

	jmp	$LN10@PerformDea
$LN9@PerformDea:

; 840  : 
; 841  :   return numLive;

	mov	eax, DWORD PTR _numLive$[ebp]

; 842  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?PerformDeadCodeElimination@SuperBlock@@QAEIXZ ENDP	; SuperBlock::PerformDeadCodeElimination
_TEXT	ENDS
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
$T44303 = -47						; size = 1
$T44302 = -46						; size = 1
$T44301 = -45						; size = 1
_pCurrentInstruction$ = -44				; size = 4
_pCurrentPacket$ = -40					; size = 4
_flags$ = -36						; size = 4
_scalarOpDep$ = -32					; size = 4
_miscOpDep$ = -28					; size = 4
_scalarOutDep$ = -24					; size = 4
_scalarInDep$ = -20					; size = 4
_miscOutDep$ = -16					; size = 4
_miscInDep$ = -12					; size = 4
_j$ = -8						; size = 4
_this$ = -4						; size = 4
?UpdateDependencyInfo@SuperBlock@@QAEXXZ PROC		; SuperBlock::UpdateDependencyInfo
; _this$ = ecx

; 845  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T44303[ebp], 0
	mov	BYTE PTR $T44301[ebp], 0
	mov	BYTE PTR $T44302[ebp], 0

; 846  :   uint32 j, miscInDep, miscOutDep, scalarInDep, scalarOutDep, miscOpDep, scalarOpDep, flags;
; 847  :   InstructionEntry *pCurrentPacket, *pCurrentInstruction;
; 848  : 
; 849  :   pCurrentInstruction = instructions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _pCurrentInstruction$[ebp], ecx

; 850  :   for(j = numInstructions; j > 0; j--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN9@UpdateDepe
$LN8@UpdateDepe:
	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN9@UpdateDepe:
	cmp	DWORD PTR _j$[ebp], 0
	jbe	$LN10@UpdateDepe

; 851  :   {
; 852  :     flags = pCurrentInstruction->flags;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _flags$[ebp], eax

; 853  :     if(!(flags & SUPERBLOCKINFO_DEAD))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 32768				; 00008000H
	jne	$LN6@UpdateDepe

; 854  :     {
; 855  :       if(!(flags & (SUPERBLOCKINFO_PACKETSTART | SUPERBLOCKINFO_PACKETEND)))

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 393216				; 00060000H
	jne	$LN5@UpdateDepe

; 856  :       {
; 857  :         //Set flags for dependencies of the current instruction where the
; 858  :         //input registers were output dependencies of previous instructions in
; 859  :         //the packet
; 860  :         scalarOpDep |= (pCurrentInstruction->scalarInputDependencies & scalarOutDep);

	cmp	BYTE PTR $T44301[ebp], 0
	jne	SHORT $LN12@UpdateDepe
	push	OFFSET $LN13@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN12@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, DWORD PTR _scalarOutDep$[ebp]
	or	ecx, DWORD PTR _scalarOpDep$[ebp]
	mov	DWORD PTR _scalarOpDep$[ebp], ecx

; 861  :         miscOpDep |= (pCurrentInstruction->miscInputDependencies & miscOutDep);

	cmp	BYTE PTR $T44302[ebp], 0
	jne	SHORT $LN14@UpdateDepe
	push	OFFSET $LN15@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN14@UpdateDepe:
	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, DWORD PTR _miscOutDep$[ebp]
	or	eax, DWORD PTR _miscOpDep$[ebp]
	mov	DWORD PTR _miscOpDep$[ebp], eax

; 862  :         
; 863  :         //Add output dependencies of the current instruction to the 
; 864  :         //aggregate output dependency flags
; 865  :         scalarOutDep |= pCurrentInstruction->scalarOutputDependencies;

	cmp	BYTE PTR $T44301[ebp], 0
	jne	SHORT $LN16@UpdateDepe
	push	OFFSET $LN13@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN16@UpdateDepe:
	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _scalarOutDep$[ebp]
	or	edx, DWORD PTR [ecx+40]
	mov	BYTE PTR $T44301[ebp], 1
	mov	DWORD PTR _scalarOutDep$[ebp], edx

; 866  :         miscOutDep |= pCurrentInstruction->miscOutputDependencies;

	cmp	BYTE PTR $T44302[ebp], 0
	jne	SHORT $LN17@UpdateDepe
	push	OFFSET $LN15@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN17@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	mov	ecx, DWORD PTR _miscOutDep$[ebp]
	or	ecx, DWORD PTR [eax+44]
	mov	BYTE PTR $T44302[ebp], 1
	mov	DWORD PTR _miscOutDep$[ebp], ecx

; 867  :         
; 868  :         //Aggregate input dependencies for the heck of it
; 869  :         scalarInDep |= pCurrentInstruction->scalarInputDependencies;

	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	eax, DWORD PTR _scalarInDep$[ebp]
	or	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _scalarInDep$[ebp], eax

; 870  :         miscInDep |= pCurrentInstruction->miscInputDependencies;

	mov	ecx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	edx, DWORD PTR _miscInDep$[ebp]
	or	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _miscInDep$[ebp], edx

; 871  : 
; 872  :         pCurrentPacket->packet->liveCount++;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN18@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN18@UpdateDepe:
	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN20@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN20@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+36], edx

; 873  :       }
; 874  :       else

	jmp	$LN6@UpdateDepe
$LN5@UpdateDepe:

; 875  :       {
; 876  :         if(flags & SUPERBLOCKINFO_PACKETSTART)

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 262144				; 00040000H
	je	$LN3@UpdateDepe

; 877  :         {
; 878  :           //Reset aggregate dependency flags and set the packet pointer to this PacketStart node
; 879  :           scalarInDep = scalarOutDep = miscInDep = miscOutDep = scalarOpDep = miscOpDep = 0;

	mov	DWORD PTR _miscOpDep$[ebp], 0
	mov	eax, DWORD PTR _miscOpDep$[ebp]
	mov	DWORD PTR _scalarOpDep$[ebp], eax
	mov	BYTE PTR $T44302[ebp], 1
	mov	ecx, DWORD PTR _scalarOpDep$[ebp]
	mov	DWORD PTR _miscOutDep$[ebp], ecx
	cmp	BYTE PTR $T44302[ebp], 0
	jne	SHORT $LN21@UpdateDepe
	push	OFFSET $LN15@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN21@UpdateDepe:
	mov	edx, DWORD PTR _miscOutDep$[ebp]
	mov	DWORD PTR _miscInDep$[ebp], edx
	mov	BYTE PTR $T44301[ebp], 1
	mov	eax, DWORD PTR _miscInDep$[ebp]
	mov	DWORD PTR _scalarOutDep$[ebp], eax
	cmp	BYTE PTR $T44301[ebp], 0
	jne	SHORT $LN22@UpdateDepe
	push	OFFSET $LN13@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN22@UpdateDepe:
	mov	ecx, DWORD PTR _scalarOutDep$[ebp]
	mov	DWORD PTR _scalarInDep$[ebp], ecx

; 880  :           pCurrentPacket = pCurrentInstruction;

	mov	BYTE PTR $T44303[ebp], 1
	mov	edx, DWORD PTR _pCurrentInstruction$[ebp]
	mov	DWORD PTR _pCurrentPacket$[ebp], edx

; 881  :           pCurrentPacket->packet->liveCount = 0;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN23@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN23@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+36], 0

; 882  :         }
; 883  :         else

	jmp	$LN6@UpdateDepe
$LN3@UpdateDepe:

; 884  :         {
; 885  :           //Now that the PacketEnd node was reached, store the aggregated packet
; 886  :           //dependency information back to the last PacketStart node
; 887  :           pCurrentPacket->scalarInputDependencies = scalarInDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN24@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN24@UpdateDepe:
	mov	edx, DWORD PTR _pCurrentPacket$[ebp]
	mov	eax, DWORD PTR _scalarInDep$[ebp]
	mov	DWORD PTR [edx+32], eax

; 888  :           pCurrentPacket->scalarOutputDependencies = scalarOutDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN25@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN25@UpdateDepe:
	cmp	BYTE PTR $T44301[ebp], 0
	jne	SHORT $LN26@UpdateDepe
	push	OFFSET $LN13@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN26@UpdateDepe:
	mov	ecx, DWORD PTR _pCurrentPacket$[ebp]
	mov	edx, DWORD PTR _scalarOutDep$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 889  :           pCurrentPacket->miscInputDependencies = miscInDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN27@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN27@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR _miscInDep$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 890  :           pCurrentPacket->miscOutputDependencies = miscOutDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN28@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN28@UpdateDepe:
	cmp	BYTE PTR $T44302[ebp], 0
	jne	SHORT $LN29@UpdateDepe
	push	OFFSET $LN15@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN29@UpdateDepe:
	mov	edx, DWORD PTR _pCurrentPacket$[ebp]
	mov	eax, DWORD PTR _miscOutDep$[ebp]
	mov	DWORD PTR [edx+44], eax

; 891  :           pCurrentPacket->scalarOpDependencies = scalarOpDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN30@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN30@UpdateDepe:
	mov	ecx, DWORD PTR _pCurrentPacket$[ebp]
	mov	edx, DWORD PTR _scalarOpDep$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 892  :           pCurrentPacket->miscOpDependencies = miscOpDep;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN31@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN31@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR _miscOpDep$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 893  :           pCurrentPacket->flags &= (~PACKETINFO_DEPENDENCY_PRESENT);

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN32@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN32@UpdateDepe:
	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN33@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN33@UpdateDepe:
	mov	edx, DWORD PTR _pCurrentPacket$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -129				; ffffff7fH
	mov	ecx, DWORD PTR _pCurrentPacket$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 894  :           if(scalarOpDep | miscOpDep)

	mov	edx, DWORD PTR _scalarOpDep$[ebp]
	or	edx, DWORD PTR _miscOpDep$[ebp]
	je	SHORT $LN6@UpdateDepe

; 895  :           {
; 896  :             pCurrentPacket->flags |= PACKETINFO_DEPENDENCY_PRESENT;

	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN34@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN34@UpdateDepe:
	cmp	BYTE PTR $T44303[ebp], 0
	jne	SHORT $LN35@UpdateDepe
	push	OFFSET $LN19@UpdateDepe
	call	__RTC_UninitUse
	add	esp, 4
$LN35@UpdateDepe:
	mov	eax, DWORD PTR _pCurrentPacket$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _pCurrentPacket$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN6@UpdateDepe:

; 897  :           }
; 898  :         }
; 899  :       }
; 900  :     }
; 901  :     pCurrentInstruction++;

	mov	eax, DWORD PTR _pCurrentInstruction$[ebp]
	add	eax, 56					; 00000038H
	mov	DWORD PTR _pCurrentInstruction$[ebp], eax
	jmp	$LN8@UpdateDepe
$LN10@UpdateDepe:

; 902  :   }
; 903  : }

	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@UpdateDepe:
$LN19@UpdateDepe:
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN15@UpdateDepe:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	79					; 0000004fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
$LN13@UpdateDepe:
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	79					; 0000004fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	0
?UpdateDependencyInfo@SuperBlock@@QAEXXZ ENDP		; SuperBlock::UpdateDependencyInfo
_TEXT	ENDS
EXTRN	?DecompressPacket@MPE@@QAEXPAEPAVInstructionCacheEntry@@I@Z:PROC ; MPE::DecompressPacket
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv357 = -864						; size = 4
tv327 = -860						; size = 4
tv291 = -856						; size = 4
tv257 = -852						; size = 4
tv189 = -848						; size = 4
_bForceILBlock$ = -843					; size = 1
_bFirstNonNOPReached$ = -842				; size = 1
_bPacketAllowsNativeCode$ = -841			; size = 1
_decodeOptions$ = -840					; size = 4
_packetCounter$ = -836					; size = 4
_packetDelaySlot2$ = -828				; size = 268
_packetDelaySlot1$ = -552				; size = 268
_packet$ = -276						; size = 268
_this$ = -4						; size = 4
_mpe$ = 8						; size = 4
_packetAddress$ = 12					; size = 4
_bContainsBranch$ = 16					; size = 4
?FetchSuperBlock@SuperBlock@@QAEHAAVMPE@@IAA_N@Z PROC	; SuperBlock::FetchSuperBlock
; _this$ = ecx

; 908  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 864				; 00000360H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-864]
	mov	ecx, 216				; 000000d8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 909  :   InstructionCacheEntry packet, packetDelaySlot1, packetDelaySlot2;
; 910  :   int32 packetCounter;
; 911  :   uint32 decodeOptions = (DECOMPRESS_OPTIONS_SCHEDULE_ECU_LAST | DECOMPRESS_OPTIONS_SCHEDULE_MEM_FIRST);

	mov	DWORD PTR _decodeOptions$[ebp], 3

; 912  :   bCanEmitNativeCode = ALLOW_NATIVE_CODE_EMIT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+60], 1

; 913  :   bool bPacketAllowsNativeCode;
; 914  :   bool bFirstNonNOPReached = false;

	mov	BYTE PTR _bFirstNonNOPReached$[ebp], 0

; 915  :   bool bForceILBlock = false;

	mov	BYTE PTR _bForceILBlock$[ebp], 0

; 916  :   
; 917  :   bContainsBranch = false;

	mov	ecx, DWORD PTR _bContainsBranch$[ebp]
	mov	BYTE PTR [ecx], 0

; 918  : 
; 919  :   nextDelayCounter = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 920  :   numPackets = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 921  :   numInstructions = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 922  : 
; 923  :   startAddress = packetAddress;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR [edx+40], eax

; 924  :   exitAddress = packetAddress;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 925  : 
; 926  :   //If the starting address is in the imaginary overlay region (0x20308000,0x2FF07FFF), mask the ending address so that it is within
; 927  :   //the real IRAM region of (20300000,20307FFF).  The starting address should not be modified as it is used as the lookup key.
; 928  : 
; 929  :   if((startAddress < MPE1_ADDR_BASE) && (startAddress >= (MPE_IRAM_BASE + OVERLAY_SIZE)))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 545259520		; 20800000H
	jae	SHORT $LN34@FetchSuper
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 540024832		; 20302000H
	jb	SHORT $LN34@FetchSuper

; 930  :   {
; 931  :     exitAddress = packetAddress = (packetAddress & (0xFFF00000 | (OVERLAY_SIZE - 1)));

	mov	edx, DWORD PTR _packetAddress$[ebp]
	and	edx, -1040385				; fff01fffH
	mov	DWORD PTR _packetAddress$[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR [eax+44], ecx
$LN34@FetchSuper:

; 932  :   }
; 933  : 
; 934  :   packetsProcessed = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 935  : 
; 936  :   if(bSinglePacket)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN33@FetchSuper

; 937  :   {
; 938  :     packetCounter = 1;

	mov	DWORD PTR _packetCounter$[ebp], 1

; 939  :   }
; 940  :   else

	jmp	SHORT $LN31@FetchSuper
$LN33@FetchSuper:

; 941  :   {
; 942  :     packetCounter = maxPacketsPerSuperBlock;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _packetCounter$[ebp], eax
$LN31@FetchSuper:

; 943  :   }
; 944  : 
; 945  :   //if(startAddress == 0x800265e0)
; 946  :   {
; 947  :     //startAddress = 0x800265e0;
; 948  :   }
; 949  : 
; 950  :   while(packetCounter > 0)

	cmp	DWORD PTR _packetCounter$[ebp], 0
	jle	$LN30@FetchSuper

; 951  :   {
; 952  :     packet.pcexec = packetAddress;

	mov	ecx, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR _packet$[ebp+28], ecx

; 953  : 
; 954  :     mpe.DecompressPacket((uint8 *)nuonEnv->GetPointerToMemory(&mpe,packetAddress,false),&packet, decodeOptions);

	mov	edx, DWORD PTR _decodeOptions$[ebp]
	push	edx
	lea	eax, DWORD PTR _packet$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _packetAddress$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpe$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?DecompressPacket@MPE@@QAEXPAEPAVInstructionCacheEntry@@I@Z ; MPE::DecompressPacket

; 955  :     packetAddress = packet.pcroute;

	mov	eax, DWORD PTR _packet$[ebp+76]
	mov	DWORD PTR _packetAddress$[ebp], eax

; 956  : 
; 957  :     packetsProcessed++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 958  : 
; 959  :     if(!(packet.packetInfo & PACKETINFO_NOP) && (packet.nuanceCount != 0))

	mov	ecx, DWORD PTR _packet$[ebp+24]
	and	ecx, 1
	jne	$LN29@FetchSuper
	cmp	DWORD PTR _packet$[ebp+20], 0
	je	$LN29@FetchSuper

; 960  :     {
; 961  :       //Packet is not a NOP nor is it a packet containing a single inhibited ECU instruction: 
; 962  :       //check to see if it contains a breakpoint or is marked as non-compilable
; 963  : 
; 964  :       if(!((packet.packetInfo & (PACKETINFO_NEVERCOMPILE | PACKETINFO_BREAKPOINT))))

	mov	edx, DWORD PTR _packet$[ebp+24]
	and	edx, 1073741826				; 40000002H
	jne	$non_compilable_packet$42095

; 965  :       {
; 966  :         //Packet does not contain a NOP: add the packet to the packet list and add the instructions to the instruction list
; 967  : 
; 968  :         if(packet.packetInfo & (PACKETINFO_BRANCH_CONDITIONAL | PACKETINFO_BRANCH_ALWAYS | PACKETINFO_BRANCH_NOP))

	mov	eax, DWORD PTR _packet$[ebp+24]
	and	eax, 234881024				; 0e000000H
	je	$LN27@FetchSuper

; 969  :         {
; 970  :           //Packet contains a branch instruction.  Non-delayed branches are fine.  Delayed branches can only be compiled if
; 971  :           //the delay slot packets do not contain additional branch instructions, indirect memory operations or direct memory
; 972  :           //operations on the control registers.
; 973  : 
; 974  :           bContainsBranch = true;

	mov	ecx, DWORD PTR _bContainsBranch$[ebp]
	mov	BYTE PTR [ecx], 1

; 975  : 
; 976  :           if(packet.packetInfo & PACKETINFO_BRANCH_ALWAYS)

	mov	edx, DWORD PTR _packet$[ebp+24]
	and	edx, 134217728				; 08000000H
	je	SHORT $LN26@FetchSuper

; 977  :           {
; 978  :             decodeOptions |= DECOMPRESS_OPTIONS_INHIBIT_ECU;

	mov	eax, DWORD PTR _decodeOptions$[ebp]
	or	eax, 4
	mov	DWORD PTR _decodeOptions$[ebp], eax
$LN26@FetchSuper:

; 979  :           }
; 980  : 
; 981  :           //if(!IsBranchConditionCompilable(startAddress, mpe.mpeIndex, packet.ecuConditionCode))// || (numPackets != 0))
; 982  :           //{
; 983  :           //  goto non_compilable_packet;
; 984  :           //}
; 985  : 
; 986  :           if(!(packet.packetInfo & PACKETINFO_BRANCH_NOP))

	mov	ecx, DWORD PTR _packet$[ebp+24]
	and	ecx, 33554432				; 02000000H
	jne	$LN25@FetchSuper

; 987  :           {
; 988  :             //Delayed branch with explicit delay slot instructions
; 989  :             packetDelaySlot1.pcexec = packetAddress;

	mov	edx, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR _packetDelaySlot1$[ebp+28], edx

; 990  :             mpe.DecompressPacket((uint8 *)nuonEnv->GetPointerToMemory(&mpe,packetAddress,false),&packetDelaySlot1, decodeOptions);

	mov	eax, DWORD PTR _decodeOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetDelaySlot1$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _packetAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?DecompressPacket@MPE@@QAEXPAEPAVInstructionCacheEntry@@I@Z ; MPE::DecompressPacket

; 991  :             packetAddress = packetDelaySlot1.pcroute;

	mov	ecx, DWORD PTR _packetDelaySlot1$[ebp+76]
	mov	DWORD PTR _packetAddress$[ebp], ecx

; 992  :             packetDelaySlot2.pcexec = packetAddress;

	mov	edx, DWORD PTR _packetAddress$[ebp]
	mov	DWORD PTR _packetDelaySlot2$[ebp+28], edx

; 993  :             mpe.DecompressPacket((uint8 *)nuonEnv->GetPointerToMemory(&mpe,packetAddress,false),&packetDelaySlot2, decodeOptions);

	mov	eax, DWORD PTR _decodeOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packetDelaySlot2$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _packetAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	call	?DecompressPacket@MPE@@QAEXPAEPAVInstructionCacheEntry@@I@Z ; MPE::DecompressPacket

; 994  :             packet.packetInfo |= SUPERBLOCKINFO_CHECK_ECUSKIPCOUNTER;

	mov	ecx, DWORD PTR _packet$[ebp+24]
	or	ecx, 1048576				; 00100000H
	mov	DWORD PTR _packet$[ebp+24], ecx

; 995  :             packetDelaySlot1.packetInfo |= SUPERBLOCKINFO_CHECK_ECUSKIPCOUNTER;

	mov	edx, DWORD PTR _packetDelaySlot1$[ebp+24]
	or	edx, 1048576				; 00100000H
	mov	DWORD PTR _packetDelaySlot1$[ebp+24], edx

; 996  :             packetDelaySlot2.packetInfo |= SUPERBLOCKINFO_CHECK_ECUSKIPCOUNTER;

	mov	eax, DWORD PTR _packetDelaySlot2$[ebp+24]
	or	eax, 1048576				; 00100000H
	mov	DWORD PTR _packetDelaySlot2$[ebp+24], eax

; 997  : 
; 998  :             packetAddress = packetDelaySlot2.pcroute;

	mov	ecx, DWORD PTR _packetDelaySlot2$[ebp+76]
	mov	DWORD PTR _packetAddress$[ebp], ecx

; 999  : 
; 1000 :             if(((packetDelaySlot1.packetInfo|packetDelaySlot2.packetInfo) & (PACKETINFO_MEMORY_IO|PACKETINFO_MEMORY_INDIRECT|PACKETINFO_ECU|PACKETINFO_NEVERCOMPILE)))

	mov	edx, DWORD PTR _packetDelaySlot1$[ebp+24]
	or	edx, DWORD PTR _packetDelaySlot2$[ebp+24]
	and	edx, 1098907652				; 41800004H
	je	SHORT $LN24@FetchSuper

; 1001 :             {
; 1002 :               if(!bFirstNonNOPReached)

	movzx	eax, BYTE PTR _bFirstNonNOPReached$[ebp]
	test	eax, eax
	jne	SHORT $LN23@FetchSuper
	jmp	$non_compilable_packet$42095

; 1003 :               {
; 1004 :                 goto non_compilable_packet;

	jmp	$non_compilable_packet$42095

; 1005 :                 bForceILBlock = true;

	mov	BYTE PTR _bForceILBlock$[ebp], 1

; 1006 :               }
; 1007 :               else

	jmp	SHORT $LN24@FetchSuper
$LN23@FetchSuper:

; 1008 :               {
; 1009 :                 goto non_compilable_packet;

	jmp	$non_compilable_packet$42095
	jmp	$non_compilable_packet$42095
$LN24@FetchSuper:

; 1010 :               }
; 1011 :             }
; 1012 :  
; 1013 :             if(!((packetDelaySlot1.packetInfo|packetDelaySlot2.packetInfo) & (PACKETINFO_MEMORY_IO|PACKETINFO_MEMORY_INDIRECT|PACKETINFO_ECU|PACKETINFO_NEVERCOMPILE)) 
; 1014 :               || bForceILBlock)

	mov	ecx, DWORD PTR _packetDelaySlot1$[ebp+24]
	or	ecx, DWORD PTR _packetDelaySlot2$[ebp+24]
	and	ecx, 1098907652				; 41800004H
	je	SHORT $LN18@FetchSuper
	movzx	edx, BYTE PTR _bForceILBlock$[ebp]
	test	edx, edx
	je	$LN19@FetchSuper
$LN18@FetchSuper:

; 1015 :             {
; 1016 :               AddPacketToList(packet,numPackets);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	lea	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList

; 1017 :               bPacketAllowsNativeCode = AddInstructionsToList(packet,&packets[numPackets],numInstructions);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	push	eax
	lea	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
	mov	BYTE PTR _bPacketAllowsNativeCode$[ebp], al

; 1018 :               bCanEmitNativeCode = bCanEmitNativeCode && bPacketAllowsNativeCode;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN37@FetchSuper
	movzx	edx, BYTE PTR _bPacketAllowsNativeCode$[ebp]
	test	edx, edx
	je	SHORT $LN37@FetchSuper
	mov	DWORD PTR tv189[ebp], 1
	jmp	SHORT $LN38@FetchSuper
$LN37@FetchSuper:
	mov	DWORD PTR tv189[ebp], 0
$LN38@FetchSuper:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv189[ebp]
	mov	BYTE PTR [eax+60], cl

; 1019 :               numInstructions += (packet.nuanceCount + 2);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _packet$[ebp+20]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1020 :               numPackets++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1021 :               packetCounter--;

	mov	ecx, DWORD PTR _packetCounter$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _packetCounter$[ebp], ecx

; 1022 : 
; 1023 :               if(bForceILBlock)
; 1024 :               {
; 1025 :                 //goto force_il_block;
; 1026 :               }
; 1027 : 
; 1028 :               if((!(packetDelaySlot1.packetInfo & PACKETINFO_NOP) && (packetDelaySlot1.nuanceCount != 0)) || bForceILBlock)

	mov	eax, DWORD PTR _packetDelaySlot1$[ebp+24]
	and	eax, 1
	jne	SHORT $LN14@FetchSuper
	cmp	DWORD PTR _packetDelaySlot1$[ebp+20], 0
	jne	SHORT $LN15@FetchSuper
$LN14@FetchSuper:
	movzx	ecx, BYTE PTR _bForceILBlock$[ebp]
	test	ecx, ecx
	je	$LN16@FetchSuper
$LN15@FetchSuper:

; 1029 :               {
; 1030 :                 AddPacketToList(packetDelaySlot1,numPackets);              

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _packetDelaySlot1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList

; 1031 :                 bPacketAllowsNativeCode = AddInstructionsToList(packetDelaySlot1,&packets[numPackets],numInstructions,bForceILBlock);

	mov	dl, BYTE PTR _bForceILBlock$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	push	eax
	lea	edx, DWORD PTR _packetDelaySlot1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
	mov	BYTE PTR _bPacketAllowsNativeCode$[ebp], al

; 1032 :                 bCanEmitNativeCode = bCanEmitNativeCode && bPacketAllowsNativeCode;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN39@FetchSuper
	movzx	edx, BYTE PTR _bPacketAllowsNativeCode$[ebp]
	test	edx, edx
	je	SHORT $LN39@FetchSuper
	mov	DWORD PTR tv257[ebp], 1
	jmp	SHORT $LN40@FetchSuper
$LN39@FetchSuper:
	mov	DWORD PTR tv257[ebp], 0
$LN40@FetchSuper:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv257[ebp]
	mov	BYTE PTR [eax+60], cl

; 1033 :                 numInstructions += (packetDelaySlot1.nuanceCount + 2);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _packetDelaySlot1$[ebp+20]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1034 :                 numPackets++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN16@FetchSuper:

; 1035 :               }
; 1036 :               packetCounter--;

	mov	ecx, DWORD PTR _packetCounter$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _packetCounter$[ebp], ecx

; 1037 : 
; 1038 :               if((!(packetDelaySlot2.packetInfo & PACKETINFO_NOP) && (packetDelaySlot2.nuanceCount != 0)) || bForceILBlock)

	mov	edx, DWORD PTR _packetDelaySlot2$[ebp+24]
	and	edx, 1
	jne	SHORT $LN11@FetchSuper
	cmp	DWORD PTR _packetDelaySlot2$[ebp+20], 0
	jne	SHORT $LN12@FetchSuper
$LN11@FetchSuper:
	movzx	eax, BYTE PTR _bForceILBlock$[ebp]
	test	eax, eax
	je	$LN13@FetchSuper
$LN12@FetchSuper:

; 1039 :               {
; 1040 :                 AddPacketToList(packetDelaySlot2,numPackets);              

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _packetDelaySlot2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList

; 1041 :                 bPacketAllowsNativeCode = AddInstructionsToList(packetDelaySlot2,&packets[numPackets],numInstructions,bForceILBlock);

	mov	cl, BYTE PTR _bForceILBlock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	lea	ecx, DWORD PTR _packetDelaySlot2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
	mov	BYTE PTR _bPacketAllowsNativeCode$[ebp], al

; 1042 :                 bCanEmitNativeCode = bCanEmitNativeCode && bPacketAllowsNativeCode;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	test	eax, eax
	je	SHORT $LN41@FetchSuper
	movzx	ecx, BYTE PTR _bPacketAllowsNativeCode$[ebp]
	test	ecx, ecx
	je	SHORT $LN41@FetchSuper
	mov	DWORD PTR tv291[ebp], 1
	jmp	SHORT $LN42@FetchSuper
$LN41@FetchSuper:
	mov	DWORD PTR tv291[ebp], 0
$LN42@FetchSuper:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv291[ebp]
	mov	BYTE PTR [edx+60], al

; 1043 :                 numInstructions += (packetDelaySlot2.nuanceCount + 2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _packetDelaySlot2$[ebp+20]
	lea	ecx, DWORD PTR [eax+edx+2]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 1044 :                 numPackets++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN13@FetchSuper:

; 1045 :               }
; 1046 :               packetCounter--;

	mov	eax, DWORD PTR _packetCounter$[ebp]
	sub	eax, 1
	mov	DWORD PTR _packetCounter$[ebp], eax

; 1047 : 
; 1048 :               packetsProcessed += 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1049 :               packetCounter = 0;

	mov	DWORD PTR _packetCounter$[ebp], 0

; 1050 : 
; 1051 :               exitAddress = packetDelaySlot2.pcroute;           

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _packetDelaySlot2$[ebp+76]
	mov	DWORD PTR [ecx+44], edx
$force_il_block$42108:

; 1052 : force_il_block:
; 1053 :               if(bForceILBlock)

	movzx	eax, BYTE PTR _bForceILBlock$[ebp]
	test	eax, eax
	je	SHORT $LN10@FetchSuper

; 1054 :               {
; 1055 :                 bCanEmitNativeCode = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+60], 0
$LN10@FetchSuper:

; 1056 :               }
; 1057 :               break;

	jmp	$LN30@FetchSuper

; 1058 :             }
; 1059 :             else

	jmp	SHORT $LN9@FetchSuper
$LN19@FetchSuper:

; 1060 :             {
; 1061 :               goto non_compilable_packet;

	jmp	$non_compilable_packet$42095
	jmp	$non_compilable_packet$42095
$LN9@FetchSuper:

; 1062 :             }
; 1063 :           }
; 1064 :           else

	jmp	$LN27@FetchSuper
$LN25@FetchSuper:

; 1065 :           {
; 1066 :             //Delayed branch with implicit NOP
; 1067 :             AddPacketToList(packet,numPackets);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _packet$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList

; 1068 :             bPacketAllowsNativeCode = AddInstructionsToList(packet,&packets[numPackets],numInstructions);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	lea	ecx, DWORD PTR _packet$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
	mov	BYTE PTR _bPacketAllowsNativeCode$[ebp], al

; 1069 :             bCanEmitNativeCode = bCanEmitNativeCode && bPacketAllowsNativeCode;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	test	eax, eax
	je	SHORT $LN43@FetchSuper
	movzx	ecx, BYTE PTR _bPacketAllowsNativeCode$[ebp]
	test	ecx, ecx
	je	SHORT $LN43@FetchSuper
	mov	DWORD PTR tv327[ebp], 1
	jmp	SHORT $LN44@FetchSuper
$LN43@FetchSuper:
	mov	DWORD PTR tv327[ebp], 0
$LN44@FetchSuper:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv327[ebp]
	mov	BYTE PTR [edx+60], al

; 1070 :             //Increment numInstructions by nuance count and add two to account for PacketStart and PacketEnd
; 1071 :             numInstructions += (packet.nuanceCount + 2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _packet$[ebp+20]
	lea	ecx, DWORD PTR [eax+edx+2]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 1072 :             //Increment packet count
; 1073 :             numPackets++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1074 :             packetCounter--;

	mov	eax, DWORD PTR _packetCounter$[ebp]
	sub	eax, 1
	mov	DWORD PTR _packetCounter$[ebp], eax

; 1075 :             //Update the exit address
; 1076 :             exitAddress = packet.pcroute;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _packet$[ebp+76]
	mov	DWORD PTR [ecx+44], edx

; 1077 :             break;

	jmp	$LN30@FetchSuper
$LN27@FetchSuper:

; 1078 :           }
; 1079 :         }
; 1080 : 
; 1081 :         bFirstNonNOPReached = true;

	mov	BYTE PTR _bFirstNonNOPReached$[ebp], 1

; 1082 : 
; 1083 :         AddPacketToList(packet,numPackets);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	lea	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToList@SuperBlock@@QAEXAAVInstructionCacheEntry@@I@Z ; SuperBlock::AddPacketToList

; 1084 :         bPacketAllowsNativeCode = AddInstructionsToList(packet,&packets[numPackets],numInstructions);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	push	eax
	lea	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInstructionsToList@SuperBlock@@QAE_NAAVInstructionCacheEntry@@PAUPacketEntry@@I_N@Z ; SuperBlock::AddInstructionsToList
	mov	BYTE PTR _bPacketAllowsNativeCode$[ebp], al

; 1085 :         bCanEmitNativeCode = bCanEmitNativeCode && bPacketAllowsNativeCode;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN45@FetchSuper
	movzx	edx, BYTE PTR _bPacketAllowsNativeCode$[ebp]
	test	edx, edx
	je	SHORT $LN45@FetchSuper
	mov	DWORD PTR tv357[ebp], 1
	jmp	SHORT $LN46@FetchSuper
$LN45@FetchSuper:
	mov	DWORD PTR tv357[ebp], 0
$LN46@FetchSuper:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv357[ebp]
	mov	BYTE PTR [eax+60], cl

; 1086 :         //Increment numInstructions by nuance count and add two to account for PacketStart and PacketEnd
; 1087 :         numInstructions += (packet.nuanceCount + 2);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _packet$[ebp+20]
	lea	edx, DWORD PTR [ecx+eax+2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1088 :         //Increment packet count
; 1089 :         numPackets++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1090 :         packetCounter--;

	mov	ecx, DWORD PTR _packetCounter$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _packetCounter$[ebp], ecx

; 1091 :         //Update the exit address
; 1092 :         exitAddress = packet.pcroute;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _packet$[ebp+76]
	mov	DWORD PTR [edx+44], eax

; 1093 :       }
; 1094 :       else

	jmp	SHORT $LN6@FetchSuper
$non_compilable_packet$42095:

; 1095 :       {
; 1096 : non_compilable_packet:
; 1097 :         //Packet contains non-compilable instruction: don't add it to the list and stop adding packets
; 1098 :         //Don't modify the current value of the delay counter
; 1099 :         exitAddress = packet.pcexec;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _packet$[ebp+28]
	mov	DWORD PTR [ecx+44], edx

; 1100 :         packetsProcessed--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1101 :         break;

	jmp	SHORT $LN30@FetchSuper
$LN6@FetchSuper:

; 1102 :       }
; 1103 :     }
; 1104 :     else

	jmp	SHORT $LN5@FetchSuper
$LN29@FetchSuper:

; 1105 :     {
; 1106 :       //Packet is a NOP or the packet contains a single inhibited ECU instruction: 
; 1107 :       //If the packet is a NOP and not in a delay slot, don't add it to the list: just update the exit address.
; 1108 :       //If the packet is in a delay slot, don't add it to the list but decrement the packet counter
; 1109 :       exitAddress = packet.pcroute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp+76]
	mov	DWORD PTR [eax+44], ecx

; 1110 :       if(nextDelayCounter || !bAllowBlockCompile)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN3@FetchSuper
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+25]
	test	ecx, ecx
	jne	SHORT $LN5@FetchSuper
$LN3@FetchSuper:

; 1111 :       //if(nextDelayCounter)
; 1112 :       {
; 1113 :         packetCounter--;

	mov	edx, DWORD PTR _packetCounter$[ebp]
	sub	edx, 1
	mov	DWORD PTR _packetCounter$[ebp], edx
$LN5@FetchSuper:

; 1114 :       }
; 1115 :     }
; 1116 : 
; 1117 :     if(nextDelayCounter > 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 1
	jbe	SHORT $LN2@FetchSuper

; 1118 :     {
; 1119 :       nextDelayCounter--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], edx
$LN2@FetchSuper:

; 1120 :     }
; 1121 :   }

	jmp	$LN31@FetchSuper
$LN30@FetchSuper:

; 1122 : 
; 1123 :   //Assume all instructions are live for now
; 1124 :   numLiveInstructions = numInstructions;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 1125 :   //Mark the last added instruction with SUPERBLOCKINFO_SYNC to ensure EliminateDeadCode works.
; 1126 :   if(numInstructions)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@FetchSuper

; 1127 :   {
; 1128 :     instructions[numInstructions - 1].flags |= SUPERBLOCKINFO_SYNC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	imul	eax, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+eax+28]
	or	eax, 524288				; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	imul	edx, 56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+edx+28], eax
$LN1@FetchSuper:

; 1129 :   }
; 1130 : 
; 1131 :   return packetsProcessed;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]

; 1132 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@FetchSuper
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 864				; 00000360H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN51@FetchSuper:
	DD	3
	DD	$LN50@FetchSuper
$LN50@FetchSuper:
	DD	-276					; fffffeecH
	DD	268					; 0000010cH
	DD	$LN47@FetchSuper
	DD	-552					; fffffdd8H
	DD	268					; 0000010cH
	DD	$LN48@FetchSuper
	DD	-828					; fffffcc4H
	DD	268					; 0000010cH
	DD	$LN49@FetchSuper
$LN49@FetchSuper:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	83					; 00000053H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$LN48@FetchSuper:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	83					; 00000053H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$LN47@FetchSuper:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?FetchSuperBlock@SuperBlock@@QAEHAAVMPE@@IAA_N@Z ENDP	; SuperBlock::FetchSuperBlock
_TEXT	ENDS
END
