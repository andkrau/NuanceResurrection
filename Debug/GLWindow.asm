; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\GLWindow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?bTerminate@@3_NA				; bTerminate
PUBLIC	?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A		; pfd
PUBLIC	?bFullScreen@@3_NA				; bFullScreen
PUBLIC	?hWnd@@3RAUHWND__@@A				; hWnd
PUBLIC	?defaultTitle@@3PADA				; defaultTitle
PUBLIC	?className@@3PADA				; className
_BSS	SEGMENT
?bTerminate@@3_NA DB 01H DUP (?)			; bTerminate
	ALIGN	4

?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A DB 028H DUP (?)	; pfd
?bFullScreen@@3_NA DB 01H DUP (?)			; bFullScreen
	ALIGN	4

?hWnd@@3RAUHWND__@@A DD 01H DUP (?)			; hWnd
_BSS	ENDS
CONST	SEGMENT
$SG65518 DB	'Error', 00H
	ORG $+2
$SG65519 DB	'Mode Switch Failed.', 0aH, 'Running In Windowed Mode.', 00H
	ORG $+2
$SG65522 DB	'GLWindow', 00H
	ORG $+3
$SG65530 DB	'Error', 00H
	ORG $+2
$SG65538 DB	'Error', 00H
	ORG $+2
$SG65546 DB	'Error', 00H
	ORG $+2
$SG65554 DB	'Error', 00H
	ORG $+2
$SG65562 DB	'Error', 00H
	ORG $+2
$SG65570 DB	'Error', 00H
	ORG $+2
$SG65677 DB	'GLWindow', 00H
	ORG $+3
$SG65680 DB	'Error', 00H
	ORG $+2
$SG65681 DB	'RegisterClassEx Failed!', 00H
$SG65693 DB	'Error', 00H
	ORG $+2
$SG65710 DB	'Error', 00H
	ORG $+2
$SG65711 DB	'Error Registering Window Class!', 00H
$SG65724 DB	'Error', 00H
	ORG $+2
$SG65725 DB	'Error Creating OpenGL Window', 00H
CONST	ENDS
_DATA	SEGMENT
?defaultTitle@@3PADA DB 'GLWindow', 00H			; defaultTitle
	ORG $+3
?className@@3PADA DB 'GLWindow', 00H			; className
_DATA	ENDS
PUBLIC	?UpdateRestoreValues@GLWindow@@QAEXXZ		; GLWindow::UpdateRestoreValues
PUBLIC	??0GLWindow@@QAE@XZ				; GLWindow::GLWindow
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\glwindow.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0GLWindow@@QAE@XZ PROC				; GLWindow::GLWindow
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 18   :   bVisible = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+56], 0

; 19   :   bUseSeparateThread = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+58], 0

; 20   :   bitsPerPixel = 32;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 32			; 00000020H

; 21   :   keyDownHandler = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 22   :   keyUpHandler = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 23   :   timerHandler = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 24   :   idleHandler = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 25   :   createHandler = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 26   :   closeHandler = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 27   :   closeQueryHandler = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 28   :   destroyHandler = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 29   :   paintHandler = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0

; 30   :   resizeHandler = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 31   :   timerInterval = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 32   :   timerID = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 33   :   x = 160;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 160			; 000000a0H

; 34   :   y = 120;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 120			; 00000078H

; 35   :   clientWidth = 320;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 320			; 00000140H

; 36   :   clientHeight = 240;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 240			; 000000f0H

; 37   : 	windowStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_THICKFRAME;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], 13500416		; 00ce0000H

; 38   : 	windowExtendedStyle = WS_EX_APPWINDOW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 262144		; 00040000H

; 39   :   fullScreenWindowStyle = WS_POPUP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], -2147483648	; 80000000H

; 40   :   fullScreenWindowStyle = WS_EX_APPWINDOW | WS_EX_TOPMOST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 262152		; 00040008H

; 41   :   title = defaultTitle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], OFFSET ?defaultTitle@@3PADA ; defaultTitle

; 42   : 
; 43   :   UpdateRestoreValues();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateRestoreValues@GLWindow@@QAEXXZ	; GLWindow::UpdateRestoreValues

; 44   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0GLWindow@@QAE@XZ ENDP				; GLWindow::GLWindow
_TEXT	ENDS
PUBLIC	??1GLWindow@@QAE@XZ				; GLWindow::~GLWindow
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1GLWindow@@QAE@XZ PROC				; GLWindow::~GLWindow
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1GLWindow@@QAE@XZ ENDP				; GLWindow::~GLWindow
_TEXT	ENDS
PUBLIC	?MMTimerCallback@GLWindow@@KGXIIKKK@Z		; GLWindow::MMTimerCallback
EXTRN	__imp__SendMessageA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_window$ = -4						; size = 4
_uID$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwUser$ = 16						; size = 4
_dw1$ = 20						; size = 4
_dw2$ = 24						; size = 4
?MMTimerCallback@GLWindow@@KGXIIKKK@Z PROC		; GLWindow::MMTimerCallback

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 52   :   GLWindow *window = (GLWindow *)dwUser;

	mov	eax, DWORD PTR _dwUser$[ebp]
	mov	DWORD PTR _window$[ebp], eax

; 53   :   SendMessage(window->hWnd,WM_TIMER,uID,(LPARAM)NULL);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _uID$[ebp]
	push	ecx
	push	275					; 00000113H
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 54   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?MMTimerCallback@GLWindow@@KGXIIKKK@Z ENDP		; GLWindow::MMTimerCallback
_TEXT	ENDS
PUBLIC	?SetTimer@GLWindow@@QAE_NXZ			; GLWindow::SetTimer
EXTRN	__imp__timeSetEvent@20:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetTimer@GLWindow@@QAE_NXZ PROC			; GLWindow::SetTimer
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 58   :   timeBeginPeriod(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__timeBeginPeriod@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 59   :   timerID = timeSetEvent(timerInterval,0,this->MMTimerCallback,(UINT)this,TIME_PERIODIC);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?MMTimerCallback@GLWindow@@KGXIIKKK@Z ; GLWindow::MMTimerCallback
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR __imp__timeSetEvent@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 60   :   return (timerID != NULL);

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+68], 0
	setne	al

; 61   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetTimer@GLWindow@@QAE_NXZ ENDP			; GLWindow::SetTimer
_TEXT	ENDS
PUBLIC	?KillTimer@GLWindow@@QAE_NXZ			; GLWindow::KillTimer
EXTRN	__imp__timeKillEvent@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?KillTimer@GLWindow@@QAE_NXZ PROC			; GLWindow::KillTimer
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 65   :   if(timerID)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN1@KillTimer

; 66   :   {
; 67   :     timeEndPeriod(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__timeEndPeriod@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 68   :     timeKillEvent(timerID);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	call	DWORD PTR __imp__timeKillEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@KillTimer:

; 69   :   }
; 70   : 
; 71   :   return true;

	mov	al, 1

; 72   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?KillTimer@GLWindow@@QAE_NXZ ENDP			; GLWindow::KillTimer
_TEXT	ENDS
EXTRN	__imp__AdjustWindowRectEx@16:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_windowRect$ = -24					; size = 16
_this$ = -4						; size = 4
?UpdateRestoreValues@GLWindow@@QAEXXZ PROC		; GLWindow::UpdateRestoreValues
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 76   :   RECT windowRect = {0, 0, clientWidth, clientHeight};

	mov	DWORD PTR _windowRect$[ebp], 0
	mov	DWORD PTR _windowRect$[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _windowRect$[ebp+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _windowRect$[ebp+12], eax

; 77   :   restoreX = x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+148], eax

; 78   :   restoreY = y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+152], eax

; 79   :   AdjustWindowRectEx(&windowRect, windowStyle, 0, windowExtendedStyle);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	push	ecx
	lea	edx, DWORD PTR _windowRect$[ebp]
	push	edx
	call	DWORD PTR __imp__AdjustWindowRectEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   :   restoreWidth = width = windowRect.right - windowRect.left;

	mov	eax, DWORD PTR _windowRect$[ebp+8]
	sub	eax, DWORD PTR _windowRect$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+140], ecx

; 81   :   restoreHeight = height = windowRect.bottom - windowRect.top;

	mov	edx, DWORD PTR _windowRect$[ebp+12]
	sub	edx, DWORD PTR _windowRect$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+144], eax

; 82   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@UpdateRest
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@UpdateRest:
	DD	1
	DD	$LN4@UpdateRest
$LN4@UpdateRest:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@UpdateRest
$LN3@UpdateRest:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
?UpdateRestoreValues@GLWindow@@QAEXXZ ENDP		; GLWindow::UpdateRestoreValues
_TEXT	ENDS
PUBLIC	?OnResize@GLWindow@@IAEXHH@Z			; GLWindow::OnResize
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_windowRect$ = -24					; size = 16
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?OnResize@GLWindow@@IAEXHH@Z PROC			; GLWindow::OnResize
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 86   :   RECT windowRect;
; 87   : 
; 88   :   GetWindowRect(hWnd, &windowRect);

	mov	esi, esp
	lea	eax, DWORD PTR _windowRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 89   :   x = windowRect.left;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _windowRect$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 90   :   y = windowRect.top;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _windowRect$[ebp+4]
	mov	DWORD PTR [edx+24], eax

; 91   :   width = windowRect.right - windowRect.left;

	mov	ecx, DWORD PTR _windowRect$[ebp+8]
	sub	ecx, DWORD PTR _windowRect$[ebp]
	mov	DWORD PTR _width$[ebp], ecx

; 92   :   height = windowRect.bottom - windowRect.top;

	mov	edx, DWORD PTR _windowRect$[ebp+12]
	sub	edx, DWORD PTR _windowRect$[ebp+4]
	mov	DWORD PTR _height$[ebp], edx

; 93   :   GetClientRect(hWnd, &windowRect);

	mov	esi, esp
	lea	eax, DWORD PTR _windowRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 94   :   clientWidth = windowRect.right - windowRect.left;

	mov	eax, DWORD PTR _windowRect$[ebp+8]
	sub	eax, DWORD PTR _windowRect$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 95   :   clientHeight = windowRect.bottom - windowRect.top;

	mov	edx, DWORD PTR _windowRect$[ebp+12]
	sub	edx, DWORD PTR _windowRect$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 96   :   if(!bFullScreen)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+57]
	test	edx, edx
	jne	SHORT $LN2@OnResize

; 97   :   {
; 98   :     UpdateRestoreValues();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateRestoreValues@GLWindow@@QAEXXZ	; GLWindow::UpdateRestoreValues
$LN2@OnResize:

; 99   :   }
; 100  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OnResize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN6@OnResize:
	DD	1
	DD	$LN5@OnResize
$LN5@OnResize:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN4@OnResize
$LN4@OnResize:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
?OnResize@GLWindow@@IAEXHH@Z ENDP			; GLWindow::OnResize
_TEXT	ENDS
PUBLIC	?Close@GLWindow@@QAEXXZ				; GLWindow::Close
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Close@GLWindow@@QAEXXZ PROC				; GLWindow::Close
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 104  :   if(bCreated)
; 105  :   {
; 106  : 	  //PostMessage(hWnd, WM_QUIT, 0, 0);
; 107  : 	  //bTerminate = true;
; 108  :   }
; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Close@GLWindow@@QAEXXZ ENDP				; GLWindow::Close
_TEXT	ENDS
PUBLIC	?ToggleFullscreen@GLWindow@@QAEXXZ		; GLWindow::ToggleFullscreen
EXTRN	__imp__PostMessageA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleFullscreen@GLWindow@@QAEXXZ PROC			; GLWindow::ToggleFullscreen
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 	PostMessage(hWnd, WM_TOGGLEFULLSCREEN, 0, 0);

	mov	esi, esp
	push	0
	push	0
	push	1025					; 00000401H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 114  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleFullscreen@GLWindow@@QAEXXZ ENDP			; GLWindow::ToggleFullscreen
_TEXT	ENDS
PUBLIC	?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z	; GLWindow::ChangeScreenResolution
EXTRN	__imp__ChangeDisplaySettingsA@8:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_dmScreenSettings$ = -164				; size = 156
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_bitsPerPixel$ = 16					; size = 4
?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z PROC	; GLWindow::ChangeScreenResolution
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	DEVMODE dmScreenSettings;
; 119  : 	ZeroMemory(&dmScreenSettings, sizeof(DEVMODE));

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _dmScreenSettings$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 120  : 	dmScreenSettings.dmSize	= sizeof(DEVMODE);

	mov	WORD PTR _dmScreenSettings$[ebp+36], 156 ; 0000009cH

; 121  : 	dmScreenSettings.dmPelsWidth = width;

	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _dmScreenSettings$[ebp+108], ecx

; 122  : 	dmScreenSettings.dmPelsHeight	= height;

	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR _dmScreenSettings$[ebp+112], edx

; 123  : 	dmScreenSettings.dmBitsPerPel	= bitsPerPixel;

	mov	eax, DWORD PTR _bitsPerPixel$[ebp]
	mov	DWORD PTR _dmScreenSettings$[ebp+104], eax

; 124  : 	dmScreenSettings.dmFields	= DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

	mov	DWORD PTR _dmScreenSettings$[ebp+40], 1835008 ; 001c0000H

; 125  : 	if(ChangeDisplaySettings(&dmScreenSettings, CDS_FULLSCREEN) != DISP_CHANGE_SUCCESSFUL)

	mov	esi, esp
	push	4
	lea	ecx, DWORD PTR _dmScreenSettings$[ebp]
	push	ecx
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@ChangeScre

; 126  : 	{
; 127  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@ChangeScre
$LN1@ChangeScre:

; 128  : 	}
; 129  : 	return true;

	mov	al, 1
$LN2@ChangeScre:

; 130  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ChangeScre
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN6@ChangeScre:
	DD	1
	DD	$LN5@ChangeScre
$LN5@ChangeScre:
	DD	-164					; ffffff5cH
	DD	156					; 0000009cH
	DD	$LN4@ChangeScre
$LN4@ChangeScre:
	DB	100					; 00000064H
	DB	109					; 0000006dH
	DB	83					; 00000053H
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z ENDP	; GLWindow::ChangeScreenResolution
_TEXT	ENDS
PUBLIC	?CreateWindowGL@GLWindow@@IAE_NXZ		; GLWindow::CreateWindowGL
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__DescribePixelFormat@16:PROC
EXTRN	__imp__GetPixelFormat@4:PROC
EXTRN	__imp__wglDeleteContext@4:PROC
EXTRN	__imp__wglMakeCurrent@8:PROC
EXTRN	__imp__wglCreateContext@4:PROC
EXTRN	__imp__SetPixelFormat@12:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__ChoosePixelFormat@8:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_bGeneric$ = -114					; size = 1
_bAccelerated$ = -113					; size = 1
_lpMsgBuf$65564 = -108					; size = 4
_lpMsgBuf$65556 = -96					; size = 4
_lpMsgBuf$65548 = -84					; size = 4
_lpMsgBuf$65540 = -72					; size = 4
_lpMsgBuf$65532 = -60					; size = 4
_lpMsgBuf$65524 = -48					; size = 4
_windowRect$ = -36					; size = 16
_wStyleEx$ = -16					; size = 4
_wStyle$ = -12						; size = 4
_PixelFormat$ = -8					; size = 4
_this$ = -4						; size = 4
?CreateWindowGL@GLWindow@@IAE_NXZ PROC			; GLWindow::CreateWindowGL
; _this$ = ecx

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 	GLuint PixelFormat;
; 138  :   unsigned __int32 wStyle, wStyleEx;
; 139  : 
; 140  : 	wStyle = windowStyle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _wStyle$[ebp], ecx

; 141  :   wStyleEx = windowExtendedStyle;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR _wStyleEx$[ebp], eax

; 142  : 
; 143  :   if(!bitsPerPixel)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN16@CreateWind

; 144  :   {
; 145  :     bitsPerPixel = 32;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 32			; 00000020H
$LN16@CreateWind:

; 146  :   }
; 147  :   
; 148  :   pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);

	mov	WORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A, 40 ; 00000028H

; 149  :   pfd.nVersion = 1;

	mov	WORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+2, 1

; 150  :   pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;

	mov	DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+4, 36 ; 00000024H

; 151  :   pfd.iPixelType = PFD_TYPE_RGBA;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+8, 0

; 152  :   pfd.cColorBits = 32;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+9, 32 ; 00000020H

; 153  :   pfd.cRedBits = pfd.cRedShift = pfd.cGreenBits = pfd.cGreenShift = pfd.cBlueBits = pfd.cBlueShift = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+15, 0
	mov	al, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+15
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+14, al
	mov	cl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+14
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+13, cl
	mov	dl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+13
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+12, dl
	mov	al, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+12
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+11, al
	mov	cl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+11
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+10, cl

; 154  :   pfd.cAlphaBits = pfd.cAlphaShift = pfd.cAccumBits = pfd.cAccumRedBits = pfd.cAccumGreenBits = pfd.cAccumBlueBits 
; 155  :     = pfd.cAccumAlphaBits = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+22, 0
	mov	dl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+22
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+21, dl
	mov	al, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+21
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+20, al
	mov	cl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+20
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+19, cl
	mov	dl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+19
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+18, dl
	mov	al, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+18
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+17, al
	mov	cl, BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+17
	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+16, cl

; 156  :   pfd.cDepthBits = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+23, 0

; 157  :   pfd.cStencilBits = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+24, 0

; 158  :   pfd.cAuxBuffers = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+25, 0

; 159  :   pfd.iLayerType = PFD_MAIN_PLANE;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+26, 0

; 160  :   pfd.bReserved = 0;

	mov	BYTE PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+27, 0

; 161  :   pfd.dwLayerMask = 0;

	mov	DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+28, 0

; 162  :   pfd.dwVisibleMask = 0;

	mov	DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+32, 0

; 163  :   pfd.dwDamageMask = 0;

	mov	DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+36, 0

; 164  : 		
; 165  : 	RECT windowRect = {x, y, clientWidth + x, clientHeight + y};

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _windowRect$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _windowRect$[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _windowRect$[ebp+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _windowRect$[ebp+12], ecx

; 166  : 
; 167  :   AdjustWindowRectEx(&windowRect, windowStyle, 0, windowExtendedStyle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	lea	ecx, DWORD PTR _windowRect$[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRectEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 168  :   restoreX = x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+148], ecx

; 169  :   restoreY = y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+152], ecx

; 170  :   restoreWidth = windowRect.right - windowRect.left;

	mov	edx, DWORD PTR _windowRect$[ebp+8]
	sub	edx, DWORD PTR _windowRect$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], edx

; 171  :   restoreHeight = windowRect.bottom - windowRect.top;

	mov	ecx, DWORD PTR _windowRect$[ebp+12]
	sub	ecx, DWORD PTR _windowRect$[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], ecx

; 172  : 
; 173  : 	if(bFullScreen == true)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+57]
	cmp	ecx, 1
	jne	$LN15@CreateWind

; 174  : 	{
; 175  : 		if(!ChangeScreenResolution(fullScreenWidth, fullScreenHeight, bitsPerPixel))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z ; GLWindow::ChangeScreenResolution
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@CreateWind

; 176  : 		{
; 177  : 			// Fullscreen Mode Failed.  Run In Windowed Mode Instead
; 178  : 			MessageBox(HWND_DESKTOP,"Mode Switch Failed.\nRunning In Windowed Mode.", "Error", MB_OK | MB_ICONEXCLAMATION);

	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET $SG65518
	push	OFFSET $SG65519
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 179  : 			bFullScreen = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+57], 0

; 180  : 		}
; 181  : 		else

	jmp	$LN15@CreateWind
$LN14@CreateWind:

; 182  : 		{
; 183  :       // Fullscreen mode switch succeeded
; 184  : 			ShowCursor(FALSE);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__ShowCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 185  : 			wStyle = fullScreenWindowStyle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _wStyle$[ebp], edx

; 186  :       wStyleEx = fullScreenWindowExtendedStyle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR _wStyleEx$[ebp], ecx

; 187  :       clientWidth = fullScreenWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+36], ecx

; 188  :       clientHeight = fullScreenHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+40], ecx

; 189  :       windowRect.left = 0;

	mov	DWORD PTR _windowRect$[ebp], 0

; 190  :       windowRect.top = 0;

	mov	DWORD PTR _windowRect$[ebp+4], 0

; 191  :       windowRect.right = fullScreenWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _windowRect$[ebp+8], eax

; 192  :       windowRect.bottom = fullScreenHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _windowRect$[ebp+12], edx

; 193  :       AdjustWindowRectEx(&windowRect, fullScreenWindowStyle, 0, fullScreenWindowExtendedStyle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	lea	ecx, DWORD PTR _windowRect$[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRectEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 194  :       x = windowRect.left;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _windowRect$[ebp]
	mov	DWORD PTR [edx+20], eax

; 195  :       y = windowRect.top;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _windowRect$[ebp+4]
	mov	DWORD PTR [ecx+24], edx

; 196  :       width = windowRect.right - windowRect.left;

	mov	eax, DWORD PTR _windowRect$[ebp+8]
	sub	eax, DWORD PTR _windowRect$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 197  :       height = windowRect.bottom - windowRect.top;

	mov	edx, DWORD PTR _windowRect$[ebp+12]
	sub	edx, DWORD PTR _windowRect$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], edx
$LN15@CreateWind:

; 198  : 		}
; 199  : 	}
; 200  : 
; 201  :   // Create The OpenGL Window
; 202  :   hWnd = CreateWindowEx(
; 203  :     wStyleEx,
; 204  : 		"GLWindow",
; 205  : 		title,
; 206  : 		wStyle,
; 207  : 		windowRect.left, windowRect.top,
; 208  : 		windowRect.right - windowRect.left,
; 209  : 		windowRect.bottom - windowRect.top,
; 210  : 		HWND_DESKTOP,
; 211  : 		0,
; 212  : 		hInstance,
; 213  : 		this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _windowRect$[ebp+12]
	sub	ecx, DWORD PTR _windowRect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _windowRect$[ebp+8]
	sub	edx, DWORD PTR _windowRect$[ebp]
	push	edx
	mov	eax, DWORD PTR _windowRect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _windowRect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wStyle$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	push	OFFSET $SG65522
	mov	edx, DWORD PTR _wStyleEx$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateWindowExA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 214  : 
; 215  :   ::hWnd = hWnd;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR ?hWnd@@3RAUHWND__@@A, eax	; hWnd

; 216  : 	if(!hWnd)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN12@CreateWind

; 217  : 	{
; 218  :     LPVOID lpMsgBuf;
; 219  :     if (!FormatMessage( 
; 220  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 221  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 222  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 223  :         NULL,
; 224  :         GetLastError(),
; 225  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 226  :         (LPTSTR) &lpMsgBuf,
; 227  :         0,
; 228  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	edx, DWORD PTR _lpMsgBuf$65524[ebp]
	push	edx
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN11@CreateWind

; 229  :     {
; 230  :       // Handle the error.
; 231  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN11@CreateWind:

; 232  :     }
; 233  : 
; 234  :     // Process any inserts in lpMsgBuf.
; 235  :     // ...
; 236  : 
; 237  :     // Display the string.
; 238  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65530
	mov	eax, DWORD PTR _lpMsgBuf$65524[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 239  : 
; 240  :     // Free the buffer.
; 241  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	ecx, DWORD PTR _lpMsgBuf$65524[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 242  : 
; 243  :     return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN12@CreateWind:

; 244  : 	}
; 245  : 
; 246  : 	hDC = GetDC(hWnd);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 247  : 
; 248  : 	if(!hDC)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	$LN10@CreateWind

; 249  : 	{
; 250  :     LPVOID lpMsgBuf;
; 251  :     if (!FormatMessage( 
; 252  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 253  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 254  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 255  :         NULL,
; 256  :         GetLastError(),
; 257  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 258  :         (LPTSTR) &lpMsgBuf,
; 259  :         0,
; 260  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	eax, DWORD PTR _lpMsgBuf$65532[ebp]
	push	eax
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN9@CreateWind

; 261  :     {
; 262  :       // Handle the error.
; 263  :       DestroyWindow(hWnd);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 264  : 		  hWnd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 265  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN9@CreateWind:

; 266  :     }
; 267  : 
; 268  :     // Process any inserts in lpMsgBuf.
; 269  :     // ...
; 270  : 
; 271  :     // Display the string.
; 272  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65538
	mov	ecx, DWORD PTR _lpMsgBuf$65532[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 273  : 
; 274  :     // Free the buffer.
; 275  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	edx, DWORD PTR _lpMsgBuf$65532[ebp]
	push	edx
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 276  : 
; 277  :     DestroyWindow(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 278  : 		hWnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 279  : 		return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN10@CreateWind:

; 280  : 	}
; 281  : 
; 282  : 	PixelFormat = ChoosePixelFormat(hDC, &pfd);

	mov	esi, esp
	push	OFFSET ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A ; pfd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__ChoosePixelFormat@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _PixelFormat$[ebp], eax

; 283  : 	if(!PixelFormat)

	cmp	DWORD PTR _PixelFormat$[ebp], 0
	jne	$LN8@CreateWind

; 284  : 	{
; 285  :     LPVOID lpMsgBuf;
; 286  :     if (!FormatMessage( 
; 287  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 288  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 289  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 290  :         NULL,
; 291  :         GetLastError(),
; 292  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 293  :         (LPTSTR) &lpMsgBuf,
; 294  :         0,
; 295  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	edx, DWORD PTR _lpMsgBuf$65540[ebp]
	push	edx
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN7@CreateWind

; 296  :     {
; 297  :       // Handle the error.
; 298  : 		  ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 299  : 		  hDC = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 300  : 		  DestroyWindow(hWnd);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 301  : 		  hWnd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 302  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN7@CreateWind:

; 303  :     }
; 304  : 
; 305  :     // Process any inserts in lpMsgBuf.
; 306  :     // ...
; 307  : 
; 308  :     // Display the string.
; 309  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65546
	mov	edx, DWORD PTR _lpMsgBuf$65540[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 310  : 
; 311  :     // Free the buffer.
; 312  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	eax, DWORD PTR _lpMsgBuf$65540[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 313  : 		ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 314  : 		hDC = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 315  : 		DestroyWindow(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 316  : 		hWnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 317  : 		return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN8@CreateWind:

; 318  : 	}
; 319  : 
; 320  : 	if(!SetPixelFormat(hDC, PixelFormat, &pfd))

	mov	esi, esp
	push	OFFSET ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A ; pfd
	mov	eax, DWORD PTR _PixelFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__SetPixelFormat@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN6@CreateWind

; 321  :   {
; 322  :     LPVOID lpMsgBuf;
; 323  :     if (!FormatMessage( 
; 324  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 325  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 326  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 327  :         NULL,
; 328  :         GetLastError(),
; 329  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 330  :         (LPTSTR) &lpMsgBuf,
; 331  :         0,
; 332  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	eax, DWORD PTR _lpMsgBuf$65548[ebp]
	push	eax
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN5@CreateWind

; 333  :     {
; 334  :       // Handle the error.
; 335  :       ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 336  : 		  hDC = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 337  : 		  DestroyWindow(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 338  : 		  hWnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 339  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN5@CreateWind:

; 340  :     }
; 341  : 
; 342  :     // Process any inserts in lpMsgBuf.
; 343  :     // ...
; 344  : 
; 345  :     // Display the string.
; 346  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65554
	mov	eax, DWORD PTR _lpMsgBuf$65548[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 347  : 
; 348  :     // Free the buffer.
; 349  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	ecx, DWORD PTR _lpMsgBuf$65548[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 350  : 
; 351  :     ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 352  : 		hDC = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 353  : 		DestroyWindow(hWnd);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 354  : 		hWnd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 355  : 		return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN6@CreateWind:

; 356  : 	}
; 357  : 
; 358  : 	hRC = wglCreateContext(hDC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__wglCreateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 359  : 
; 360  : 	if(!hRC)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN4@CreateWind

; 361  : 	{
; 362  :     LPVOID lpMsgBuf;
; 363  :     if (!FormatMessage( 
; 364  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 365  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 366  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 367  :         NULL,
; 368  :         GetLastError(),
; 369  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 370  :         (LPTSTR) &lpMsgBuf,
; 371  :         0,
; 372  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	eax, DWORD PTR _lpMsgBuf$65556[ebp]
	push	eax
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@CreateWind

; 373  :     {
; 374  :       // Handle the error.
; 375  :       ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 376  : 		  hDC = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 377  : 		  DestroyWindow(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 378  : 		  hWnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 379  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN3@CreateWind:

; 380  :     }
; 381  : 
; 382  :     // Display the string.
; 383  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65562
	mov	eax, DWORD PTR _lpMsgBuf$65556[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 384  : 
; 385  :     // Free the buffer.
; 386  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	ecx, DWORD PTR _lpMsgBuf$65556[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 387  : 		ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 388  : 		hDC = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 389  : 		DestroyWindow(hWnd);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 390  : 		hWnd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 391  : 		return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN4@CreateWind:

; 392  : 	}
; 393  : 
; 394  : 	if(!wglMakeCurrent(hDC, hRC))

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__wglMakeCurrent@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN2@CreateWind

; 395  : 	{
; 396  :     LPVOID lpMsgBuf;
; 397  :     if (!FormatMessage( 
; 398  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 399  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 400  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 401  :         NULL,
; 402  :         GetLastError(),
; 403  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 404  :         (LPTSTR) &lpMsgBuf,
; 405  :         0,
; 406  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	edx, DWORD PTR _lpMsgBuf$65564[ebp]
	push	edx
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@CreateWind

; 407  :     {
; 408  :       // Handle the error.
; 409  :       wglDeleteContext(hRC);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__wglDeleteContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 410  : 		  hRC = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 411  : 		  ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 412  : 		  hDC = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 413  : 		  DestroyWindow(hWnd);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 414  : 		  hWnd = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 415  :       return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN1@CreateWind:

; 416  :     }
; 417  : 
; 418  :     // Process any inserts in lpMsgBuf.
; 419  :     // ...
; 420  : 
; 421  :     // Display the string.
; 422  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65570
	mov	edx, DWORD PTR _lpMsgBuf$65564[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 423  : 
; 424  :     // Free the buffer.
; 425  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	eax, DWORD PTR _lpMsgBuf$65564[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 426  : 
; 427  :     wglDeleteContext(hRC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__wglDeleteContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 428  : 		hRC = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 429  : 		ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 430  : 		hDC = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 431  : 		DestroyWindow(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 432  : 		hWnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 433  : 		return false;

	xor	al, al
	jmp	$LN17@CreateWind
$LN2@CreateWind:

; 434  : 	}
; 435  : 
; 436  :   DescribePixelFormat(hDC,GetPixelFormat(hDC),sizeof(PIXELFORMATDESCRIPTOR),&pfd);

	mov	esi, esp
	push	OFFSET ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A ; pfd
	push	40					; 00000028H
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__GetPixelFormat@4
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__DescribePixelFormat@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 437  :   bool bAccelerated = pfd.dwFlags & PFD_GENERIC_ACCELERATED;

	mov	ecx, DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+4
	and	ecx, 4096				; 00001000H
	setne	dl
	mov	BYTE PTR _bAccelerated$[ebp], dl

; 438  :   bool bGeneric = pfd.dwFlags & PFD_GENERIC_FORMAT;

	mov	eax, DWORD PTR ?pfd@@3UtagPIXELFORMATDESCRIPTOR@@A+4
	and	eax, 64					; 00000040H
	setne	cl
	mov	BYTE PTR _bGeneric$[ebp], cl

; 439  : 
; 440  : 	ShowWindow(hWnd, SW_NORMAL);

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 441  : 	bVisible = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+56], 1

; 442  : 	OnResize(clientWidth, clientHeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnResize@GLWindow@@IAEXHH@Z		; GLWindow::OnResize

; 443  : 
; 444  : 	return true;

	mov	al, 1
$LN17@CreateWind:

; 445  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@CreateWind
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN27@CreateWind:
	DD	7
	DD	$LN26@CreateWind
$LN26@CreateWind:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN19@CreateWind
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@CreateWind
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN21@CreateWind
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN22@CreateWind
	DD	-84					; ffffffacH
	DD	4
	DD	$LN23@CreateWind
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN24@CreateWind
	DD	-108					; ffffff94H
	DD	4
	DD	$LN25@CreateWind
$LN25@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN24@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN23@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN22@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN21@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN20@CreateWind:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN19@CreateWind:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
?CreateWindowGL@GLWindow@@IAE_NXZ ENDP			; GLWindow::CreateWindowGL
_TEXT	ENDS
PUBLIC	?CleanUp@GLWindow@@IAEXXZ			; GLWindow::CleanUp
EXTRN	__imp__UnregisterClassA@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CleanUp@GLWindow@@IAEXXZ PROC				; GLWindow::CleanUp
; _this$ = ecx

; 448  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 449  : 	if(hWnd)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN4@CleanUp

; 450  : 	{
; 451  : 		if(hDC)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN3@CleanUp

; 452  : 		{
; 453  : 			wglMakeCurrent(hDC, 0);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__wglMakeCurrent@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 454  : 			if(hRC)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN2@CleanUp

; 455  : 			{
; 456  : 				wglDeleteContext(hRC);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__wglDeleteContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 457  : 				hRC = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN2@CleanUp:

; 458  : 			}
; 459  : 			ReleaseDC(hWnd, hDC);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 460  : 			hDC = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN3@CleanUp:

; 461  : 		}
; 462  : 		DestroyWindow(hWnd);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 463  : 		hWnd = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN4@CleanUp:

; 464  : 	}
; 465  : 
; 466  : 	if(bFullScreen)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+57]
	test	edx, edx
	je	SHORT $LN1@CleanUp

; 467  : 	{
; 468  : 		ChangeDisplaySettings(NULL,0);

	mov	esi, esp
	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 469  : 		ShowCursor(TRUE);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__ShowCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@CleanUp:

; 470  : 	}
; 471  : 
; 472  : 	UnregisterClass(className, hInstance);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR __imp__UnregisterClassA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CleanUp@GLWindow@@IAEXXZ ENDP				; GLWindow::CleanUp
_TEXT	ENDS
PUBLIC	?GLWindowProc@GLWindow@@KGJPAUHWND__@@IIJ@Z	; GLWindow::GLWindowProc
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__glClear@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv143 = -116						; size = 4
tv72 = -112						; size = 4
tv67 = -108						; size = 4
_creation$65605 = -104					; size = 4
_ps$ = -96						; size = 64
_windowRect$ = -24					; size = 16
_window$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?GLWindowProc@GLWindow@@KGJPAUHWND__@@IIJ@Z PROC	; GLWindow::GLWindowProc

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 477  : 	GLWindow *window = (GLWindow *)(GetWindowLong(hWnd, GWL_USERDATA));

	mov	esi, esp
	push	-21					; ffffffebH
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _window$[ebp], eax

; 478  :   RECT windowRect;
; 479  :   PAINTSTRUCT ps;
; 480  : 
; 481  : 	switch(uMsg)

	mov	ecx, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 15			; 0000000fH
	ja	SHORT $LN42@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 15			; 0000000fH
	je	$LN7@GLWindowPr
	mov	edx, DWORD PTR tv67[ebp]
	sub	edx, 1
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 4
	ja	$LN38@GLWindowPr
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN48@GLWindowPr[eax*4]
$LN42@GLWindowPr:
	cmp	DWORD PTR tv67[ebp], 257		; 00000101H
	ja	SHORT $LN43@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 257		; 00000101H
	je	$LN9@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 16			; 00000010H
	je	$LN29@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 20			; 00000014H
	je	$LN4@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 256		; 00000100H
	je	$LN12@GLWindowPr
	jmp	$LN38@GLWindowPr
$LN43@GLWindowPr:
	cmp	DWORD PTR tv67[ebp], 274		; 00000112H
	je	SHORT $LN35@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 275		; 00000113H
	je	SHORT $LN37@GLWindowPr
	cmp	DWORD PTR tv67[ebp], 1025		; 00000401H
	je	$LN3@GLWindowPr
	jmp	$LN38@GLWindowPr
$LN37@GLWindowPr:

; 482  : 	{
; 483  :     case WM_TIMER:
; 484  :       if(window->timerHandler)

	mov	ecx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $LN36@GLWindowPr

; 485  :       {
; 486  :         window->timerHandler((unsigned __int32)wParam);

	mov	esi, esp
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@GLWindowPr:

; 487  :       }
; 488  :       return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN35@GLWindowPr:

; 489  : 		case WM_SYSCOMMAND:
; 490  : 		{
; 491  : 			switch(wParam)

	mov	edx, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	cmp	DWORD PTR tv72[ebp], 61760		; 0000f140H
	je	SHORT $LN32@GLWindowPr
	cmp	DWORD PTR tv72[ebp], 61808		; 0000f170H
	je	SHORT $LN32@GLWindowPr
	jmp	SHORT $LN33@GLWindowPr
$LN32@GLWindowPr:

; 492  : 			{
; 493  : 				case SC_SCREENSAVE:
; 494  : 				case SC_MONITORPOWER:
; 495  : 				  return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN33@GLWindowPr:

; 496  : 			}
; 497  : 			break;

	jmp	$LN38@GLWindowPr
$LN31@GLWindowPr:

; 498  : 		}
; 499  : 		case WM_CREATE:
; 500  : 		{
; 501  : 			CREATESTRUCT *creation = (CREATESTRUCT *)(lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR _creation$65605[ebp], eax

; 502  : 			window = (GLWindow *)(creation->lpCreateParams);

	mov	ecx, DWORD PTR _creation$65605[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _window$[ebp], edx

; 503  : 			SetWindowLong(hWnd, GWL_USERDATA, (LONG)(window));

	mov	esi, esp
	mov	eax, DWORD PTR _window$[ebp]
	push	eax
	push	-21					; ffffffebH
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetWindowLongA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 504  : 
; 505  :       if(window->createHandler)

	mov	edx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN30@GLWindowPr

; 506  :       {
; 507  :         window->createHandler(wParam, lParam);

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@GLWindowPr:

; 508  :       }
; 509  : 
; 510  : 		}
; 511  : 		return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN29@GLWindowPr:

; 512  : 
; 513  : 		case WM_CLOSE:
; 514  :       if(window->closeQueryHandler)

	mov	ecx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN28@GLWindowPr

; 515  :       {
; 516  :         if(!window->closeQueryHandler(0,0))

	mov	esi, esp
	push	0
	push	0
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@GLWindowPr

; 517  :         {
; 518  :           //CloseQuery callback said not to close the window
; 519  :           return -1;

	or	eax, -1
	jmp	$LN40@GLWindowPr

; 520  :         }
; 521  :         else

	jmp	SHORT $LN28@GLWindowPr
$LN27@GLWindowPr:

; 522  :         {
; 523  :           if(window->closeHandler)

	mov	edx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN28@GLWindowPr

; 524  :           {
; 525  :             //Close callback exists, so call it
; 526  :             window->closeHandler(0,0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@GLWindowPr:

; 527  :           }
; 528  :         }
; 529  :       }
; 530  : 
; 531  :       //Call the default close handler
; 532  : 			window->Close();

	mov	ecx, DWORD PTR _window$[ebp]
	call	?Close@GLWindow@@QAEXXZ			; GLWindow::Close

; 533  : 		  return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN24@GLWindowPr:

; 534  : 
; 535  :     case WM_DESTROY:
; 536  :       if(window->destroyHandler)

	mov	edx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	SHORT $LN23@GLWindowPr

; 537  :       {
; 538  :         window->destroyHandler(0,0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@GLWindowPr:

; 539  :       }
; 540  :       return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN22@GLWindowPr:

; 541  : 
; 542  :     case WM_MOVE:
; 543  :       GetWindowRect(window->hWnd,&windowRect);

	mov	esi, esp
	lea	edx, DWORD PTR _windowRect$[ebp]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 544  :       if(!window->bFullScreen)

	mov	edx, DWORD PTR _window$[ebp]
	movzx	eax, BYTE PTR [edx+57]
	test	eax, eax
	jne	SHORT $LN21@GLWindowPr

; 545  :       {
; 546  :         window->x = windowRect.left;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _windowRect$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 547  :         window->y = windowRect.top;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _windowRect$[ebp+4]
	mov	DWORD PTR [eax+24], ecx

; 548  :         window->UpdateRestoreValues();

	mov	ecx, DWORD PTR _window$[ebp]
	call	?UpdateRestoreValues@GLWindow@@QAEXXZ	; GLWindow::UpdateRestoreValues
$LN21@GLWindowPr:

; 549  :       }
; 550  :       break;

	jmp	$LN38@GLWindowPr
$LN20@GLWindowPr:

; 551  : 
; 552  : 		case WM_SIZE:
; 553  : 			switch(wParam)

	mov	edx, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv143[ebp], edx
	cmp	DWORD PTR tv143[ebp], 0
	je	SHORT $LN14@GLWindowPr
	cmp	DWORD PTR tv143[ebp], 1
	je	SHORT $LN17@GLWindowPr
	cmp	DWORD PTR tv143[ebp], 2
	je	SHORT $LN16@GLWindowPr
	jmp	$LN18@GLWindowPr
$LN17@GLWindowPr:

; 554  : 			{
; 555  : 				case SIZE_MINIMIZED:
; 556  : 					window->bVisible = false;

	mov	eax, DWORD PTR _window$[ebp]
	mov	BYTE PTR [eax+56], 0

; 557  : 				  return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN16@GLWindowPr:

; 558  : 
; 559  : 				case SIZE_MAXIMIZED:
; 560  : 					window->bVisible = true;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	BYTE PTR [ecx+56], 1

; 561  : 	        window->OnResize(LOWORD(lParam), HIWORD(lParam));

	mov	edx, DWORD PTR _lParam$[ebp]
	shr	edx, 16					; 00000010H
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _lParam$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	push	edx
	mov	ecx, DWORD PTR _window$[ebp]
	call	?OnResize@GLWindow@@IAEXHH@Z		; GLWindow::OnResize

; 562  :           if(window->resizeHandler)

	mov	eax, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN15@GLWindowPr

; 563  :           {
; 564  :             window->resizeHandler(LOWORD(lParam),HIWORD(lParam));

	mov	ecx, DWORD PTR _lParam$[ebp]
	shr	ecx, 16					; 00000010H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _lParam$[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@GLWindowPr:

; 565  :           }
; 566  : 				  return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN14@GLWindowPr:

; 567  : 
; 568  : 				case SIZE_RESTORED:
; 569  : 					window->bVisible = true;

	mov	edx, DWORD PTR _window$[ebp]
	mov	BYTE PTR [edx+56], 1

; 570  : 	        window->OnResize(LOWORD(lParam), HIWORD(lParam));

	mov	eax, DWORD PTR _lParam$[ebp]
	shr	eax, 16					; 00000010H
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _lParam$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	call	?OnResize@GLWindow@@IAEXHH@Z		; GLWindow::OnResize

; 571  :           if(window->resizeHandler)

	mov	ecx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN13@GLWindowPr

; 572  :           {
; 573  :             window->resizeHandler(LOWORD(lParam),HIWORD(lParam));

	mov	edx, DWORD PTR _lParam$[ebp]
	shr	edx, 16					; 00000010H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@GLWindowPr:

; 574  :           }
; 575  : 				  return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN18@GLWindowPr:

; 576  : 			}
; 577  : 		  break;

	jmp	$LN38@GLWindowPr
$LN12@GLWindowPr:

; 578  : 
; 579  : 		case WM_KEYDOWN:
; 580  :       if(window->keyDownHandler)

	mov	eax, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN11@GLWindowPr

; 581  :       {
; 582  :         window->keyDownHandler((int)wParam,(unsigned __int32)lParam);

	mov	esi, esp
	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	dx, WORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@GLWindowPr:

; 583  :       }
; 584  : 
; 585  : 	    if((int)wParam == VK_F1)

	cmp	DWORD PTR _wParam$[ebp], 112		; 00000070H
	jne	SHORT $LN10@GLWindowPr

; 586  : 	    {
; 587  : 		    window->ToggleFullscreen();

	mov	ecx, DWORD PTR _window$[ebp]
	call	?ToggleFullscreen@GLWindow@@QAEXXZ	; GLWindow::ToggleFullscreen
$LN10@GLWindowPr:

; 588  : 	    }
; 589  : 
; 590  : 		  break;

	jmp	$LN38@GLWindowPr
$LN9@GLWindowPr:

; 591  : 
; 592  : 		case WM_KEYUP:
; 593  :       if(window->keyUpHandler)

	mov	edx, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN8@GLWindowPr

; 594  :       {
; 595  :         window->keyUpHandler((int)wParam,(unsigned __int32)lParam);

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	cx, WORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@GLWindowPr:

; 596  :       }
; 597  : 		  break;

	jmp	$LN38@GLWindowPr
$LN7@GLWindowPr:

; 598  : 
; 599  :     case WM_PAINT:
; 600  :       BeginPaint(hWnd,&ps);

	mov	esi, esp
	lea	ecx, DWORD PTR _ps$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__BeginPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 601  :       if(window->paintHandler)

	mov	eax, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [eax+108], 0
	je	SHORT $LN6@GLWindowPr

; 602  :       {
; 603  :         window->paintHandler((int)wParam,(unsigned __int32)lParam);

	mov	esi, esp
	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 604  :       }
; 605  :       else

	jmp	SHORT $LN5@GLWindowPr
$LN6@GLWindowPr:

; 606  :       {
; 607  :         glClear(GL_COLOR_BUFFER_BIT);

	mov	esi, esp
	push	16384					; 00004000H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@GLWindowPr:

; 608  :       }
; 609  :       EndPaint(hWnd,&ps);

	mov	esi, esp
	lea	edx, DWORD PTR _ps$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__EndPaint@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 610  : 		  break;

	jmp	$LN38@GLWindowPr
$LN4@GLWindowPr:

; 611  : 
; 612  :     case WM_ERASEBKGND:
; 613  :       return 0;

	xor	eax, eax
	jmp	$LN40@GLWindowPr
$LN3@GLWindowPr:

; 614  : 
; 615  : 		case WM_TOGGLEFULLSCREEN:
; 616  : 			window->bFullScreen = !window->bFullScreen;

	mov	ecx, DWORD PTR _window$[ebp]
	movzx	edx, BYTE PTR [ecx+57]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	mov	eax, DWORD PTR _window$[ebp]
	mov	BYTE PTR [eax+57], dl

; 617  :       if(window->bFullScreen)

	mov	ecx, DWORD PTR _window$[ebp]
	movzx	edx, BYTE PTR [ecx+57]
	test	edx, edx
	je	$LN2@GLWindowPr

; 618  :       {
; 619  :         window->restoreX = window->x;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+148], edx

; 620  :         window->restoreY = window->y;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+152], edx

; 621  :         window->restoreWidth = window->width;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+140], edx

; 622  :         window->restoreHeight = window->height;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+144], edx

; 623  : 
; 624  :         windowRect.left = 0;

	mov	DWORD PTR _windowRect$[ebp], 0

; 625  :         windowRect.top = 0;

	mov	DWORD PTR _windowRect$[ebp+4], 0

; 626  :         windowRect.right = window->fullScreenWidth;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _windowRect$[ebp+8], ecx

; 627  :         windowRect.bottom = window->fullScreenHeight;

	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _windowRect$[ebp+12], eax

; 628  :      		AdjustWindowRectEx(&windowRect, window->windowStyle, 0, window->windowExtendedStyle);

	mov	esi, esp
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	push	0
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	push	ecx
	lea	edx, DWORD PTR _windowRect$[ebp]
	push	edx
	call	DWORD PTR __imp__AdjustWindowRectEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 629  : 
; 630  :         window->clientWidth = window->fullScreenWidth;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+36], edx

; 631  :         window->clientHeight = window->fullScreenHeight;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+40], edx

; 632  :         window->width = windowRect.right - windowRect.left;

	mov	eax, DWORD PTR _windowRect$[ebp+8]
	sub	eax, DWORD PTR _windowRect$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 633  :         window->height = windowRect.bottom - windowRect.top;

	mov	edx, DWORD PTR _windowRect$[ebp+12]
	sub	edx, DWORD PTR _windowRect$[ebp+4]
	mov	eax, DWORD PTR _window$[ebp]
	mov	DWORD PTR [eax+32], edx

; 634  :         window->x = windowRect.left;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _windowRect$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 635  :         window->y = windowRect.top;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _windowRect$[ebp+4]
	mov	DWORD PTR [eax+24], ecx

; 636  : 
; 637  :         ShowWindow(window->hWnd,SW_HIDE);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 638  :         SetWindowPos(window->hWnd, HWND_TOP, window->x, window->y, window->width, window->height, 0);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	push	0
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SetWindowPos@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  :         ShowWindow(window->hWnd,SW_NORMAL);

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 640  :         window->ChangeScreenResolution(window->clientWidth,window->clientHeight,window->bitsPerPixel);

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	call	?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z ; GLWindow::ChangeScreenResolution

; 641  :       }
; 642  :       else

	jmp	$LN38@GLWindowPr
$LN2@GLWindowPr:

; 643  :       {
; 644  :         //Switch back to the desktop resolution
; 645  :         window->x = window->restoreX;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR [ecx+20], eax

; 646  :         window->y = window->restoreY;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+152]
	mov	DWORD PTR [ecx+24], eax

; 647  :         window->width = window->restoreWidth;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	DWORD PTR [ecx+28], eax

; 648  :         window->height = window->restoreHeight;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [ecx+32], eax

; 649  : 
; 650  :         ShowWindow(window->hWnd,SW_HIDE);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 651  :         window->ChangeScreenResolution(0,0,0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _window$[ebp]
	call	?ChangeScreenResolution@GLWindow@@IAE_NHHH@Z ; GLWindow::ChangeScreenResolution

; 652  :         SetWindowPos(window->hWnd, HWND_TOP,window->x,window->y,window->width,window->height,0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 653  :         ShowWindow(window->hWnd,SW_NORMAL);

	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 654  : 
; 655  :         GetClientRect(window->hWnd,&windowRect);

	mov	esi, esp
	lea	eax, DWORD PTR _windowRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _window$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 656  :         window->clientWidth = windowRect.right;

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR _windowRect$[ebp+8]
	mov	DWORD PTR [eax+36], ecx

; 657  :         window->clientHeight = windowRect.bottom;

	mov	edx, DWORD PTR _window$[ebp]
	mov	eax, DWORD PTR _windowRect$[ebp+12]
	mov	DWORD PTR [edx+40], eax
$LN38@GLWindowPr:

; 658  :       }
; 659  : 		  break;
; 660  : 	}
; 661  : 
; 662  : 	return DefWindowProc(hWnd, uMsg, wParam, lParam);

	mov	esi, esp
	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _uMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__DefWindowProcA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@GLWindowPr:

; 663  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN47@GLWindowPr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN47@GLWindowPr:
	DD	2
	DD	$LN46@GLWindowPr
$LN46@GLWindowPr:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN44@GLWindowPr
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN45@GLWindowPr
$LN45@GLWindowPr:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
$LN44@GLWindowPr:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
	npad	2
$LN48@GLWindowPr:
	DD	$LN31@GLWindowPr
	DD	$LN24@GLWindowPr
	DD	$LN22@GLWindowPr
	DD	$LN38@GLWindowPr
	DD	$LN20@GLWindowPr
?GLWindowProc@GLWindow@@KGJPAUHWND__@@IIJ@Z ENDP	; GLWindow::GLWindowProc
_TEXT	ENDS
PUBLIC	?RegisterWindowClass@GLWindow@@IAE_NXZ		; GLWindow::RegisterWindowClass
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__LoadCursorA@8:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_windowClass$ = -56					; size = 48
_this$ = -4						; size = 4
?RegisterWindowClass@GLWindow@@IAE_NXZ PROC		; GLWindow::RegisterWindowClass
; _this$ = ecx

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 	WNDCLASSEX windowClass;
; 668  : 	memset(&windowClass, 0, sizeof (WNDCLASSEX));

	push	48					; 00000030H
	push	0
	lea	eax, DWORD PTR _windowClass$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 669  : 	windowClass.cbSize = sizeof (WNDCLASSEX);

	mov	DWORD PTR _windowClass$[ebp], 48	; 00000030H

; 670  : 	windowClass.style	= CS_HREDRAW | CS_VREDRAW | CS_OWNDC;

	mov	DWORD PTR _windowClass$[ebp+4], 35	; 00000023H

; 671  : 	windowClass.lpfnWndProc	= (WNDPROC)(GLWindowProc);

	mov	DWORD PTR _windowClass$[ebp+8], OFFSET ?GLWindowProc@GLWindow@@KGJPAUHWND__@@IIJ@Z ; GLWindow::GLWindowProc

; 672  : 	windowClass.hInstance	= hInstance;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _windowClass$[ebp+20], edx

; 673  : 	windowClass.hbrBackground	= (HBRUSH)NULL;

	mov	DWORD PTR _windowClass$[ebp+32], 0

; 674  : 	windowClass.hCursor	= LoadCursor(NULL, IDC_ARROW);

	mov	esi, esp
	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _windowClass$[ebp+28], eax

; 675  : 	windowClass.lpszClassName	= "GLWindow";

	mov	DWORD PTR _windowClass$[ebp+40], OFFSET $SG65677

; 676  : 
; 677  : 	if(!RegisterClassEx(&windowClass))

	mov	esi, esp
	lea	eax, DWORD PTR _windowClass$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN1@RegisterWi

; 678  : 	{
; 679  : 		// NOTE: Failure, Should Never Happen
; 680  : 		MessageBox(HWND_DESKTOP, "RegisterClassEx Failed!", "Error", MB_OK | MB_ICONEXCLAMATION);

	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET $SG65680
	push	OFFSET $SG65681
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 681  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@RegisterWi
$LN1@RegisterWi:

; 682  : 	}
; 683  : 
; 684  : 	return true;

	mov	al, 1
$LN2@RegisterWi:

; 685  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@RegisterWi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@RegisterWi:
	DD	1
	DD	$LN5@RegisterWi
$LN5@RegisterWi:
	DD	-56					; ffffffc8H
	DD	48					; 00000030H
	DD	$LN4@RegisterWi
$LN4@RegisterWi:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
?RegisterWindowClass@GLWindow@@IAE_NXZ ENDP		; GLWindow::RegisterWindowClass
_TEXT	ENDS
PUBLIC	?GLWindowMain@GLWindow@@KGKPAX@Z		; GLWindow::GLWindowMain
PUBLIC	?Create@GLWindow@@QAE_NXZ			; GLWindow::Create
EXTRN	__imp__CreateThread@24:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_lpMsgBuf$65687 = -12					; size = 4
_this$ = -4						; size = 4
?Create@GLWindow@@QAE_NXZ PROC				; GLWindow::Create
; _this$ = ecx

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 689  :   if(!bUseSeparateThread)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58]
	test	ecx, ecx
	jne	SHORT $LN3@Create

; 690  :   {
; 691  :     GLWindowMain(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?GLWindowMain@GLWindow@@KGKPAX@Z	; GLWindow::GLWindowMain

; 692  :     return true;

	mov	al, 1
	jmp	$LN4@Create
$LN3@Create:

; 693  :   }
; 694  :   
; 695  :   threadHandle = CreateThread(NULL,0,GLWindow::GLWindowMain,this,0,&threadID);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET ?GLWindowMain@GLWindow@@KGKPAX@Z	; GLWindow::GLWindowMain
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], eax

; 696  :  
; 697  :   if(!threadHandle)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+136], 0
	jne	SHORT $LN2@Create

; 698  :   {
; 699  :     LPVOID lpMsgBuf;
; 700  :     if (!FormatMessage( 
; 701  :         FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 702  :         FORMAT_MESSAGE_FROM_SYSTEM | 
; 703  :         FORMAT_MESSAGE_IGNORE_INSERTS,
; 704  :         NULL,
; 705  :         GetLastError(),
; 706  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 707  :         (LPTSTR) &lpMsgBuf,
; 708  :         0,
; 709  :         NULL ))

	mov	esi, esp
	push	0
	push	0
	lea	ecx, DWORD PTR _lpMsgBuf$65687[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN1@Create

; 710  :     {
; 711  :       // Handle the error.
; 712  :       return false;

	xor	al, al
	jmp	SHORT $LN4@Create
$LN1@Create:

; 713  :     }
; 714  : 
; 715  :     // Process any inserts in lpMsgBuf.
; 716  :     // ...
; 717  : 
; 718  :     // Display the string.
; 719  :     MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );

	mov	esi, esp
	push	64					; 00000040H
	push	OFFSET $SG65693
	mov	edx, DWORD PTR _lpMsgBuf$65687[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 720  : 
; 721  :     // Free the buffer.
; 722  :     LocalFree( lpMsgBuf );  

	mov	esi, esp
	mov	eax, DWORD PTR _lpMsgBuf$65687[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Create:

; 723  :   }
; 724  : 
; 725  :   return threadHandle;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+136], 0
	setne	al
$LN4@Create:

; 726  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Create
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@Create:
	DD	1
	DD	$LN7@Create
$LN7@Create:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@Create
$LN6@Create:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	77					; 0000004dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?Create@GLWindow@@QAE_NXZ ENDP				; GLWindow::Create
_TEXT	ENDS
PUBLIC	?MessagePump@GLWindow@@QAE_NXZ			; GLWindow::MessagePump
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_msg$ = -36						; size = 28
_this$ = -4						; size = 4
?MessagePump@GLWindow@@QAE_NXZ PROC			; GLWindow::MessagePump
; _this$ = ecx

; 731  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 732  : 	MSG	msg;
; 733  : 
; 734  :   if(PeekMessage(&msg, hWnd, 0, 0, PM_REMOVE))

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@MessagePum

; 735  : 	{
; 736  :   	DispatchMessage(&msg);

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@MessagePum:

; 737  : 	}
; 738  : 
; 739  :   return true;

	mov	al, 1

; 740  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@MessagePum
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@MessagePum:
	DD	1
	DD	$LN5@MessagePum
$LN5@MessagePum:
	DD	-36					; ffffffdcH
	DD	28					; 0000001cH
	DD	$LN4@MessagePum
$LN4@MessagePum:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
?MessagePump@GLWindow@@QAE_NXZ ENDP			; GLWindow::MessagePump
_TEXT	ENDS
EXTRN	__imp__WaitMessage@0:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_msg$ = -40						; size = 28
_bMessagePumpActive$ = -5				; size = 1
_glWindow$ = -4						; size = 4
_param$ = 8						; size = 4
?GLWindowMain@GLWindow@@KGKPAX@Z PROC			; GLWindow::GLWindowMain

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 744  :   GLWindow *glWindow = (GLWindow *)param;

	mov	eax, DWORD PTR _param$[ebp]
	mov	DWORD PTR _glWindow$[ebp], eax

; 745  : 	bool bMessagePumpActive;
; 746  : 	MSG	msg;
; 747  : 
; 748  : 	// Fill Out Application Data
; 749  :   glWindow->className = ::className;

	mov	ecx, DWORD PTR _glWindow$[ebp]
	mov	DWORD PTR [ecx+16], OFFSET ?className@@3PADA ; className

; 750  : 
; 751  : 	// Fill Out Window
; 752  : 
; 753  : 	// Register the window class
; 754  : 	if(!glWindow->RegisterWindowClass())

	mov	ecx, DWORD PTR _glWindow$[ebp]
	call	?RegisterWindowClass@GLWindow@@IAE_NXZ	; GLWindow::RegisterWindowClass
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@GLWindowMa

; 755  : 	{
; 756  : 		MessageBox(HWND_DESKTOP, "Error Registering Window Class!", "Error", MB_OK | MB_ICONEXCLAMATION);

	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET $SG65710
	push	OFFSET $SG65711
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 757  : 		return false;

	xor	eax, eax
	jmp	$LN12@GLWindowMa
$LN11@GLWindowMa:

; 758  : 	}
; 759  : 
; 760  : 	bTerminate = false;

	mov	BYTE PTR ?bTerminate@@3_NA, 0		; bTerminate

; 761  : 
; 762  : 	// Create A Window
; 763  : 	if(glWindow->CreateWindowGL())

	mov	ecx, DWORD PTR _glWindow$[ebp]
	call	?CreateWindowGL@GLWindow@@IAE_NXZ	; GLWindow::CreateWindowGL
	movzx	eax, al
	test	eax, eax
	je	$LN10@GLWindowMa

; 764  : 	{
; 765  :     glWindow->OnResize(glWindow->clientWidth,glWindow->clientHeight);

	mov	ecx, DWORD PTR _glWindow$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _glWindow$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _glWindow$[ebp]
	call	?OnResize@GLWindow@@IAEXHH@Z		; GLWindow::OnResize

; 766  :     
; 767  : 		bMessagePumpActive = true;

	mov	BYTE PTR _bMessagePumpActive$[ebp], 1

; 768  :     glWindow->bCreated = true;

	mov	edx, DWORD PTR _glWindow$[ebp]
	mov	BYTE PTR [edx+112], 1

; 769  :     if(glWindow->bUseSeparateThread)

	mov	eax, DWORD PTR _glWindow$[ebp]
	movzx	ecx, BYTE PTR [eax+58]
	test	ecx, ecx
	je	$LN9@GLWindowMa
$LN8@GLWindowMa:

; 770  :     {
; 771  : 		  while(bMessagePumpActive)

	movzx	edx, BYTE PTR _bMessagePumpActive$[ebp]
	test	edx, edx
	je	SHORT $LN7@GLWindowMa

; 772  : 		  {
; 773  : 			  // Success Creating Window.  Check For Window Messages
; 774  : 			  if(PeekMessage(&msg, glWindow->hWnd, 0, 0, PM_REMOVE))

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _glWindow$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN6@GLWindowMa

; 775  : 			  {
; 776  : 				  // Check For WM_QUIT Message
; 777  : 				  if(msg.message != WM_QUIT)

	cmp	DWORD PTR _msg$[ebp+4], 18		; 00000012H
	je	SHORT $LN5@GLWindowMa

; 778  : 				  {
; 779  : 					  DispatchMessage(&msg);

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 780  : 				  }
; 781  : 				  else

	jmp	SHORT $LN4@GLWindowMa
$LN5@GLWindowMa:

; 782  : 				  {
; 783  : 					  bMessagePumpActive = false;

	mov	BYTE PTR _bMessagePumpActive$[ebp], 0
$LN4@GLWindowMa:

; 784  : 				  }
; 785  :         }
; 786  :         else

	jmp	SHORT $LN3@GLWindowMa
$LN6@GLWindowMa:

; 787  : 			  {
; 788  :   			  // Process Application Loop
; 789  : 				  if(glWindow->idleHandler)

	mov	ecx, DWORD PTR _glWindow$[ebp]
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $LN2@GLWindowMa

; 790  :           {
; 791  :             glWindow->idleHandler(0,0);

	mov	esi, esp
	push	0
	push	0
	mov	edx, DWORD PTR _glWindow$[ebp]
	mov	eax, DWORD PTR [edx+88]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@GLWindowMa:

; 792  :           }
; 793  : 
; 794  :           WaitMessage();

	mov	esi, esp
	call	DWORD PTR __imp__WaitMessage@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@GLWindowMa:

; 795  : 			  }
; 796  :       }

	jmp	SHORT $LN8@GLWindowMa
$LN7@GLWindowMa:

; 797  : 
; 798  :       glWindow->CleanUp();

	mov	ecx, DWORD PTR _glWindow$[ebp]
	call	?CleanUp@GLWindow@@IAEXXZ		; GLWindow::CleanUp

; 799  :       glWindow->bCreated = false;

	mov	ecx, DWORD PTR _glWindow$[ebp]
	mov	BYTE PTR [ecx+112], 0
$LN9@GLWindowMa:

; 800  :     }
; 801  :   }
; 802  : 	else

	jmp	SHORT $LN1@GLWindowMa
$LN10@GLWindowMa:

; 803  : 	{
; 804  : 		MessageBox(HWND_DESKTOP, "Error Creating OpenGL Window", "Error", MB_OK | MB_ICONEXCLAMATION);

	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET $SG65724
	push	OFFSET $SG65725
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 805  :     return false;

	xor	eax, eax
	jmp	SHORT $LN12@GLWindowMa
$LN1@GLWindowMa:

; 806  : 	}
; 807  : 
; 808  : 	return true;

	mov	eax, 1
$LN12@GLWindowMa:

; 809  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@GLWindowMa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN16@GLWindowMa:
	DD	1
	DD	$LN15@GLWindowMa
$LN15@GLWindowMa:
	DD	-40					; ffffffd8H
	DD	28					; 0000001cH
	DD	$LN14@GLWindowMa
$LN14@GLWindowMa:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
?GLWindowMain@GLWindow@@KGKPAX@Z ENDP			; GLWindow::GLWindowMain
_TEXT	ENDS
END
