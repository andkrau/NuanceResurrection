; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\Syscall.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?WaitForInterruptList@@3PAIA			; WaitForInterruptList
_BSS	SEGMENT
?WaitForInterruptList@@3PAIA DD 04H DUP (?)		; WaitForInterruptList
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12178
_DATA	ENDS
CONST	SEGMENT
$SG12178 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z	; Syscall_InterruptTriggered
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\syscall.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_interruptMask$ = -8					; size = 4
_mpeIndex$ = -4						; size = 4
_mpe$ = 8						; size = 4
?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z PROC		; Syscall_InterruptTriggered

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13   :   uint32 mpeIndex = mpe->mpeIndex;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _mpeIndex$[ebp], ecx

; 14   :   uint32 interruptMask = WaitForInterruptList[mpeIndex];

	mov	edx, DWORD PTR _mpeIndex$[ebp]
	mov	eax, DWORD PTR ?WaitForInterruptList@@3PAIA[edx*4]
	mov	DWORD PTR _interruptMask$[ebp], eax

; 15   : 
; 16   :   if(interruptMask)

	cmp	DWORD PTR _interruptMask$[ebp], 0
	je	SHORT $LN3@Syscall_In

; 17   :   {
; 18   :     if(mpe->intsrc & (mpe->inten1 | (1 << mpe->inten2sel)) & interruptMask)

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+444]
	shl	edx, cl
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+432]
	mov	ecx, DWORD PTR _mpe$[ebp]
	and	edx, DWORD PTR [ecx+420]
	and	edx, DWORD PTR _interruptMask$[ebp]
	je	SHORT $LN3@Syscall_In

; 19   :     {
; 20   :       //enabled interrupt is waiting to be processed so wake up the processor
; 21   :       mpe->mpectl |= MPECTRL_MPEGO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+384]
	or	eax, 2
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+384], eax

; 22   :       //no longer waiting for interrupts
; 23   :       WaitForInterruptList[mpeIndex] = 0;

	mov	edx, DWORD PTR _mpeIndex$[ebp]
	mov	DWORD PTR ?WaitForInterruptList@@3PAIA[edx*4], 0

; 24   :       //register the state change in case we want to optimize the outer dispatch loop
; 25   :       nuonEnv->bProcessorStartStopChange = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+85], 1
$LN3@Syscall_In:

; 26   :     }
; 27   :   }
; 28   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Syscall_InterruptTriggered@@YAXPAVMPE@@@Z ENDP		; Syscall_InterruptTriggered
_TEXT	ENDS
PUBLIC	?Syscall_WaitForInterruptCommon@@YAXII@Z	; Syscall_WaitForInterruptCommon
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = -4						; size = 4
_mpeIndex$ = 8						; size = 4
_interruptMask$ = 12					; size = 4
?Syscall_WaitForInterruptCommon@@YAXII@Z PROC		; Syscall_WaitForInterruptCommon

; 31   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 32   :   MPE *mpe = nuonEnv->mpe[mpeIndex];

	mov	eax, DWORD PTR _mpeIndex$[ebp]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _mpe$[ebp], edx

; 33   :   if(interruptMask && !(mpe->intsrc & (mpe->inten1 | (1 << mpe->inten2sel)) & interruptMask))

	cmp	DWORD PTR _interruptMask$[ebp], 0
	je	SHORT $LN2@Syscall_Wa
	mov	eax, DWORD PTR _mpe$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+444]
	shl	edx, cl
	mov	eax, DWORD PTR _mpe$[ebp]
	or	edx, DWORD PTR [eax+432]
	mov	ecx, DWORD PTR _mpe$[ebp]
	and	edx, DWORD PTR [ecx+420]
	and	edx, DWORD PTR _interruptMask$[ebp]
	jne	SHORT $LN2@Syscall_Wa

; 34   :   {
; 35   :     //stop
; 36   :     mpe->mpectl &= ~MPECTRL_MPEGO;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+384]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx+384], eax

; 37   :     //clear hw and sw masks
; 38   :     mpe->intctl = 0;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx+428], 0

; 39   :     WaitForInterruptList[mpe->mpeIndex] = interruptMask;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	edx, DWORD PTR _interruptMask$[ebp]
	mov	DWORD PTR ?WaitForInterruptList@@3PAIA[ecx*4], edx

; 40   :       //register the state change in case we want to optimize the outer dispatch loop
; 41   :     nuonEnv->bProcessorStartStopChange = true;

	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [eax+85], 1
$LN2@Syscall_Wa:

; 42   :   }
; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Syscall_WaitForInterruptCommon@@YAXII@Z ENDP		; Syscall_WaitForInterruptCommon
_TEXT	ENDS
PUBLIC	?Syscall_WaitForCommPacket@@YAXPAVMPE@@@Z	; Syscall_WaitForCommPacket
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?media_mpe@@3IA:DWORD				; media_mpe
EXTRN	?media_mpe_allocated@@3IA:DWORD			; media_mpe_allocated
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_memPtr$ = -16						; size = 4
_mpeIndex$ = -4						; size = 4
_mpe$ = 8						; size = 4
?Syscall_WaitForCommPacket@@YAXPAVMPE@@@Z PROC		; Syscall_WaitForCommPacket

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 47   :   uint32 mpeIndex = mpe->mpeIndex;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _mpeIndex$[ebp], ecx

; 48   :   uint32 queue_head;
; 49   :   uint32 queue_tail;
; 50   :   uint32 *memPtr;
; 51   :   if(media_mpe_allocated && (mpeIndex == media_mpe))

	cmp	DWORD PTR ?media_mpe_allocated@@3IA, 0	; media_mpe_allocated
	je	SHORT $LN9@Syscall_Wa@2
	mov	edx, DWORD PTR _mpeIndex$[ebp]
	cmp	edx, DWORD PTR ?media_mpe@@3IA		; media_mpe
	jne	SHORT $LN9@Syscall_Wa@2

; 52   :   {
; 53   :     if(mpeIndex == 0)

	cmp	DWORD PTR _mpeIndex$[ebp], 0
	jne	SHORT $LN8@Syscall_Wa@2

; 54   :     {
; 55   :       memPtr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,MINIBIOS_QUEUE2_TAIL_ADDRESS,false);

	push	0
	push	537926680				; 20101c18H
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 56   :     }
; 57   :     else

	jmp	SHORT $LN7@Syscall_Wa@2
$LN8@Syscall_Wa@2:

; 58   :     {
; 59   :       memPtr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,MINIBIOSX_QUEUE2_TAIL_ADDRESS,false);

	push	0
	push	537922584				; 20100c18H
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax
$LN7@Syscall_Wa@2:

; 60   :     }
; 61   : 
; 62   :     if(*memPtr == *(memPtr + 1))

	mov	edx, DWORD PTR _memPtr$[ebp]
	mov	eax, DWORD PTR _memPtr$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN6@Syscall_Wa@2

; 63   :     {
; 64   :       //If queue2 head equals queue2 tail then there are no user packets available so the processor should wait for interrupts
; 65   :       Syscall_WaitForInterruptCommon(mpeIndex,mpe->inten1 | (1 << mpe->inten2sel));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+444]
	shl	eax, cl
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+432]
	push	eax
	mov	edx, DWORD PTR _mpeIndex$[ebp]
	push	edx
	call	?Syscall_WaitForInterruptCommon@@YAXII@Z ; Syscall_WaitForInterruptCommon
	add	esp, 8
$LN6@Syscall_Wa@2:

; 66   :     }
; 67   :   }

	jmp	$LN10@Syscall_Wa@2
$LN9@Syscall_Wa@2:

; 68   :   else if(mpeIndex == 3)

	cmp	DWORD PTR _mpeIndex$[ebp], 3
	jne	SHORT $LN4@Syscall_Wa@2

; 69   :   {
; 70   :     //MPE3 is running the BIOS so check the BIOS commrecv packet storage address
; 71   :     memPtr = (uint32 *)nuonEnv->GetPointerToMemory(mpe,COMMRECV_PACKET_AVAILABLE_ADDRESS,false);

	push	0
	push	-2139095832				; 807ffce8H
	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _memPtr$[ebp], eax

; 72   :     if(!*memPtr)

	mov	ecx, DWORD PTR _memPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@Syscall_Wa@2

; 73   :     {
; 74   :       //No user comm packet is available so wait for interrupts
; 75   :       Syscall_WaitForInterruptCommon(mpeIndex,mpe->inten1 | (1 << mpe->inten2sel));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+444]
	shl	eax, cl
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+432]
	push	eax
	mov	edx, DWORD PTR _mpeIndex$[ebp]
	push	edx
	call	?Syscall_WaitForInterruptCommon@@YAXII@Z ; Syscall_WaitForInterruptCommon
	add	esp, 8
$LN3@Syscall_Wa@2:

; 76   :     }
; 77   :   }

	jmp	SHORT $LN10@Syscall_Wa@2
$LN4@Syscall_Wa@2:

; 78   :   else if(!(mpe->commctl & COMM_RECV_BUFFER_FULL_BIT))

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+492]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN10@Syscall_Wa@2

; 79   :   {
; 80   :     //The commrecv buffer is empty so there is obviously no available packet and we should wait for interrupts
; 81   :     Syscall_WaitForInterruptCommon(mpeIndex,mpe->inten1 | (1 << mpe->inten2sel));

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+444]
	shl	eax, cl
	mov	ecx, DWORD PTR _mpe$[ebp]
	or	eax, DWORD PTR [ecx+432]
	push	eax
	mov	edx, DWORD PTR _mpeIndex$[ebp]
	push	edx
	call	?Syscall_WaitForInterruptCommon@@YAXII@Z ; Syscall_WaitForInterruptCommon
	add	esp, 8
$LN10@Syscall_Wa@2:

; 82   :   }
; 83   : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Syscall_WaitForCommPacket@@YAXPAVMPE@@@Z ENDP		; Syscall_WaitForCommPacket
_TEXT	ENDS
PUBLIC	?Syscall_WaitForInterrupt@@YAXPAVMPE@@@Z	; Syscall_WaitForInterrupt
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpeIndex$ = -8						; size = 4
_interruptMask$ = -4					; size = 4
_mpe$ = 8						; size = 4
?Syscall_WaitForInterrupt@@YAXPAVMPE@@@Z PROC		; Syscall_WaitForInterrupt

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 87   :   uint32 interruptMask = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _interruptMask$[ebp], ecx

; 88   :   uint32 mpeIndex = mpe->mpeIndex;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	eax, DWORD PTR [edx+664]
	mov	DWORD PTR _mpeIndex$[ebp], eax

; 89   : 
; 90   :   Syscall_WaitForInterruptCommon(mpeIndex, interruptMask);

	mov	ecx, DWORD PTR _interruptMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mpeIndex$[ebp]
	push	edx
	call	?Syscall_WaitForInterruptCommon@@YAXII@Z ; Syscall_WaitForInterruptCommon
	add	esp, 8

; 91   : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Syscall_WaitForInterrupt@@YAXPAVMPE@@@Z ENDP		; Syscall_WaitForInterrupt
_TEXT	ENDS
PUBLIC	?Syscall_ClearWaitForInterrupt@@YAXPAVMPE@@@Z	; Syscall_ClearWaitForInterrupt
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_mpe$ = 8						; size = 4
?Syscall_ClearWaitForInterrupt@@YAXPAVMPE@@@Z PROC	; Syscall_ClearWaitForInterrupt

; 94   : {

	push	ebp
	mov	ebp, esp

; 95   :   WaitForInterruptList[mpe->mpeIndex] = 0;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR ?WaitForInterruptList@@3PAIA[ecx*4], 0

; 96   : }

	pop	ebp
	ret	0
?Syscall_ClearWaitForInterrupt@@YAXPAVMPE@@@Z ENDP	; Syscall_ClearWaitForInterrupt
_TEXT	ENDS
PUBLIC	?ExecuteSyscall_Interrupts@@YAXPAVMPE@@I@Z	; ExecuteSyscall_Interrupts
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv65 = -8						; size = 4
_mpeIndex$ = -4						; size = 4
_mpe$ = 8						; size = 4
_function$ = 12						; size = 4
?ExecuteSyscall_Interrupts@@YAXPAVMPE@@I@Z PROC		; ExecuteSyscall_Interrupts

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 100  :   uint32 mpeIndex = mpe->mpeIndex;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR _mpeIndex$[ebp], ecx

; 101  : 
; 102  :   switch(function)

	mov	edx, DWORD PTR _function$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN2@ExecuteSys
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN1@ExecuteSys
	jmp	SHORT $LN5@ExecuteSys
$LN2@ExecuteSys:

; 103  :   {
; 104  :     case 0:
; 105  :       Syscall_WaitForInterrupt(mpe);

	mov	eax, DWORD PTR _mpe$[ebp]
	push	eax
	call	?Syscall_WaitForInterrupt@@YAXPAVMPE@@@Z ; Syscall_WaitForInterrupt
	add	esp, 4

; 106  :       break;

	jmp	SHORT $LN5@ExecuteSys
$LN1@ExecuteSys:

; 107  :     case 1:
; 108  :       Syscall_WaitForCommPacket(mpe);

	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?Syscall_WaitForCommPacket@@YAXPAVMPE@@@Z ; Syscall_WaitForCommPacket
	add	esp, 4
$LN5@ExecuteSys:

; 109  :       break;
; 110  :   }
; 111  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ExecuteSyscall_Interrupts@@YAXPAVMPE@@I@Z ENDP		; ExecuteSyscall_Interrupts
_TEXT	ENDS
PUBLIC	?ExecuteSyscall@@YAXPAVMPE@@I@Z			; ExecuteSyscall
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
tv66 = -12						; size = 4
_function$ = -8						; size = 4
_category$ = -4						; size = 4
_mpe$ = 8						; size = 4
_syscall$ = 12						; size = 4
?ExecuteSyscall@@YAXPAVMPE@@I@Z PROC			; ExecuteSyscall

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 115  :   uint32 category = syscall >> 24;

	mov	eax, DWORD PTR _syscall$[ebp]
	shr	eax, 24					; 00000018H
	mov	DWORD PTR _category$[ebp], eax

; 116  :   uint32 function = syscall & 0xFFFFFFUL;

	mov	ecx, DWORD PTR _syscall$[ebp]
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR _function$[ebp], ecx

; 117  : 
; 118  :   //Category 0: Compiler hints
; 119  :     //1: Set invariant region
; 120  :     //2: Clear invariant region
; 121  :   //Category 1: Interrupts
; 122  :     //0: WaitForInterrupt
; 123  :     //1: WaitForCommPacket
; 124  :   switch(category)

	mov	edx, DWORD PTR _category$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN1@ExecuteSys@2
	jmp	SHORT $LN5@ExecuteSys@2

; 125  :   {
; 126  :     case 0:
; 127  :       break;

	jmp	SHORT $LN5@ExecuteSys@2
$LN1@ExecuteSys@2:

; 128  :     case 1:
; 129  :       ExecuteSyscall_Interrupts(mpe, function);

	mov	eax, DWORD PTR _function$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	call	?ExecuteSyscall_Interrupts@@YAXPAVMPE@@I@Z ; ExecuteSyscall_Interrupts
	add	esp, 8
$LN5@ExecuteSys@2:

; 130  :       break;   
; 131  :   }
; 132  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ExecuteSyscall@@YAXPAVMPE@@I@Z ENDP			; ExecuteSyscall
_TEXT	ENDS
END
