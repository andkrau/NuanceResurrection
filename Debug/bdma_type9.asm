; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\bdma_type9.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12224
_DATA	ENDS
CONST	SEGMENT
$SG12224 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?BDMA_Type9_Write_0@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_0
EXTRN	?SwapWordBytes@@YIXPAG@Z:PROC			; SwapWordBytes
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	?structMainChannel@@3UVidChannel@@A:BYTE	; structMainChannel
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\bdma_type9.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
tv282 = -208						; size = 4
tv267 = -204						; size = 4
tv264 = -200						; size = 4
$T43620 = -193						; size = 1
_ztransfer$41396 = -188					; size = 2
_ztarget$41395 = -176					; size = 2
_result$41394 = -166					; size = 1
_bZTestResult$ = -165					; size = 1
_bUpdateZ$ = -164					; size = 1
_bUpdatePixel$ = -163					; size = 1
_bCompareZ$ = -162					; size = 1
_bTrigger$ = -161					; size = 1
_bRemote$ = -160					; size = 1
_bDup$ = -159						; size = 1
_bDirect$ = -158					; size = 1
_bRead$ = -157						; size = 1
_mapOffset$ = -156					; size = 4
_destZOffset$ = -148					; size = 4
_zmap$ = -144						; size = 4
_map$ = -140						; size = 4
_mpeBase$ = -136					; size = 4
_sdramBase$ = -132					; size = 4
_mode$ = -128						; size = 4
_bva$ = -124						; size = 4
_zcompare$ = -120					; size = 4
_ypos$ = -116						; size = 4
_ylen$ = -112						; size = 4
_xpos$ = -108						; size = 4
_xlen$ = -104						; size = 4
_xsize$ = -100						; size = 4
_destBStep$ = -96					; size = 4
_destAStep$ = -92					; size = 4
_srcBStep$ = -88					; size = 4
_srcAStep$ = -84					; size = 4
_destOffset$ = -80					; size = 4
_srcOffset$ = -76					; size = 4
_destB$ = -72						; size = 4
_destA$ = -68						; size = 4
_srcB$ = -64						; size = 4
_srcA$ = -60						; size = 4
_bCount$ = -56						; size = 4
_aCount$ = -52						; size = 4
_pixtype$ = -48						; size = 4
_type$ = -44						; size = 4
_directValue$ = -36					; size = 4
_pDest$ = -28						; size = 4
_pSrc$ = -24						; size = 4
_baseMemory$ = -20					; size = 4
_intMemory$ = -16					; size = 4
_pSrc16$ = -12						; size = 4
_pDest16$ = -8						; size = 4
_pSrc32$ = -4						; size = 4
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_0

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13   :   uint32 *pSrc32;
; 14   :   uint16 *pDest16, *pSrc16;
; 15   :   void *intMemory, *baseMemory, *pSrc, *pDest;
; 16   :   uint32 directValue, type, pixtype;
; 17   :   uint32 aCount, bCount;
; 18   :   uint32 srcA, srcB, destA, destB, srcOffset, destOffset;
; 19   :   int32 srcAStep, srcBStep, destAStep, destBStep, xsize;
; 20   :   uint32 xlen, xpos, ylen, ypos, zcompare, bva;
; 21   :   uint32 mode, sdramBase, mpeBase, map, zmap, destZOffset, srcZOffset, mapOffset;
; 22   : 
; 23   :   bool bRead, bDirect, bDup, bRemote, bTrigger, bCompareZ, bUpdatePixel, bUpdateZ, bZTestResult;
; 24   : 
; 25   :   bRemote = flags & (1UL << 28);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 268435456				; 10000000H
	setne	cl
	mov	BYTE PTR _bRemote$[ebp], cl

; 26   :   bDirect = flags & (1UL << 27);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 134217728				; 08000000H
	setne	al
	mov	BYTE PTR _bDirect$[ebp], al

; 27   :   bDup = flags & (3UL << 26); //bDup = dup | direct

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 201326592				; 0c000000H
	setne	dl
	mov	BYTE PTR _bDup$[ebp], dl

; 28   :   bTrigger = flags & (1UL << 25);

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 33554432				; 02000000H
	setne	cl
	mov	BYTE PTR _bTrigger$[ebp], cl

; 29   :   bRead = flags & (1UL << 13);

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8192				; 00002000H
	setne	al
	mov	BYTE PTR _bRead$[ebp], al

; 30   :   xsize = (flags >> 13) & 0x7F8UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 13					; 0000000dH
	and	ecx, 2040				; 000007f8H
	mov	DWORD PTR _xsize$[ebp], ecx

; 31   :   type = (flags >> 14) & 0x03UL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 14					; 0000000eH
	and	edx, 3
	mov	DWORD PTR _type$[ebp], edx

; 32   :   mode = flags & 0xFFFUL;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR _mode$[ebp], eax

; 33   :   zcompare = (flags >> 1) & 0x07UL;

	mov	ecx, DWORD PTR _flags$[ebp]
	shr	ecx, 1
	and	ecx, 7
	mov	DWORD PTR _zcompare$[ebp], ecx

; 34   :   pixtype = (flags >> 4) & 0x0FUL;

	mov	edx, DWORD PTR _flags$[ebp]
	shr	edx, 4
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _pixtype$[ebp], edx

; 35   :   bva = ((flags >> 7) & 0x06UL) | (flags & 0x01UL);

	mov	eax, DWORD PTR _flags$[ebp]
	shr	eax, 7
	and	eax, 6
	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	or	eax, ecx
	mov	DWORD PTR _bva$[ebp], eax

; 36   :   sdramBase = baseaddr & 0x7FFFFFFEUL;

	mov	edx, DWORD PTR _baseaddr$[ebp]
	and	edx, 2147483646				; 7ffffffeH
	mov	DWORD PTR _sdramBase$[ebp], edx

; 37   :   mpeBase = intaddr & 0x7FFFFFFCUL;

	mov	eax, DWORD PTR _intaddr$[ebp]
	and	eax, 2147483644				; 7ffffffcH
	mov	DWORD PTR _mpeBase$[ebp], eax

; 38   :   xlen = (xinfo >> 16) & 0x3FFUL;

	mov	ecx, DWORD PTR _xinfo$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _xlen$[ebp], ecx

; 39   :   xpos = xinfo & 0x7FFUL;

	mov	edx, DWORD PTR _xinfo$[ebp]
	and	edx, 2047				; 000007ffH
	mov	DWORD PTR _xpos$[ebp], edx

; 40   :   ylen = (yinfo >> 16) & 0x3FFUL;

	mov	eax, DWORD PTR _yinfo$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 1023				; 000003ffH
	mov	DWORD PTR _ylen$[ebp], eax

; 41   :   ypos = yinfo & 0x7FFUL;

	mov	ecx, DWORD PTR _yinfo$[ebp]
	and	ecx, 2047				; 000007ffH
	mov	DWORD PTR _ypos$[ebp], ecx

; 42   : 
; 43   :   directValue = intaddr;

	mov	edx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], edx

; 44   : 
; 45   :   //pixel+Z write (16 + 16Z)
; 46   :   bCompareZ = true;

	mov	BYTE PTR _bCompareZ$[ebp], 1

; 47   :   bUpdatePixel = true;

	mov	BYTE PTR _bUpdatePixel$[ebp], 1

; 48   :   bUpdateZ = true;

	mov	BYTE PTR _bUpdateZ$[ebp], 1

; 49   : 
; 50   :   if(pixtype == 15 || pixtype == 12)

	cmp	DWORD PTR _pixtype$[ebp], 15		; 0000000fH
	je	SHORT $LN33@BDMA_Type9
	cmp	DWORD PTR _pixtype$[ebp], 12		; 0000000cH
	jne	SHORT $LN34@BDMA_Type9
$LN33@BDMA_Type9:

; 51   :   {
; 52   :     map = 2;

	mov	DWORD PTR _map$[ebp], 2
$LN34@BDMA_Type9:

; 53   :   }
; 54   : 
; 55   :   if(pixtype > 12)

	cmp	DWORD PTR _pixtype$[ebp], 12		; 0000000cH
	jbe	SHORT $LN32@BDMA_Type9

; 56   :   {
; 57   :     map = pixtype - 13;

	mov	eax, DWORD PTR _pixtype$[ebp]
	sub	eax, 13					; 0000000dH
	mov	DWORD PTR _map$[ebp], eax

; 58   :     zmap = 2;

	mov	DWORD PTR _zmap$[ebp], 2

; 59   :   }
; 60   :   else

	jmp	SHORT $LN31@BDMA_Type9
$LN32@BDMA_Type9:

; 61   :   {
; 62   :     map = pixtype - 9;

	mov	ecx, DWORD PTR _pixtype$[ebp]
	sub	ecx, 9
	mov	DWORD PTR _map$[ebp], ecx

; 63   :     zmap = 3;

	mov	DWORD PTR _zmap$[ebp], 3
$LN31@BDMA_Type9:

; 64   :   }
; 65   : 
; 66   : 
; 67   :   //The formula (framebuffer width * framebuffer size * (zmap - map)) specifies the pixel
; 68   :   //offset that is added to the pixel address to obtain the address of the associated z-value
; 69   : 
; 70   :   destZOffset = xsize * structMainChannel.src_height * zmap;

	mov	edx, DWORD PTR _xsize$[ebp]
	imul	edx, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	imul	edx, DWORD PTR _zmap$[ebp]
	mov	DWORD PTR _destZOffset$[ebp], edx

; 71   :   mapOffset = xsize * structMainChannel.src_height * map;

	mov	eax, DWORD PTR _xsize$[ebp]
	imul	eax, DWORD PTR ?structMainChannel@@3UVidChannel@@A+36
	imul	eax, DWORD PTR _map$[ebp]
	mov	DWORD PTR _mapOffset$[ebp], eax

; 72   : 
; 73   :   if(bRemote)

	movzx	ecx, BYTE PTR _bRemote$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@BDMA_Type9

; 74   :   {
; 75   :     //internal address is system address (but still in MPE memory)
; 76   :     intMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(mpeBase >> 23) & 0x1FUL], mpeBase & 0x207FFFFF, false);

	push	0
	mov	edx, DWORD PTR _mpeBase$[ebp]
	and	edx, 545259519				; 207fffffH
	push	edx
	mov	eax, DWORD PTR _mpeBase$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax

; 77   :   }
; 78   :   else

	jmp	SHORT $LN29@BDMA_Type9
$LN30@BDMA_Type9:

; 79   :   {
; 80   :     //internal address is local to MPE
; 81   :     intMemory = nuonEnv->GetPointerToMemory(the_mpe, mpeBase & 0x207FFFFF, false);

	push	0
	mov	eax, DWORD PTR _mpeBase$[ebp]
	and	eax, 545259519				; 207fffffH
	push	eax
	mov	ecx, DWORD PTR _the_mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _intMemory$[ebp], eax
$LN29@BDMA_Type9:

; 82   :   }
; 83   : 
; 84   :   //base address is always a system address (absolute)
; 85   :   baseMemory = nuonEnv->GetPointerToMemory(nuonEnv->mpe[(sdramBase >> 23) & 0x1FUL], sdramBase, false);

	push	0
	mov	edx, DWORD PTR _sdramBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _sdramBase$[ebp]
	shr	eax, 23					; 00000017H
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR _baseMemory$[ebp], eax

; 86   : 
; 87   :   pSrc = intMemory;

	mov	eax, DWORD PTR _intMemory$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax

; 88   :   pDest = baseMemory;

	mov	ecx, DWORD PTR _baseMemory$[ebp]
	mov	DWORD PTR _pDest$[ebp], ecx

; 89   : 
; 90   :   if(bDup)

	movzx	edx, BYTE PTR _bDup$[ebp]
	test	edx, edx
	je	SHORT $LN28@BDMA_Type9

; 91   :   {
; 92   :     if(bDirect)

	movzx	eax, BYTE PTR _bDirect$[ebp]
	test	eax, eax
	je	SHORT $LN27@BDMA_Type9

; 93   :     {
; 94   :       //Direct and Dup: intaddr is data.
; 95   :       directValue = intaddr;

	mov	ecx, DWORD PTR _intaddr$[ebp]
	mov	DWORD PTR _directValue$[ebp], ecx

; 96   :       //swap back to big endian format
; 97   :       SwapScalarBytes(&directValue);

	lea	ecx, DWORD PTR _directValue$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 98   :     }
; 99   :     else

	jmp	SHORT $LN26@BDMA_Type9
$LN27@BDMA_Type9:

; 100  :     {
; 101  :       //Dup but not Direct: read scalar from memory, no need to swap
; 102  :       directValue = *(uint32 *)intMemory;

	mov	edx, DWORD PTR _intMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _directValue$[ebp], eax
$LN26@BDMA_Type9:

; 103  :     }
; 104  : 
; 105  :     pSrc = (void *)&directValue;

	lea	ecx, DWORD PTR _directValue$[ebp]
	mov	DWORD PTR _pSrc$[ebp], ecx

; 106  :     srcAStep = 0;

	mov	DWORD PTR _srcAStep$[ebp], 0

; 107  :     srcBStep = 0;

	mov	DWORD PTR _srcBStep$[ebp], 0

; 108  :   }
; 109  :   else

	jmp	SHORT $LN25@BDMA_Type9
$LN28@BDMA_Type9:

; 110  :   {
; 111  :     srcAStep = 1;

	mov	DWORD PTR _srcAStep$[ebp], 1

; 112  :     srcBStep = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _srcBStep$[ebp], edx
$LN25@BDMA_Type9:

; 113  :   }
; 114  : 
; 115  :   srcOffset = 0;

	mov	DWORD PTR _srcOffset$[ebp], 0

; 116  :   destOffset = ((ypos * (uint32)xsize)) + xpos;

	mov	eax, DWORD PTR _ypos$[ebp]
	imul	eax, DWORD PTR _xsize$[ebp]
	add	eax, DWORD PTR _xpos$[ebp]
	mov	DWORD PTR _destOffset$[ebp], eax

; 117  : 
; 118  :   //BVA = 000 (horizontal DMA, x increment, y increment)
; 119  :   destAStep = 1;

	mov	DWORD PTR _destAStep$[ebp], 1

; 120  :   destBStep = xsize;

	mov	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destBStep$[ebp], ecx

; 121  :   aCount = xlen;

	mov	edx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], edx

; 122  :   bCount = ylen;

	mov	eax, DWORD PTR _ylen$[ebp]
	mov	DWORD PTR _bCount$[ebp], eax

; 123  : 
; 124  :   pSrc32 = ((uint32 *)pSrc) + srcOffset;

	mov	ecx, DWORD PTR _srcOffset$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pSrc32$[ebp], eax

; 125  :   pSrc16 = ((uint16 *)pSrc) + srcOffset;

	mov	ecx, DWORD PTR _srcOffset$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pSrc16$[ebp], eax

; 126  :   pDest16 = (uint16 *)pDest + destOffset;

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _pDest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pDest16$[ebp], eax

; 127  :   srcB = 0;

	mov	DWORD PTR _srcB$[ebp], 0

; 128  :   destB = 0;

	mov	DWORD PTR _destB$[ebp], 0

; 129  : 
; 130  :   if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->mainChannelUpperLimit) ||
; 131  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->mainChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->mainChannelUpperLimit))

	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+52]
	jb	SHORT $LN22@BDMA_Type9
	mov	edx, DWORD PTR _destOffset$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+48]
	jbe	SHORT $LN23@BDMA_Type9
$LN22@BDMA_Type9:
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+52]
	jb	SHORT $LN24@BDMA_Type9
	mov	ecx, DWORD PTR _xsize$[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _ylen$[ebp]
	add	ecx, DWORD PTR _destOffset$[ebp]
	add	ecx, DWORD PTR _xlen$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+48]
	ja	SHORT $LN24@BDMA_Type9
$LN23@BDMA_Type9:

; 132  :   {
; 133  :     nuonEnv->bMainBufferModified = true;

	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [edx+86], 1

; 134  :   }
; 135  :   else if((GetPixBaseAddr(sdramBase,destOffset,2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,destOffset,2) <= nuonEnv->overlayChannelUpperLimit) ||

	jmp	SHORT $LN17@BDMA_Type9
$LN24@BDMA_Type9:

; 136  :       (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) >= nuonEnv->overlayChannelLowerLimit) && (GetPixBaseAddr(sdramBase,(destOffset+((xsize - 1)*ylen)+xlen),2) <= nuonEnv->overlayChannelUpperLimit))

	mov	eax, DWORD PTR _destOffset$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+60]
	jb	SHORT $LN18@BDMA_Type9
	mov	ecx, DWORD PTR _destOffset$[ebp]
	mov	edx, DWORD PTR _sdramBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	eax, DWORD PTR [ecx+56]
	jbe	SHORT $LN19@BDMA_Type9
$LN18@BDMA_Type9:
	mov	edx, DWORD PTR _xsize$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _ylen$[ebp]
	add	edx, DWORD PTR _destOffset$[ebp]
	add	edx, DWORD PTR _xlen$[ebp]
	mov	eax, DWORD PTR _sdramBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	ecx, DWORD PTR [edx+60]
	jb	SHORT $LN17@BDMA_Type9
	mov	eax, DWORD PTR _xsize$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _ylen$[ebp]
	add	eax, DWORD PTR _destOffset$[ebp]
	add	eax, DWORD PTR _xlen$[ebp]
	mov	ecx, DWORD PTR _sdramBase$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	cmp	edx, DWORD PTR [eax+56]
	ja	SHORT $LN17@BDMA_Type9
$LN19@BDMA_Type9:

; 137  :   {
; 138  :     nuonEnv->bOverlayBufferModified = true;

	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	mov	BYTE PTR [ecx+87], 1
$LN17@BDMA_Type9:

; 139  :   }
; 140  : 
; 141  :   while(bCount--)

	mov	edx, DWORD PTR _bCount$[ebp]
	mov	DWORD PTR tv264[ebp], edx
	mov	eax, DWORD PTR _bCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _bCount$[ebp], eax
	cmp	DWORD PTR tv264[ebp], 0
	je	$LN35@BDMA_Type9

; 142  :   {
; 143  :     srcA = 0;

	mov	DWORD PTR _srcA$[ebp], 0

; 144  :     destA = 0;

	mov	DWORD PTR _destA$[ebp], 0

; 145  :     aCount = xlen;

	mov	ecx, DWORD PTR _xlen$[ebp]
	mov	DWORD PTR _aCount$[ebp], ecx
$LN15@BDMA_Type9:

; 146  : 
; 147  :     while(aCount--)

	mov	edx, DWORD PTR _aCount$[ebp]
	mov	DWORD PTR tv267[ebp], edx
	mov	eax, DWORD PTR _aCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _aCount$[ebp], eax
	cmp	DWORD PTR tv267[ebp], 0
	je	$LN14@BDMA_Type9

; 148  :     {
; 149  :       bZTestResult = false;

	mov	BYTE PTR _bZTestResult$[ebp], 0

; 150  : 
; 151  :       if(bCompareZ && (zcompare != 0))

	movzx	ecx, BYTE PTR _bCompareZ$[ebp]
	test	ecx, ecx
	je	$LN13@BDMA_Type9
	cmp	DWORD PTR _zcompare$[ebp], 0
	je	$LN13@BDMA_Type9
	mov	BYTE PTR $T43620[ebp], 0

; 152  :       {
; 153  :         bool result;
; 154  :         int16 ztarget, ztransfer;
; 155  : 
; 156  :         ztarget = pDest16[destA + destB + destZOffset];

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, DWORD PTR _destB$[ebp]
	add	edx, DWORD PTR _destZOffset$[ebp]
	mov	eax, DWORD PTR _pDest16$[ebp]
	mov	cx, WORD PTR [eax+edx*2]
	mov	WORD PTR _ztarget$41395[ebp], cx

; 157  :         ztransfer = ((uint16 *)(&pSrc32[srcA + srcB]))[1];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _pSrc32$[ebp]
	mov	cx, WORD PTR [eax+edx*4+2]
	mov	WORD PTR _ztransfer$41396[ebp], cx

; 158  :         SwapWordBytes((uint16 *)&ztarget);

	lea	ecx, DWORD PTR _ztarget$41395[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 159  :         SwapWordBytes((uint16 *)&ztransfer);

	lea	ecx, DWORD PTR _ztransfer$41396[ebp]
	call	?SwapWordBytes@@YIXPAG@Z		; SwapWordBytes

; 160  : 
; 161  :         switch(zcompare)

	mov	edx, DWORD PTR _zcompare$[ebp]
	mov	DWORD PTR tv282[ebp], edx
	mov	eax, DWORD PTR tv282[ebp]
	sub	eax, 1
	mov	DWORD PTR tv282[ebp], eax
	cmp	DWORD PTR tv282[ebp], 6
	ja	$LN11@BDMA_Type9
	mov	ecx, DWORD PTR tv282[ebp]
	jmp	DWORD PTR $LN44@BDMA_Type9[ecx*4]
$LN10@BDMA_Type9:

; 162  :         {
; 163  :           case 0x1:
; 164  :             result = (ztarget < ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setl	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 165  :             break;

	jmp	$LN11@BDMA_Type9
$LN9@BDMA_Type9:

; 166  :           case 0x2:
; 167  :             result = (ztarget == ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	sete	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 168  :             break;

	jmp	$LN11@BDMA_Type9
$LN8@BDMA_Type9:

; 169  :           case 0x3:
; 170  :             result = (ztarget <= ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setle	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 171  :             break;

	jmp	SHORT $LN11@BDMA_Type9
$LN7@BDMA_Type9:

; 172  :           case 0x4:
; 173  :             result = (ztarget > ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setg	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 174  :             break;

	jmp	SHORT $LN11@BDMA_Type9
$LN6@BDMA_Type9:

; 175  :           case 0x5:
; 176  :             result = (ztarget != ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setne	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 177  :             break;

	jmp	SHORT $LN11@BDMA_Type9
$LN5@BDMA_Type9:

; 178  :           case 0x6:
; 179  :             result = (ztarget >= ztransfer);

	movsx	edx, WORD PTR _ztarget$41395[ebp]
	movsx	eax, WORD PTR _ztransfer$41396[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	setge	cl
	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], cl

; 180  :             break;

	jmp	SHORT $LN11@BDMA_Type9
$LN4@BDMA_Type9:

; 181  :           case 0x7:
; 182  :             result = false;

	mov	BYTE PTR $T43620[ebp], 1
	mov	BYTE PTR _result$41394[ebp], 0
$LN11@BDMA_Type9:

; 183  :             break;
; 184  :         }
; 185  : 
; 186  :         bZTestResult = result;

	cmp	BYTE PTR $T43620[ebp], 0
	jne	SHORT $LN37@BDMA_Type9
	push	OFFSET $LN38@BDMA_Type9
	call	__RTC_UninitUse
	add	esp, 4
$LN37@BDMA_Type9:
	mov	dl, BYTE PTR _result$41394[ebp]
	mov	BYTE PTR _bZTestResult$[ebp], dl
$LN13@BDMA_Type9:

; 187  :       }
; 188  : 
; 189  :       if(!bZTestResult)

	movzx	eax, BYTE PTR _bZTestResult$[ebp]
	test	eax, eax
	jne	SHORT $LN3@BDMA_Type9

; 190  :       {
; 191  :         if(zcompare == 7)

	cmp	DWORD PTR _zcompare$[ebp], 7
	jne	SHORT $LN2@BDMA_Type9

; 192  :         {
; 193  :           pDest16[destA + destB + mapOffset] = ((uint16 *)(&pSrc16[srcA + srcB]))[0];        

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcB$[ebp]
	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, DWORD PTR _destB$[ebp]
	add	edx, DWORD PTR _mapOffset$[ebp]
	mov	eax, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc16$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx*2], cx

; 194  :         }
; 195  :         else

	jmp	SHORT $LN3@BDMA_Type9
$LN2@BDMA_Type9:

; 196  :         {
; 197  :           pDest16[destA + destB + mapOffset] = ((uint16 *)(&pSrc32[srcA + srcB]))[0];

	mov	edx, DWORD PTR _srcA$[ebp]
	add	edx, DWORD PTR _srcB$[ebp]
	mov	eax, DWORD PTR _destA$[ebp]
	add	eax, DWORD PTR _destB$[ebp]
	add	eax, DWORD PTR _mapOffset$[ebp]
	mov	ecx, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	dx, WORD PTR [esi+edx*4]
	mov	WORD PTR [ecx+eax*2], dx

; 198  :           pDest16[destA + destB + destZOffset] = ((uint16 *)(&pSrc32[srcA + srcB]))[1];

	mov	eax, DWORD PTR _srcA$[ebp]
	add	eax, DWORD PTR _srcB$[ebp]
	mov	ecx, DWORD PTR _destA$[ebp]
	add	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _destZOffset$[ebp]
	mov	edx, DWORD PTR _pDest16$[ebp]
	mov	esi, DWORD PTR _pSrc32$[ebp]
	mov	ax, WORD PTR [esi+eax*4+2]
	mov	WORD PTR [edx+ecx*2], ax
$LN3@BDMA_Type9:

; 199  :         }
; 200  :       }
; 201  : 
; 202  :       srcA += srcAStep;

	mov	ecx, DWORD PTR _srcA$[ebp]
	add	ecx, DWORD PTR _srcAStep$[ebp]
	mov	DWORD PTR _srcA$[ebp], ecx

; 203  :       destA += 1;

	mov	edx, DWORD PTR _destA$[ebp]
	add	edx, 1
	mov	DWORD PTR _destA$[ebp], edx

; 204  :     }

	jmp	$LN15@BDMA_Type9
$LN14@BDMA_Type9:

; 205  : 
; 206  :     srcB += srcBStep;

	mov	eax, DWORD PTR _srcB$[ebp]
	add	eax, DWORD PTR _srcBStep$[ebp]
	mov	DWORD PTR _srcB$[ebp], eax

; 207  :     destB += xsize;

	mov	ecx, DWORD PTR _destB$[ebp]
	add	ecx, DWORD PTR _xsize$[ebp]
	mov	DWORD PTR _destB$[ebp], ecx

; 208  :   }

	jmp	$LN17@BDMA_Type9
$LN35@BDMA_Type9:

; 209  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN43@BDMA_Type9
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN43@BDMA_Type9:
	DD	3
	DD	$LN42@BDMA_Type9
$LN42@BDMA_Type9:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN39@BDMA_Type9
	DD	-176					; ffffff50H
	DD	2
	DD	$LN40@BDMA_Type9
	DD	-188					; ffffff44H
	DD	2
	DD	$LN41@BDMA_Type9
$LN41@BDMA_Type9:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN40@BDMA_Type9:
	DB	122					; 0000007aH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN39@BDMA_Type9:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN38@BDMA_Type9:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
	npad	3
$LN44@BDMA_Type9:
	DD	$LN10@BDMA_Type9
	DD	$LN9@BDMA_Type9
	DD	$LN8@BDMA_Type9
	DD	$LN7@BDMA_Type9
	DD	$LN6@BDMA_Type9
	DD	$LN5@BDMA_Type9
	DD	$LN4@BDMA_Type9
?BDMA_Type9_Write_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_0
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_1@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_1

; 212  : {

	push	ebp
	mov	ebp, esp

; 213  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_1
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_2@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_2

; 216  : {

	push	ebp
	mov	ebp, esp

; 217  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_2
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_3@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_3

; 220  : {

	push	ebp
	mov	ebp, esp

; 221  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_3
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_4@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_4

; 224  : {

	push	ebp
	mov	ebp, esp

; 225  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_4
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_5@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_5

; 228  : {

	push	ebp
	mov	ebp, esp

; 229  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_5
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_6@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_6

; 232  : {

	push	ebp
	mov	ebp, esp

; 233  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_6
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Write_7@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Write_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Write_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Write_7

; 236  : {

	push	ebp
	mov	ebp, esp

; 237  : }

	pop	ebp
	ret	0
?BDMA_Type9_Write_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Write_7
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_0@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_0
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_0@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_0

; 240  : {

	push	ebp
	mov	ebp, esp

; 241  :   the_mpe->regs[0] = 0;

	mov	eax, DWORD PTR _the_mpe$[ebp]
	mov	DWORD PTR [eax], 0

; 242  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_0@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_0
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_1@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_1
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_1@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_1

; 245  : {

	push	ebp
	mov	ebp, esp

; 246  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_1@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_1
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_2@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_2
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_2@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_2

; 249  : {

	push	ebp
	mov	ebp, esp

; 250  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_2@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_2
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_3@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_3
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_3@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_3

; 253  : {

	push	ebp
	mov	ebp, esp

; 254  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_3@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_3
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_4@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_4
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_4@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_4

; 257  : {

	push	ebp
	mov	ebp, esp

; 258  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_4@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_4
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_5@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_5
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_5@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_5

; 261  : {

	push	ebp
	mov	ebp, esp

; 262  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_5@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_5
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_6@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_6
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_6@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_6

; 265  : {

	push	ebp
	mov	ebp, esp

; 266  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_6@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_6
_TEXT	ENDS
PUBLIC	?BDMA_Type9_Read_7@@YAXPAVMPE@@IIIII@Z		; BDMA_Type9_Read_7
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_the_mpe$ = 8						; size = 4
_flags$ = 12						; size = 4
_baseaddr$ = 16						; size = 4
_xinfo$ = 20						; size = 4
_yinfo$ = 24						; size = 4
_intaddr$ = 28						; size = 4
?BDMA_Type9_Read_7@@YAXPAVMPE@@IIIII@Z PROC		; BDMA_Type9_Read_7

; 269  : {

	push	ebp
	mov	ebp, esp

; 270  : }

	pop	ebp
	ret	0
?BDMA_Type9_Read_7@@YAXPAVMPE@@IIIII@Z ENDP		; BDMA_Type9_Read_7
_TEXT	ENDS
END
