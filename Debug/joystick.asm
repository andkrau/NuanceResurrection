; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\NuanceExperimental\joystick.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?controller@@3PAUControllerData@@A		; controller
_BSS	SEGMENT
?controller@@3PAUControllerData@@A DD 01H DUP (?)	; controller
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG12298
_DATA	ENDS
CONST	SEGMENT
$SG12298 DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?ControllerInitialize@@YAXPAVMPE@@@Z		; ControllerInitialize
EXTRN	?SwapScalarBytes@@YIXPAI@Z:PROC			; SwapScalarBytes
EXTRN	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z:PROC ; NuonEnvironment::GetPointerToMemory
EXTRN	?nuonEnv@@3PAVNuonEnvironment@@A:DWORD		; nuonEnv
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\nuanceexperimental\joystick.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_i$41389 = -20						; size = 4
_config$ = -12						; size = 4
_properties$ = -4					; size = 4
_mpe$ = 8						; size = 4
?ControllerInitialize@@YAXPAVMPE@@@Z PROC		; ControllerInitialize

; 15   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 16   :   uint32 properties;
; 17   :   uint32 config;
; 18   : 
; 19   :   //return the last 144 bytes of the BIOS region
; 20   :   mpe->regs[0] = CONTROLLER_ADDRESS;

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [eax], -2139095184		; 807fff70H

; 21   :   controller = (ControllerData *)(nuonEnv->GetPointerToMemory(mpe,CONTROLLER_ADDRESS));

	push	1
	push	-2139095184				; 807fff70H
	mov	ecx, DWORD PTR _mpe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?nuonEnv@@3PAVNuonEnvironment@@A ; nuonEnv
	call	?GetPointerToMemory@NuonEnvironment@@QAEPAXPAVMPE@@I_N@Z ; NuonEnvironment::GetPointerToMemory
	mov	DWORD PTR ?controller@@3PAUControllerData@@A, eax ; controller

; 22   :   for(uint32 i = 0; i < NUM_CONTROLLER_ENTRIES; i++)

	mov	DWORD PTR _i$41389[ebp], 0
	jmp	SHORT $LN3@Controller
$LN2@Controller:
	mov	edx, DWORD PTR _i$41389[ebp]
	add	edx, 1
	mov	DWORD PTR _i$41389[ebp], edx
$LN3@Controller:
	cmp	DWORD PTR _i$41389[ebp], 9
	jae	$LN1@Controller

; 23   :   {
; 24   :     controller[i].config = 0;

	mov	eax, DWORD PTR _i$41389[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	DWORD PTR [ecx+eax], 0

; 25   :     controller[i].buttons = 0;

	mov	edx, DWORD PTR _i$41389[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	WORD PTR [eax+edx+4], 0

; 26   :     controller[i].remote_buttons = 0;

	mov	ecx, DWORD PTR _i$41389[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	DWORD PTR [edx+ecx+12], 0

; 27   :     controller[i].d1.xAxis = 0;

	mov	eax, DWORD PTR _i$41389[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [ecx+eax+6], 0

; 28   :     controller[i].d2.yAxis = 0;

	mov	edx, DWORD PTR _i$41389[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [eax+edx+7], 0

; 29   :     controller[i].d3.xAxis2 = 0;

	mov	ecx, DWORD PTR _i$41389[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [edx+ecx+8], 0

; 30   :     controller[i].d4.yAxis2 = 0;

	mov	eax, DWORD PTR _i$41389[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [ecx+eax+9], 0

; 31   :     controller[i].d5.quadjoyX = 0;

	mov	edx, DWORD PTR _i$41389[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [eax+edx+10], 0

; 32   :     controller[i].d6.quadjoyY = 0;

	mov	ecx, DWORD PTR _i$41389[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [edx+ecx+11], 0

; 33   :   }

	jmp	$LN2@Controller
$LN1@Controller:

; 34   : 
; 35   :   properties = KEYBOARD_JOYSTICK_PROPERTIES;

	mov	DWORD PTR _properties$[ebp], 15		; 0000000fH

; 36   :   config = CONTROLLER_CHANGED_BIT | properties;

	mov	eax, DWORD PTR _properties$[ebp]
	or	eax, -2147483648			; 80000000H
	mov	DWORD PTR _config$[ebp], eax

; 37   : 
; 38   : #ifdef LITTLE_ENDIAN
; 39   :   SwapScalarBytes(&config);

	lea	ecx, DWORD PTR _config$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 40   : #endif
; 41   :   controller[1].config = config;

	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	edx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 42   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Controller
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@Controller:
	DD	1
	DD	$LN7@Controller
$LN7@Controller:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@Controller
$LN6@Controller:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
?ControllerInitialize@@YAXPAVMPE@@@Z ENDP		; ControllerInitialize
_TEXT	ENDS
PUBLIC	?DeviceDetect@@YAXPAVMPE@@@Z			; DeviceDetect
; Function compile flags: /Odtp /RTCsu
_TEXT	SEGMENT
_config$ = -12						; size = 4
_slot$ = -4						; size = 4
_mpe$ = 8						; size = 4
?DeviceDetect@@YAXPAVMPE@@@Z PROC			; DeviceDetect

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 46   :   uint32 slot = mpe->regs[0];

	mov	eax, DWORD PTR _mpe$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _slot$[ebp], ecx

; 47   :   uint32 config;
; 48   : 
; 49   :   if(slot == 1)

	cmp	DWORD PTR _slot$[ebp], 1
	jne	SHORT $LN4@DeviceDete

; 50   :   {
; 51   :     config = controller[1].config;

	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _config$[ebp], eax

; 52   : #ifdef LITTLE_ENDIAN
; 53   :     SwapScalarBytes(&config);

	lea	ecx, DWORD PTR _config$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 54   : #endif
; 55   : 
; 56   :     if((config & CONTROLLER_CHANGED_BIT) == 0)

	mov	ecx, DWORD PTR _config$[ebp]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN3@DeviceDete

; 57   :     {
; 58   :       mpe->regs[0] = 0xFFFFFFFFUL; //unchanged: -1

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], -1

; 59   :       return;

	jmp	$LN5@DeviceDete
$LN3@DeviceDete:

; 60   :     }
; 61   : 
; 62   :     if(controller)

	cmp	DWORD PTR ?controller@@3PAUControllerData@@A, 0 ; controller
	je	SHORT $LN2@DeviceDete

; 63   :     {
; 64   :       config = CONTROLLER_STATUS_BIT | KEYBOARD_JOYSTICK_PROPERTIES;

	mov	DWORD PTR _config$[ebp], 1073741839	; 4000000fH

; 65   : #ifdef LITTLE_ENDIAN
; 66   :       SwapScalarBytes(&config);

	lea	ecx, DWORD PTR _config$[ebp]
	call	?SwapScalarBytes@@YIXPAI@Z		; SwapScalarBytes

; 67   : #endif
; 68   :       controller[1].config = config;

	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	ecx, DWORD PTR _config$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN2@DeviceDete:

; 69   :     }
; 70   : 
; 71   :     mpe->regs[0] = 1;

	mov	edx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [edx], 1

; 72   :   }
; 73   :   else

	jmp	$LN5@DeviceDete
$LN4@DeviceDete:

; 74   :   {
; 75   :     controller[slot].config = 0;

	mov	eax, DWORD PTR _slot$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	DWORD PTR [ecx+eax], 0

; 76   :     controller[slot].buttons = 0;

	mov	edx, DWORD PTR _slot$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	WORD PTR [eax+edx+4], 0

; 77   :     controller[slot].d1.xAxis = 0;

	mov	ecx, DWORD PTR _slot$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [edx+ecx+6], 0

; 78   :     controller[slot].d2.yAxis = 0;

	mov	eax, DWORD PTR _slot$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [ecx+eax+7], 0

; 79   :     controller[slot].d3.xAxis2 = 0;

	mov	edx, DWORD PTR _slot$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [eax+edx+8], 0

; 80   :     controller[slot].d4.yAxis2 = 0;

	mov	ecx, DWORD PTR _slot$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [edx+ecx+9], 0

; 81   :     controller[slot].d5.quadjoyX = 0;

	mov	eax, DWORD PTR _slot$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [ecx+eax+10], 0

; 82   :     controller[slot].d6.quadjoyY = 0;

	mov	edx, DWORD PTR _slot$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR ?controller@@3PAUControllerData@@A ; controller
	mov	BYTE PTR [eax+edx+11], 0

; 83   :     mpe->regs[0] = 0; //No controller, for now

	mov	ecx, DWORD PTR _mpe$[ebp]
	mov	DWORD PTR [ecx], 0
$LN5@DeviceDete:

; 84   :   }
; 85   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@DeviceDete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@DeviceDete:
	DD	1
	DD	$LN8@DeviceDete
$LN8@DeviceDete:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN7@DeviceDete
$LN7@DeviceDete:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
?DeviceDetect@@YAXPAVMPE@@@Z ENDP			; DeviceDetect
_TEXT	ENDS
END
