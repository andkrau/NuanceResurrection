;some crap I don't care about
20301b50	or #$00000001,<>#-13,r0
20301b54	or r3,r0
20301b56	bra #$20301b72
20301b58	sub r3,r3
20301b5a	or #$00000001,<>#1,r3

;START OF MINIBIOS AUDIO JUMPTABLE
20301b5e	bra #$20301b68
;R3 = 0
20301b60	sub r3,r3
;R3 = $80000000
20301b62	or #$00000001,<>#1,r3
;BRANCH TO DMA_START
20301b66	bra #$20301b72

20301b68	mv_s r0,r4
;R0 = R0 << 16 (NUMBER OF SCALARS << 16)
20301b6a	asl #$fffffff0,r0
;RETURN IF R0 IS NOW ZERO
20301b6c	rts eq,nop
;R0 = R0 | 0x2000 (NUMBER OF SCALARS << 16) | DMA_READ)
20301b6e	or #$00000001,<>#-13,r0
;DMA_START:
20301b72	push v1
;WAIT_FOR_DMA_COMPLETE:
;R4 = MDMACTL
20301b74	ld_s mdmactl,r4
;R5 = ODMACTL
20301b78	ld_s odmactl,r5
;TEST PENDING BIT OF MDMACTL
20301b7c	btst #$00000004,r4
;BRANCH BACK TO WAIT_FOR_DMA_COMPLETE IF MDMACTL PENDING BIT IS SET, TEST PENDING BIT OF ODMACTL
20301b7e	lbra ne,#$20301b74,nop
	btst #$00000004,r5
;BRANC BACK TO WAIT_FOR_DMA_COMPLETE IF ODMACTL PENDING BIT IS SET, TEST BIT 31 OF R1
20301b84	lbra ne,#$20301b74,nop
	btst #$0000001f,r1
;R5 = ADDRESS OF MDMACTL REGISTER
20301b8a	mv_s #$20500600,r5
;BRANCH TO DO_SOMETHING IF UPPER BIT OF DMA EXTERNAL ADDRESS IS CLEAR ($40000000 - $4FFFFFFF)
20301b90	lbra eq,#$20301b9a,nop
;R5 = ADDRESS OF ODMACTL REGISTER
20301b94	mv_s #$20500500,r5

;DO_SOMETHING:

;R4 = (NUMBER OF DMA COMMANDS & 01)
20301b9a	and #$00000001,r3,r4
;R4 = (R3 & 0x01) << 4
20301b9e	asl #$fffffffc,r4
;R4 = $20101BE0 + ((R3 & 0x01) << 4)
20301ba0	add #$20101be0,r4
;STORE V0 AT $20101BE0 + ((R3 & 0x01) << 4)
20301ba6	st_v v0,(r4)
;R5 = ADDRESS OF MDMACPTR OR ODMACPTR
20301baa	add #$00000010,r5
;MDMACPTR/ODMACPTR = R4 ($20101BE0 + ((R3 & 0x01) << 4))
20301bac	st_s r4,(r5)
;R5 = ADDRESS OF MDMACTL REGISTER OR ODMACTL REGISTER
20301bae	sub #$00000010,r5
;TEST BIT 31 OF R3
20301bb0	btst #$0000001f,r3
;IF BIT 31 OF R3 IS SET, BRANCH TO EPILOGUE
20301bb2	lbra eq,#$20301bc2,nop
;WAIT_FOR_DMA_DONE:
;R4 = MDMACTL/ODMACTL CONTENTS
20301bb6	ld_s (r5),r4
20301bb8	nop
;R4 = NUMBER OF PENDING/ACTIVE DMA REQUESTS
20301bba	bits #$00000004,>>#0,r4
;IF PENDING/ACTIVE DMA REQUESTS IS NOT ZERO, BRANCH BACK TO WAIT_FOR_DMA_DONE
20301bbe	lbra ne,#$20301bb6,nop
;EPILOGUE
20301bc2	rts,nop
	pop v1

;BRANCH TO WAIT_FOR_DMA_DONE
20301bc6	bra #$20301bb6
20301bc8	push v1
;R5 = ADDRESS OF ODMACTL REGISTER 
20301bca	mv_s #$20500500,r5
;BRANCH TO WAIT_FOR_DMA_DONE
20301bd0	bra #$20301bb6
20301bd2	push v1
;R5 = ADDRESS OF MDMACTL REGISTER 
20301bd4	mv_s #$20500600,r5

;START OF MINIBIOS LEVEL1 INTERRUPT HANDLER
20301bda	ld_s rz,r13
20301bdc	push v1
;R15 = INTSRC
20301bde	ld_s intsrc,r15
;R14 = INTEN1
20301be0	ld_s inten1,r14
20301be2	push v0
;R15 = INTSRC & INTEN1
20301be4	and r14,r15
;TEST (INTSRC & INTEN1) FOR ??? BIT SET
20301be6	btst #$00000003,r15
;CALL HANDLER IF BIT 3 IS SET
20301be8	jsr ne,#$20301c96,nop
;TEST (INTSRC & INTEN1) FOR ??? BIT SET
20301bec	btst #$00000002,r15
;CALL HANDLER IF BIT 2 IS SET
20301bee	jsr ne,#$20301f02,nop
;R1 = SCALAR AT $20101000 (OR AT $20300000 IF MINIBIOS RUNNING ON MPE2 OR MPE3 I BET)
20301bf2	ld_s ??register,r1
;TEST (INTSRC & INTEN1) FOR AUDIO BIT SET
20301bf6	btst #$0000001b,r15
;CALL AUDIO HANDLER (POINTED TO BY $20101000) IF AUDIO BIT IS SET
20301bf8	jsr ne,(r1),nop
;TEST (INTSRC & INTEN1) FOR EXCEPTION BIT SET
20301bfc	btst #$00000000,r15
;CALL HANDLER IF EXCEPTION BIT IS SET
20301bfe	jsr ne,#$20301b14,nop
;EPILOGUE
20301c02	pop v0
20301c04	pop v1
20301c06	st_s r13,rz
20301c08	pop v2
20301c0a	st_s r12,cc
	rti rzi1
20301c0e	pop v3
20301c10	nop

;START OF MINIBIOS LEVEL2 INTERRUPT HANDLER
20301c12	push v0
20301c14	push v1
20301c16	push v2
20301c18	push r31,rcc,rzi2,rz
;R31 = SCALAR AT $20101C20 (COMM PACKET QUEUE POINTER VARIABLE: POINTS TO NEXT FREE ENTRY)
20301c1a	ld_s ??register,r31
;CALLED ROUTINE SHOULD RETURN TO EPILOGUE
20301c1e	st_s #$20301c86,rz
;R0 = COMMCTL
20301c26	ld_s commctl,r0
;R1 = COMMINFO
20301c2a	ld_s comminfo,r1
;TEST RECVBUFFER FULL BIT OF COMMCTL
20301c2e	btst #$0000001f,r0
;BRANCH TO EPILOGUE IF RECVBUFFER FULL BIT IS NOT SET
20301c30	lbra eq,#$20301c86,nop
;R0 = RECV SOURCE ID, CLEAR BIT 4 OF INTSRC (COMMRECV)
20301c34	bits #$00000007,>>#16,r0
	st_s #$00000010,intclr
;V1 = COMMRECV, COMPARE RECV SOURCE ID TO $4A (CODED DATA INTERFACE)
20301c3c	ld_v commrecv,v1
	cmp #$0000004a,r0
;R1 = RECV COMMINFO, BRANCH TO $20301E34 IF RECV SOURCE ID WAS $4A (CODED DATA INTERFACE)
20301c44	bits #$00000007,>>#16,r1
	jmp eq,#$20301e34,nop
;COMPARE RECV SOURCE ID TO $03
20301c4c	cmp #$00000003,r0
;BRANCH TO NOT_MPE3 IF RECV SOURCE IS IS NOT $03, COMPARE RECV COMMINFO TO $D0
20301c4e	bra ne,#$20301c58
	cmp #$000000d0,r1
;BRANCH TO $20301DE6 IF RECV SOURCE IS MPE3 AND RECV COMMINFO IS $D0
20301c54	jmp eq,#$20301de6,nop

;NOT_MPE3:
;STORE V0 INTO (QUEUE POINTER)[0]
20301c58	st_v v0,(r31)
	add #$00000010,r31
;STORE V0 INTO (QUEUE POINTER)[16], SET QUEUE POINTER TO NEXT FREE ENTRY (OLD POINTER + 32)
20301c5e	st_v v1,(r31)
	add #$00000010,r31
;R0 = SCALAR AT $20101C28, COMPARE UPDATED QUEUE POINTER TO $20101DA0 
20301c64	ld_s ??register,r0
	cmp #$20101da0,r31
;BRANCH TO COMPARE_UPDATED_QUEUE_POINTER IF UPDATED QUEUE POINTER IS LESS THAN $20101DA0
20301c6e	lbra lt,#$20301c78,nop

;SET UPDATED QUEUE POINTER TO POINT TO THE QUEUE POINTER VARIABLE
20301c72	mv_s #$20101c20,r31

;COMPARE_UPDATED_QUEUE_POINTER:
;COMPARE UPDATED QUEUE POINTER TO SCALAR AT $20301C28 (PROBABLY POINTER TO LAST QUEUE ENTRY) 
20301c78	cmp r0,r31
;BRANCH IF STACK POINTER IS EQUAL TO SCALAR AT $20301C28: SETS COMMRECV EXCEPTION BIT AND BRANCHES TO INTSRC_2_HANDLER TO PROCESS IT
20301c7a	lbra eq,#$20301c92,nop
;STORE UPDATED QUEUE POINTER BACK TO MEMORY ($20101C20)
20301c7e	st_s r31,??register
;TRIGGER INTSRC3 INTERRUPT
20301c82	st_s #$00000008,intsrc
;EPILOGUE
20301c86	pop r31,rcc,rzi2,rz
20301c88	pop v2
20301c8a	pop v1
	rti rzi2
20301c8e	pop v0
20301c90	nop

;SET COMMRECV EXCEPTION BIT IN EXCEPSRC
20301c92	st_s #$00000004,excepsrc

;INTSRC_3_HANDLER:
;CLEAR THE INTSRC3 BIT IN THE INTSRC REGISTER
20301c96	st_s #$00000008,intclr
20301c9a	push v3,rz
;LOAD V2 WITH VECTOR STARTING AT $20101C20
20301c9c	ld_v ??register,v2
20301ca0	st_s #$20301c9c,rz
;COMPARE CURRENT QUEUE POINTER WITH THE HEAD POINTER
20301ca8	cmp r9,r8
;IF THE CURRENT QUEUE POSITION EQUALS THE HEAD POSITION, BRANCH TO EPILOGUE
20301caa	lbra eq,#$20301d46,nop
;V0 = (CURRENT QUEUE POINTER)[0]
20301cae	ld_v (r9),v0
	add #$00000010,r9
;V1 = (CURRENT QUEUE POINTER)[16]
20301cb4	ld_v (r9),v1
	add #$00000010,r9
;COMPARE THE NEXT QUEUE ENTRY ADDRESS AFTER THE CURRENT ENTRY TO $20101DA0
20301cba	ld_s ??register,r3
	cmp #$20101da0,r9
;BRANCH IF NEXT QUEUE ENTRY ADDRESS IS NOT $20101DA0
20301cc4	lbra ne,#$20301cce,nop
;ADJUST QUEUE POINTER TO STARTING ENTRY ($20101C20)
20301cc8	mv_s #$20101c20,r9

;STORE CURRENT QUEUE POINTER BACK TO MEMORY
20301cce	st_s r9,??register
;COMPARE SENDER ID TO $03
20301cd2	cmp #$00000003,r0
20301cd4	lbra ne,#$20301d10,nop
;R2 = SCALAR AT $20101008
20301cd8	ld_s ??register,r2
20301cdc	and #$000000f0,r1,r3
;COMPARE RECV COMMINFO TO $A0
20301ce4	cmp #$000000a0,r3
	ld_s ??register,r3
20301cec	jmp eq,(r2),nop
	cmp #$000000c0,r1
20301cf4	jmp eq,#$20301ad0,nop
	cmp #$000000c2,r1
20301cfc	jmp eq,#$20301b08,nop
	cmp #$000000c3,r1
20301d04	jmp eq,#$20301b1c,nop
	cmp #$000000c4,r1
20301d0c	jmp eq,#$20301b2e,nop
20301d10	cmp #$00000000,r3
20301d12	jmp ne,(r3),nop
20301d16	add #$00000020,r10,r8
20301d1e	cmp #$20101e40,r8
20301d24	lbra ne,#$20301d2e,nop
20301d28	mv_s #$20101da0,r8
20301d2e	cmp r8,r11
20301d30	lbra eq,#$20301d42,nop
20301d34	st_v v0,(r10)
	add #$00000010,r10
20301d3a	st_v v1,(r10)
20301d3e	st_s r8,??register
20301d42	lbra #$20301c9c,nop
;EPILOGUE:
20301d46	pop v3,rz
20301d48	nop
20301d4a	rts,nop

;start of minibios documented functions
20301d4c	push v2
20301d4e	ld_b (r28),r8
	mul r0,r8
	add r0,r1
20301d56	add_sv v0,v0
20301d58	add r0,r0
20301d5a	add r0,r0
20301d5c	eor r19,r6
20301d5e	bra lt,#$20301d36
